name: Simple CI

on:
  push:
    branches: [ main, dev, test, develop ]
  # 允许手动触发（用于测试）
  workflow_dispatch:

env:
  GO_VERSION: '1.24'

jobs:
  # 代码检查和格式化
  lint:
    name: Code Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.64.2

      - name: Run golangci-lint
        run: |
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            golangci-lint run --timeout=10m --new-from-rev=HEAD~1
          else
            # Fallback for shallow/manual runs without history
            golangci-lint run --timeout=10m ./api/... ./service/... ./pkg/...
          fi

      - name: Check code formatting
        run: |
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            changed_go_files=$(git diff --name-only HEAD~1..HEAD -- '*.go' || true)
          else
            changed_go_files=$(git ls-files '*.go')
          fi

          if [ -z "$changed_go_files" ]; then
            echo "No changed Go files to format-check."
            exit 0
          fi

          existing_go_files=$(echo "$changed_go_files" | while read -r f; do [ -n "$f" ] && [ -f "$f" ] && echo "$f"; done)
          if [ -z "$existing_go_files" ]; then
            echo "No existing changed Go files to format-check."
            exit 0
          fi

          unformatted_files=$(echo "$existing_go_files" | xargs gofmt -s -l)
          if [ -n "$unformatted_files" ]; then
            echo "The following changed files are not formatted:"
            echo "$unformatted_files"
            exit 1
          fi

  # 安全扫描
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install gosec
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest

      - name: Run gosec
        run: gosec ./...
        continue-on-error: true

  # 单元测试（不需要 MongoDB）
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:7.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh 'mongodb://admin:password@localhost:27017' --eval 'db.stats().ok'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Run unit tests
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
        run: |
          TEST_PACKAGES=$(go list ./... | \
            grep -v '^Qingyu_backend/cmd/' | \
            grep -v '^Qingyu_backend/test/' | \
            grep -v '^Qingyu_backend/tests/' | \
            grep -v '^Qingyu_backend/.archive/')
          go test -v -race -short -coverprofile=coverage.txt -covermode=atomic \
            $TEST_PACKAGES

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.txt
          flags: unittests
        continue-on-error: true

  # 集成测试（使用 Docker Compose）
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Start test infrastructure
        run: |
          docker compose -f docker/docker-compose.test.yml up -d mongodb-test redis-test
          echo "Waiting for services to be healthy..."
          sleep 5

      - name: Wait for MongoDB
        run: |
          for i in {1..30}; do
            if docker exec qingyu-mongodb-test mongosh --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; then
              echo "MongoDB is ready!"
              exit 0
            fi
            echo "Waiting for MongoDB... ($i/30)"
            sleep 2
          done
          echo "MongoDB failed to start"
          docker compose -f docker/docker-compose.test.yml logs mongodb-test
          exit 1

      - name: Wait for Redis
        run: |
          for i in {1..15}; do
            if docker exec qingyu-redis-test redis-cli ping > /dev/null 2>&1; then
              echo "Redis is ready!"
              exit 0
            fi
            echo "Waiting for Redis... ($i/15)"
            sleep 1
          done
          echo "Redis failed to start"
          exit 1

      - name: Wait for gRPC AI Service
        run: |
          for i in {1..30}; do
            if docker exec qingyu-grpc-ai-test python -c "import socket; s=socket.socket(); s.settimeout(2); s.connect(('localhost', 50051)); s.close()" 2>/dev/null; then
              echo "gRPC AI Service is ready!"
              exit 0
            fi
            echo "Waiting for gRPC AI Service... ($i/30)"
            sleep 2
          done
          echo "gRPC AI Service check skipped (integration tests may not require it)"
          docker compose -f docker/docker-compose.test.yml logs grpc-ai-service || true

      - name: Download dependencies
        run: go mod download

      - name: Run integration tests
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          GRPC_AI_SERVICE_ADDR: localhost:50051
          ENVIRONMENT: test
        run: |
          go test -v -race -timeout 10m \
            ./test/integration/...

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== MongoDB Logs ==="
          docker compose -f docker/docker-compose.test.yml logs mongodb-test
          echo "=== Redis Logs ==="
          docker compose -f docker/docker-compose.test.yml logs redis-test
          echo "=== gRPC AI Service Logs ==="
          docker compose -f docker/docker-compose.test.yml logs grpc-ai-service || true

      - name: Stop test infrastructure
        if: always()
        run: docker compose -f docker/docker-compose.test.yml down -v

  # API 测试（使用 Docker Compose）
  api-tests:
    name: API Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Start test infrastructure
        run: |
          docker compose -f docker/docker-compose.test.yml up -d mongodb-test redis-test
          sleep 5

      - name: Wait for MongoDB
        run: |
          for i in {1..30}; do
            if docker exec qingyu-mongodb-test mongosh --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; then
              echo "MongoDB is ready!"
              exit 0
            fi
            echo "Waiting for MongoDB... ($i/30)"
            sleep 2
          done
          echo "MongoDB failed to start"
          docker compose -f docker/docker-compose.test.yml logs mongodb-test
          exit 1

      - name: Wait for Redis
        run: |
          for i in {1..15}; do
            if docker exec qingyu-redis-test redis-cli ping > /dev/null 2>&1; then
              echo "Redis is ready!"
              exit 0
            fi
            echo "Waiting for Redis... ($i/15)"
            sleep 1
          done
          echo "Redis failed to start"
          exit 1

      - name: Wait for gRPC AI Service
        run: |
          for i in {1..30}; do
            if docker exec qingyu-grpc-ai-test python -c "import socket; s=socket.socket(); s.settimeout(2); s.connect(('localhost', 50051)); s.close()" 2>/dev/null; then
              echo "gRPC AI Service is ready!"
              exit 0
            fi
            echo "Waiting for gRPC AI Service... ($i/30)"
            sleep 2
          done
          echo "gRPC AI Service check skipped (may not be needed for API tests)"

      - name: Download dependencies
        run: go mod download

      - name: Build application
        run: go build -o server cmd/server/main.go

      - name: Start application
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          GRPC_AI_SERVICE_ADDR: localhost:50051
          ENVIRONMENT: test
        run: |
          ./server &
          echo "Waiting for server to start..."
          sleep 5

      - name: Run API tests
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          ENVIRONMENT: test
        run: |
          go test -v -race -timeout 10m \
            ./test/api/...

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== MongoDB Logs ==="
          docker compose -f docker/docker-compose.test.yml logs mongodb-test
          echo "=== Redis Logs ==="
          docker compose -f docker/docker-compose.test.yml logs redis-test
          echo "=== gRPC AI Service Logs ==="
          docker compose -f docker/docker-compose.test.yml logs grpc-ai-service || true

      - name: Stop test infrastructure
        if: always()
        run: |
          docker compose -f docker/docker-compose.test.yml down -v
          pkill -f server || true

  # E2E测试（三层架构）
  e2e-tests:
    name: E2E Tests
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Start test infrastructure
        run: docker compose -f docker/docker-compose.test.yml up -d mongodb-test redis-test

      - name: Wait for MongoDB
        run: |
          for i in {1..30}; do
            if docker exec qingyu-mongodb-test mongosh --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; then
              echo "MongoDB is ready!"
              exit 0
            fi
            echo "Waiting for MongoDB... ($i/30)"
            sleep 2
          done
          echo "MongoDB failed to start"
          docker compose -f docker/docker-compose.test.yml logs mongodb-test
          exit 1

      - name: Download dependencies
        run: go mod download

      - name: Wait for Redis
        run: |
          for i in {1..15}; do
            if docker exec qingyu-redis-test redis-cli ping > /dev/null 2>&1; then
              echo "Redis is ready!"
              exit 0
            fi
            echo "Waiting for Redis... ($i/15)"
            sleep 1
          done
          echo "Redis failed to start"
          exit 1

      - name: Run E2E Layer 1 - Basic Flows
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          ENVIRONMENT: test
        run: |
          echo "=========================================="
          echo "Running E2E Layer 1: Basic Flow Tests"
          echo "=========================================="
          go test -v -tags=e2e -timeout 5m ./test/e2e/layer1_basic/...

      - name: Run E2E Layer 2 - Data Consistency
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          ENVIRONMENT: test
        run: |
          echo "=========================================="
          echo "Running E2E Layer 2: Data Consistency Tests"
          echo "=========================================="
          go test -v -tags=e2e -timeout 8m ./test/e2e/layer2_consistency/...

      - name: Run E2E Layer 3 - Boundary Scenarios
        env:
          MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          MONGODB_DATABASE: qingyu_test
          QINGYU_DATABASE_PRIMARY_MONGODB_URI: mongodb://admin:password@localhost:27017/qingyu?authSource=admin
          QINGYU_DATABASE_PRIMARY_MONGODB_DATABASE: qingyu_test
          REDIS_ADDR: localhost:6379
          ENVIRONMENT: test
        run: |
          echo "=========================================="
          echo "Running E2E Layer 3: Boundary Scenario Tests"
          echo "=========================================="
          go test -v -tags=e2e -timeout 10m ./test/e2e/layer3_boundary/...

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== MongoDB Logs ==="
          docker compose -f docker/docker-compose.test.yml logs mongodb-test

      - name: Stop test infrastructure
        if: always()
        run: docker compose -f docker/docker-compose.test.yml down -v

  # 依赖检查（仅在主分支运行，避免过于频繁）
  dependency-check:
    name: Dependency Check
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Check for vulnerabilities
        run: govulncheck ./...
        continue-on-error: true

      - name: Verify dependencies
        run: |
          go mod verify
          go mod tidy
          git diff --exit-code go.mod go.sum

  # 所有检查通过
  all-checks-passed:
    name: All Checks Passed
    needs: [lint, security, unit-tests, integration-tests, api-tests, e2e-tests, dependency-check]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check all jobs status
        run: |
          # 核心检查必须通过
          if [ "${{ needs.lint.result }}" != "success" ] || \
             [ "${{ needs.unit-tests.result }}" != "success" ]; then
            echo "❌ Core checks failed (lint or unit-tests)"
            exit 1
          fi

          # 集成测试、API测试和E2E测试（如果运行了必须通过）
          if [ "${{ needs.integration-tests.result }}" == "failure" ] || \
             [ "${{ needs.api-tests.result }}" == "failure" ] || \
             [ "${{ needs.e2e-tests.result }}" == "failure" ]; then
            echo "❌ Integration, API, or E2E tests failed"
            exit 1
          fi

          # 安全扫描和依赖检查可以是警告
          if [ "${{ needs.security.result }}" == "failure" ]; then
            echo "⚠️ Security scan has warnings"
          fi

          if [ "${{ needs.dependency-check.result }}" == "failure" ]; then
            echo "⚠️ Dependency check has warnings"
          fi

          echo "✅ All critical checks passed successfully!"

