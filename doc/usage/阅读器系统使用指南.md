# 阅读器系统使用指南

> **文档版本**: v1.0  
> **创建日期**: 2025-10-09  
> **适用对象**: 前端开发者、移动端开发者  
> **系统版本**: v1.0

## 📚 目录

- [1. 快速开始](#1-快速开始)
- [2. 常见场景](#2-常见场景)
- [3. 最佳实践](#3-最佳实践)
- [4. 性能优化](#4-性能优化)
- [5. 常见问题](#5-常见问题)

---

## 1. 快速开始

### 1.1 环境准备

#### 配置认证

```javascript
import axios from 'axios';

// 创建API客户端
const apiClient = axios.create({
  baseURL: 'http://your-domain/api/v1',
  timeout: 10000
});

// 请求拦截器 - 添加Token
apiClient.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器 - 处理错误
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      // Token过期，跳转登录
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### 1.2 第一个请求

#### 获取章节内容

```javascript
async function loadChapter(chapterId) {
  try {
    // 获取章节信息
    const chapterInfo = await apiClient.get(`/reader/chapters/${chapterId}`);
    
    // 获取章节内容
    const contentRes = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    
    return {
      info: chapterInfo.data,
      content: contentRes.data.content
    };
  } catch (error) {
    if (error.response?.status === 403) {
      // VIP章节
      showVIPDialog();
    } else {
      console.error('加载章节失败:', error);
    }
    throw error;
  }
}

// 使用
loadChapter('507f1f77bcf86cd799439011')
  .then(({ info, content }) => {
    console.log('章节标题:', info.title);
    console.log('章节内容:', content);
  });
```

---

## 2. 常见场景

### 2.1 场景一：实现完整的阅读器

#### 需求描述

实现一个功能完整的阅读器，包括：
- 加载章节内容
- 自动保存阅读进度
- 章节导航（上一章/下一章）
- 书签、高亮、笔记功能
- 个性化阅读设置

#### 实现步骤

**步骤1：创建阅读器组件**

```vue
<template>
  <div class="reader-container" :style="readerStyle">
    <!-- 顶部工具栏 -->
    <div class="reader-header">
      <button @click="goBack">返回</button>
      <h1>{{ chapterInfo?.title }}</h1>
      <button @click="toggleSettings">设置</button>
    </div>
    
    <!-- 章节内容 -->
    <div 
      ref="contentRef"
      class="reader-content" 
      @mouseup="handleTextSelection"
      @scroll="handleScroll"
    >
      <div v-html="renderedContent"></div>
    </div>
    
    <!-- 底部导航 -->
    <div class="reader-footer">
      <button @click="goPrevChapter" :disabled="!hasPrev">上一章</button>
      <div class="progress">{{ (scrollProgress * 100).toFixed(0) }}%</div>
      <button @click="goNextChapter" :disabled="!hasNext">下一章</button>
    </div>
    
    <!-- 选中文本工具栏 -->
    <div v-if="selectedText" class="text-toolbar" :style="toolbarStyle">
      <button @click="createHighlight">高亮</button>
      <button @click="createNote">笔记</button>
      <button @click="createBookmark">书签</button>
    </div>
    
    <!-- 设置面板 -->
    <SettingsPanel 
      v-if="showSettings" 
      :settings="settings"
      @update="updateSettings"
      @close="showSettings = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { apiClient } from '@/utils/api';

const route = useRoute();
const router = useRouter();

// 数据状态
const chapterInfo = ref(null);
const chapterContent = ref('');
const annotations = ref([]);
const settings = ref(null);
const scrollProgress = ref(0);
const selectedText = ref('');
const toolbarStyle = ref({});
const showSettings = ref(false);

// 章节导航
const navigation = ref({
  prevChapter: null,
  nextChapter: null
});

// 计算属性
const hasPrev = computed(() => !!navigation.value.prevChapter);
const hasNext = computed(() => !!navigation.value.nextChapter);

const readerStyle = computed(() => ({
  fontSize: `${settings.value?.fontSize || 16}px`,
  fontFamily: settings.value?.fontFamily || 'Microsoft YaHei',
  lineHeight: settings.value?.lineHeight || 1.8,
  backgroundColor: settings.value?.backgroundColor || '#FFFFFF',
  color: settings.value?.textColor || '#000000'
}));

const renderedContent = computed(() => {
  // 将标注渲染到内容中
  let content = chapterContent.value;
  
  // 应用高亮
  annotations.value
    .filter(a => a.type === 'highlight')
    .forEach(annotation => {
      const [start, end] = annotation.range.split('-').map(Number);
      // 简化处理：实际需要更复杂的逻辑
      content = highlightText(content, start, end);
    });
  
  return content;
});

// 加载章节
async function loadChapter(chapterId) {
  try {
    // 并行加载章节信息、内容、标注
    const [infoRes, contentRes, annotationsRes] = await Promise.all([
      apiClient.get(`/reader/chapters/${chapterId}`),
      apiClient.get(`/reader/chapters/${chapterId}/content`),
      apiClient.get(`/reader/annotations/chapter`, {
        params: {
          bookId: route.params.bookId,
          chapterId
        }
      })
    ]);
    
    chapterInfo.value = infoRes.data;
    chapterContent.value = contentRes.data.content;
    annotations.value = annotationsRes.data;
    
    // 加载章节导航
    loadNavigation();
    
    // 恢复阅读进度
    await restoreProgress();
  } catch (error) {
    if (error.response?.status === 403) {
      showVIPDialog();
    } else {
      console.error('加载章节失败:', error);
    }
  }
}

// 加载章节导航
async function loadNavigation() {
  const res = await apiClient.get('/reader/chapters/navigation', {
    params: {
      bookId: route.params.bookId,
      chapterNum: chapterInfo.value.chapterNum
    }
  });
  
  navigation.value = res.data;
}

// 恢复阅读进度
async function restoreProgress() {
  const res = await apiClient.get(`/reader/progress/${route.params.bookId}`);
  const progress = res.data;
  
  if (progress && progress.chapterId === chapterInfo.value.id) {
    // 滚动到上次阅读位置
    setTimeout(() => {
      const contentEl = contentRef.value;
      contentEl.scrollTop = contentEl.scrollHeight * progress.progress;
    }, 100);
  }
}

// 监听滚动，计算进度
const contentRef = ref(null);
const saveProgressTimer = ref(null);

function handleScroll(e) {
  const el = e.target;
  scrollProgress.value = el.scrollTop / (el.scrollHeight - el.clientHeight);
  
  // 防抖保存进度
  if (saveProgressTimer.value) {
    clearTimeout(saveProgressTimer.value);
  }
  
  saveProgressTimer.value = setTimeout(() => {
    saveProgress();
  }, 2000);
}

// 保存阅读进度
async function saveProgress() {
  try {
    await apiClient.post('/reader/progress', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      progress: scrollProgress.value
    });
  } catch (error) {
    console.error('保存进度失败:', error);
  }
}

// 文本选择处理
function handleTextSelection() {
  const selection = window.getSelection();
  const text = selection.toString().trim();
  
  if (text) {
    selectedText.value = text;
    
    // 计算工具栏位置
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    
    toolbarStyle.value = {
      top: `${rect.top - 50}px`,
      left: `${rect.left + rect.width / 2}px`,
      transform: 'translateX(-50%)'
    };
  } else {
    selectedText.value = '';
  }
}

// 创建高亮
async function createHighlight() {
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'highlight',
      text: selectedText.value,
      range: getSelectionRange()
    });
    
    // 刷新标注
    await loadAnnotations();
    selectedText.value = '';
  } catch (error) {
    console.error('创建高亮失败:', error);
  }
}

// 创建笔记
async function createNote() {
  const note = prompt('请输入笔记内容：');
  if (!note) return;
  
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'note',
      text: selectedText.value,
      note: note,
      range: getSelectionRange()
    });
    
    selectedText.value = '';
  } catch (error) {
    console.error('创建笔记失败:', error);
  }
}

// 创建书签
async function createBookmark() {
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'bookmark'
    });
    
    alert('书签已添加');
  } catch (error) {
    console.error('创建书签失败:', error);
  }
}

// 章节导航
async function goPrevChapter() {
  if (navigation.value.prevChapter) {
    await loadChapter(navigation.value.prevChapter.id);
    contentRef.value.scrollTop = 0;
  }
}

async function goNextChapter() {
  if (navigation.value.nextChapter) {
    await loadChapter(navigation.value.nextChapter.id);
    contentRef.value.scrollTop = 0;
  }
}

// 加载阅读设置
async function loadSettings() {
  const res = await apiClient.get('/reader/settings');
  settings.value = res.data;
}

// 更新设置
async function updateSettings(newSettings) {
  try {
    await apiClient.put('/reader/settings', newSettings);
    settings.value = { ...settings.value, ...newSettings };
  } catch (error) {
    console.error('更新设置失败:', error);
  }
}

// 记录阅读时长
let startTime = Date.now();
let readingDuration = 0;

const readingTimer = setInterval(() => {
  readingDuration = Math.floor((Date.now() - startTime) / 1000);
}, 1000);

// 组件挂载
onMounted(() => {
  loadSettings();
  loadChapter(route.params.chapterId);
});

// 组件卸载
onUnmounted(() => {
  // 保存进度和时长
  saveProgress();
  
  if (readingDuration > 0) {
    apiClient.put('/reader/progress/reading-time', {
      bookId: route.params.bookId,
      duration: readingDuration
    });
  }
  
  clearInterval(readingTimer);
});
</script>

<style scoped>
.reader-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.reader-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  border-bottom: 1px solid #eee;
}

.reader-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  line-height: inherit;
}

.reader-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  border-top: 1px solid #eee;
}

.text-toolbar {
  position: fixed;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 5px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  z-index: 1000;
}

.text-toolbar button {
  margin: 0 5px;
}
</style>
```

**步骤2：辅助函数**

```javascript
// 获取选中文本的范围
function getSelectionRange() {
  const selection = window.getSelection();
  if (!selection.rangeCount) return '';
  
  const range = selection.getRangeAt(0);
  const contentEl = contentRef.value;
  
  // 计算相对于内容容器的位置
  const preRange = range.cloneRange();
  preRange.selectNodeContents(contentEl);
  preRange.setEnd(range.startContainer, range.startOffset);
  
  const start = preRange.toString().length;
  const end = start + range.toString().length;
  
  return `${start}-${end}`;
}

// 高亮文本
function highlightText(content, start, end) {
  return content.substring(0, start) +
    '<mark>' + content.substring(start, end) + '</mark>' +
    content.substring(end);
}

// 显示VIP对话框
function showVIPDialog() {
  if (confirm('该章节需要VIP权限，是否前往开通？')) {
    router.push('/vip');
  }
}
```

---

### 2.2 场景二：实现阅读历史

#### 需求描述

显示用户的阅读历史记录，包括最近阅读和所有历史。

#### 实现步骤

```vue
<template>
  <div class="reading-history">
    <!-- Tab切换 -->
    <div class="tabs">
      <button 
        :class="{ active: currentTab === 'recent' }"
        @click="currentTab = 'recent'"
      >
        最近阅读
      </button>
      <button 
        :class="{ active: currentTab === 'unfinished' }"
        @click="currentTab = 'unfinished'"
      >
        未读完
      </button>
      <button 
        :class="{ active: currentTab === 'finished' }"
        @click="currentTab = 'finished'"
      >
        已读完
      </button>
    </div>
    
    <!-- 最近阅读 -->
    <div v-if="currentTab === 'recent'" class="book-list">
      <div 
        v-for="progress in recentReading" 
        :key="progress.bookId"
        class="book-item"
        @click="continueReading(progress)"
      >
        <img :src="progress.bookCover" alt="封面" />
        <div class="book-info">
          <h3>{{ progress.bookTitle }}</h3>
          <p>已读至：{{ progress.chapterTitle }}</p>
          <div class="progress-bar">
            <div 
              class="progress-fill" 
              :style="{ width: `${progress.progress * 100}%` }"
            ></div>
          </div>
          <p class="time">{{ formatTime(progress.lastReadAt) }}</p>
        </div>
      </div>
    </div>
    
    <!-- 未读完 -->
    <div v-if="currentTab === 'unfinished'" class="book-list">
      <div 
        v-for="progress in unfinishedBooks" 
        :key="progress.bookId"
        class="book-item"
      >
        <!-- Similar structure -->
      </div>
    </div>
    
    <!-- 已读完 -->
    <div v-if="currentTab === 'finished'" class="book-list">
      <div 
        v-for="progress in finishedBooks" 
        :key="progress.bookId"
        class="book-item"
      >
        <!-- Similar structure -->
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue';
import { useRouter } from 'vue-router';
import { apiClient } from '@/utils/api';

const router = useRouter();
const currentTab = ref('recent');
const recentReading = ref([]);
const unfinishedBooks = ref([]);
const finishedBooks = ref([]);

// 加载最近阅读
async function loadRecentReading() {
  const res = await apiClient.get('/reader/progress/recent', {
    params: { limit: 20 }
  });
  recentReading.value = res.data;
}

// 加载未读完书籍
async function loadUnfinishedBooks() {
  const res = await apiClient.get('/reader/progress/unfinished');
  unfinishedBooks.value = res.data;
}

// 加载已读完书籍
async function loadFinishedBooks() {
  const res = await apiClient.get('/reader/progress/finished');
  finishedBooks.value = res.data;
}

// 继续阅读
function continueReading(progress) {
  router.push({
    name: 'Reader',
    params: {
      bookId: progress.bookId,
      chapterId: progress.chapterId
    }
  });
}

// 格式化时间
function formatTime(timestamp) {
  const date = new Date(timestamp);
  const now = new Date();
  const diff = now - date;
  
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  
  if (minutes < 60) return `${minutes}分钟前`;
  if (hours < 24) return `${hours}小时前`;
  if (days < 7) return `${days}天前`;
  
  return date.toLocaleDateString();
}

// Tab切换时加载数据
watch(currentTab, (newTab) => {
  if (newTab === 'recent' && !recentReading.value.length) {
    loadRecentReading();
  } else if (newTab === 'unfinished' && !unfinishedBooks.value.length) {
    loadUnfinishedBooks();
  } else if (newTab === 'finished' && !finishedBooks.value.length) {
    loadFinishedBooks();
  }
});

onMounted(() => {
  loadRecentReading();
});
</script>
```

---

### 2.3 场景三：实现笔记管理

#### 需求描述

展示用户的所有笔记，支持搜索和跳转。

#### 实现步骤

```vue
<template>
  <div class="notes-manager">
    <!-- 搜索栏 -->
    <div class="search-bar">
      <input 
        v-model="searchKeyword"
        type="text"
        placeholder="搜索笔记..."
        @input="debounceSearch"
      />
    </div>
    
    <!-- 笔记列表 -->
    <div class="notes-list">
      <div 
        v-for="note in notes" 
        :key="note.id"
        class="note-item"
        @click="jumpToNote(note)"
      >
        <div class="note-header">
          <h3>{{ note.bookTitle }}</h3>
          <span class="note-time">{{ formatDate(note.createdAt) }}</span>
        </div>
        <div class="note-content">
          <div class="original-text">
            <strong>原文：</strong>
            <p>{{ note.text }}</p>
          </div>
          <div class="note-text">
            <strong>笔记：</strong>
            <p>{{ note.note }}</p>
          </div>
        </div>
        <div class="note-footer">
          <span>{{ note.chapterTitle }}</span>
          <button @click.stop="deleteNote(note.id)">删除</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { debounce } from 'lodash';
import { apiClient } from '@/utils/api';

const router = useRouter();
const searchKeyword = ref('');
const notes = ref([]);

// 加载所有笔记
async function loadNotes(bookId) {
  const res = await apiClient.get('/reader/annotations/notes', {
    params: { bookId }
  });
  notes.value = res.data;
}

// 搜索笔记
async function searchNotes() {
  if (!searchKeyword.value) {
    loadNotes();
    return;
  }
  
  const res = await apiClient.get('/reader/annotations/notes/search', {
    params: { keyword: searchKeyword.value }
  });
  notes.value = res.data;
}

// 防抖搜索
const debounceSearch = debounce(searchNotes, 300);

// 跳转到笔记位置
function jumpToNote(note) {
  router.push({
    name: 'Reader',
    params: {
      bookId: note.bookId,
      chapterId: note.chapterId
    },
    query: {
      highlightAnnotation: note.id
    }
  });
}

// 删除笔记
async function deleteNote(noteId) {
  if (!confirm('确定要删除这条笔记吗？')) return;
  
  try {
    await apiClient.delete(`/reader/annotations/${noteId}`);
    notes.value = notes.value.filter(n => n.id !== noteId);
  } catch (error) {
    console.error('删除笔记失败:', error);
  }
}

// 格式化日期
function formatDate(timestamp) {
  return new Date(timestamp).toLocaleString();
}

onMounted(() => {
  loadNotes();
});
</script>
```

---

## 3. 最佳实践

### 3.1 进度保存策略

#### 3.1.1 防抖保存

```javascript
// 使用防抖避免频繁请求
const saveProgressDebounced = debounce(async (progress) => {
  await apiClient.post('/reader/progress', progress);
}, 2000);

// 滚动时调用
function handleScroll() {
  const progress = calculateProgress();
  saveProgressDebounced(progress);
}
```

#### 3.1.2 本地缓存 + 定时同步

```javascript
class ProgressManager {
  constructor() {
    this.cache = new Map();
    this.syncInterval = null;
  }
  
  // 本地保存
  saveLocal(bookId, progress) {
    this.cache.set(bookId, {
      ...progress,
      timestamp: Date.now()
    });
    
    // 同时保存到localStorage
    localStorage.setItem(
      `progress:${bookId}`,
      JSON.stringify(progress)
    );
  }
  
  // 定时同步到服务器
  startSync() {
    this.syncInterval = setInterval(() => {
      this.syncToServer();
    }, 30000); // 每30秒同步一次
  }
  
  async syncToServer() {
    for (const [bookId, progress] of this.cache) {
      try {
        await apiClient.post('/reader/progress', progress);
        console.log(`同步进度成功: ${bookId}`);
      } catch (error) {
        console.error(`同步进度失败: ${bookId}`, error);
      }
    }
  }
  
  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
}

// 使用
const progressManager = new ProgressManager();
progressManager.startSync();

// 页面卸载时停止
window.addEventListener('beforeunload', () => {
  progressManager.stopSync();
  progressManager.syncToServer(); // 立即同步一次
});
```

### 3.2 标注高亮渲染

#### 使用Range API精确定位

```javascript
class AnnotationRenderer {
  constructor(container) {
    this.container = container;
  }
  
  // 应用所有标注
  applyAnnotations(annotations) {
    annotations.forEach(annotation => {
      if (annotation.type === 'highlight') {
        this.highlightText(annotation);
      }
    });
  }
  
  // 高亮文本
  highlightText(annotation) {
    const [start, end] = annotation.range.split('-').map(Number);
    
    const textNodes = this.getTextNodes(this.container);
    let currentPos = 0;
    
    for (const node of textNodes) {
      const nodeLength = node.textContent.length;
      
      if (currentPos + nodeLength < start) {
        currentPos += nodeLength;
        continue;
      }
      
      if (currentPos > end) {
        break;
      }
      
      const rangeStart = Math.max(0, start - currentPos);
      const rangeEnd = Math.min(nodeLength, end - currentPos);
      
      if (rangeStart < rangeEnd) {
        const range = document.createRange();
        range.setStart(node, rangeStart);
        range.setEnd(node, rangeEnd);
        
        const mark = document.createElement('mark');
        mark.className = 'highlight';
        mark.dataset.annotationId = annotation.id;
        
        range.surroundContents(mark);
      }
      
      currentPos += nodeLength;
    }
  }
  
  // 获取所有文本节点
  getTextNodes(element) {
    const textNodes = [];
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    return textNodes;
  }
}

// 使用
const renderer = new AnnotationRenderer(contentElement);
renderer.applyAnnotations(annotations);
```

### 3.3 阅读设置持久化

```javascript
class SettingsManager {
  static DEFAULTS = {
    fontSize: 16,
    fontFamily: 'Microsoft YaHei',
    lineHeight: 1.8,
    backgroundColor: '#FFFFFF',
    textColor: '#000000',
    pageMode: 'scroll',
    autoSave: true,
    showProgress: true
  };
  
  // 获取设置（本地优先）
  static async getSettings() {
    // 先从localStorage获取
    const localSettings = localStorage.getItem('readerSettings');
    if (localSettings) {
      return JSON.parse(localSettings);
    }
    
    // 从服务器获取
    try {
      const res = await apiClient.get('/reader/settings');
      const settings = res.data || this.DEFAULTS;
      
      // 保存到本地
      localStorage.setItem('readerSettings', JSON.stringify(settings));
      
      return settings;
    } catch (error) {
      return this.DEFAULTS;
    }
  }
  
  // 更新设置
  static async updateSettings(updates) {
    // 立即更新本地
    const current = JSON.parse(localStorage.getItem('readerSettings')) || {};
    const newSettings = { ...current, ...updates };
    localStorage.setItem('readerSettings', JSON.stringify(newSettings));
    
    // 异步同步到服务器
    try {
      await apiClient.put('/reader/settings', updates);
    } catch (error) {
      console.error('同步设置失败:', error);
    }
    
    return newSettings;
  }
}
```

---

## 4. 性能优化

### 4.1 章节预加载

```javascript
class ChapterPreloader {
  constructor() {
    this.cache = new Map();
    this.preloading = new Set();
  }
  
  // 预加载下一章
  async preloadNext(bookId, currentChapterNum) {
    const nextChapterNum = currentChapterNum + 1;
    const cacheKey = `${bookId}:${nextChapterNum}`;
    
    if (this.cache.has(cacheKey) || this.preloading.has(cacheKey)) {
      return;
    }
    
    this.preloading.add(cacheKey);
    
    try {
      // 获取下一章信息
      const navRes = await apiClient.get('/reader/chapters/navigation', {
        params: { bookId, chapterNum: currentChapterNum }
      });
      
      const nextChapter = navRes.data.nextChapter;
      if (!nextChapter) return;
      
      // 预加载内容
      const contentRes = await apiClient.get(
        `/reader/chapters/${nextChapter.id}/content`
      );
      
      this.cache.set(cacheKey, {
        info: nextChapter,
        content: contentRes.data.content,
        timestamp: Date.now()
      });
      
      console.log(`预加载完成: 第${nextChapterNum}章`);
    } catch (error) {
      console.error('预加载失败:', error);
    } finally {
      this.preloading.delete(cacheKey);
    }
  }
  
  // 获取缓存
  getCache(bookId, chapterNum) {
    const cacheKey = `${bookId}:${chapterNum}`;
    const cached = this.cache.get(cacheKey);
    
    if (!cached) return null;
    
    // 检查缓存是否过期（10分钟）
    if (Date.now() - cached.timestamp > 600000) {
      this.cache.delete(cacheKey);
      return null;
    }
    
    return cached;
  }
  
  // 清理缓存
  clearCache() {
    this.cache.clear();
  }
}

// 使用
const preloader = new ChapterPreloader();

// 加载章节时触发预加载
async function loadChapter(bookId, chapterId, chapterNum) {
  // 尝试从缓存获取
  const cached = preloader.getCache(bookId, chapterNum);
  if (cached) {
    displayChapter(cached);
  } else {
    // 正常加载
    await normalLoadChapter(bookId, chapterId);
  }
  
  // 预加载下一章
  preloader.preloadNext(bookId, chapterNum);
}
```

### 4.2 虚拟滚动优化长章节

```javascript
import { useVirtualList } from '@vueuse/core';

function LongChapterReader({ paragraphs }) {
  const { list, containerProps, wrapperProps } = useVirtualList(
    paragraphs,
    {
      itemHeight: 100, // 估计每段落高度
      overscan: 5
    }
  );
  
  return (
    <div {...containerProps} style={{ height: '600px', overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.value.map(({ data, index }) => (
          <p key={index} style={{ minHeight: '100px' }}>
            {data}
          </p>
        ))}
      </div>
    </div>
  );
}
```

---

## 5. 常见问题

### 5.1 如何处理VIP章节？

**问题**: 用户点击VIP章节时如何处理？

**解决方案**:

```javascript
async function loadChapter(chapterId) {
  try {
    const res = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    return res.data.content;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIP章节
      const confirmed = await showVIPDialog({
        title: '该章节需要VIP权限',
        message: '开通VIP即可无限畅读',
        confirmText: '立即开通'
      });
      
      if (confirmed) {
        router.push('/vip');
      }
    } else {
      throw error;
    }
  }
}
```

### 5.2 如何实现离线阅读？

**问题**: 支持用户下载章节离线阅读。

**解决方案**:

```javascript
class OfflineManager {
  constructor() {
    this.db = null;
    this.initDB();
  }
  
  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('ReaderDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        if (!db.objectStoreNames.contains('chapters')) {
          db.createObjectStore('chapters', { keyPath: 'id' });
        }
      };
    });
  }
  
  // 下载章节
  async downloadChapter(chapterId) {
    const content = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    
    const transaction = this.db.transaction(['chapters'], 'readwrite');
    const store = transaction.objectStore('chapters');
    
    await store.put({
      id: chapterId,
      content: content.data.content,
      downloadedAt: Date.now()
    });
  }
  
  // 获取离线章节
  async getOfflineChapter(chapterId) {
    const transaction = this.db.transaction(['chapters'], 'readonly');
    const store = transaction.objectStore('chapters');
    
    return new Promise((resolve, reject) => {
      const request = store.get(chapterId);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```

### 5.3 如何实现阅读统计看板？

**问题**: 展示用户的阅读数据统计。

**解决方案**:

```vue
<template>
  <div class="reading-stats">
    <div class="stat-card">
      <h3>总阅读时长</h3>
      <p class="stat-value">{{ formatDuration(stats.totalReadingTime) }}</p>
    </div>
    
    <div class="stat-card">
      <h3>本周阅读</h3>
      <p class="stat-value">{{ formatDuration(stats.weekReadingTime) }}</p>
    </div>
    
    <div class="stat-card">
      <h3>已读书籍</h3>
      <p class="stat-value">{{ stats.finishedCount }}本</p>
    </div>
    
    <div class="stat-card">
      <h3>在读书籍</h3>
      <p class="stat-value">{{ stats.unfinishedCount }}本</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { apiClient } from '@/utils/api';

const stats = ref({
  totalReadingTime: 0,
  weekReadingTime: 0,
  finishedCount: 0,
  unfinishedCount: 0
});

async function loadStats() {
  // 并行加载统计数据
  const [totalRes, weekRes] = await Promise.all([
    apiClient.get('/reader/progress/stats', { params: { period: 'all' } }),
    apiClient.get('/reader/progress/stats', { params: { period: 'week' } })
  ]);
  
  stats.value = {
    totalReadingTime: totalRes.data.totalReadingTime,
    weekReadingTime: weekRes.data.totalReadingTime,
    finishedCount: totalRes.data.finishedCount,
    unfinishedCount: totalRes.data.unfinishedCount
  };
}

function formatDuration(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  
  if (hours > 0) {
    return `${hours}小时${minutes}分钟`;
  }
  return `${minutes}分钟`;
}

onMounted(() => {
  loadStats();
});
</script>
```

---

## 附录

### A. 完整示例项目结构

```
reader-frontend/
├── src/
│   ├── api/
│   │   ├── chapter.js       # 章节API
│   │   ├── progress.js      # 进度API
│   │   ├── annotation.js    # 标注API
│   │   └── settings.js      # 设置API
│   ├── components/
│   │   ├── Reader.vue       # 阅读器组件
│   │   ├── ChapterNav.vue   # 章节导航
│   │   ├── AnnotationTool.vue  # 标注工具
│   │   └── SettingsPanel.vue   # 设置面板
│   ├── views/
│   │   ├── ReaderPage.vue      # 阅读页面
│   │   ├── HistoryPage.vue     # 历史记录
│   │   └── NotesPage.vue       # 笔记管理
│   ├── utils/
│   │   ├── preloader.js        # 预加载
│   │   ├── progress.js         # 进度管理
│   │   └── offline.js          # 离线管理
│   └── stores/
│       ├── reader.js           # 阅读器状态
│       └── settings.js         # 设置状态
└── package.json
```

### B. 资源链接

- API文档: [阅读器系统API文档](./阅读器系统API文档.md)
- Swagger文档: `http://your-domain/swagger/index.html`

---

**文档维护**: 青羽前端团队  
**最后更新**: 2025-10-09

