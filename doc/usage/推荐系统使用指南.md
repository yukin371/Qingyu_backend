# 推荐系统使用指南

> **适用版本**: v1.0.0  
> **更新时间**: 2025-10-10  
> **目标读者**: 前端开发、产品经理、测试工程师

---

## 📚 目录

1. [系统概述](#系统概述)
2. [快速开始](#快速开始)
3. [核心功能](#核心功能)
4. [使用场景](#使用场景)
5. [最佳实践](#最佳实践)
6. [常见问题](#常见问题)
7. [性能优化](#性能优化)

---

## 系统概述

### 功能简介

青羽推荐系统是基于用户行为和物品特征的智能推荐引擎，为用户提供个性化的书籍推荐服务。

### 核心特性

✅ **个性化推荐**: 基于用户画像的内容推荐  
✅ **相似物品**: 基于协同过滤的相似推荐  
✅ **行为采集**: 实时记录用户行为，动态更新画像  
✅ **冷启动**: 新用户热门书籍推荐  
✅ **高性能**: Redis缓存 + MongoDB存储  
✅ **易集成**: RESTful API，响应时间 < 200ms

### 推荐算法

| 算法类型 | 说明 | 适用场景 |
|---------|------|---------|
| 基于用户画像 | 标签/作者/分类偏好匹配 | 已有用户行为数据 |
| 协同过滤 | 物品相似度计算 | 书籍详情页"相似推荐" |
| 热门推荐 | 按阅读量/收藏量排序 | 新用户冷启动 |

---

## 快速开始

### 前置条件

- 用户已登录（获取 JWT Token）
- 后端服务已启动（默认端口: 8080）
- Redis 和 MongoDB 已配置

### 5分钟上手

#### 1. 前端集成（JavaScript）

```javascript
// 1. 获取个性化推荐（首页推荐）
async function loadRecommendations() {
  const response = await fetch('/api/v1/recommendation/personalized?limit=10', {
    headers: {
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });
  
  const result = await response.json();
  
  if (result.code === 200) {
    const bookIds = result.data.recommendations;
    // 批量获取书籍详情
    displayBooks(bookIds);
  }
}

// 2. 书籍详情页：获取相似书籍
async function loadSimilarBooks(bookId) {
  const response = await fetch(`/api/v1/recommendation/similar?itemId=${bookId}&limit=6`);
  const result = await response.json();
  
  if (result.code === 200) {
    displaySimilarBooks(result.data.similar_items);
  }
}

// 3. 记录用户行为
async function trackBehavior(itemId, behaviorType, value) {
  await fetch('/api/v1/recommendation/behavior', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${localStorage.getItem('token')}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      itemId,
      behaviorType,
      value
    })
  });
}

// 使用示例：用户点击书籍
function onBookClick(bookId) {
  trackBehavior(bookId, 'click', 1.0);
}

// 使用示例：用户阅读章节
function onChapterRead(bookId, chapterId, duration) {
  trackBehavior(bookId, 'read', duration);
}
```

#### 2. React 集成

```jsx
import { useEffect, useState } from 'react';
import { getPersonalizedRecommendations, recordBehavior } from './api/recommendation';

function RecommendationSection() {
  const [books, setBooks] = useState([]);
  
  useEffect(() => {
    loadRecommendations();
  }, []);
  
  async function loadRecommendations() {
    const result = await getPersonalizedRecommendations(10);
    if (result.code === 200) {
      // 批量获取书籍详情
      const bookDetails = await fetchBookDetails(result.data.recommendations);
      setBooks(bookDetails);
    }
  }
  
  function handleBookClick(bookId) {
    recordBehavior(bookId, 'click', 1.0);
    // 跳转到书籍详情页
    window.location.href = `/book/${bookId}`;
  }
  
  return (
    <div className="recommendation-section">
      <h2>为你推荐</h2>
      <div className="book-grid">
        {books.map(book => (
          <BookCard 
            key={book.id} 
            book={book} 
            onClick={() => handleBookClick(book.id)} 
          />
        ))}
      </div>
    </div>
  );
}
```

#### 3. Vue 集成

```vue
<template>
  <div class="recommendation-section">
    <h2>为你推荐</h2>
    <div class="book-grid">
      <book-card 
        v-for="book in books" 
        :key="book.id" 
        :book="book"
        @click="handleBookClick(book.id)"
      />
    </div>
  </div>
</template>

<script>
import { getPersonalizedRecommendations, recordBehavior } from '@/api/recommendation';

export default {
  data() {
    return {
      books: []
    };
  },
  
  mounted() {
    this.loadRecommendations();
  },
  
  methods: {
    async loadRecommendations() {
      const result = await getPersonalizedRecommendations(10);
      if (result.code === 200) {
        const bookDetails = await this.fetchBookDetails(result.data.recommendations);
        this.books = bookDetails;
      }
    },
    
    handleBookClick(bookId) {
      recordBehavior(bookId, 'click', 1.0);
      this.$router.push(`/book/${bookId}`);
    }
  }
};
</script>
```

---

## 核心功能

### 1. 个性化推荐

**功能说明**: 根据用户历史行为和偏好，推荐可能感兴趣的书籍。

**API**: `GET /api/v1/recommendation/personalized?limit=10`

**使用场景**:
- 首页推荐模块
- "猜你喜欢"模块
- 空闲状态推荐

**代码示例**:

```javascript
// 1. 基础用法
const result = await getPersonalizedRecommendations(10);

// 2. 带错误处理
async function loadPersonalizedBooks() {
  try {
    const result = await getPersonalizedRecommendations(10);
    
    if (result.code === 200) {
      const bookIds = result.data.recommendations;
      
      // 检查推荐来源
      if (result.data.source === 'hot_books') {
        console.log('新用户，返回热门书籍');
      } else {
        console.log('基于用户画像推荐');
      }
      
      // 加载书籍详情
      displayBooks(bookIds);
    } else {
      console.error('推荐失败:', result.message);
    }
  } catch (error) {
    console.error('网络错误:', error);
  }
}

// 3. 分页加载（瀑布流）
let offset = 0;
async function loadMoreRecommendations() {
  const result = await getPersonalizedRecommendations(20);
  // 追加到现有列表
  appendBooks(result.data.recommendations);
}
```

**最佳实践**:

1. **缓存结果**: 前端缓存推荐结果5分钟，减少请求
2. **懒加载**: 使用虚拟滚动，按需加载书籍详情
3. **埋点上报**: 记录推荐位曝光和点击，用于算法优化

```javascript
// 曝光埋点
function trackRecommendationImpression(bookIds) {
  // 上报推荐位曝光
  analytics.track('recommendation_impression', {
    book_ids: bookIds,
    position: 'homepage',
    timestamp: Date.now()
  });
}

// 点击埋点
function onRecommendationClick(bookId, position) {
  // 记录行为（用于推荐系统）
  recordBehavior(bookId, 'click', 1.0);
  
  // 上报点击事件（用于数据分析）
  analytics.track('recommendation_click', {
    book_id: bookId,
    position: position,
    timestamp: Date.now()
  });
}
```

---

### 2. 相似物品推荐

**功能说明**: 推荐与指定书籍相似的其他书籍（公开接口，无需登录）。

**API**: `GET /api/v1/recommendation/similar?itemId={bookId}&limit=6`

**使用场景**:
- 书籍详情页"相似推荐"模块
- "看过这本书的人还看了"
- 书籍列表页相关推荐

**代码示例**:

```javascript
// 1. 书籍详情页
async function loadBookDetail(bookId) {
  // 加载书籍详情
  const bookDetail = await fetchBookDetail(bookId);
  displayBookDetail(bookDetail);
  
  // 加载相似书籍
  const result = await getSimilarItems(bookId, 6);
  if (result.code === 200) {
    displaySimilarBooks(result.data.similar_items);
  }
}

// 2. 列表页相关推荐
function BookListItem({ book }) {
  const [similarBooks, setSimilarBooks] = useState([]);
  
  async function loadSimilar() {
    const result = await getSimilarItems(book.id, 3);
    if (result.code === 200) {
      setSimilarBooks(result.data.similar_items);
    }
  }
  
  return (
    <div className="book-item">
      <BookCover book={book} />
      <button onClick={loadSimilar}>查看相似</button>
      {similarBooks.length > 0 && (
        <div className="similar-books">
          {similarBooks.map(id => <MiniBookCard key={id} bookId={id} />)}
        </div>
      )}
    </div>
  );
}
```

**最佳实践**:

1. **延迟加载**: 相似推荐在用户滚动到对应区域时再加载
2. **缓存策略**: 相似推荐缓存24小时，减少服务器压力
3. **降级方案**: 如果相似推荐失败，展示同分类热门书籍

```javascript
async function loadSimilarBooksWithFallback(bookId) {
  try {
    const result = await getSimilarItems(bookId, 6);
    
    if (result.code === 200 && result.data.similar_items.length > 0) {
      return result.data.similar_items;
    } else {
      // 降级：返回同分类热门书籍
      const book = await fetchBookDetail(bookId);
      return await getHotBooksByCategory(book.category, 6);
    }
  } catch (error) {
    console.error('加载相似书籍失败:', error);
    return [];
  }
}
```

---

### 3. 用户行为记录

**功能说明**: 记录用户的浏览、点击、收藏、阅读等行为，用于更新用户画像。

**API**: `POST /api/v1/recommendation/behavior`

**行为类型**:

| 类型 | 触发时机 | value | metadata |
|------|---------|-------|----------|
| view | 进入书籍详情页 | 停留时长（秒） | - |
| click | 点击书籍卡片 | 1.0 | `{position: 'homepage'}` |
| collect | 收藏书籍 | 1.0 | - |
| read | 阅读章节 | 阅读时长（秒） | `{chapterId, progress}` |
| finish | 读完章节 | 1.0 | `{chapterId}` |
| like | 点赞评论 | 1.0 | `{commentId}` |
| share | 分享书籍 | 1.0 | `{platform: 'wechat'}` |

**代码示例**:

```javascript
// 1. 点击行为（书籍卡片）
function BookCard({ book, position }) {
  async function handleClick() {
    // 记录点击行为
    await recordBehavior(book.id, 'click', 1.0, {
      position: position // 'homepage', 'recommendation', 'search'
    });
    
    // 跳转到详情页
    window.location.href = `/book/${book.id}`;
  }
  
  return <div onClick={handleClick}>...</div>;
}

// 2. 浏览行为（详情页停留时长）
function BookDetailPage({ bookId }) {
  useEffect(() => {
    const startTime = Date.now();
    
    return () => {
      const duration = (Date.now() - startTime) / 1000;
      if (duration > 5) { // 停留超过5秒才记录
        recordBehavior(bookId, 'view', duration);
      }
    };
  }, [bookId]);
  
  return <div>...</div>;
}

// 3. 阅读行为（章节阅读）
function ReaderPage({ bookId, chapterId }) {
  const startTime = useRef(Date.now());
  const [progress, setProgress] = useState(0);
  
  // 定期保存阅读进度
  useEffect(() => {
    const timer = setInterval(() => {
      const duration = (Date.now() - startTime.current) / 1000;
      
      // 每30秒记录一次
      if (duration >= 30) {
        recordBehavior(bookId, 'read', duration, {
          chapterId,
          progress: progress / 100
        });
        
        startTime.current = Date.now();
      }
    }, 30000);
    
    return () => clearInterval(timer);
  }, [bookId, chapterId, progress]);
  
  // 读完章节
  function handleChapterFinish() {
    recordBehavior(bookId, 'finish', 1.0, {
      chapterId
    });
  }
  
  return <div>...</div>;
}

// 4. 收藏行为
async function handleCollect(bookId) {
  // 调用收藏API
  await collectBook(bookId);
  
  // 记录收藏行为
  await recordBehavior(bookId, 'collect', 1.0);
  
  showToast('收藏成功');
}

// 5. 分享行为
async function handleShare(bookId, platform) {
  // 调用分享API
  await shareBook(bookId, platform);
  
  // 记录分享行为
  await recordBehavior(bookId, 'share', 1.0, {
    platform: platform // 'wechat', 'qq', 'weibo'
  });
}
```

**最佳实践**:

1. **批量上报**: 本地缓存行为数据，每分钟批量上报一次
2. **异步处理**: 行为记录不阻塞主流程，失败静默处理
3. **数据清洗**: 过滤无效行为（如停留时间<3秒）

```javascript
// 批量上报管理器
class BehaviorReporter {
  constructor() {
    this.queue = [];
    this.timer = null;
    this.startReporting();
  }
  
  // 添加行为到队列
  add(itemId, behaviorType, value, metadata) {
    this.queue.push({
      itemId,
      behaviorType,
      value,
      metadata,
      timestamp: Date.now()
    });
    
    // 队列超过10条，立即上报
    if (this.queue.length >= 10) {
      this.flush();
    }
  }
  
  // 定期上报（每分钟）
  startReporting() {
    this.timer = setInterval(() => {
      this.flush();
    }, 60000);
  }
  
  // 批量上报
  async flush() {
    if (this.queue.length === 0) return;
    
    const behaviors = [...this.queue];
    this.queue = [];
    
    try {
      // 批量上报（需要后端支持）
      await fetch('/api/v1/recommendation/behavior/batch', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ behaviors })
      });
    } catch (error) {
      console.error('行为上报失败:', error);
      // 失败的行为重新加入队列
      this.queue.unshift(...behaviors);
    }
  }
  
  // 页面关闭时上报
  destroy() {
    clearInterval(this.timer);
    this.flush();
  }
}

// 全局单例
const behaviorReporter = new BehaviorReporter();

// 页面卸载时上报
window.addEventListener('beforeunload', () => {
  behaviorReporter.destroy();
});

// 简化的API
function trackBehavior(itemId, behaviorType, value, metadata) {
  behaviorReporter.add(itemId, behaviorType, value, metadata);
}
```

---

## 使用场景

### 场景1: 首页推荐模块

**需求**: 首页展示10本个性化推荐书籍

```javascript
// 1. 加载推荐
async function loadHomepageRecommendations() {
  const result = await getPersonalizedRecommendations(10);
  
  if (result.code === 200) {
    const bookIds = result.data.recommendations;
    const books = await fetchBookDetails(bookIds);
    
    // 曝光埋点
    trackRecommendationImpression(bookIds);
    
    // 渲染
    renderRecommendationSection(books);
  }
}

// 2. 点击事件
function onBookClick(bookId, index) {
  // 记录点击行为
  recordBehavior(bookId, 'click', 1.0);
  
  // 点击埋点
  analytics.track('recommendation_click', {
    book_id: bookId,
    position: 'homepage',
    index: index
  });
  
  // 跳转
  window.location.href = `/book/${bookId}`;
}
```

### 场景2: 书籍详情页相似推荐

**需求**: 详情页底部展示6本相似书籍

```javascript
async function loadBookDetailPage(bookId) {
  // 加载书籍详情
  const book = await fetchBookDetail(bookId);
  renderBookDetail(book);
  
  // 记录浏览行为
  trackViewBehavior(bookId);
  
  // 加载相似书籍
  const result = await getSimilarItems(bookId, 6);
  if (result.code === 200) {
    const similarBooks = await fetchBookDetails(result.data.similar_items);
    renderSimilarSection(similarBooks);
  }
}

// 浏览时长记录
function trackViewBehavior(bookId) {
  const startTime = Date.now();
  
  window.addEventListener('beforeunload', () => {
    const duration = (Date.now() - startTime) / 1000;
    if (duration > 5) {
      recordBehavior(bookId, 'view', duration);
    }
  });
}
```

### 场景3: 阅读页行为追踪

**需求**: 追踪用户阅读时长和阅读进度

```javascript
class ReaderTracker {
  constructor(bookId, chapterId) {
    this.bookId = bookId;
    this.chapterId = chapterId;
    this.startTime = Date.now();
    this.lastReportTime = Date.now();
    this.startReporting();
  }
  
  // 每30秒上报一次
  startReporting() {
    this.timer = setInterval(() => {
      const duration = (Date.now() - this.lastReportTime) / 1000;
      
      recordBehavior(this.bookId, 'read', duration, {
        chapterId: this.chapterId,
        progress: this.getProgress()
      });
      
      this.lastReportTime = Date.now();
    }, 30000);
  }
  
  // 获取阅读进度
  getProgress() {
    const scrollTop = window.scrollY;
    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
    return scrollTop / scrollHeight;
  }
  
  // 读完章节
  finishChapter() {
    clearInterval(this.timer);
    
    const duration = (Date.now() - this.lastReportTime) / 1000;
    recordBehavior(this.bookId, 'read', duration, {
      chapterId: this.chapterId,
      progress: 1.0
    });
    
    recordBehavior(this.bookId, 'finish', 1.0, {
      chapterId: this.chapterId
    });
  }
  
  // 清理
  destroy() {
    clearInterval(this.timer);
    
    const duration = (Date.now() - this.lastReportTime) / 1000;
    if (duration > 5) {
      recordBehavior(this.bookId, 'read', duration, {
        chapterId: this.chapterId,
        progress: this.getProgress()
      });
    }
  }
}

// 使用
const tracker = new ReaderTracker(bookId, chapterId);

// 读完章节
function onNextChapter() {
  tracker.finishChapter();
  // 加载下一章
}

// 页面关闭
window.addEventListener('beforeunload', () => {
  tracker.destroy();
});
```

---

## 最佳实践

### 1. 性能优化

**前端缓存**:

```javascript
// 本地缓存推荐结果
const CACHE_KEY = 'qingyu_recommendations';
const CACHE_DURATION = 5 * 60 * 1000; // 5分钟

async function getCachedRecommendations() {
  const cached = localStorage.getItem(CACHE_KEY);
  
  if (cached) {
    const { data, timestamp } = JSON.parse(cached);
    
    if (Date.now() - timestamp < CACHE_DURATION) {
      return data;
    }
  }
  
  // 缓存失效，重新请求
  const result = await getPersonalizedRecommendations(10);
  
  if (result.code === 200) {
    localStorage.setItem(CACHE_KEY, JSON.stringify({
      data: result.data.recommendations,
      timestamp: Date.now()
    }));
    
    return result.data.recommendations;
  }
}
```

**懒加载**:

```javascript
// 使用Intersection Observer延迟加载
function RecommendationSection() {
  const ref = useRef(null);
  const [books, setBooks] = useState([]);
  
  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        loadRecommendations();
        observer.disconnect();
      }
    });
    
    observer.observe(ref.current);
    
    return () => observer.disconnect();
  }, []);
  
  async function loadRecommendations() {
    const result = await getPersonalizedRecommendations(10);
    if (result.code === 200) {
      const bookDetails = await fetchBookDetails(result.data.recommendations);
      setBooks(bookDetails);
    }
  }
  
  return <div ref={ref}>...</div>;
}
```

### 2. 错误处理

```javascript
async function safeGetRecommendations(limit = 10, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const result = await getPersonalizedRecommendations(limit);
      
      if (result.code === 200) {
        return result.data.recommendations;
      } else {
        console.warn(`推荐失败: ${result.message}`);
      }
    } catch (error) {
      console.error(`请求失败 (${i + 1}/${retries}):`, error);
      
      if (i === retries - 1) {
        // 最后一次失败，返回默认推荐
        return getDefaultRecommendations();
      }
      
      // 指数退避
      await delay(Math.pow(2, i) * 1000);
    }
  }
}

// 默认推荐（热门书籍）
function getDefaultRecommendations() {
  return fetchHotBooks(10);
}
```

### 3. 用户体验

**骨架屏**:

```jsx
function RecommendationSection() {
  const [loading, setLoading] = useState(true);
  const [books, setBooks] = useState([]);
  
  useEffect(() => {
    loadRecommendations();
  }, []);
  
  async function loadRecommendations() {
    setLoading(true);
    const result = await getPersonalizedRecommendations(10);
    if (result.code === 200) {
      const bookDetails = await fetchBookDetails(result.data.recommendations);
      setBooks(bookDetails);
    }
    setLoading(false);
  }
  
  if (loading) {
    return <SkeletonBookGrid count={10} />;
  }
  
  return <BookGrid books={books} />;
}
```

**刷新推荐**:

```jsx
function RecommendationSection() {
  const [books, setBooks] = useState([]);
  const [refreshing, setRefreshing] = useState(false);
  
  async function handleRefresh() {
    setRefreshing(true);
    
    // 清除缓存
    clearRecommendationCache();
    
    // 重新加载
    const result = await getPersonalizedRecommendations(10);
    if (result.code === 200) {
      const bookDetails = await fetchBookDetails(result.data.recommendations);
      setBooks(bookDetails);
    }
    
    setRefreshing(false);
  }
  
  return (
    <div>
      <div className="section-header">
        <h2>为你推荐</h2>
        <button onClick={handleRefresh} disabled={refreshing}>
          {refreshing ? '刷新中...' : '换一批'}
        </button>
      </div>
      <BookGrid books={books} />
    </div>
  );
}
```

---

## 常见问题

### Q1: 新用户没有推荐怎么办？

**A**: 系统会自动返回热门书籍作为冷启动策略。

```javascript
const result = await getPersonalizedRecommendations(10);

if (result.data.source === 'hot_books') {
  // 新用户，展示"热门推荐"标题
  showHotBooksTitle();
} else {
  // 老用户，展示"为你推荐"标题
  showPersonalizedTitle();
}
```

### Q2: 推荐结果多久更新一次？

**A**: 
- 后端缓存：1小时
- 用户产生新行为后，缓存立即失效
- 前端建议5分钟刷新一次

### Q3: 如何提高推荐准确率？

**A**: 
1. 尽可能记录用户行为（view, click, read等）
2. 传递详细的metadata（如阅读进度、停留时长）
3. 用户点击推荐后及时上报点击事件

### Q4: 相似推荐为什么有时返回空？

**A**: 
- 新书籍特征未计算完成
- 书籍特征不足（标签、作者、分类缺失）
- 建议降级到同分类热门书籍

```javascript
const result = await getSimilarItems(bookId, 6);

if (!result.data.similar_items || result.data.similar_items.length === 0) {
  // 降级：同分类热门书籍
  const book = await fetchBookDetail(bookId);
  const hotBooks = await getHotBooksByCategory(book.category, 6);
  displaySimilarBooks(hotBooks);
}
```

### Q5: 行为上报失败怎么办？

**A**: 
- 行为记录失败不影响主流程
- 建议实现本地缓存 + 重试机制
- 失败的行为可以暂存，下次再上报

---

## 性能优化

### 指标监控

```javascript
// 埋点：推荐请求耗时
function trackRecommendationPerformance() {
  const startTime = performance.now();
  
  const result = await getPersonalizedRecommendations(10);
  
  const duration = performance.now() - startTime;
  
  analytics.track('recommendation_performance', {
    duration: duration,
    success: result.code === 200,
    timestamp: Date.now()
  });
}
```

### 预加载

```javascript
// 首页加载时预加载推荐
window.addEventListener('DOMContentLoaded', () => {
  // 预加载推荐（不阻塞渲染）
  prefetchRecommendations();
});

async function prefetchRecommendations() {
  const result = await getPersonalizedRecommendations(20);
  // 缓存到localStorage
  cacheRecommendations(result.data.recommendations);
}
```

### CDN加速

- 书籍封面图使用CDN
- 推荐API考虑使用CDN边缘节点
- 静态资源（JS/CSS）使用CDN

---

## 技术支持

**问题反馈**: issues@qingyu.com  
**文档反馈**: docs@qingyu.com  
**技术交流**: tech-community@qingyu.com

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-10  
**维护团队**: 青羽推荐系统团队


