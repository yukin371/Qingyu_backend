# 配置文件加载顺序和优先级说明

## 📋 配置文件概述

项目中有三个配置文件，用于不同的环境：

| 配置文件 | 用途 | 使用场景 |
|---------|------|---------|
| `config.yaml` | **默认配置** | 本地开发、通用配置 |
| `config.test.yaml` | **测试配置** | 运行测试时使用 |
| `config.docker.yaml` | **Docker配置** | Docker容器环境 |

## 🔄 配置加载顺序（优先级从高到低）

### 1. **环境变量（最高优先级）**

```bash
# 环境变量会覆盖配置文件中的所有值
export QINGYU_DATABASE_PRIMARY_MONGODB_URI="mongodb://prod-host:27017"
export QINGYU_JWT_SECRET="production-secret"
export QINGYU_SERVER_PORT="9090"
```

**命名规则**：`QINGYU_` + 配置路径（`.` 替换为 `_`）

示例：
- `database.primary.mongodb.uri` → `QINGYU_DATABASE_PRIMARY_MONGODB_URI`
- `jwt.secret` → `QINGYU_JWT_SECRET`
- `server.port` → `QINGYU_SERVER_PORT`

### 2. **指定的配置文件**

通过环境变量 `CONFIG_FILE` 指定完整配置文件路径：

```bash
# 方式1: 指定完整路径
export CONFIG_FILE="/path/to/config.test.yaml"
go run cmd/server/main.go

# 方式2: 指定配置目录
export CONFIG_PATH="./config"
# 会自动查找 config.yaml

# 方式3: Docker环境
docker run -e CONFIG_FILE="/app/config/config.docker.yaml" ...
```

### 3. **默认配置文件查找**

如果没有设置 `CONFIG_FILE` 或 `CONFIG_PATH`，会按以下顺序查找：

```go
// 查找顺序（优先检测测试配置）
1. config.test.yaml              // ⭐ 测试配置（第一优先级）
   - 在以下路径搜索：
     ① configPath/config.test.yaml
     ② ./config/config.test.yaml
     ③ ../../config/config.test.yaml
     ④ ./config.test.yaml

2. 如果未找到 config.test.yaml，使用默认配置：
   ① ./config/config.yaml         // 项目根目录的config子目录
   ② ../../config/config.yaml     // 从cmd/server运行时
   ③ ./config.yaml                // 当前目录
   ④ /app/config/config.yaml      // Docker环境默认路径
```

**⚠️ 重要**：`config.test.yaml` 具有**自动检测优先级**，如果存在会优先加载，无需手动指定。这对测试环境特别有用。

### 4. **代码中的默认值（最低优先级）**

在 `config/config.go` 的 `setDefaults()` 函数中定义。

## 🎯 不同环境的使用方式

### **本地开发环境**

```bash
# 1. 不设置任何环境变量（使用config.yaml）
go run cmd/server/main.go

# 2. 或者明确指定
export CONFIG_FILE="./config/config.yaml"
go run cmd/server/main.go
```

**实际加载的配置**：`config/config.yaml`

### **测试环境**

```bash
# 方式1: 在测试代码中指定
_, err := config.LoadConfig("../../config/config.test.yaml")

# 方式2: 通过环境变量
export CONFIG_FILE="./config/config.test.yaml"
go test ./test/integration/...

# 方式3: 通过Makefile
make test  # 内部会设置CONFIG_FILE
```

**实际加载的配置**：`config/config.test.yaml`

### **Docker环境**

```bash
# docker-compose.yml 中设置
services:
  backend:
    environment:
      - CONFIG_FILE=/app/config/config.docker.yaml
    volumes:
      - ./config:/app/config
```

**实际加载的配置**：`config/config.docker.yaml`

## 📊 配置加载流程图

```
┌─────────────────────────────────────┐
│   启动应用/测试                        │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│  检查 CONFIG_FILE 环境变量             │
│  是否设置？                            │
└───────┬─────────────────────────────┘
        │
    ┌───┴───┐
   是        否
    │        │
    │        ▼
    │   ┌────────────────────────────┐
    │   │ 🔍 自动检测 config.test.yaml │
    │   │ （测试配置优先）             │
    │   └───┬────────────────────────┘
    │       │
    │   ┌───┴───┐
    │  找到      未找到
    │   │        │
    │   │        ▼
    │   │   ┌──────────────────────────┐
    │   │   │ 检查 CONFIG_PATH          │
    │   │   │ 是否设置？                 │
    │   │   └───┬──────────────────────┘
    │   │       │
    │   │   ┌───┴───┐
    │   │  是        否
    │   │   │        │
    │   │   │        ▼
    │   │   │   ┌────────────────────┐
    │   │   │   │ 检查Docker环境      │
    │   │   │   │ /app/config存在？   │
    │   │   │   └───┬────────────────┘
    │   │   │       │
    │   │   │   ┌───┴───┐
    │   │   │  是        否
    │   │   │   │        │
    │   │   │   ▼        ▼
    │   │   │  Docker   当前目录
    │   │   │  路径     ./config
    │   │   │   │        │
    │   └───┴───┴────────┴───┐
    │                        │
    ▼                        ▼
┌──────────────────────────────────────┐
│  使用指定/检测到的配置文件              │
└───────────────┬──────────────────────┘
                │
                ▼
┌──────────────────────────────────────┐
│  Viper 加载配置文件                     │
│  1. 读取YAML文件                       │
│  2. 应用默认值                         │
│  3. 覆盖环境变量                       │
└───────────────┬──────────────────────┘
                │
                ▼
┌──────────────────────────────────────┐
│  验证配置                              │
│  (ValidateConfig)                     │
└───────────────┬──────────────────────┘
                │
                ▼
┌──────────────────────────────────────┐
│  配置加载完成                          │
│  GlobalConfig 可用                    │
└──────────────────────────────────────┘
```

## 🛡️ 避免配置冲突的最佳实践

### 1. **环境分离原则**

每个配置文件负责不同的环境，**不要混用**：

```bash
# ❌ 错误：在测试中使用开发配置
CONFIG_FILE="./config/config.yaml" go test ./test/...

# ✅ 正确1：测试使用测试配置（自动检测）
# 如果 config.test.yaml 存在，会自动优先加载
go test ./test/...

# ✅ 正确2：明确指定测试配置
CONFIG_FILE="./config/config.test.yaml" go test ./test/...
```

**⭐ 推荐**：将 `config.test.yaml` 提交到版本控制，确保团队测试环境一致。

### 2. **配置文件结构保持一致**

所有配置文件应保持相同的结构，只修改值：

```yaml
# 所有配置文件都应包含这些顶级键
server:
  port: ...
  mode: ...

mongodb:
  uri: ...
  database: ...

jwt:
  secret: ...
  expire: ...
```

### 3. **使用环境特定的值**

| 配置项 | config.yaml | config.test.yaml | config.docker.yaml |
|-------|-------------|------------------|-------------------|
| `mongodb.database` | `Qingyu_backend` | `qingyu_test` | `Qingyu_writer` |
| `mongodb.uri` | `localhost:27017` | `localhost:27017` | `mongodb:27017` |
| `redis.db` | `0` | `1` | `0` |
| `server.mode` | `debug` | `test` | `debug` |
| `jwt.secret` | `qingyu_secret_key` | `test-secret-key-...` | `qingyu_secret_key` |

### 4. **数据库隔离**

```yaml
# config.yaml (开发)
mongodb:
  database: "Qingyu_backend"
  
# config.test.yaml (测试)
mongodb:
  database: "qingyu_test"    # 使用不同的数据库名
  
# config.docker.yaml (Docker)
mongodb:
  database: "Qingyu_writer"  # 使用不同的数据库名
```

### 5. **Redis数据库隔离**

```yaml
# config.yaml (开发)
redis:
  db: 0
  
# config.test.yaml (测试)
redis:
  db: 1    # 使用不同的Redis DB

# config.docker.yaml (Docker)
redis:
  db: 0
```

## 🔍 如何确认当前使用的配置

### 方法1: 查看启动日志

```bash
go run cmd/server/main.go

# 输出：
# [Main] Working directory: /path/to/project
# [Main] CONFIG_FILE env: 
# [Main] CONFIG_PATH env: 
# [Main] Using current directory for config: .
# [Main] Final config path: .
# [Main] Configuration loaded successfully
```

### 方法2: 使用环境变量验证

```bash
# 设置CONFIG_FILE
export CONFIG_FILE="./config/config.test.yaml"
go run cmd/server/main.go

# 输出会显示：
# [Main] CONFIG_FILE env: ./config/config.test.yaml
# [Main] Final config path: ./config/config.test.yaml
```

### 方法3: 代码中获取配置

```go
import "Qingyu_backend/config"

// 获取当前数据库名（确认使用哪个配置）
dbConfig, _ := config.GetDatabaseConfig()
fmt.Printf("当前数据库: %s\n", dbConfig.Primary.MongoDB.Database)

// 输出示例：
// 开发环境: 当前数据库: Qingyu_backend
// 测试环境: 当前数据库: qingyu_test
// Docker环境: 当前数据库: Qingyu_writer
```

## 📝 配置文件优先级总结表

| 优先级 | 来源 | 示例 | 适用场景 |
|-------|------|------|---------|
| **1（最高）** | 环境变量 | `QINGYU_JWT_SECRET=prod-secret` | 生产环境敏感配置 |
| **2** | CONFIG_FILE | `export CONFIG_FILE="./config/config.test.yaml"` | 明确指定配置文件 |
| **3** | 测试配置自动检测 | `config.test.yaml` 存在 | **测试环境（⭐新增）** |
| **4** | CONFIG_PATH | `export CONFIG_PATH="./config"` | 指定配置目录 |
| **5** | Docker检测 | `/app/config/config.yaml` 存在 | Docker容器环境 |
| **6** | 自动搜索 | `./config/config.yaml` | 默认行为 |
| **7（最低）** | 代码默认值 | `setDefaults()` | 兜底配置 |

## 🚀 实际使用示例

### 示例1: 本地开发

```bash
# 使用默认config.yaml（如果没有config.test.yaml）
cd /path/to/Qingyu_backend
go run cmd/server/main.go

# 如果存在 config.test.yaml，会优先使用：
# [Config] Using test config: ./config/config.test.yaml

# 数据库：Qingyu_backend (或 qingyu_test 如果使用test配置)
# Redis DB: 0 (或 1 如果使用test配置)
# 端口：8080
```

### 示例2: 运行集成测试（⭐推荐）

```bash
# 方式1: 自动检测测试配置（推荐）
# 只要 config.test.yaml 存在，会自动加载
go test ./test/integration/scenario_ai_generation_test.go -v
# [Config] Using test config: ./config/config.test.yaml

# 方式2: 明确指定配置文件（仍然支持）
export CONFIG_FILE="./config/config.test.yaml"
go test ./test/integration/... -v

# 测试配置：
# 数据库：qingyu_test
# Redis DB: 1
# 端口：8080
```

### 示例3: Docker部署

```yaml
# docker-compose.yml
services:
  backend:
    image: qingyu-backend:latest
    environment:
      - CONFIG_FILE=/app/config/config.docker.yaml
    volumes:
      - ./config:/app/config
```

```bash
docker-compose up

# 数据库：Qingyu_writer
# MongoDB URI: mongodb:27017 (Docker服务名)
# Redis: redis:6379 (Docker服务名)
```

### 示例4: 生产环境（环境变量覆盖）

```bash
# 基于config.yaml，但关键配置通过环境变量覆盖
export CONFIG_FILE="./config/config.yaml"
export QINGYU_JWT_SECRET="super-secure-production-secret"
export QINGYU_MONGODB_URI="mongodb://prod-user:pass@prod-host:27017"
export QINGYU_SERVER_MODE="release"

go run cmd/server/main.go

# 数据库URI被覆盖为生产地址
# JWT密钥使用生产密钥
# 服务器模式：release
```

## ⚠️ 常见问题和解决方案

### 问题1: 配置文件未找到

**现象**：
```
Warning: Config file not found: Config File "config" Not Found in [...]
```

**解决方案**：
```bash
# 确认配置文件位置
ls -la config/

# 设置明确的路径
export CONFIG_FILE="./config/config.yaml"
```

### 问题2: 测试使用了开发数据库

**现象**：测试数据污染了开发数据库

**解决方案**：
```go
// 在测试中明确指定测试配置
_, err := config.LoadConfig("../../config/config.test.yaml")

// 或使用环境变量
// export CONFIG_FILE="./config/config.test.yaml"
```

### 问题3: Docker容器无法连接数据库

**现象**：
```
Failed to connect to MongoDB: no reachable servers
```

**解决方案**：
```yaml
# config.docker.yaml 应使用Docker服务名
mongodb:
  uri: "mongodb://mongodb:27017"  # 不是 localhost
  
redis:
  addr: "redis:6379"  # 不是 localhost:6379
```

### 问题4: 环境变量未生效

**现象**：设置了环境变量但配置没有更改

**解决方案**：
```bash
# 确认环境变量格式正确
# ❌ 错误
export QINGYU_DATABASE.URI="..."

# ✅ 正确（使用下划线）
export QINGYU_DATABASE_PRIMARY_MONGODB_URI="..."

# 验证环境变量
printenv | grep QINGYU
```

## 📚 配置检查清单

使用以下清单确保配置正确：

- [ ] 三个配置文件的结构保持一致
- [ ] 每个环境使用不同的数据库名
- [ ] 测试环境使用不同的Redis DB
- [ ] Docker配置使用服务名而非localhost
- [ ] 生产环境JWT密钥足够强
- [ ] 敏感信息通过环境变量传递
- [ ] 测试配置文件不包含生产数据
- [ ] 启动时检查日志确认使用正确的配置

## 🎓 最佳实践总结

1. **开发环境**：使用 `config.yaml`，无需设置环境变量
2. **测试环境**：明确指定 `config.test.yaml`，使用独立数据库
3. **Docker环境**：使用 `config.docker.yaml`，配置Docker服务名
4. **生产环境**：基础配置文件 + 环境变量覆盖敏感信息
5. **配置隔离**：不同环境使用不同的数据库名和Redis DB
6. **版本控制**：配置文件提交到Git，但敏感信息使用`.env`或环境变量

---

**最后更新**：2025-10-25  
**维护者**：青羽后端团队

