# 书城系统使用指南

> **文档版本**: v1.0  
> **创建日期**: 2025-10-09  
> **适用对象**: 前端开发者、移动端开发者  
> **系统版本**: v1.0

## 📚 目录

- [1. 快速开始](#1-快速开始)
- [2. 常见场景](#2-常见场景)
- [3. 最佳实践](#3-最佳实践)
- [4. 性能优化](#4-性能优化)
- [5. 错误处理](#5-错误处理)
- [6. 常见问题](#6-常见问题)

---

## 1. 快速开始

### 1.1 环境准备

#### 配置Base URL

```javascript
// JavaScript
const BASE_URL = 'http://your-domain/api/v1';

// TypeScript
const BASE_URL: string = 'http://your-domain/api/v1';
```

```python
# Python
BASE_URL = 'http://your-domain/api/v1'
```

#### 创建HTTP客户端

```javascript
// axios示例
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://your-domain/api/v1',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 响应拦截器
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    console.error('API错误:', error);
    return Promise.reject(error);
  }
);
```

### 1.2 第一个请求

#### 获取首页数据

```javascript
async function getHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    console.log('首页数据:', response.data);
    return response.data;
  } catch (error) {
    console.error('获取首页数据失败:', error);
    throw error;
  }
}

// 使用
getHomepage()
  .then(data => {
    // 处理首页数据
    const { banners, recommended_books, featured_books, categories } = data;
    // 渲染页面
  });
```

---

## 2. 常见场景

### 2.1 场景一：展示书城首页

#### 需求描述

展示书城首页，包括Banner轮播图、推荐书籍、精选书籍、分类导航和榜单数据。

#### 实现步骤

**步骤1：获取首页数据**

```javascript
async function loadHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    const {
      banners,
      recommended_books,
      featured_books,
      categories,
      rankings
    } = response.data;
    
    // 渲染各个模块
    renderBanners(banners);
    renderRecommendedBooks(recommended_books);
    renderFeaturedBooks(featured_books);
    renderCategories(categories);
    renderRankings(rankings);
  } catch (error) {
    showErrorMessage('加载首页失败，请稍后重试');
  }
}
```

**步骤2：渲染Banner**

```javascript
function renderBanners(banners) {
  // Vue示例
  this.banners = banners.map(banner => ({
    id: banner.id,
    imageUrl: banner.image_url,
    linkUrl: banner.link_url,
    title: banner.title,
    onClick: () => handleBannerClick(banner.id, banner.link_url)
  }));
}

async function handleBannerClick(bannerId, linkUrl) {
  // 记录点击统计
  try {
    await apiClient.post(`/bookstore/banners/${bannerId}/click`);
  } catch (error) {
    console.warn('记录Banner点击失败:', error);
  }
  
  // 跳转
  window.location.href = linkUrl;
}
```

**步骤3：渲染推荐书籍**

```javascript
function renderRecommendedBooks(books) {
  this.recommendedBooks = books.map(book => ({
    id: book.id,
    title: book.title,
    author: book.author,
    coverUrl: book.cover_image_url,
    categoryName: book.category_name,
    rating: book.rating,
    viewCount: formatNumber(book.view_count),
    onClick: () => navigateToBookDetail(book.id)
  }));
}

// 数字格式化
function formatNumber(num) {
  if (num >= 10000) {
    return (num / 10000).toFixed(1) + '万';
  }
  return num.toString();
}
```

#### 完整示例（Vue 3）

```vue
<template>
  <div class="homepage">
    <!-- Banner轮播 -->
    <div class="banner-section">
      <swiper :slides="banners" @slide-click="handleBannerClick">
        <template #slide="{ slide }">
          <img :src="slide.imageUrl" :alt="slide.title" />
        </template>
      </swiper>
    </div>
    
    <!-- 推荐书籍 -->
    <section class="recommended-section">
      <h2>推荐书籍</h2>
      <div class="book-grid">
        <book-card
          v-for="book in recommendedBooks"
          :key="book.id"
          :book="book"
          @click="navigateToBookDetail(book.id)"
        />
      </div>
    </section>
    
    <!-- 分类导航 -->
    <section class="category-section">
      <category-nav :categories="categories" />
    </section>
    
    <!-- 榜单 -->
    <section class="ranking-section">
      <ranking-list :rankings="rankings" />
    </section>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { apiClient } from '@/utils/api';

const banners = ref([]);
const recommendedBooks = ref([]);
const categories = ref([]);
const rankings = ref([]);

async function loadHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    const data = response.data;
    
    banners.value = data.banners;
    recommendedBooks.value = data.recommended_books;
    categories.value = data.categories;
    rankings.value = data.rankings;
  } catch (error) {
    console.error('加载首页失败:', error);
  }
}

async function handleBannerClick(banner) {
  try {
    await apiClient.post(`/bookstore/banners/${banner.id}/click`);
  } catch (error) {
    console.warn('记录点击失败:', error);
  }
  navigateTo(banner.linkUrl);
}

function navigateToBookDetail(bookId) {
  router.push(`/books/${bookId}`);
}

onMounted(() => {
  loadHomepage();
});
</script>
```

---

### 2.2 场景二：书籍搜索

#### 需求描述

实现书籍搜索功能，支持关键词搜索、分类筛选、标签筛选、排序等。

#### 实现步骤

**步骤1：创建搜索表单**

```javascript
const searchForm = {
  keyword: '',
  categoryId: '',
  author: '',
  tags: [],
  sortBy: 'view_count',
  sortOrder: 'desc',
  page: 1,
  size: 20
};
```

**步骤2：执行搜索**

```javascript
async function searchBooks(params) {
  try {
    const response = await apiClient.get('/bookstore/books/search', {
      params: {
        keyword: params.keyword,
        categoryId: params.categoryId,
        author: params.author,
        tags: params.tags,
        sortBy: params.sortBy,
        sortOrder: params.sortOrder,
        page: params.page,
        size: params.size
      }
    });
    
    return {
      books: response.data,
      total: response.total,
      page: response.page,
      size: response.size
    };
  } catch (error) {
    console.error('搜索失败:', error);
    throw error;
  }
}
```

**步骤3：处理分页**

```javascript
async function handlePageChange(page) {
  searchForm.page = page;
  const result = await searchBooks(searchForm);
  
  this.books = result.books;
  this.total = result.total;
  this.currentPage = result.page;
}
```

#### 完整示例（React）

```jsx
import React, { useState, useEffect } from 'react';
import { apiClient } from './utils/api';

function BookSearch() {
  const [searchParams, setSearchParams] = useState({
    keyword: '',
    categoryId: '',
    sortBy: 'view_count',
    sortOrder: 'desc',
    page: 1,
    size: 20
  });
  
  const [searchResults, setSearchResults] = useState({
    books: [],
    total: 0,
    page: 1
  });
  
  const [loading, setLoading] = useState(false);
  
  // 执行搜索
  const handleSearch = async () => {
    setLoading(true);
    try {
      const response = await apiClient.get('/bookstore/books/search', {
        params: searchParams
      });
      
      setSearchResults({
        books: response.data,
        total: response.total,
        page: response.page
      });
    } catch (error) {
      console.error('搜索失败:', error);
      alert('搜索失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };
  
  // 更新搜索参数
  const updateSearchParam = (key, value) => {
    setSearchParams(prev => ({
      ...prev,
      [key]: value,
      page: 1 // 重置页码
    }));
  };
  
  // 分页处理
  const handlePageChange = (page) => {
    setSearchParams(prev => ({
      ...prev,
      page
    }));
  };
  
  // 监听搜索参数变化
  useEffect(() => {
    if (searchParams.keyword) {
      handleSearch();
    }
  }, [searchParams]);
  
  return (
    <div className="book-search">
      <div className="search-form">
        <input
          type="text"
          placeholder="搜索书名、作者..."
          value={searchParams.keyword}
          onChange={(e) => updateSearchParam('keyword', e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
        />
        
        <select
          value={searchParams.sortBy}
          onChange={(e) => updateSearchParam('sortBy', e.target.value)}
        >
          <option value="view_count">按热度</option>
          <option value="rating">按评分</option>
          <option value="created_at">按时间</option>
        </select>
        
        <button onClick={handleSearch} disabled={loading}>
          {loading ? '搜索中...' : '搜索'}
        </button>
      </div>
      
      <div className="search-results">
        {searchResults.books.map(book => (
          <BookCard key={book.id} book={book} />
        ))}
      </div>
      
      <Pagination
        current={searchResults.page}
        total={searchResults.total}
        pageSize={searchParams.size}
        onChange={handlePageChange}
      />
    </div>
  );
}
```

---

### 2.3 场景三：阅读章节

#### 需求描述

展示书籍章节列表，支持章节导航（上一章/下一章）、章节内容获取。

#### 实现步骤

**步骤1：获取章节列表**

```javascript
async function getChapterList(bookId, page = 1, size = 100) {
  try {
    const response = await apiClient.get(`/books/${bookId}/chapters`, {
      params: { page, size }
    });
    
    return {
      chapters: response.data,
      total: response.total
    };
  } catch (error) {
    console.error('获取章节列表失败:', error);
    throw error;
  }
}
```

**步骤2：获取章节内容**

```javascript
async function getChapterContent(chapterId) {
  try {
    const response = await apiClient.get(`/chapters/${chapterId}/content`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIP章节需要权限
      showVipPrompt();
    } else {
      console.error('获取章节内容失败:', error);
    }
    throw error;
  }
}
```

**步骤3：章节导航**

```javascript
async function navigateToNextChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/next`);
    const nextChapter = response.data;
    
    // 加载下一章内容
    await loadChapter(nextChapter.id);
  } catch (error) {
    if (error.response?.status === 404) {
      showMessage('已经是最后一章了');
    } else {
      console.error('获取下一章失败:', error);
    }
  }
}

async function navigateToPreviousChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/previous`);
    const prevChapter = response.data;
    
    // 加载上一章内容
    await loadChapter(prevChapter.id);
  } catch (error) {
    if (error.response?.status === 404) {
      showMessage('已经是第一章了');
    } else {
      console.error('获取上一章失败:', error);
    }
  }
}
```

#### 完整示例（Vue 3 Composition API）

```vue
<template>
  <div class="chapter-reader">
    <!-- 章节标题 -->
    <div class="chapter-header">
      <h1>{{ currentChapter?.title }}</h1>
      <div class="chapter-info">
        <span>第{{ currentChapter?.chapter_num }}章</span>
        <span>{{ currentChapter?.word_count }}字</span>
      </div>
    </div>
    
    <!-- 章节内容 -->
    <div class="chapter-content" v-html="chapterContent"></div>
    
    <!-- 章节导航 -->
    <div class="chapter-nav">
      <button
        @click="navigateToPrevious"
        :disabled="!hasPrevious"
      >
        上一章
      </button>
      
      <button @click="showChapterList">
        目录
      </button>
      
      <button
        @click="navigateToNext"
        :disabled="!hasNext"
      >
        下一章
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import { apiClient } from '@/utils/api';

const route = useRoute();
const currentChapter = ref(null);
const chapterContent = ref('');
const loading = ref(false);

// 加载章节
async function loadChapter(chapterId) {
  loading.value = true;
  try {
    // 获取章节信息
    const chapterResponse = await apiClient.get(`/chapters/${chapterId}`);
    currentChapter.value = chapterResponse.data;
    
    // 获取章节内容
    const contentResponse = await apiClient.get(`/chapters/${chapterId}/content`);
    chapterContent.value = contentResponse.data.content;
  } catch (error) {
    console.error('加载章节失败:', error);
    alert('加载章节失败，请稍后重试');
  } finally {
    loading.value = false;
  }
}

// 上一章
async function navigateToPrevious() {
  try {
    const response = await apiClient.get(`/chapters/${currentChapter.value.id}/previous`);
    await loadChapter(response.data.id);
  } catch (error) {
    if (error.response?.status === 404) {
      alert('已经是第一章了');
    }
  }
}

// 下一章
async function navigateToNext() {
  try {
    const response = await apiClient.get(`/chapters/${currentChapter.value.id}/next`);
    await loadChapter(response.data.id);
  } catch (error) {
    if (error.response?.status === 404) {
      alert('已经是最后一章了');
    }
  }
}

// 是否有上一章
const hasPrevious = computed(() => {
  return currentChapter.value?.chapter_num > 1;
});

// 是否有下一章
const hasNext = computed(() => {
  // 这里需要从书籍信息中获取总章节数
  return true; // 简化处理
});

onMounted(() => {
  const chapterId = route.params.chapterId;
  loadChapter(chapterId);
});
</script>

<style scoped>
.chapter-content {
  line-height: 1.8;
  font-size: 18px;
  padding: 20px;
  white-space: pre-wrap;
}

.chapter-nav {
  display: flex;
  justify-content: space-between;
  padding: 20px;
  position: sticky;
  bottom: 0;
  background: white;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
}
</style>
```

---

### 2.4 场景四：榜单展示

#### 需求描述

展示多个维度的榜单（实时榜、周榜、月榜、新人榜），支持榜单切换。

#### 实现步骤

**步骤1：获取榜单数据**

```javascript
async function getRanking(type, period = '', limit = 20) {
  try {
    const response = await apiClient.get(`/bookstore/rankings/${type}`, {
      params: { period, limit }
    });
    
    return response.data;
  } catch (error) {
    console.error('获取榜单失败:', error);
    throw error;
  }
}
```

**步骤2：榜单切换**

```javascript
async function switchRanking(type) {
  currentRankingType.value = type;
  
  // 根据类型获取对应的周期
  const period = getRankingPeriod(type);
  
  const rankingData = await getRanking(type, period);
  currentRanking.value = rankingData;
}

function getRankingPeriod(type) {
  if (type === 'realtime') {
    return ''; // 实时榜不需要周期
  } else if (type === 'weekly') {
    // 返回当前周期，格式：2024-W01
    return getCurrentWeekPeriod();
  } else if (type === 'monthly' || type === 'newbie') {
    // 返回当前月份，格式：2024-01
    return getCurrentMonthPeriod();
  }
  return '';
}

function getCurrentWeekPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const week = getWeekNumber(now);
  return `${year}-W${week.toString().padStart(2, '0')}`;
}

function getCurrentMonthPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  return `${year}-${month.toString().padStart(2, '0')}`;
}
```

#### 完整示例（React）

```jsx
import React, { useState, useEffect } from 'react';

function RankingList() {
  const [rankingType, setRankingType] = useState('realtime');
  const [rankingData, setRankingData] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const rankingTabs = [
    { type: 'realtime', label: '实时榜' },
    { type: 'weekly', label: '周榜' },
    { type: 'monthly', label: '月榜' },
    { type: 'newbie', label: '新人榜' }
  ];
  
  // 加载榜单
  const loadRanking = async (type) => {
    setLoading(true);
    try {
      const period = getRankingPeriod(type);
      const response = await apiClient.get(`/bookstore/rankings/${type}`, {
        params: { period, limit: 20 }
      });
      setRankingData(response.data);
    } catch (error) {
      console.error('加载榜单失败:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // 切换榜单
  const handleTabChange = (type) => {
    setRankingType(type);
    loadRanking(type);
  };
  
  useEffect(() => {
    loadRanking(rankingType);
  }, []);
  
  return (
    <div className="ranking-container">
      {/* 榜单切换Tab */}
      <div className="ranking-tabs">
        {rankingTabs.map(tab => (
          <button
            key={tab.type}
            className={rankingType === tab.type ? 'active' : ''}
            onClick={() => handleTabChange(tab.type)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      
      {/* 榜单列表 */}
      <div className="ranking-list">
        {loading ? (
          <div className="loading">加载中...</div>
        ) : (
          rankingData.map((item, index) => (
            <div key={item.book_id} className="ranking-item">
              <div className="rank-number">
                {index + 1}
              </div>
              <img
                src={item.cover_image_url}
                alt={item.title}
                className="book-cover"
              />
              <div className="book-info">
                <h3>{item.title}</h3>
                <p className="author">{item.author}</p>
                <div className="stats">
                  <span>热度: {item.score}</span>
                  {item.trend && (
                    <span className={`trend ${item.trend}`}>
                      {item.trend === 'up' ? '↑' : '↓'}
                    </span>
                  )}
                </div>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

---

## 3. 最佳实践

### 3.1 请求优化

#### 3.1.1 使用防抖和节流

```javascript
// 搜索防抖
import { debounce } from 'lodash';

const handleSearch = debounce(async (keyword) => {
  if (!keyword) return;
  
  const results = await searchBooks({ keyword });
  displaySearchResults(results);
}, 300);

// 使用
<input
  type="text"
  @input="handleSearch($event.target.value)"
  placeholder="搜索书籍..."
/>
```

#### 3.1.2 请求取消

```javascript
import axios from 'axios';

let cancelTokenSource = null;

async function searchBooks(keyword) {
  // 取消之前的请求
  if (cancelTokenSource) {
    cancelTokenSource.cancel('新的搜索请求');
  }
  
  // 创建新的取消令牌
  cancelTokenSource = axios.CancelToken.source();
  
  try {
    const response = await apiClient.get('/bookstore/books/search', {
      params: { keyword },
      cancelToken: cancelTokenSource.token
    });
    
    return response.data;
  } catch (error) {
    if (axios.isCancel(error)) {
      console.log('请求已取消:', error.message);
    } else {
      throw error;
    }
  }
}
```

#### 3.1.3 批量请求

```javascript
// 批量获取书籍详情
async function getBooksDetails(bookIds) {
  // 使用Promise.all并行请求
  try {
    const promises = bookIds.map(id =>
      apiClient.get(`/bookstore/books/${id}`)
    );
    
    const results = await Promise.all(promises);
    return results.map(r => r.data);
  } catch (error) {
    console.error('批量获取失败:', error);
    throw error;
  }
}
```

### 3.2 缓存策略

#### 3.2.1 内存缓存

```javascript
class BookstoreCache {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5分钟
  }
  
  set(key, value) {
    this.cache.set(key, {
      data: value,
      timestamp: Date.now()
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear() {
    this.cache.clear();
  }
}

const cache = new BookstoreCache();

// 使用缓存
async function getBookWithCache(bookId) {
  const cacheKey = `book:${bookId}`;
  
  // 尝试从缓存获取
  let book = cache.get(cacheKey);
  if (book) {
    console.log('从缓存获取:', bookId);
    return book;
  }
  
  // 从API获取
  const response = await apiClient.get(`/bookstore/books/${bookId}`);
  book = response.data;
  
  // 存入缓存
  cache.set(cacheKey, book);
  
  return book;
}
```

#### 3.2.2 LocalStorage缓存

```javascript
class LocalStorageCache {
  constructor(prefix = 'bookstore') {
    this.prefix = prefix;
  }
  
  getKey(key) {
    return `${this.prefix}:${key}`;
  }
  
  set(key, value, ttl = 3600000) { // 默认1小时
    const item = {
      data: value,
      expiry: Date.now() + ttl
    };
    
    try {
      localStorage.setItem(
        this.getKey(key),
        JSON.stringify(item)
      );
    } catch (error) {
      console.error('LocalStorage存储失败:', error);
    }
  }
  
  get(key) {
    try {
      const itemStr = localStorage.getItem(this.getKey(key));
      if (!itemStr) return null;
      
      const item = JSON.parse(itemStr);
      
      // 检查过期
      if (Date.now() > item.expiry) {
        this.remove(key);
        return null;
      }
      
      return item.data;
    } catch (error) {
      console.error('LocalStorage读取失败:', error);
      return null;
    }
  }
  
  remove(key) {
    localStorage.removeItem(this.getKey(key));
  }
  
  clear() {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith(this.prefix + ':')) {
        localStorage.removeItem(key);
      }
    });
  }
}

const localCache = new LocalStorageCache();

// 使用LocalStorage缓存分类树
async function getCategoryTreeWithCache() {
  const cacheKey = 'category_tree';
  
  // 尝试从缓存获取
  let tree = localCache.get(cacheKey);
  if (tree) {
    return tree;
  }
  
  // 从API获取
  const response = await apiClient.get('/bookstore/categories/tree');
  tree = response.data;
  
  // 存入缓存（1小时）
  localCache.set(cacheKey, tree, 3600000);
  
  return tree;
}
```

### 3.3 错误处理

#### 3.3.1 统一错误处理

```javascript
// 错误处理工具
class ErrorHandler {
  static handle(error, context = '') {
    console.error(`[${context}] 错误:`, error);
    
    if (error.response) {
      // HTTP错误
      const { status, data } = error.response;
      
      switch (status) {
        case 400:
          return this.handleBadRequest(data);
        case 401:
          return this.handleUnauthorized();
        case 404:
          return this.handleNotFound(data);
        case 500:
          return this.handleServerError(data);
        default:
          return this.handleUnknownError(error);
      }
    } else if (error.request) {
      // 网络错误
      return this.handleNetworkError();
    } else {
      // 其他错误
      return this.handleUnknownError(error);
    }
  }
  
  static handleBadRequest(data) {
    const message = data.message || '请求参数错误';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleUnauthorized() {
    const message = '请先登录';
    showErrorNotification(message);
    // 跳转到登录页
    router.push('/login');
    return { success: false, message };
  }
  
  static handleNotFound(data) {
    const message = data.message || '资源不存在';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleServerError(data) {
    const message = '服务器错误，请稍后重试';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleNetworkError() {
    const message = '网络连接失败，请检查网络';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleUnknownError(error) {
    const message = '未知错误，请稍后重试';
    showErrorNotification(message);
    return { success: false, message };
  }
}

// 使用示例
async function loadBook(bookId) {
  try {
    const response = await apiClient.get(`/bookstore/books/${bookId}`);
    return response.data;
  } catch (error) {
    ErrorHandler.handle(error, 'loadBook');
    return null;
  }
}
```

#### 3.3.2 重试机制

```javascript
async function fetchWithRetry(fetchFn, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchFn();
    } catch (error) {
      console.log(`尝试 ${i + 1}/${maxRetries} 失败`);
      
      if (i === maxRetries - 1) {
        throw error;
      }
      
      // 等待后重试
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // 指数退避
    }
  }
}

// 使用示例
const book = await fetchWithRetry(
  () => apiClient.get(`/bookstore/books/${bookId}`),
  3,
  1000
);
```

### 3.4 性能监控

#### 记录API性能

```javascript
class APIMonitor {
  static async measureAPI(apiName, fetchFn) {
    const startTime = performance.now();
    
    try {
      const result = await fetchFn();
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.logPerformance(apiName, duration, 'success');
      
      return result;
    } catch (error) {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.logPerformance(apiName, duration, 'error');
      
      throw error;
    }
  }
  
  static logPerformance(apiName, duration, status) {
    console.log(`[API性能] ${apiName}: ${duration.toFixed(2)}ms [${status}]`);
    
    // 可以上报到监控系统
    if (window.analytics) {
      window.analytics.track('api_performance', {
        api: apiName,
        duration,
        status
      });
    }
  }
}

// 使用示例
const homepage = await APIMonitor.measureAPI(
  'getHomepage',
  () => apiClient.get('/bookstore/homepage')
);
```

---

## 4. 性能优化

### 4.1 图片优化

#### 4.1.1 使用CDN

```javascript
function getOptimizedImageUrl(url, options = {}) {
  const {
    width = null,
    quality = 80,
    format = 'webp'
  } = options;
  
  if (!url) return '';
  
  // 使用CDN参数优化图片
  const params = new URLSearchParams();
  if (width) params.append('w', width);
  params.append('q', quality);
  params.append('f', format);
  
  return `${url}?${params.toString()}`;
}

// 使用示例
<img
  :src="getOptimizedImageUrl(book.cover_image_url, { width: 300, quality: 80 })"
  :alt="book.title"
/>
```

#### 4.1.2 懒加载

```javascript
// 使用Intersection Observer实现图片懒加载
class LazyImageLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            const src = img.dataset.src;
            
            if (src) {
              img.src = src;
              img.removeAttribute('data-src');
              this.observer.unobserve(img);
            }
          }
        });
      },
      {
        rootMargin: '50px'
      }
    );
  }
  
  observe(img) {
    this.observer.observe(img);
  }
  
  disconnect() {
    this.observer.disconnect();
  }
}

const lazyLoader = new LazyImageLoader();

// 使用示例（Vue）
<img
  v-lazy-load
  :data-src="book.cover_image_url"
  alt="book cover"
/>

// Vue指令
app.directive('lazy-load', {
  mounted(el) {
    lazyLoader.observe(el);
  }
});
```

### 4.2 列表优化

#### 虚拟滚动

```javascript
// 使用虚拟滚动优化长列表
import { useVirtualList } from '@vueuse/core';

function BookList({ books }) {
  const { list, containerProps, wrapperProps } = useVirtualList(
    books,
    {
      itemHeight: 100, // 每项高度
      overscan: 5 // 预渲染项数
    }
  );
  
  return (
    <div {...containerProps} style={{ height: '600px', overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.value.map(({ data, index }) => (
          <div key={index} style={{ height: '100px' }}>
            <BookCard book={data} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 4.3 预加载

#### 预加载下一章

```javascript
// 阅读章节时预加载下一章
async function loadChapterWithPrefetch(chapterId) {
  // 加载当前章节
  const chapter = await loadChapter(chapterId);
  
  // 预加载下一章
  prefetchNextChapter(chapterId);
  
  return chapter;
}

async function prefetchNextChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/next`);
    const nextChapter = response.data;
    
    // 预加载下一章内容（不等待）
    apiClient.get(`/chapters/${nextChapter.id}/content`)
      .then(response => {
        // 存入缓存
        cache.set(`chapter:${nextChapter.id}`, response.data);
      })
      .catch(error => {
        console.warn('预加载下一章失败:', error);
      });
  } catch (error) {
    // 没有下一章，忽略错误
  }
}
```

---

## 5. 错误处理

### 5.1 常见错误类型

#### 网络错误

```javascript
if (error.message === 'Network Error') {
  showErrorNotification('网络连接失败，请检查网络设置');
}
```

#### 超时错误

```javascript
if (error.code === 'ECONNABORTED') {
  showErrorNotification('请求超时，请稍后重试');
}
```

#### 404错误

```javascript
if (error.response?.status === 404) {
  showErrorNotification('书籍不存在或已下架');
  router.push('/404');
}
```

### 5.2 错误上报

```javascript
function reportError(error, context) {
  // 上报到错误监控系统
  if (window.Sentry) {
    window.Sentry.captureException(error, {
      tags: {
        component: context.component,
        api: context.api
      },
      extra: {
        params: context.params
      }
    });
  }
}

// 使用示例
try {
  const book = await getBook(bookId);
} catch (error) {
  reportError(error, {
    component: 'BookDetail',
    api: 'getBook',
    params: { bookId }
  });
  
  ErrorHandler.handle(error);
}
```

---

## 6. 常见问题

### 6.1 如何处理VIP章节？

**问题**: 用户点击VIP章节时如何处理权限验证？

**解决方案**:

```javascript
async function loadChapter(chapterId) {
  try {
    const response = await apiClient.get(`/chapters/${chapterId}/content`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIP章节需要权限
      showVIPPrompt({
        title: '该章节需要VIP权限',
        message: '开通VIP即可阅读全部章节',
        onConfirm: () => {
          router.push('/vip');
        }
      });
    } else {
      throw error;
    }
  }
}
```

### 6.2 如何实现阅读记录？

**问题**: 记录用户的阅读进度和历史。

**解决方案**:

```javascript
// 保存阅读进度到本地
class ReadingHistory {
  static save(bookId, chapterId, progress) {
    const history = this.getAll();
    
    history[bookId] = {
      chapter_id: chapterId,
      progress: progress,
      timestamp: Date.now()
    };
    
    localStorage.setItem('reading_history', JSON.stringify(history));
  }
  
  static get(bookId) {
    const history = this.getAll();
    return history[bookId] || null;
  }
  
  static getAll() {
    const historyStr = localStorage.getItem('reading_history');
    return historyStr ? JSON.parse(historyStr) : {};
  }
}

// 使用示例
// 阅读章节时保存进度
function onChapterRead(bookId, chapterId, scrollProgress) {
  ReadingHistory.save(bookId, chapterId, scrollProgress);
}

// 打开书籍时恢复进度
function openBook(bookId) {
  const history = ReadingHistory.get(bookId);
  
  if (history) {
    // 跳转到上次阅读的章节
    router.push(`/chapters/${history.chapter_id}`);
  } else {
    // 跳转到第一章
    loadFirstChapter(bookId);
  }
}
```

### 6.3 如何优化搜索体验？

**问题**: 搜索时频繁请求导致性能问题。

**解决方案**:

```javascript
import { debounce } from 'lodash';

// 使用防抖 + 缓存
const searchCache = new Map();

const debouncedSearch = debounce(async (keyword) => {
  // 检查缓存
  if (searchCache.has(keyword)) {
    displayResults(searchCache.get(keyword));
    return;
  }
  
  // 执行搜索
  try {
    const results = await apiClient.get('/bookstore/books/search', {
      params: { keyword }
    });
    
    // 存入缓存
    searchCache.set(keyword, results.data);
    
    // 显示结果
    displayResults(results.data);
  } catch (error) {
    console.error('搜索失败:', error);
  }
}, 300);

// 使用
<input
  type="text"
  @input="debouncedSearch($event.target.value)"
  placeholder="搜索书籍..."
/>
```

### 6.4 如何处理分页加载？

**问题**: 实现无限滚动分页加载。

**解决方案**:

```javascript
// 使用Intersection Observer实现无限滚动
function useInfiniteScroll(loadMore) {
  const sentinel = ref(null);
  const loading = ref(false);
  const hasMore = ref(true);
  
  onMounted(() => {
    const observer = new IntersectionObserver(
      async (entries) => {
        const entry = entries[0];
        
        if (entry.isIntersecting && !loading.value && hasMore.value) {
          loading.value = true;
          
          try {
            const result = await loadMore();
            hasMore.value = result.hasMore;
          } catch (error) {
            console.error('加载更多失败:', error);
          } finally {
            loading.value = false;
          }
        }
      },
      {
        rootMargin: '100px'
      }
    );
    
    if (sentinel.value) {
      observer.observe(sentinel.value);
    }
    
    onUnmounted(() => {
      observer.disconnect();
    });
  });
  
  return { sentinel, loading, hasMore };
}

// 使用示例
const books = ref([]);
const currentPage = ref(1);

async function loadMoreBooks() {
  const response = await apiClient.get('/bookstore/books/recommended', {
    params: {
      page: currentPage.value,
      size: 20
    }
  });
  
  books.value.push(...response.data);
  currentPage.value++;
  
  return {
    hasMore: response.data.length === 20
  };
}

const { sentinel, loading } = useInfiniteScroll(loadMoreBooks);
```

---

## 附录

### A. 完整示例项目

**项目结构**

```
bookstore-frontend/
├── src/
│   ├── api/
│   │   ├── client.js          # API客户端配置
│   │   ├── bookstore.js       # 书城API
│   │   ├── chapter.js         # 章节API
│   │   └── ranking.js         # 榜单API
│   ├── utils/
│   │   ├── cache.js           # 缓存工具
│   │   ├── error-handler.js   # 错误处理
│   │   └── monitor.js         # 性能监控
│   ├── components/
│   │   ├── BookCard.vue       # 书籍卡片
│   │   ├── ChapterList.vue    # 章节列表
│   │   └── RankingList.vue    # 榜单列表
│   └── views/
│       ├── Homepage.vue       # 首页
│       ├── BookDetail.vue     # 书籍详情
│       └── ChapterReader.vue  # 章节阅读
└── package.json
```

### B. 资源链接

- API文档: [书城系统API文档](./书城系统API文档.md)
- Swagger文档: `http://your-domain/swagger/index.html`
- 技术支持: dev@qingyu.com

---

**文档维护**: 青羽前端团队  
**最后更新**: 2025-10-09

