# 青羽平台软件工程规范 v2.0

> **文档版本**: v2.0
> **最后更新**: 2025-10-06
> **项目名称**: 青羽一站式阅读写作平台
> **适用范围**: 全体开发人员

---

## 1. 概述

### 1.1 目的

本规范旨在为青羽平台建立全面、系统的软件工程标准，确保开发团队在需求、设计、编码、测试、部署等各个环节遵循统一的规范和最佳实践，从而保证软件质量、提升开发效率、降低维护成本。

### 1.2 适用范围

- ✅ 需求分析与管理
- ✅ 软件架构与设计
- ✅ 编码开发规范（Go、JavaScript/TypeScript）
- ✅ 测试与质量保证
- ✅ 项目管理与协作
- ✅ 配置管理与版本控制
- ✅ 部署与运维
- ✅ 文档编写规范

### 1.3 指导原则

**核心原则**：

1. **架构优先**：基于分层架构和Repository模式
2. **质量为本**：代码质量、测试覆盖率、性能指标
3. **安全第一**：安全设计贯穿始终
4. **持续改进**：敏捷开发、快速迭代
5. **团队协作**：代码审查、知识共享
6. **文档完善**：文档与代码同步更新

**工程价值观**：

- 🎯 **清晰胜于聪明**：代码可读性优先
- 🔧 **简单胜于复杂**：避免过度设计
- ✅ **测试胜于调试**：测试驱动开发
- 📚 **文档胜于口头**：知识显性化
- 🚀 **迭代胜于完美**：持续交付价值

---

## 2. 需求工程规范

### 2.1 需求分析流程

#### 2.1.1 需求收集阶段

**输入**：

- 用户反馈和需求
- 市场调研数据
- 竞品分析报告
- 业务发展策略

**活动**：

1. **用户访谈**：与目标用户深度交流
2. **问卷调查**：大规模用户需求收集
3. **数据分析**：用户行为数据挖掘
4. **竞品研究**：分析竞争对手功能
5. **头脑风暴**：团队创新讨论

**输出**：

- 需求清单（初稿）
- 用户画像
- 使用场景描述

#### 2.1.2 需求分析阶段

**分析维度**：

- **功能需求**：用户需要什么功能
- **非功能需求**：性能、安全、可用性等
- **业务价值**：需求对业务的影响
- **技术可行性**：实现难度和成本
- **优先级**：P0/P1/P2/P3分级

**分析方法**：

- KANO模型（基本、期望、兴奋需求）
- 用户故事地图
- 业务流程分析
- 技术风险评估

**输出**：

- 需求分析报告
- 需求优先级列表
- 风险评估报告

#### 2.1.3 需求文档化阶段

**文档类型**：

1. **需求规格说明书(SRS)**：详细的功能和非功能需求
2. **用户故事(User Story)**：以用户视角描述需求
3. **验收标准(Acceptance Criteria)**：需求验收条件
4. **需求追溯矩阵**：需求到设计、代码、测试的映射

**文档模板**：

```markdown
## 需求标题

**需求ID**: REQ-[模块]-[序号]  
**优先级**: P0/P1/P2/P3  
**提出人**: XXX  
**创建时间**: YYYY-MM-DD

### 需求描述
（清晰描述需求内容）

### 用户故事
作为 [用户角色]，我想要 [功能]，以便 [目标]。

### 验收标准
- [ ] 标准1
- [ ] 标准2
- [ ] 标准3

### 技术考虑
（技术实现要点、依赖、风险）

### 相关需求
- REQ-XXX-001
- REQ-XXX-002
```

### 2.2 需求管理规范

#### 2.2.1 需求变更管理

**变更流程**：

```
需求变更申请 → 影响分析 → 评审决策 → 变更实施 → 变更验证
```

**变更控制**：

- ✅ 所有变更必须走正式流程
- ✅ 评估变更对进度、成本、质量的影响
- ✅ 变更必须经过相关方审批
- ✅ 变更记录需归档

#### 2.2.2 需求追踪管理

**追溯矩阵**：

| 需求ID           | 设计文档        | 代码模块          | 测试用例      | 状态   |
| ---------------- | --------------- | ----------------- | ------------- | ------ |
| REQ-AI-AGENT-001 | agent_design.md | service/ai/agent/ | test_agent.go | 已完成 |
| REQ-RAG-001      | rag_design.md   | service/ai/rag/   | test_rag.go   | 进行中 |

**追踪工具**：

- Git提交关联需求ID（如：`[REQ-AI-001] Implement Agent tool calling`）
- 代码注释标注需求来源
- 测试用例关联需求ID

#### 2.2.3 需求验证

**验证方法**：

- ✅ 需求评审会议（产品、开发、测试）
- ✅ 原型验证（快速验证核心交互）
- ✅ 用户测试（邀请目标用户试用）
- ✅ 数据分析（A/B测试、灰度发布）

### 2.3 需求文档标准

**文档规范**：

- 使用Markdown格式编写
- 存放在 `doc/engineering/`目录
- 需求ID命名规则：`REQ-[模块]-[功能]-[序号]`
  - 例：`REQ-AI-AGENT-001`、`REQ-READING-BOOKSTORE-001`
- 优先级标记：P0⭐⭐⭐⭐⭐、P1⭐⭐⭐⭐、P2⭐⭐⭐、P3⭐⭐

---

## 3. 软件架构规范

### 3.1 架构原则

#### 3.1.1 分层架构原则

**架构层次**：

```
┌─────────────────────────────────────────┐
│     Router Layer (路由层)                │  HTTP路由、中间件
├─────────────────────────────────────────┤
│       API Layer (接口层)                 │  请求处理、响应构建
├─────────────────────────────────────────┤
│     Service Layer (业务逻辑层)           │  业务规则、流程控制
├─────────────────────────────────────────┤
│   Repository Layer (数据访问层)          │  数据持久化、查询封装
├─────────────────────────────────────────┤
│      Model Layer (数据模型层)            │  数据结构、验证规则
└─────────────────────────────────────────┘
```

**依赖规则**：

- ✅ 上层可以依赖下层
- ❌ 下层不能依赖上层
- ✅ 同层之间通过接口交互
- ✅ 依赖接口而非具体实现（DIP - 依赖倒置原则）

**层次职责**：

- **Router层**：定义路由、注册中间件
- **API层**：参数绑定、验证、调用Service、构建响应
- **Service层**：业务逻辑、事务协调、事件发布
- **Repository层**：数据操作、查询封装、缓存管理
- **Model层**：数据结构、字段标签、验证规则

#### 3.1.2 Repository模式

**接口定义**：

```go
// Repository接口（interfaces/user/UserRepository_interface.go）
type UserRepository interface {
    // 基础CRUD
    Create(ctx context.Context, user *models.User) error
    GetByID(ctx context.Context, id string) (*models.User, error)
    Update(ctx context.Context, id string, updates map[string]interface{}) error
    Delete(ctx context.Context, id string) error
  
    // 业务查询
    GetByEmail(ctx context.Context, email string) (*models.User, error)
    List(ctx context.Context, filter infrastructure.Filter) ([]*models.User, error)
  
    // 健康检查
    Health(ctx context.Context) error
}
```

**具体实现**：

```go
// MongoDB实现（mongodb/user/user_repository_mongo.go）
type MongoUserRepository struct {
    collection   *mongo.Collection
    queryBuilder infrastructure.QueryBuilder
}

func NewMongoUserRepository(db *mongo.Database) UserRepository {
    return &MongoUserRepository{
        collection:   db.Collection("users"),
        queryBuilder: mongodb.NewMongoQueryBuilder(),
    }
}

func (r *MongoUserRepository) Create(ctx context.Context, user *models.User) error {
    // 实现细节
}
```

**工厂模式**：

```go
// Repository工厂
type RepositoryFactory interface {
    CreateUserRepository() user.UserRepository
    CreateProjectRepository() writing.ProjectRepository
    CreateAIRepository() ai.AIRepository
    Health(ctx context.Context) error
    Close() error
}
```

**规范要求**：

- ✅ 所有数据访问必须通过Repository
- ✅ Repository接口在 `repository/interfaces/`定义
- ✅ 具体实现按数据库类型组织（mongodb/、postgres/）
- ✅ 使用工厂模式创建Repository实例
- ❌ Service层不得直接操作数据库

#### 3.1.3 依赖注入原则

**服务容器**：

```go
// 服务容器（service/container/service_container.go）
type ServiceContainer struct {
    repositoryFactory interfaces.RepositoryFactory
    services          map[string]base.BaseService
    eventBus          base.EventBus
}

func NewServiceContainer(factory interfaces.RepositoryFactory) *ServiceContainer {
    container := &ServiceContainer{
        repositoryFactory: factory,
        services:          make(map[string]base.BaseService),
        eventBus:          base.NewSimpleEventBus(),
    }
  
    // 注册服务
    container.registerServices()
    return container
}

func (c *ServiceContainer) registerServices() {
    // 创建并注册UserService
    userService := user.NewUserService(
        c.repositoryFactory.CreateUserRepository(),
        c.repositoryFactory.CreateRoleRepository(),
        c.eventBus,
    )
    c.RegisterService("UserService", userService)
  
    // 创建并注册AIService
    aiService := ai.NewAIService(
        c.repositoryFactory.CreateAIRepository(),
        c.eventBus,
    )
    c.RegisterService("AIService", aiService)
}
```

**依赖注入示例**：

```go
// Service构造函数
func NewUserService(
    userRepo repository.UserRepository,      // 注入Repository接口
    roleRepo repository.RoleRepository,
    eventBus base.EventBus,                  // 注入EventBus接口
) *UserService {
    return &UserService{
        userRepo:  userRepo,
        roleRepo:  roleRepo,
        eventBus:  eventBus,
        validator: base.NewBaseValidator(),
    }
}
```

**规范要求**：

- ✅ 使用构造函数注入依赖
- ✅ 依赖接口而非具体实现
- ✅ 通过ServiceContainer管理服务生命周期
- ❌ 禁止在代码中直接new具体实现类

#### 3.1.4 事件驱动架构

**事件总线**：

```go
// 事件接口
type Event interface {
    GetEventType() string
    GetEventData() interface{}
    GetTimestamp() time.Time
    GetSource() string
}

// 事件处理器
type EventHandler interface {
    Handle(ctx context.Context, event Event) error
    GetHandlerName() string
    GetSupportedEventTypes() []string
}

// 事件总线
type EventBus interface {
    Subscribe(eventType string, handler EventHandler) error
    Unsubscribe(eventType string, handlerName string) error
    Publish(ctx context.Context, event Event) error
    PublishAsync(ctx context.Context, event Event) error
}
```

**事件发布**：

```go
// Service层发布事件
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) error {
    // ... 创建用户逻辑
  
    // 发布用户创建事件
    event := &base.BaseEvent{
        EventType: "user.created",
        EventData: map[string]interface{}{
            "user_id": user.ID,
            "email":   user.Email,
        },
        Timestamp: time.Now(),
        Source:    "UserService",
    }
    s.eventBus.PublishAsync(ctx, event)
  
    return nil
}
```

**事件订阅**：

```go
// 初始化时订阅事件
func initEventHandlers(eventBus base.EventBus) {
    // 订阅用户创建事件，发送欢迎邮件
    welcomeHandler := &WelcomeEmailHandler{
        emailService: email.NewEmailService(),
    }
    eventBus.Subscribe("user.created", welcomeHandler)
  
    // 订阅用户创建事件，初始化钱包
    walletHandler := &InitWalletHandler{
        walletService: wallet.NewWalletService(),
    }
    eventBus.Subscribe("user.created", walletHandler)
}
```

**规范要求**：

- ✅ 跨Service的操作优先使用事件
- ✅ 异步操作使用PublishAsync
- ✅ 事件命名规范：`[实体].[动作]`（如 `user.created`）
- ✅ 事件处理失败不应影响主流程

### 3.2 模块化设计规范

#### 3.2.1 模块划分原则

**模块边界**：

- 按业务领域划分（DDD - 领域驱动设计）
- 高内聚、低耦合
- 模块间通过接口或事件通信

**核心模块**：

1. **阅读端模块**：书城、阅读器、推荐、社交
2. **写作端模块**：编辑器、项目管理、设定百科
3. **AI服务模块**：AI适配器、Agent系统、RAG系统
4. **用户中心模块**：用户管理、角色权限、用户等级
5. **共享服务模块**：通知、存储、搜索、钱包
6. **基础设施模块**：认证、中间件、配置、监控

#### 3.2.2 目录结构规范

```
Qingyu_backend/
├── api/v1/                      # API层
│   ├── system/                  # 系统API
│   ├── document/                # 文档API
│   ├── ai/                      # AI API
│   ├── reading/                 # 阅读API
│   └── shared/                  # 共享API
├── service/                     # Service层
│   ├── base/                    # 基础服务
│   ├── container/               # 服务容器
│   ├── interfaces/              # Service接口
│   ├── user/                    # 用户服务
│   ├── ai/                      # AI服务
│   ├── project/                 # 项目服务
│   └── shared/                  # 共享服务
├── repository/                  # Repository层
│   ├── interfaces/              # Repository接口
│   │   ├── infrastructure/      # 基础接口
│   │   ├── user/                # 用户Repository接口
│   │   ├── writing/             # 写作Repository接口
│   │   └── repository_factory.go
│   ├── mongodb/                 # MongoDB实现
│   │   ├── user/
│   │   ├── writing/
│   │   └── factory.go
│   └── Mock/                    # Mock实现（测试用）
├── models/                      # Model层
│   ├── users/                   # 用户模型
│   ├── document/                # 文档模型
│   ├── ai/                      # AI模型
│   └── shared/                  # 共享模型
├── router/                      # Router层
│   ├── users/
│   ├── project/
│   ├── ai/
│   └── enter.go
├── middleware/                  # 中间件
├── config/                      # 配置
├── pkg/                         # 公共包
│   ├── errors/                  # 错误处理
│   ├── validator/               # 验证器
│   └── response/                # 响应格式化
├── test/                        # 测试
│   ├── api/                     # API测试
│   ├── service/                 # Service测试
│   ├── repository/              # Repository测试
│   └── integration/             # 集成测试
├── doc/                         # 文档
│   ├── engineering/             # 工程文档
│   ├── design/                  # 设计文档
│   ├── api/                     # API文档
│   └── implementation/          # 实现指南
├── docker/                      # Docker配置
├── main.go                      # 入口文件
└── go.mod                       # Go模块
```

### 3.3 设计文档规范

**必需文档**：

1. **架构设计文档**：整体架构、技术选型、核心流程
2. **模块设计文档**：模块职责、接口定义、数据模型
3. **API设计文档**：接口定义、请求响应格式、错误码
4. **数据库设计文档**：表结构、索引设计、数据字典

**文档模板**：参考 `doc/design/设计文档模板.md`

**设计评审**：

- 重大功能设计需经过评审
- 评审参与方：架构师、开发、测试、产品
- 评审要点：可行性、性能、安全、可维护性

---

## 4. 编码规范

### 4.1 Go语言编码规范

#### 4.1.1 命名规范

**包命名**：

```go
// ✅ 正确：小写、简洁、有意义
package userservice
package aiagent

// ❌ 错误：驼峰、下划线
package UserService
package ai_agent
```

**常量命名**：

```go
// ✅ 正确：大驼峰或全大写+下划线
const MaxRetryCount = 3
const DEFAULT_TIMEOUT = 30 * time.Second

// ❌ 错误：小写
const maxretrycount = 3
```

**变量命名**：

```go
// ✅ 正确：小驼峰
var userID string
var eventBus base.EventBus

// ❌ 错误：下划线
var user_id string
var event_bus base.EventBus
```

**函数/方法命名**：

```go
// ✅ 正确：大驼峰（导出）或小驼峰（私有），动词开头
func CreateUser(ctx context.Context, req *CreateUserRequest) error
func validateUserInput(user *User) error

// ❌ 错误：名词开头
func User(ctx context.Context) error
```

**结构体命名**：

```go
// ✅ 正确：大驼峰
type UserService struct {
    userRepo repository.UserRepository
    eventBus base.EventBus
}

// ❌ 错误：小写、下划线
type userService struct {}
type User_Service struct {}
```

**接口命名**：

```go
// ✅ 正确：大驼峰，名词或名词+er
type UserRepository interface {}
type EventHandler interface {}

// ❌ 错误：加Interface后缀（在文件名中体现）
type UserRepositoryInterface interface {}
```

#### 4.1.2 代码组织规范

**文件命名**：

```
// ✅ 正确：小写+下划线
user_service.go
user_repository_mongo.go
UserRepository_interface.go  // 接口文件可以大驼峰

// ❌ 错误：驼峰
UserService.go
```

**导入顺序**：

```go
import (
    // 1. 标准库
    "context"
    "fmt"
    "time"
  
    // 2. 第三方库
    "github.com/gin-gonic/gin"
    "go.mongodb.org/mongo-driver/mongo"
  
    // 3. 项目内部包
    "Qingyu_backend/models/users"
    "Qingyu_backend/repository/interfaces/user"
)
```

**结构体字段顺序**：

```go
type UserService struct {
    // 1. 导出字段
    Name    string
    Version string
  
    // 2. 未导出字段（依赖）
    userRepo  repository.UserRepository
    eventBus  base.EventBus
    validator base.Validator
}
```

#### 4.1.3 注释规范

**包注释**：

```go
// Package user 提供用户管理相关的业务逻辑，
// 包括用户注册、登录、信息管理等功能。
package user
```

**函数注释**：

```go
// CreateUser 创建新用户
//
// 参数:
//   ctx: 上下文，用于传递请求信息和控制超时
//   req: 创建用户请求，包含用户名、邮箱、密码等信息
//
// 返回:
//   resp: 创建用户响应，包含用户ID和基本信息
//   error: 错误信息，成功时为nil
//
// 错误码:
//   VALIDATION_ERROR: 参数验证失败
//   BUSINESS_ERROR: 邮箱已被注册
//   INTERNAL_ERROR: 创建用户失败
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
    // 实现
}
```

**结构体注释**：

```go
// UserService 用户服务
//
// 负责处理用户相关的业务逻辑，包括：
// - 用户注册和登录
// - 用户信息管理
// - 权限验证
//
// 依赖:
// - UserRepository: 用户数据访问
// - RoleRepository: 角色数据访问
// - EventBus: 事件发布
type UserService struct {
    userRepo  repository.UserRepository
    roleRepo  repository.RoleRepository
    eventBus  base.EventBus
    validator base.Validator
}
```

**行内注释**：

```go
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) error {
    // 1. 参数验证
    if err := s.validateCreateUserRequest(req); err != nil {
        return errors.NewValidationError("参数验证失败").WithDetails(err.Error())
    }
  
    // 2. 业务规则检查：邮箱唯一性
    exists, err := s.userRepo.ExistsByEmail(ctx, req.Email)
    if err != nil {
        return errors.NewInternalError("检查邮箱失败").WithCause(err)
    }
    if exists {
        return errors.NewBusinessError("邮箱已被注册")
    }
  
    // 3. 密码加密
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return errors.NewInternalError("密码加密失败").WithCause(err)
    }
  
    // ... 后续逻辑
}
```

#### 4.1.4 错误处理规范

**统一错误类型**：

```go
// 使用项目统一的UnifiedError
func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    user, err := s.userRepo.GetByID(ctx, id)
    if err != nil {
        return nil, errors.NewInternalError("查询用户失败").
            WithCause(err).
            WithService("UserService", "GetUser").
            WithMetadata("user_id", id)
    }
  
    if user == nil {
        return nil, errors.NewNotFoundError("用户不存在").
            WithMetadata("user_id", id)
    }
  
    return user, nil
}
```

**错误传播**：

```go
// ✅ 正确：包装错误，添加上下文信息
if err != nil {
    return fmt.Errorf("创建用户失败: %w", err)
}

// ❌ 错误：直接返回底层错误
if err != nil {
    return err
}

// ❌ 错误：吞掉错误
if err != nil {
    log.Println(err)
    return nil
}
```

**错误检查**：

```go
// ✅ 正确：立即检查错误
result, err := doSomething()
if err != nil {
    return err
}

// ❌ 错误：延迟检查
result, err := doSomething()
// ... 其他代码
if err != nil {
    return err
}
```

#### 4.1.5 代码质量标准

**函数复杂度**：

- 单个函数不超过50行（特殊情况除外）
- 圈复杂度 < 10
- 嵌套层级 < 4层

**代码重复**：

- 重复代码提取为函数
- 相似逻辑使用泛型或接口

**性能考虑**：

```go
// ✅ 正确：预分配切片容量
users := make([]*User, 0, expectedSize)

// ❌ 错误：频繁扩容
users := []*User{}

// ✅ 正确：使用strings.Builder拼接字符串
var builder strings.Builder
for _, s := range strs {
    builder.WriteString(s)
}
result := builder.String()

// ❌ 错误：使用+拼接
result := ""
for _, s := range strs {
    result += s  // 每次都会重新分配内存
}
```

### 4.2 前端编码规范（JavaScript/TypeScript）

#### 4.2.1 命名规范

```javascript
// 变量：小驼峰
const userName = 'John';
const userAge = 25;

// 常量：全大写+下划线
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';

// 函数：小驼峰，动词开头
function getUserById(id) {}
function fetchUserData() {}

// 类：大驼峰
class UserService {}
class BookstoreManager {}

// 组件：大驼峰
function UserProfile() {}
function BookList() {}

// 私有成员：_开头
class User {
    _privateMethod() {}
}
```

#### 4.2.2 TypeScript类型定义

```typescript
// ✅ 正确：明确的类型定义
interface User {
    id: string;
    username: string;
    email: string;
    createdAt: Date;
}

function getUser(id: string): Promise<User> {
    // ...
}

// ❌ 错误：使用any
function getUser(id: any): Promise<any> {
    // ...
}
```

### 4.3 代码审查规范

**审查清单**：

- [ ] 是否符合架构设计（分层、依赖注入）
- [ ] 是否遵循编码规范（命名、注释、格式）
- [ ] 错误处理是否完善
- [ ] 是否有单元测试，覆盖率是否达标
- [ ] 是否有潜在的性能问题
- [ ] 是否有安全隐患
- [ ] 是否有足够的日志记录
- [ ] 文档是否更新

**审查流程**：

1. 提交Pull Request
2. 自动化检查（lint、test、build）
3. 至少1人代码审查
4. 修改并回复审查意见
5. 审查通过后合并

---

## 5. 测试规范

### 5.1 测试策略

**测试金字塔**：

```
       /\
      /  \  End-to-End Tests (10%)
     /    \
    /------\  Integration Tests (20%)
   /        \
  /----------\  Unit Tests (70%)
 /            \
```

**测试覆盖率要求**：

- 单元测试：≥ 80%
- 集成测试：≥ 60%
- 关键路径：100%

### 5.2 单元测试规范

**测试文件命名**：

```
user_service.go → user_service_test.go
user_repository_mongo.go → user_repository_mongo_test.go
```

**测试函数命名**：

```go
// 格式：Test[FunctionName]_[Scenario]_[ExpectedResult]
func TestUserService_CreateUser_Success(t *testing.T) {}
func TestUserService_CreateUser_EmailExists_ReturnsError(t *testing.T) {}
func TestUserService_CreateUser_InvalidInput_ReturnsValidationError(t *testing.T) {}
```

**测试结构（AAA模式）**：

```go
func TestUserService_CreateUser_Success(t *testing.T) {
    // Arrange（准备）
    mockUserRepo := &MockUserRepository{}
    mockEventBus := &MockEventBus{}
    service := NewUserService(mockUserRepo, nil, mockEventBus)
  
    req := &CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
  
    mockUserRepo.On("ExistsByEmail", mock.Anything, "test@example.com").Return(false, nil)
    mockUserRepo.On("Create", mock.Anything, mock.AnythingOfType("*models.User")).Return(nil)
  
    // Act（执行）
    resp, err := service.CreateUser(context.Background(), req)
  
    // Assert（断言）
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    assert.Equal(t, "testuser", resp.Username)
  
    mockUserRepo.AssertExpectations(t)
}
```

**Mock使用**：

```go
// 使用testify/mock创建Mock
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Create(ctx context.Context, user *models.User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

func (m *MockUserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) {
    args := m.Called(ctx, email)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*models.User), args.Error(1)
}
```

### 5.3 集成测试规范

**测试组织**：

```
test/integration/
├── user_integration_test.go
├── ai_integration_test.go
└── setup_test.go  // 测试环境初始化
```

**集成测试示例**：

```go
func TestUserServiceIntegration(t *testing.T) {
    // 1. 初始化测试数据库
    config := &interfaces.MongoConfig{
        URI:      "mongodb://localhost:27017",
        Database: "test_db",
        Timeout:  30 * time.Second,
    }
  
    factory, err := mongodb.NewMongoRepositoryFactory(config)
    require.NoError(t, err)
    defer factory.Close()
  
    // 2. 创建Service
    userRepo := factory.CreateUserRepository()
    eventBus := base.NewSimpleEventBus()
    service := user.NewUserService(userRepo, nil, eventBus)
  
    // 3. 执行测试
    req := &user.CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
  
    resp, err := service.CreateUser(context.Background(), req)
    require.NoError(t, err)
    require.NotNil(t, resp)
  
    // 4. 验证数据库状态
    user, err := userRepo.GetByEmail(context.Background(), "test@example.com")
    require.NoError(t, err)
    assert.Equal(t, "testuser", user.Username)
  
    // 5. 清理测试数据
    defer userRepo.Delete(context.Background(), resp.UserID)
}
```

### 5.4 性能测试规范

**工具选择**：

- 压力测试：wrk、Apache Bench
- 负载测试：JMeter、Locust
- 性能分析：pprof

**性能指标**：

- API响应时间：P95 < 200ms
- QPS：≥ 5000
- 并发用户数：≥ 10000

**性能测试示例**：

```bash
# 使用wrk进行压力测试
wrk -t12 -c400 -d30s --latency http://localhost:8080/api/v1/users

# 输出示例
Running 30s test @ http://localhost:8080/api/v1/users
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    45.23ms   12.34ms  200.00ms   89.23%
    Req/Sec     0.89k    123.45    1.23k    76.54%
  Latency Distribution
     50%   43.21ms
     75%   52.34ms
     90%   61.23ms
     99%   91.45ms
  320000 requests in 30.00s, 45.67MB read
Requests/sec:  10666.67
Transfer/sec:   1.52MB
```

---

## 6. 项目管理规范

### 6.1 版本控制规范

#### 6.1.1 Git工作流（GitFlow）

**分支策略**：

```
main (production)     ──────●────●────●──────→
                            /      \
develop (integration) ─●───●────────●───●───→
                       |         /   \
feature/xxx           ●─●─●─●──/     \
                                       \
hotfix/xxx                              ●─●─●
```

**分支命名**：

- `main`：生产环境分支
- `develop`：开发集成分支
- `feature/[功能名]`：功能开发分支
- `hotfix/[bug名]`：紧急修复分支
- `release/v[版本号]`：发布准备分支

**分支管理规则**：

- `main`分支：只接受release和hotfix的合并
- `develop`分支：接受feature的合并
- `feature`分支：从develop创建，完成后合并回develop
- `hotfix`分支：从main创建，完成后合并回main和develop

#### 6.1.2 提交规范（Conventional Commits）

**提交格式**：

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型（type）**：

- `feat`：新功能
- `fix`：Bug修复
- `docs`：文档更新
- `style`：代码格式（不影响代码运行）
- `refactor`：重构（既不是新功能也不是Bug修复）
- `perf`：性能优化
- `test`：测试相关
- `chore`：构建过程或辅助工具的变动

**示例**：

```
feat(ai): implement Agent tool calling framework

- Add tool registration interface
- Implement tool execution engine
- Add permission control for tool calling

Closes #123
```

```
fix(auth): fix JWT token expiration check

Previously, expired tokens were still accepted.
Now properly validate token expiration.

Fixes #456
```

**关联Issue**：

```
feat(rag): add vector database integration

Refs #789
```

### 6.2 持续集成/持续部署（CI/CD）

#### 6.2.1 CI Pipeline

**GitHub Actions工作流**：

```yaml
name: CI

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ develop, main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
    
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
    
      - name: Install dependencies
        run: go mod download
    
      - name: Lint
        run: golangci-lint run
    
      - name: Test
        run: go test -v -race -coverprofile=coverage.out ./...
    
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
  
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
    
      - name: Build Docker image
        run: docker build -t qingyu-backend:${{ github.sha }} .
    
      - name: Push to registry
        run: |
          docker tag qingyu-backend:${{ github.sha }} registry.example.com/qingyu-backend:latest
          docker push registry.example.com/qingyu-backend:latest
```

#### 6.2.2 代码质量检查

**工具配置**：

```yaml
# .golangci.yml
linters:
  enable:
    - gofmt
    - goimports
    - golint
    - govet
    - errcheck
    - staticcheck
    - unused
    - gosimple
    - structcheck
    - varcheck
    - ineffassign
    - deadcode

linters-settings:
  gofmt:
    simplify: true
  goimports:
    local-prefixes: Qingyu_backend
  golint:
    min-confidence: 0.8

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
```

**SonarQube集成**：

```yaml
sonar:
  projectKey: qingyu-backend
  projectName: Qingyu Backend
  projectVersion: 1.0
  sources: .
  exclusions: |
    **/*_test.go,
    **/vendor/**,
    **/mock/**
  test.inclusions: |
    **/*_test.go
  go.coverage.reportPaths: coverage.out
```

### 6.3 敏捷开发规范

#### 6.3.1 迭代管理

**Sprint周期**：2周

**Sprint流程**：

1. **Sprint Planning**（周一上午）

   - 评审需求优先级
   - 估算Story Point
   - 制定Sprint目标
   - 分配任务
2. **Daily Standup**（每天上午10点，15分钟）

   - 昨天完成了什么
   - 今天计划做什么
   - 遇到什么阻碍
3. **Sprint Review**（周五下午）

   - 演示完成的功能
   - 收集反馈
4. **Sprint Retrospective**（周五下午）

   - 总结经验教训
   - 改进行动计划

#### 6.3.2 任务管理

**任务状态**：

- `Todo`：待开始
- `In Progress`：进行中
- `In Review`：代码审查中
- `Testing`：测试中
- `Done`：已完成

**Story Point估算**（斐波那契数列）：

- 1 point：1-2小时
- 2 points：半天
- 3 points：1天
- 5 points：2-3天
- 8 points：3-5天
- 13 points：1周（需拆分）

---

## 7. 部署运维规范

### 7.1 环境管理

**环境分类**：

- **开发环境（Dev）**：本地开发
- **测试环境（Test）**：功能测试
- **预发布环境（Staging）**：生产验证
- **生产环境（Production）**：正式运行

**环境配置**：

```yaml
# config/config.yaml
environments:
  dev:
    database:
      uri: mongodb://localhost:27017
      database: qingyu_dev
    redis:
      addr: localhost:6379
    ai:
      provider: openai
      api_key: ${DEV_OPENAI_KEY}
  
  test:
    database:
      uri: mongodb://test-db:27017
      database: qingyu_test
    redis:
      addr: test-redis:6379
  
  production:
    database:
      uri: ${PROD_MONGO_URI}
      database: qingyu_prod
    redis:
      addr: ${PROD_REDIS_ADDR}
    ai:
      provider: ${PROD_AI_PROVIDER}
      api_key: ${PROD_AI_KEY}
```

### 7.2 Docker化部署

**Dockerfile**：

```dockerfile
# 构建阶段
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o qingyu-backend .

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/qingyu-backend .
COPY --from=builder /app/config ./config

EXPOSE 8080

CMD ["./qingyu-backend"]
```

**Docker Compose**：

```yaml
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ENV=production
      - MONGO_URI=${MONGO_URI}
      - REDIS_ADDR=${REDIS_ADDR}
    depends_on:
      - mongodb
      - redis
    restart: unless-stopped
  
  mongodb:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db
    restart: unless-stopped
  
  redis:
    image: redis:6.0-alpine
    ports:
      - "6379:6379"
    restart: unless-stopped
  
  milvus:
    image: milvusdb/milvus:v2.3.0
    ports:
      - "19530:19530"
    volumes:
      - milvus-data:/var/lib/milvus
    restart: unless-stopped

volumes:
  mongo-data:
  milvus-data:
```

### 7.3 监控告警

**监控指标**：

```yaml
# Prometheus配置
scrape_configs:
  - job_name: 'qingyu-backend'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

**关键指标**：

- **系统指标**：CPU、内存、磁盘、网络
- **应用指标**：QPS、响应时间、错误率
- **业务指标**：用户数、订单数、收入
- **AI指标**：API调用量、Token消耗、成本

**告警规则**：

```yaml
groups:
  - name: qingyu-alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }}%"
    
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High response time"
          description: "P95 response time is {{ $value }}s"
```

### 7.4 日志管理

**日志级别**：

- `DEBUG`：调试信息
- `INFO`：一般信息
- `WARN`：警告信息
- `ERROR`：错误信息
- `FATAL`：致命错误

**结构化日志**：

```go
import "go.uber.org/zap"

logger.Info("User created successfully",
    zap.String("user_id", userID),
    zap.String("email", email),
    zap.String("service", "UserService"),
    zap.String("operation", "CreateUser"),
)

logger.Error("Failed to create user",
    zap.Error(err),
    zap.String("email", email),
    zap.String("service", "UserService"),
    zap.String("operation", "CreateUser"),
)
```

**日志收集**：

- 工具：Filebeat + Logstash + Elasticsearch + Kibana (ELK Stack)
- 日志保留期：30天（生产环境）

---

## 8. 文档规范

### 8.1 文档分类

**工程文档**（`doc/engineering/`）：

- 需求分析文档
- 软件需求规格说明书(SRS)
- 软件工程规范
- 架构设计文档

**设计文档**（`doc/design/`）：

- 模块设计文档
- 数据库设计文档
- 接口设计文档

**实现文档**（`doc/implementation/`）：

- 实现指南
- 修复清单
- 技术选型文档

**API文档**（`doc/api/`）：

- API接口文档
- API使用示例

### 8.2 文档编写规范

**Markdown规范**：

- 使用标准Markdown语法
- 代码块指定语言：\`\`\`go、\`\`\`javascript
- 使用表格组织数据
- 使用Emoji增强可读性（适度）

**文档结构**：

```markdown
# 文档标题

> **文档版本**: v1.0  
> **最后更新**: 2025-10-06  
> **作者**: XXX

## 1. 概述
（简要说明文档目的和范围）

## 2. 主要内容
（详细内容）

## 3. 参考资料
（相关文档、链接）
```

**版本管理**：

- 重大更新时创建新版本文档（如 `xxx_v2.0.md`）
- 在文档头部标注版本和更新日期
- 维护版本历史表格

### 8.3 文档维护

**更新原则**：

- 代码变更必须同步更新文档
- 每个Sprint结束时检查文档完整性
- 定期审查文档，清理过时内容

**文档审查**：

- 重要文档需经过评审
- 检查内容准确性、完整性、可读性
- 确保文档与实际代码一致

---

## 9. 安全工程规范

### 9.1 安全编码实践

**输入验证**：

```go
// ✅ 正确：严格验证输入
func (api *UserApi) Register(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数格式错误", err.Error())
        return
    }
  
    // 参数验证
    if err := api.validator.Struct(&req); err != nil {
        response.ValidationError(c, err)
        return
    }
  
    // ...
}

// ❌ 错误：直接使用未验证的输入
func (api *UserApi) Register(c *gin.Context) {
    email := c.PostForm("email")  // 未验证
    // 直接使用email进行数据库查询
}
```

**SQL注入防护**：

```go
// ✅ 正确：使用参数化查询
filter := bson.M{"email": email}
result := collection.FindOne(ctx, filter)

// ❌ 错误：字符串拼接
query := fmt.Sprintf("SELECT * FROM users WHERE email = '%s'", email)
```

**XSS防护**：

```go
// 对用户输入进行HTML转义
import "html"

safeContent := html.EscapeString(userInput)
```

**密码安全**：

```go
// ✅ 正确：使用bcrypt加密
hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

// ❌ 错误：明文存储或MD5加密
password := req.Password  // 明文
hashedPassword := md5.Sum([]byte(password))  // MD5不安全
```

### 9.2 认证授权安全

**JWT配置**：

```go
// 设置合理的过期时间
claims := jwt.MapClaims{
    "user_id": userID,
    "exp":     time.Now().Add(7 * 24 * time.Hour).Unix(),  // 7天
}

// 使用强密钥
jwtSecret := []byte(config.JWT.Secret)  // 至少32字节随机字符串
```

**RBAC权限检查**：

```go
// 每个接口都进行权限检查
func (api *AdminApi) DeleteUser(c *gin.Context) {
    // 检查是否为管理员
    if !middleware.HasPermission(c, "admin") {
        response.Error(c, http.StatusForbidden, "权限不足", "")
        return
    }
  
    // ...
}
```

### 9.3 数据安全

**敏感数据加密**：

```go
// 敏感字段加密存储
type User struct {
    ID       string `bson:"_id" json:"id"`
    Email    string `bson:"email" json:"email"`
    Password string `bson:"password" json:"-"`  // 不返回给客户端
    // ...
}
```

**HTTPS强制**：

```go
// 配置HTTPS
r := gin.Default()
r.Use(middleware.HTTPSRedirect())  // 强制HTTPS
r.RunTLS(":443", "cert.pem", "key.pem")
```

**数据脱敏**：

```go
// 日志中脱敏敏感信息
logger.Info("User login",
    zap.String("email", maskEmail(email)),  // 脱敏邮箱
    zap.String("ip", clientIP),
)

func maskEmail(email string) string {
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return "***"
    }
    return parts[0][:2] + "***@" + parts[1]
}
```

---

## 10. 附录

### 10.1 工具推荐

**开发工具**：

- IDE：GoLand、VSCode
- API测试：Postman、Insomnia
- 数据库工具：MongoDB Compass、Redis Desktop Manager

**代码质量工具**：

- Linter：golangci-lint
- 测试：go test、testify
- 覆盖率：go cover
- 静态分析：SonarQube

**DevOps工具**：

- 版本控制：Git、GitHub
- CI/CD：GitHub Actions、Jenkins
- 容器化：Docker、Docker Compose
- 编排：Kubernetes
- 监控：Prometheus、Grafana
- 日志：ELK Stack

### 10.2 参考资料

**官方文档**：

- [Go语言规范](https://go.dev/ref/spec)
- [Gin框架文档](https://gin-gonic.com/docs/)
- [MongoDB Go Driver](https://pkg.go.dev/go.mongodb.org/mongo-driver)

**最佳实践**：

- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)

**架构设计**：

- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design](https://martinfowler.com/tags/domain%20driven%20design.html)
- [Microservices Patterns](https://microservices.io/patterns/index.html)

**项目文档**：

- [青羽平台架构设计规范](../architecture/架构设计规范.md)
- [Repository层设计规范](../architecture/repository层设计规范.md)
- [模块化架构设计v2.0](../design/青羽平台模块化架构设计v2.0.md)

### 10.3 术语表

| 术语         | 英文                        | 说明                       |
| ------------ | --------------------------- | -------------------------- |
| 仓储         | Repository                  | 数据访问层，封装数据库操作 |
| 依赖注入     | Dependency Injection        | 通过构造函数注入依赖       |
| 事件总线     | Event Bus                   | 事件发布订阅机制           |
| 领域驱动设计 | Domain-Driven Design (DDD)  | 以业务领域为核心的设计方法 |
| 持续集成     | Continuous Integration (CI) | 频繁集成代码到主分支       |
| 持续部署     | Continuous Deployment (CD)  | 自动化部署到生产环境       |

---

## 11. 版本历史

| 版本 | 日期       | 变更内容                                                                | 作者       |
| ---- | ---------- | ----------------------------------------------------------------------- | ---------- |
| v1.0 | 2024-01-XX | 初始版本，基础工程规范                                                  | 项目组     |
| v2.0 | 2025-10-06 | 重构版本，整合Repository模式、Service层、事件驱动、Agent系统、RAG系统等 | 青羽架构组 |

---

**最后更新**: 2025-10-06
