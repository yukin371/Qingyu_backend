# 青羽轻量级读写平台 —— 项目概述（V2）

## 1. 项目定位

| 维度 | 说明 |
|------|------|
| 目标人群 | 中文网络文学作者、学习型读者、AI 辅助写作研究者 |
| 核心场景 | ① 写作：AI 续写 + 设定百科 + 关系图谱<br>② 阅读：个性化推荐 + 生词本 + 段评<br>③ 学习：阅读打卡 + 代币激励 + 写作数据分析 |
| 产品边界 | 不做「起点/晋江」类重型商业平台，而是「可二次开发的教学级」开源样板；所有模块均保留 Mock 接口，方便替换成真实支付、版权、审核等外部依赖。 |

## 2. 技术愿景

- 成为「Go + MongoDB + Vue3」技术栈的最佳实践样本
- 所有业务模块均提供「双实现」：线上微服务版 + 本地轻量版（go run 即可起）
- 文档先行：任何代码 PR 必须附带「接口文档 + 设计决策表 + 缺失补全清单」

## 3. 架构总览与设计决策

### 3.1 逻辑架构视图

```
┌─────────────────────────────────────────────────────────────┐
│                    Frontend Layer                           │
│              Vue3 + TypeScript + Pinia                     │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP/WebSocket
┌─────────────────────▼───────────────────────────────────────┐
│                  Gateway Layer                              │
│                 Gin Router + Middleware                     │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐  │
│  │    Auth     │   Logger    │ Rate Limit  │  Security   │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘  │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                 Business Layer                              │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐  │
│  │   Reading   │   Writing   │     AI      │    Core     │  │
│  │   Module    │   Module    │   Module    │   Module    │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘  │
│  ┌─────────────┬─────────────────────────────────────────┐  │
│  │  Platform   │            Shared Services              │  │
│  │   Module    │     (Wallet, Storage, MQ, etc.)        │  │
│  └─────────────┴─────────────────────────────────────────┘  │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                 Data Layer                                  │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐  │
│  │   MongoDB   │    Redis    │Elasticsearch│  File Store │  │
│  │ (Primary)   │  (Cache)    │  (Search)   │   (OSS)     │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 架构设计决策与权衡

#### 决策1：单体 vs 微服务架构
**选择**：模块化单体 + 微服务演进路径

**权衡考虑**：
| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| 纯单体 | 部署简单、调试方便 | 扩展性差、技术栈绑定 | 小型项目、快速原型 |
| 纯微服务 | 扩展性强、技术栈灵活 | 复杂度高、运维成本大 | 大型项目、成熟团队 |
| **模块化单体** | **平衡复杂度和扩展性** | **需要良好的模块边界** | **中型项目、教学样本** |

**实施策略**：
```go
// 模块化设计 - 清晰的边界和接口
type ModuleRegistry struct {
    Reading  ReadingModule
    Writing  WritingModule
    AI       AIModule
    Core     CoreModule
    Platform PlatformModule
}

// 每个模块都可以独立部署（通过编译标签控制）
//go:build reading
func init() {
    registry.Register("reading", NewReadingModule())
}
```

#### 决策2：同步 vs 异步处理
**选择**：混合模式 - 核心流程同步，辅助功能异步

**设计原则**：
- **用户感知操作**：同步处理，立即反馈（如登录、发布文章）
- **后台任务**：异步处理，提升性能（如推荐计算、数据统计）
- **外部依赖**：异步处理，避免阻塞（如邮件发送、AI 调用）

**实现机制**：
```go
// 同步处理示例 - 用户登录
func (h *AuthHandler) Login(c *gin.Context) {
    // 直接处理，立即返回结果
    user, err := h.authService.Login(req.Username, req.Password)
    if err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    c.JSON(200, gin.H{"token": user.Token})
}

// 异步处理示例 - 推荐计算
func (s *RecommendService) UpdateRecommendations(userID string) {
    // 放入队列，异步处理
    s.taskQueue.Enqueue(tasks.NewRecommendTask(userID))
}
```

#### 决策3：数据一致性策略
**选择**：最终一致性 + 关键业务强一致性

**一致性级别设计**：
```go
// 强一致性场景（用户余额、权限）
type WalletService struct {
    // 使用 MongoDB 事务保证 ACID
    func (s *WalletService) Transfer(from, to string, amount int64) error {
        return s.db.WithTransaction(func(ctx context.Context) error {
            // 原子性转账操作
            if err := s.debit(ctx, from, amount); err != nil {
                return err
            }
            return s.credit(ctx, to, amount)
        })
    }
}

// 最终一致性场景（阅读统计、推荐数据）
type StatisticsService struct {
    // 使用事件驱动，异步更新
    func (s *StatisticsService) OnBookRead(event BookReadEvent) {
        // 异步更新统计数据，允许短暂不一致
        go s.updateReadCount(event.BookID, event.UserID)
        go s.updateRecommendations(event.UserID)
    }
}
```

#### 决策4：缓存策略设计
**选择**：多层缓存 + 智能失效

**缓存层次**：
```go
// L1: 应用内存缓存（热点数据）
type MemoryCache struct {
    cache map[string]interface{}
    ttl   time.Duration
}

// L2: Redis 分布式缓存（共享数据）
type RedisCache struct {
    client redis.Client
}

// L3: CDN 缓存（静态资源）
type CDNCache struct {
    endpoint string
}

// 缓存策略配置
type CacheConfig struct {
    UserProfile    CacheLevel{L1: 5*time.Minute, L2: 1*time.Hour}
    BookContent    CacheLevel{L2: 24*time.Hour, L3: 7*24*time.Hour}
    SearchResults  CacheLevel{L2: 30*time.Minute}
    Recommendations CacheLevel{L2: 2*time.Hour}
}
```

#### 决策5：错误处理与监控
**选择**：统一错误码 + 分层监控

**错误处理设计**：
```go
// 统一错误码定义
type ErrorCode struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Detail  string `json:"detail,omitempty"`
}

var (
    ErrUserNotFound     = ErrorCode{10001, "用户不存在", ""}
    ErrInvalidPassword  = ErrorCode{10002, "密码错误", ""}
    ErrBookNotFound     = ErrorCode{20001, "书籍不存在", ""}
    ErrInsufficientBalance = ErrorCode{30001, "余额不足", ""}
)

// 分层监控设计
type MonitoringStack struct {
    // 应用层监控
    Metrics    prometheus.Registry  // 业务指标
    Tracing    jaeger.Tracer       // 链路追踪
    
    // 基础设施监控
    Database   mongodb.Monitor     // 数据库性能
    Cache      redis.Monitor       // 缓存命中率
    Queue      rabbitmq.Monitor    // 消息队列
}
```

## 4. 模块状态速览（与代码目录实时对齐）

| 模块 | 目录 | 设计文档 | 接口完成度 | 备注 |
|------|------|----------|------------|------|
| Reading | /api/v1/reader<br>/reading<br>/recommendation | ✅ 6 篇 | 70% | 书城、阅读器、推荐、任务、社交、生词本 |
| Writing | /api/v1/writer<br>/document | ✅ 4 篇 | 60% | 编辑器、设定百科、AI 辅助、关系图谱 |
| AI | /api/v1/ai<br>/service/ai/adapter | ✅ 6 篇 | 75% | 多模型适配、流式响应、上下文管理 |
| Core | /api/v1/system<br>/core<br>/middleware | ✅ 5 篇 | 80% | JWT、RBAC、项目/文档 CRUD、版本控制 |
| Platform | /service/user<br>/project | ✅ 7 篇 | 50% | 用户中心、作品管理、搜索、数据分析、通知 |
| Shared | /service/wallet<br>/storage | ✅ 6 篇 | 90% | 钱包、推荐、文件、MQ、权限、后台 |
| Security | /middleware + /doc/design/security | ⚠️ 1 篇 | 30% | 仅威胁建模，缺落地细节 |
| Ops | 暂无独立目录 | ❌ 0 篇 | 0% | 监控、日志、CI/CD、灾备全缺失 |

## 5. 已知技术债与约束

| 债项 | 级别 | 解决思路 |
|------|------|----------|
| 缺「通信模块」设计 | 🔥 高 | 补 WebSocket + Push + Mail + SMS 子模块 |
| 缺「监控运维」设计 | 🔥 高 | Prometheus + Grafana + ELK + Sentry 一条龙 |
| 缺「测试体系」文档 | 🔥 中 | 单元(go test)、接口(httpexpect)、性能(k6)三层 |
| 缺「容器化 & CI/CD」 | 🔥 中 | Dockerfile + docker-compose + GitHub Actions |
| Repository 层方法爆炸 | ⚠️ 中 | 按「读写分离 + 聚合根」重构，见 /doc/重构规划 |
| Service 层循环依赖 | ⚠️ 低 | 引入「接口层 + 容器化注入」已出方案，待实施 |

## 6. 下一里程碑（MVP 0.9）

**截止时间**：2025-12-31

**验收标准**：
- 端到端跑通「注册 → 创建项目 → 写作 → 发布 → 阅读 → 获得代币」主流程
- 核心 20 个 API 100% 单测覆盖，性能 500 QPS 下 P99 < 500 ms
- 提供「docker-compose up」一键拉起，日志、监控、告警开箱即用
- 文档补齐率 ≥ 90%（即下文「缺失清单」全部 ✅）

## 7. 缺失设计文档一览

| 序号 | 文档名 | 应放路径 | 优先级 |
|------|--------|----------|--------|
| 1 | WebSocket 实时通信设计.md | /doc/design/communication/ | 🔥 |
| 2 | 消息推送系统（Push/邮件/短信）.md | /doc/design/communication/ | 🔥 |
| 3 | 监控指标体系 & Prometheus 规划.md | /doc/design/ops/ | 🔥 |
| 4 | 日志规范 & ELK Stack 落地.md | /doc/design/ops/ | 🔥 |
| 5 | CI-CD 流水线与容器化部署.md | /doc/design/ops/ | 🔥 |
| 6 | 灾备与数据备份恢复策略.md | /doc/design/ops/ | ⚠️ |
| 7 | 自动化测试总体方案.md | /doc/design/testing/ | ⚠️ |
| 8 | 性能测试模型 & k6 脚本.md | /doc/design/testing/ | ⚠️ |
| 9 | 安全加固清单（OWASP Top10 对照）.md | /doc/design/security/ | ⚠️ |
| 10 | 环境配置与多租户隔离方案.md | /doc/design/platform/ | ⚠️ |

## 8. 项目当前不足速查表

### 代码层
- handler 层：部分接口仍直接返回 mongo 原始错误，需包装统一错误码
- service 层：AI 适配器未做熔断/限流，一旦 429 直接雪崩
- repository 层：缺少二级索引脚本，已出现 200 ms+ 的 COLLSCAN
- router 层：/api/v1 之外缺 /health、/metrics、/debug 标准化端点

### 文档层
- 设计文档未同步到「代码版本」：README 里引用的时序图还是 v0.3 字段
- API 变更未走「版本号」策略，出现同一路径返回结构不一致
- 缺少「字段级变更记录」，前后端联调常因少字段返空

### 工程层
- 本地启动依赖 mongo/redis/es 需手动装，未提供一键 docker-compose
- 缺「多环境」配置（local/docker/dev/stage/prod），现在只有 config.yaml
- 缺「make 目标」：测试、lint、mock、迁移、压测 都要手敲长命令
- 缺「代码生成」：model、repo、service 仍 copy-paste，易出错

### 安全层
- JWT 未启用刷新 + 黑名单，泄露后无法强制失效
- 文件上传仅检查 Content-Type，未做魔数 & 尺寸 & 病毒扫描
- 管理后台接口与普通接口共用端口，未做网络隔离
- 缺「操作审计日志」，无法追踪「谁删了哪本书」

## 9. 立即行动清单（本周可完成）

- [ ] 在 /doc/design 下新建 communication/、ops/、testing/ 三个目录，并把上表 10 篇文档建空文件
- [ ] 把本 V2 概述替换掉原 /doc/architecture/项目概述.md，并在 Obsidian 里加上 [[待办]] 链接
- [ ] 在根目录新增 Makefile，先写四条命令：make run、make test、make lint、make mock
- [ ] 提交一条 PR，仅做「统一错误码」+ /health + /metrics 端点，作为后续监控的基线
- [ ] 开一条 Issue 模板「设计文档补全申请.md」，方便后续同学认领缺失文档

做完以上 5 步，再把本文件最后一节「下一里程碑」剪出来单独建 /doc/里程碑/MVP0.9.md，就可以按迭代滚动下去了。

---

## 技术栈详情与选型原因

### 后端技术栈选型分析

#### 1. 编程语言：Go
**选择原因**：
- **性能优势**：原生并发支持，goroutine 轻量级线程模型适合高并发场景
- **部署简便**：编译为单一可执行文件，无运行时依赖，容器化友好
- **生态成熟**：丰富的第三方库，特别是 Web 框架和数据库驱动
- **团队技能**：学习曲线平缓，适合中小团队快速上手
- **社区活跃**：Google 背书，长期维护保障

**对比分析**：
| 语言 | 性能 | 开发效率 | 部署复杂度 | 生态成熟度 | 选择理由 |
|------|------|----------|------------|------------|----------|
| Go | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 综合最优 |
| Java | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ 过于重型 |
| Node.js | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ 单线程瓶颈 |
| Python | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ 性能不足 |

#### 2. Web 框架：Gin
**选择原因**：
- **高性能**：基于 httprouter，路由性能优异，中间件机制灵活
- **轻量级**：核心代码简洁，启动快速，内存占用低
- **中间件生态**：丰富的第三方中间件，满足认证、日志、限流等需求
- **JSON 处理**：内置 JSON 绑定和验证，API 开发效率高
- **文档完善**：官方文档详细，社区示例丰富

**架构适配性**：
```go
// Gin 的中间件链式设计完美适配我们的分层架构
r := gin.Default()
r.Use(middleware.Logger())      // 日志中间件
r.Use(middleware.CORS())        // 跨域中间件
r.Use(middleware.JWT())         // 认证中间件
r.Use(middleware.RateLimit())   // 限流中间件
```

#### 3. 数据存储架构：多数据库策略
**整体设计思路**：根据数据特性和访问模式选择最适合的存储方案

##### 3.1 主数据库：MongoDB
**选择原因**：
- **文档模型**：天然适配复杂嵌套数据（如书籍章节、用户设定）
- **Schema 灵活**：支持敏捷开发，字段变更无需迁移脚本
- **水平扩展**：分片机制成熟，支持海量数据存储
- **JSON 原生**：与 Go struct 和前端 JSON 无缝对接
- **聚合管道**：强大的数据分析能力，支持复杂统计查询

**适用场景**：
```go
// 书籍文档结构示例 - 体现 MongoDB 文档模型优势
type Book struct {
    ID          primitive.ObjectID `bson:"_id,omitempty"`
    Title       string            `bson:"title"`
    Author      Author            `bson:"author"`           // 嵌套文档
    Chapters    []Chapter         `bson:"chapters"`         // 数组字段
    Tags        []string          `bson:"tags"`             // 动态标签
    Metadata    map[string]any    `bson:"metadata"`         // 灵活元数据
    CreatedAt   time.Time         `bson:"created_at"`
}
```

##### 3.2 缓存层：Redis
**选择原因**：
- **高性能**：内存存储，微秒级响应时间
- **数据结构丰富**：支持 String、Hash、List、Set、ZSet 等
- **持久化机制**：RDB + AOF 双重保障数据安全
- **集群支持**：Redis Cluster 提供高可用方案
- **Lua 脚本**：原子性操作，支持复杂业务逻辑

**使用策略**：
```go
// 缓存使用场景设计
type CacheStrategy struct {
    // 热点数据缓存（TTL: 1小时）
    BookRanking    string // "ranking:books:daily"
    UserSession    string // "session:user:{id}"
    
    // 计数器缓存（TTL: 永久）
    ReadCount      string // "count:read:{book_id}"
    LikeCount      string // "count:like:{book_id}"
    
    // 分布式锁（TTL: 30秒）
    WriteLock      string // "lock:write:{doc_id}"
}
```

##### 3.3 搜索引擎：Elasticsearch
**选择原因**：
- **全文检索**：支持中文分词，相关性评分算法成熟
- **实时索引**：近实时搜索，数据更新延迟 < 1秒
- **聚合分析**：强大的数据分析能力，支持多维度统计
- **高可用性**：分片和副本机制，支持集群部署
- **RESTful API**：与 Go HTTP 客户端集成简单

**索引设计示例**：
```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "content": {
        "type": "text",
        "analyzer": "ik_max_word"
      },
      "tags": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date"
      }
    }
  }
}
```

#### 4. 架构模式：分层架构 + 依赖注入
**设计原则**：
- **单一职责**：每层只负责特定功能，职责清晰
- **依赖倒置**：高层模块不依赖低层模块，都依赖抽象
- **开闭原则**：对扩展开放，对修改封闭
- **接口隔离**：客户端不应依赖它不需要的接口

**分层设计**：
```
┌─────────────────┐
│   Router Layer  │ ← HTTP 路由和参数绑定
├─────────────────┤
│  Handler Layer  │ ← 请求处理和响应封装
├─────────────────┤
│  Service Layer  │ ← 业务逻辑和事务管理
├─────────────────┤
│Repository Layer │ ← 数据访问和持久化
├─────────────────┤
│   Model Layer   │ ← 数据模型和验证规则
└─────────────────┘
```

**依赖注入实现**：
```go
// 接口定义（依赖倒置）
type BookRepository interface {
    Create(ctx context.Context, book *models.Book) error
    FindByID(ctx context.Context, id string) (*models.Book, error)
    Update(ctx context.Context, book *models.Book) error
    Delete(ctx context.Context, id string) error
}

// 构造函数注入（控制反转）
func NewBookService(
    bookRepo BookRepository,
    cacheRepo CacheRepository,
    searchRepo SearchRepository,
) BookService {
    return &BookServiceImpl{
        bookRepo:   bookRepo,
        cacheRepo:  cacheRepo,
        searchRepo: searchRepo,
    }
}
```

#### 5. 认证授权：JWT + RBAC
**JWT 选择原因**：
- **无状态**：服务端无需存储 session，支持水平扩展
- **跨域友好**：适合前后端分离架构
- **标准化**：RFC 7519 标准，生态成熟
- **自包含**：token 包含用户信息，减少数据库查询

**RBAC 模型设计**：
```go
// 权限模型设计
type User struct {
    ID    string `json:"id"`
    Roles []Role `json:"roles"`
}

type Role struct {
    ID          string       `json:"id"`
    Name        string       `json:"name"`
    Permissions []Permission `json:"permissions"`
}

type Permission struct {
    Resource string `json:"resource"` // 资源：book, user, project
    Action   string `json:"action"`   // 操作：create, read, update, delete
    Scope    string `json:"scope"`    // 范围：own, team, all
}
```

#### 6. 开发工具链选择

##### 6.1 容器化：Docker
**选择原因**：
- **环境一致性**：开发、测试、生产环境完全一致
- **部署简化**：一次构建，到处运行
- **资源隔离**：进程、网络、文件系统隔离
- **微服务友好**：支持服务拆分和独立部署

##### 6.2 热重载：Air
**选择原因**：
- **开发效率**：代码变更自动重启，提升开发体验
- **配置灵活**：支持自定义监听文件类型和重启策略
- **轻量级**：对系统资源占用极小

### 技术选型权衡与风险

#### 优势总结
1. **性能优异**：Go + Gin + Redis 组合，支持高并发访问
2. **开发效率**：MongoDB 文档模型 + JSON 原生支持，快速迭代
3. **扩展性强**：微服务架构 + 容器化部署，支持水平扩展
4. **维护成本低**：技术栈统一，学习成本和运维复杂度可控

#### 潜在风险与应对
1. **MongoDB 事务限制**：
   - **风险**：复杂事务场景支持有限
   - **应对**：设计时避免跨文档事务，使用聚合根模式

2. **Elasticsearch 运维复杂**：
   - **风险**：集群管理和调优需要专业知识
   - **应对**：提供单机版本，生产环境可选择托管服务

3. **Go 生态相对年轻**：
   - **风险**：某些领域库不如 Java/Python 成熟
   - **应对**：选择社区活跃的库，必要时自行实现

### 未来演进路径

#### 短期优化（3-6个月）
- 引入 gRPC 支持微服务通信
- 集成 Prometheus + Grafana 监控体系
- 添加 Jaeger 分布式链路追踪

#### 中期演进（6-12个月）
- 考虑引入 Kubernetes 容器编排
- 评估 PostgreSQL 替换部分 MongoDB 场景
- 集成 Apache Kafka 处理高吞吐消息

#### 长期规划（1-2年）
- 微服务架构完全拆分
- 多云部署和灾备方案
- AI 模型本地化部署
