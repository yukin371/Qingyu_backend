# 事件驱动模块结构分析

## 模块概述

事件驱动模块是青羽写作平台的核心基础设施，采用发布-订阅模式（Publish-Subscribe Pattern）实现服务间的松耦合通信。该模块通过内存事件总线（EventBus）提供同步和异步的事件发布机制，支持多个处理器订阅同一事件，为系统的可扩展性和可维护性提供强有力的支持。

## 目录结构

```
事件驱动模块/
├── service/base/                   # 基础服务层
│   └── base_service.go            # EventBus接口和实现
├── service/events/                # 事件定义层
│   ├── user_events.go             # 用户相关事件
│   ├── reading_events.go          # 阅读相关事件
│   └── writer_events.go           # 写作相关事件
├── service/container/             # 服务容器
│   └── service_container.go       # EventBus集成到容器
└── test/service/                  # 测试文件
    └── eventbus_test.go           # EventBus单元测试
```

## 核心组件

### 1. EventBus 基础设施 (`service/base/base_service.go`)

#### 1.1 核心接口定义

```go
// Event 事件接口
type Event interface {
    GetEventType() string           // 事件类型
    GetEventData() interface{}      // 事件数据
    GetTimestamp() time.Time        // 事件时间戳
    GetSource() string              // 事件来源
}

// EventHandler 事件处理器接口
type EventHandler interface {
    Handle(ctx context.Context, event Event) error
    GetHandlerName() string
    GetSupportedEventTypes() []string
}

// EventBus 事件总线接口
type EventBus interface {
    Subscribe(eventType string, handler EventHandler) error
    Unsubscribe(eventType string, handlerName string) error
    Publish(ctx context.Context, event Event) error        // 同步发布
    PublishAsync(ctx context.Context, event Event) error   // 异步发布
}
```

#### 1.2 BaseEvent 实现

```go
type BaseEvent struct {
    EventType string      `json:"event_type"`
    EventData interface{} `json:"event_data"`
    Timestamp time.Time   `json:"timestamp"`
    Source    string      `json:"source"`
}

func (e *BaseEvent) GetEventType() string {
    return e.EventType
}

func (e *BaseEvent) GetEventData() interface{} {
    return e.EventData
}

func (e *BaseEvent) GetTimestamp() time.Time {
    return e.Timestamp
}

func (e *BaseEvent) GetSource() string {
    return e.Source
}
```

#### 1.3 SimpleEventBus 实现

```go
type SimpleEventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
}

// NewSimpleEventBus 创建新的事件总线
func NewSimpleEventBus() *SimpleEventBus {
    return &SimpleEventBus{
        handlers: make(map[string][]EventHandler),
    }
}

// Subscribe 订阅事件
func (bus *SimpleEventBus) Subscribe(eventType string, handler EventHandler) error {
    bus.mu.Lock()
    defer bus.mu.Unlock()
    bus.handlers[eventType] = append(bus.handlers[eventType], handler)
    return nil
}

// Publish 同步发布事件
func (bus *SimpleEventBus) Publish(ctx context.Context, event Event) error {
    bus.mu.RLock()
    handlers := bus.handlers[event.GetEventType()]
    bus.mu.RUnlock()

    for _, handler := range handlers {
        if err := handler.Handle(ctx, event); err != nil {
            return err
        }
    }
    return nil
}

// PublishAsync 异步发布事件
func (bus *SimpleEventBus) PublishAsync(ctx context.Context, event Event) error {
    bus.mu.RLock()
    handlers := bus.handlers[event.GetEventType()]
    bus.mu.RUnlock()

    for _, handler := range handlers {
        go func(h EventHandler) {
            _ = h.Handle(ctx, event)
        }(handler)
    }
    return nil
}
```

### 2. 用户事件 (`service/events/user_events.go`)

#### 2.1 事件类型常量

```go
const (
    EventTypeUserRegistered = "user.registered"
    EventTypeUserLoggedIn   = "user.logged_in"
    EventTypeUserLoggedOut  = "user.logged_out"
    EventTypeUserUpdated    = "user.updated"
    EventTypeUserDeleted    = "user.deleted"
)
```

#### 2.2 事件数据结构

```go
type UserEventData struct {
    UserID   string                 `json:"user_id"`
    Username string                 `json:"username"`
    Email    string                 `json:"email"`
    Action   string                 `json:"action"`
    Time     time.Time              `json:"time"`
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

#### 2.3 事件工厂函数

```go
func NewUserRegisteredEvent(userID, username, email string) base.Event {
    return &base.BaseEvent{
        EventType: EventTypeUserRegistered,
        EventData: UserEventData{
            UserID:   userID,
            Username: username,
            Email:    email,
            Action:   "registered",
            Time:     time.Now(),
        },
        Timestamp: time.Now(),
        Source:    "UserService",
    }
}
```

### 3. 阅读事件 (`service/events/reading_events.go`)

#### 3.1 事件类型常量

```go
const (
    EventTypeChapterRead      = "reading.chapter_read"
    EventTypeBookmarkAdded    = "reading.bookmark_added"
    EventTypeNoteCreated      = "reading.note_created"
    EventTypeReadingProgress  = "reading.progress_updated"
    EventTypeReadingCompleted = "reading.book_completed"
)
```

#### 3.2 事件数据结构

```go
type ReadingEventData struct {
    UserID    string                 `json:"user_id"`
    BookID    string                 `json:"book_id"`
    ChapterID string                 `json:"chapter_id,omitempty"`
    Action    string                 `json:"action"`
    Progress  int                    `json:"progress,omitempty"`
    Time      time.Time              `json:"time"`
    Metadata  map[string]interface{} `json:"metadata,omitempty"`
}
```

### 4. 写作事件 (`service/events/writer_events.go`)

#### 4.1 事件类型常量

```go
const (
    // 角色事件
    EventTypeCharacterCreated = "character.created"
    EventTypeCharacterUpdated = "character.updated"
    EventTypeCharacterDeleted = "character.deleted"

    // 地点事件
    EventTypeLocationCreated = "location.created"
    EventTypeLocationUpdated = "location.updated"
    EventTypeLocationDeleted = "location.deleted"

    // 时间线事件
    EventTypeTimelineEventCreated = "timeline_event.created"
    EventTypeTimelineEventUpdated = "timeline_event.updated"
)
```

## 事件处理器

### 1. 用户事件处理器

#### 1.1 WelcomeEmailHandler

```go
type WelcomeEmailHandler struct {
    name        string
    emailService EmailService
}

func NewWelcomeEmailHandler(emailService EmailService) *WelcomeEmailHandler {
    return &WelcomeEmailHandler{
        name:        "WelcomeEmailHandler",
        emailService: emailService,
    }
}

func (h *WelcomeEmailHandler) Handle(ctx context.Context, event base.Event) error {
    data, ok := event.GetEventData().(UserEventData)
    if !ok {
        return fmt.Errorf("事件数据类型错误")
    }

    log.Printf("[WelcomeEmailHandler] 发送欢迎邮件给用户: %s (%s)",
        data.Username, data.Email)
    // h.emailService.SendWelcomeEmail(data.Email, data.Username)
    return nil
}

func (h *WelcomeEmailHandler) GetHandlerName() string {
    return h.name
}

func (h *WelcomeEmailHandler) GetSupportedEventTypes() []string {
    return []string{EventTypeUserRegistered}
}
```

#### 1.2 UserActivityLogHandler

```go
type UserActivityLogHandler struct {
    name string
    logRepo ActivityLogRepository
}

func (h *UserActivityLogHandler) Handle(ctx context.Context, event base.Event) error {
    data, _ := event.GetEventData().(UserEventData)
    log.Printf("[UserActivityLog] 用户活动: %s - 用户: %s, 动作: %s",
        event.GetEventType(), data.Username, data.Action)
    return nil
}

func (h *UserActivityLogHandler) GetSupportedEventTypes() []string {
    return []string{
        EventTypeUserRegistered,
        EventTypeUserLoggedIn,
        EventTypeUserLoggedOut,
        EventTypeUserUpdated,
    }
}
```

#### 1.3 UserStatisticsHandler

```go
type UserStatisticsHandler struct {
    name         string
    statsRepo    StatisticsRepository
}

func (h *UserStatisticsHandler) Handle(ctx context.Context, event base.Event) error {
    switch event.GetEventType() {
    case EventTypeUserRegistered:
        log.Printf("[UserStatistics] 新用户注册，更新总用户数")
    case EventTypeUserLoggedIn:
        log.Printf("[UserStatistics] 更新活跃用户数")
    }
    return nil
}

func (h *UserStatisticsHandler) GetSupportedEventTypes() []string {
    return []string{
        EventTypeUserRegistered,
        EventTypeUserLoggedIn,
        EventTypeUserDeleted,
    }
}
```

### 2. 阅读事件处理器

#### 2.1 ReadingStatisticsHandler

```go
type ReadingStatisticsHandler struct {
    name string
    statsRepo StatisticsRepository
}

func (h *ReadingStatisticsHandler) Handle(ctx context.Context, event base.Event) error {
    data, _ := event.GetEventData().(ReadingEventData)
    switch event.GetEventType() {
    case EventTypeChapterRead:
        log.Printf("[ReadingStatistics] 用户 %s 阅读了章节 %s",
            data.UserID, data.ChapterID)
    case EventTypeReadingProgress:
        log.Printf("[ReadingStatistics] 用户 %s 阅读进度: %d%%",
            data.UserID, data.Progress)
    }
    return nil
}

func (h *ReadingStatisticsHandler) GetSupportedEventTypes() []string {
    return []string{
        EventTypeChapterRead,
        EventTypeReadingProgress,
        EventTypeReadingCompleted,
    }
}
```

#### 2.2 RecommendationUpdateHandler

```go
type RecommendationUpdateHandler struct {
    name             string
    recommendService RecommendationService
}

func (h *RecommendationUpdateHandler) Handle(ctx context.Context, event base.Event) error {
    data, _ := event.GetEventData().(ReadingEventData)
    log.Printf("[RecommendationUpdate] 基于用户 %s 的阅读行为更新推荐列表",
        data.UserID)
    return nil
}

func (h *RecommendationUpdateHandler) GetSupportedEventTypes() []string {
    return []string{
        EventTypeChapterRead,
        EventTypeReadingCompleted,
    }
}
```

## 服务容器集成

### ServiceContainer 集成

```go
type ServiceContainer struct {
    repositoryFactory repoInterfaces.RepositoryFactory
    services          map[string]serviceInterfaces.BaseService
    initialized       bool

    // 基础设施
    eventBus          serviceInterfaces.EventBus  // 事件总线
}

// NewServiceContainer 创建服务容器时自动初始化EventBus
func NewServiceContainer(repositoryFactory repoInterfaces.RepositoryFactory) *ServiceContainer {
    return &ServiceContainer{
        repositoryFactory: repositoryFactory,
        services:          make(map[string]serviceInterfaces.BaseService),
        initialized:       false,
        eventBus:          base.NewSimpleEventBus(), // 创建事件总线
    }
}

// GetEventBus 获取事件总线
func (c *ServiceContainer) GetEventBus() serviceInterfaces.EventBus {
    return c.eventBus
}
```

### 服务中注入 EventBus

```go
// ReaderService 自动注入EventBus
c.readerService = readingService.NewReaderService(
    chapterRepo,
    progressRepo,
    annotationRepo,
    settingsRepo,
    c.eventBus,  // 注入事件总线
    nil,         // cacheService
    nil,         // vipService
)
```

## 使用示例

### 示例1: 用户注册事件

```go
// UserService
func (s *UserService) RegisterUser(ctx context.Context, req *RegisterRequest) error {
    // 1. 执行业务逻辑
    user := createUser(req)
    err := s.userRepo.Create(ctx, user)
    if err != nil {
        return err
    }

    // 2. 发布事件（异步）
    event := events.NewUserRegisteredEvent(user.ID, user.Username, user.Email)
    s.eventBus.PublishAsync(ctx, event)

    return nil
}
```

### 示例2: 章节阅读事件

```go
// ReaderService
func (s *ReaderService) ReadChapter(ctx context.Context,
    userID, bookID, chapterID string) error {
    // 1. 更新阅读进度
    s.progressRepo.UpdateProgress(ctx, userID, bookID, chapterID)

    // 2. 发布阅读事件
    event := events.NewChapterReadEvent(userID, bookID, chapterID)
    s.eventBus.PublishAsync(ctx, event)

    return nil
}
```

### 示例3: 点赞事件

```go
// LikeService
func (s *LikeService) LikeBook(ctx context.Context, userID, bookID string) error {
    // 1. 业务逻辑 - 添加点赞记录
    like := &social.Like{
        UserID:     userID,
        TargetType: social.LikeTargetTypeBook,
        TargetID:   bookID,
        CreatedAt:  time.Now(),
    }
    s.likeRepo.AddLike(ctx, like)

    // 2. 发布点赞事件
    s.publishLikeEvent(ctx, "like.book.added", userID,
        social.LikeTargetTypeBook, bookID)

    return nil
}
```

### 示例4: 注册事件处理器

```go
// 应用启动时注册处理器
func setupEventHandlers(eventBus base.EventBus) {
    // 用户注册事件的处理器
    eventBus.Subscribe(events.EventTypeUserRegistered,
        events.NewWelcomeEmailHandler(emailService))
    eventBus.Subscribe(events.EventTypeUserRegistered,
        events.NewUserActivityLogHandler(logRepo))
    eventBus.Subscribe(events.EventTypeUserRegistered,
        events.NewUserStatisticsHandler(statsRepo))

    // 阅读事件的处理器
    eventBus.Subscribe(events.EventTypeChapterRead,
        events.NewReadingStatisticsHandler(statsRepo))
    eventBus.Subscribe(events.EventTypeChapterRead,
        events.NewRecommendationUpdateHandler(recommendService))
}
```

## 典型应用场景

### 场景1: 用户注册流程

```
用户注册
  ↓
UserService.RegisterUser()
  ↓
发布 user.registered 事件
  ↓
并行处理:
  → WelcomeEmailHandler: 发送欢迎邮件
  → UserActivityLogHandler: 记录用户活动
  → UserStatisticsHandler: 更新统计数据
```

### 场景2: 章节阅读流程

```
用户阅读章节
  ↓
ReaderService.ReadChapter()
  ↓
发布 reading.chapter_read 事件
  ↓
并行处理:
  → ReadingStatisticsHandler: 更新阅读统计
  → RecommendationUpdateHandler: 更新推荐算法
```

### 场景3: 书籍点赞流程

```
用户点赞书籍
  ↓
LikeService.LikeBook()
  ↓
发布 like.book.added 事件
  ↓
并行处理:
  → NotificationHandler: 发送通知给作者
  → StatisticsHandler: 更新书籍热度
  → RecommendationHandler: 更新推荐权重
```

## 依赖关系

### 依赖的模块
- 无（事件驱动模块是基础设施模块）

### 被依赖的模块
- 所有业务模块（用户、阅读、写作、社交等）都使用事件总线发布事件
- 所有处理器都订阅特定事件进行处理

### 外部服务
- **无**：当前实现为内存事件总线，不依赖外部服务

## 配置项

```yaml
events:
  eventbus:
    type: memory              # 当前支持: memory
    async_enabled: true       # 是否启用异步发布
    max_handlers: 100         # 每个事件最多处理器数量
    timeout: 30s              # 处理器执行超时时间

  # 事件持久化（可选，用于审计和重放）
  persistence:
    enabled: false
    storage: mongodb          # 存储方式: mongodb/redis
    collection: events_log    # MongoDB集合名
    ttl: 30d                 # 事件日志保留时间

  # 事件重试（可选）
  retry:
    enabled: false
    max_retries: 3
    backoff: exponential     # 重试策略: fixed/exponential
    initial_delay: 1s
    max_delay: 60s
```

## 性能特性

### 1. 低延迟
- 事件发布延迟极低（微秒级）
- 内存事件总线，无网络开销
- 同步发布：等待所有处理器完成
- 异步发布：立即返回，不阻塞主流程

### 2. 高并发
- 支持多个处理器并行处理同一事件
- 读写锁保证并发安全
- 异步处理提高吞吐量

### 3. 可扩展
- 支持动态注册/注销事件处理器
- 一个事件可以被多个处理器处理
- 处理器可独立开发和测试

## 测试覆盖

### 单元测试 (`test/service/eventbus_test.go`)

```go
// 测试用例列表：
1. TestSimpleEventBus_Subscribe          // 事件订阅
2. TestSimpleEventBus_Publish            // 同步事件发布
3. TestSimpleEventBus_PublishAsync       // 异步事件发布
4. TestSimpleEventBus_MultipleHandlers   // 多个处理器
5. TestSimpleEventBus_Unsubscribe        // 取消订阅
6. TestSimpleEventBus_DifferentEventTypes // 不同事件类型
7. TestReadingEvents                     // 阅读事件
8. TestReadingProgressEvents             // 阅读进度事件
9. TestEventData                         // 事件数据验证
```

### 测试结果

```
=== RUN   TestSimpleEventBus_Subscribe
--- PASS: TestSimpleEventBus_Subscribe (0.00s)
=== RUN   TestSimpleEventBus_Publish
--- PASS: TestSimpleEventBus_Publish (0.01s)
=== RUN   TestSimpleEventBus_PublishAsync
--- PASS: TestSimpleEventBus_PublishAsync (0.10s)
=== RUN   TestSimpleEventBus_MultipleHandlers
[WelcomeEmailHandler] 发送欢迎邮件给用户: testuser
[UserActivityLog] 用户活动: user.registered
[UserStatistics] 新用户注册: testuser
--- PASS: TestSimpleEventBus_MultipleHandlers (0.00s)
=== RUN   TestSimpleEventBus_Unsubscribe
--- PASS: TestSimpleEventBus_Unsubscribe (0.00s)
=== RUN   TestSimpleEventBus_DifferentEventTypes
[UserActivityLog] 用户活动: user.registered
[UserActivityLog] 用户活动: user.logged_in
--- PASS: TestSimpleEventBus_DifferentEventTypes (0.00s)
=== RUN   TestReadingEvents
[ReadingStatistics] 用户 user123 阅读了章节 chapter789
[RecommendationUpdate] 基于用户 user123 的阅读行为更新推荐列表
--- PASS: TestReadingEvents (0.01s)
=== RUN   TestEventData
--- PASS: TestEventData (0.00s)

PASS
ok      Qingyu_backend/test/service     0.279s
```

## 扩展点

### 1. 持久化事件
- 将事件存储到数据库或 Redis
- 支持事件回放和审计
- 实现事件溯源（Event Sourcing）

### 2. 分布式事件总线
- 集成 RabbitMQ/Kafka 等消息队列
- 支持跨服务的异步通信
- 实现最终一致性

### 3. 事件重试机制
- 失败事件自动重试
- 指数退避策略
- 死信队列处理

### 4. 事件监控
- 事件发布和处理的性能指标
- 处理器执行时间监控
- 事件流量统计和告警

### 5. 事件版本管理
- 支持事件数据结构演进
- 向后兼容性保证
- 多版本事件共存

## 最佳实践

### 1. 事件命名规范

使用点号分隔的命名空间：
```
用户域：user.*
阅读域：reading.*
书城域：bookstore.*
写作域：writer.*
AI域：ai.*
社交域：social.*
财务域：finance.*
```

### 2. 事件数据设计原则

```go
type EventData struct {
    // 必要的业务数据
    UserID   string
    Action   string
    Time     time.Time

    // 可选的元数据
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

**原则**：
- 保持事件数据结构简单
- 避免包含敏感信息
- 使用幂等性设计
- 只包含必要的业务数据

### 3. 处理器设计原则

- ✅ **单一职责**：每个处理器只做一件事
- ✅ **幂等性**：可重复执行不会产生副作用
- ✅ **错误隔离**：处理器失败不影响主流程
- ✅ **异步处理**：长时间操作使用异步处理
- ✅ **超时控制**：避免处理器执行时间过长

### 4. 同步 vs 异步选择

**使用同步发布 (Publish)** 当：
- 需要确保处理完成
- 处理失败需要回滚
- 关键业务逻辑

**使用异步发布 (PublishAsync)** 当：
- 不影响主流程
- 可以容忍失败
- 通知、统计、日志等

### 5. 错误处理

```go
func (bus *SimpleEventBus) Publish(ctx context.Context, event Event) error {
    bus.mu.RLock()
    handlers := bus.handlers[event.GetEventType()]
    bus.mu.RUnlock()

    var errors []error
    for _, handler := range handlers {
        if err := handler.Handle(ctx, event); err != nil {
            // 记录错误，但不中断其他处理器
            log.Printf("[EventBus] 处理器 %s 处理事件 %s 失败: %v",
                handler.GetHandlerName(), event.GetEventType(), err)
            errors = append(errors, err)
        }
    }

    if len(errors) > 0 {
        return fmt.Errorf("部分处理器执行失败: %v", errors)
    }
    return nil
}
```

## 监控指标

- **事件发布速率**：每秒发布的事件数量
- **事件处理延迟**：事件从发布到处理的平均延迟
- **处理器执行时间**：每个处理器的平均执行时间
- **失败率**：事件处理失败的百分比
- **队列深度**：待处理事件的队列长度
- **处理器数量**：每个事件类型的处理器数量

## 未来规划

### 短期 (1-2周)
- [ ] 为所有核心Service添加事件发布
- [ ] 实现更多业务场景的事件处理器
- [ ] 添加事件持久化（审计日志）

### 中期 (1个月)
- [ ] 实现事件重试机制
- [ ] 添加事件监控和指标
- [ ] 优化事件处理性能

### 长期 (3个月)
- [ ] 集成分布式消息队列（RabbitMQ/Kafka）
- [ ] 实现跨服务事件通信
- [ ] 实现事件溯源（Event Sourcing）

## 总结

事件驱动模块作为青羽写作平台的核心基础设施，提供了：

✅ **松耦合**：服务之间通过事件总线通信，无需直接依赖
✅ **可扩展**：轻松添加新的事件类型和处理器
✅ **高性能**：低延迟、高并发的事件处理
✅ **易维护**：清晰的业务逻辑分离和单一职责

通过合理的事件设计和处理器实现，系统可以灵活应对业务需求的变化，为系统的持续演进提供了坚实的基础。
