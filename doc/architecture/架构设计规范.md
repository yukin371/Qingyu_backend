# 架构设计规范

## 1. 概述

### 1.1 目的
本规范旨在为青羽项目的架构设计提供统一的标准和指导原则，确保系统架构的一致性、可维护性和可扩展性。

### 1.2 适用范围
- 系统整体架构设计
- 微服务架构设计
- 数据架构设计
- 技术架构设计
- 部署架构设计
- 安全架构设计

### 1.3 设计原则
- **模块化**：系统应采用模块化设计，各模块职责清晰
- **可扩展性**：架构应支持水平和垂直扩展
- **高可用性**：系统应具备容错和故障恢复能力
- **安全性**：架构设计应考虑安全威胁和防护措施
- **性能优化**：架构应支持高并发和低延迟要求
- **技术统一**：采用统一的技术栈和开发规范

## 2. 架构文档分类

### 2.1 系统架构文档
**用途**：描述系统的整体架构和组件关系

**包含内容**：
- 系统概览和边界
- 核心组件和服务
- 组件间的交互关系
- 数据流和控制流
- 技术选型说明

### 2.2 微服务架构文档
**用途**：描述微服务的划分和治理策略

**包含内容**：
- 服务划分原则
- 服务边界定义
- 服务间通信机制
- 服务发现和注册
- 负载均衡策略
- 容错和熔断机制

### 2.3 数据架构文档
**用途**：描述数据存储和处理架构

**包含内容**：
- 数据模型设计
- 数据库选型和分片策略
- 数据一致性保证
- 数据备份和恢复
- 数据安全和隐私保护

### 2.4 技术架构文档
**用途**：描述技术栈和开发框架

**包含内容**：
- 技术栈选择
- 开发框架和工具
- 代码组织结构
- 构建和部署流程
- 监控和日志系统

### 2.5 部署架构文档
**用途**：描述系统的部署和运维架构

**包含内容**：
- 部署环境规划
- 容器化和编排策略
- 网络架构设计
- 存储架构设计
- 监控和告警系统

### 2.6 安全架构文档
**用途**：描述系统的安全设计和防护措施

**包含内容**：
- 安全威胁分析
- 身份认证和授权
- 数据加密和传输安全
- 网络安全防护
- 安全审计和合规

## 3. 架构设计文档模板

### 3.1 标准架构文档模板

```markdown
# [系统名称]架构设计

## 1. 架构概述
- **系统简介**：系统的基本功能和定位
- **架构目标**：架构设计要达到的目标
- **设计约束**：技术、业务、资源等约束条件
- **关键质量属性**：性能、可用性、安全性等要求

## 2. 架构视图

### 2.1 逻辑架构
- **分层架构**：展示系统的逻辑分层
  - **表示层（Presentation Layer）**：API接口、路由处理、请求响应
  - **业务逻辑层（Service Layer）**：业务规则、流程控制、数据转换
  - **数据访问层（Repository Layer）**：数据持久化、查询封装、事务管理、缓存策略
  - **数据存储层（Data Layer）**：数据库、缓存、文件存储
- **模块划分**：各层内部的模块组织
- **依赖关系**：模块间的依赖关系图，遵循依赖倒置原则，Service层依赖Repository抽象接口

### 2.2 物理架构
- **部署视图**：系统的物理部署结构
- **网络拓扑**：网络连接和通信路径
- **硬件配置**：服务器、存储、网络设备配置

### 2.3 运行时架构
- **进程视图**：运行时的进程和线程模型
- **数据流**：数据在系统中的流转过程
- **控制流**：系统的控制和协调机制

## 3. 核心组件设计

### 3.1 [组件名称1]
- **功能职责**：组件的主要功能和职责
- **接口定义**：对外提供的接口规范
- **内部结构**：组件的内部实现结构
- **依赖关系**：与其他组件的依赖关系，特别是与Repository层的交互
- **关键算法**：核心算法和处理逻辑
- **性能考虑**：性能优化和瓶颈分析

### 3.2 Repository层设计
- **接口抽象**：定义数据访问接口，实现数据库无关性
- **实现分离**：具体数据库实现与业务逻辑分离
- **事务管理**：统一的事务处理和回滚机制
- **查询优化**：复杂查询的封装和优化
- **缓存策略**：数据缓存和失效策略
- **错误处理**：数据访问异常的统一处理
- **分类设计**：
  - **基础Repository**：提供通用的CRUD操作
  - **业务Repository**：针对特定业务场景的复杂查询和操作
  - **聚合Repository**：处理多个实体关联的复杂操作
- **与Service层交互**：定义清晰的接口，支持依赖注入和单元测试

**Repository层详细实现示例**：

#### 3.2.1 基础Repository接口
```go
// BaseRepository 基础Repository接口，提供通用CRUD操作
type BaseRepository[T any, ID comparable] interface {
    // 基础CRUD操作
    Create(ctx context.Context, entity *T) error
    GetByID(ctx context.Context, id ID) (*T, error)
    Update(ctx context.Context, id ID, updates map[string]interface{}) error
    Delete(ctx context.Context, id ID) error
    
    // 查询操作
    List(ctx context.Context, filter Filter) ([]*T, error)
    Count(ctx context.Context, filter Filter) (int64, error)
    
    // 健康检查
    Health(ctx context.Context) error
}

// Filter 查询过滤器
type Filter struct {
    Conditions map[string]interface{} `json:"conditions"`
    OrderBy    []OrderBy              `json:"order_by"`
    Limit      int64                  `json:"limit"`
    Offset     int64                  `json:"offset"`
}

type OrderBy struct {
    Field string `json:"field"`
    Desc  bool   `json:"desc"`
}
```

#### 3.2.2 业务Repository接口
```go
// UserRepository 用户Repository接口，继承基础Repository并添加业务特定方法
type UserRepository interface {
    // 继承基础Repository接口
    BaseRepository[*User, string]
    
    // 用户特定的查询方法
    GetByUsername(ctx context.Context, username string) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    ExistsByUsername(ctx context.Context, username string) (bool, error)
    ExistsByEmail(ctx context.Context, email string) (bool, error)
    
    // 用户状态管理
    UpdateLastLogin(ctx context.Context, id string) error
    UpdatePassword(ctx context.Context, id string, hashedPassword string) error
    GetActiveUsers(ctx context.Context, limit int64) ([]*User, error)
    
    // 复杂查询
    SearchUsers(ctx context.Context, keyword string, filters UserFilter) ([]*User, error)
    GetUsersByRole(ctx context.Context, roleID string) ([]*User, error)
    
    // 事务操作
    Transaction(ctx context.Context, fn func(ctx context.Context, repo UserRepository) error) error
}

// UserFilter 用户查询过滤器
type UserFilter struct {
    Status    string    `json:"status,omitempty"`
    CreatedAt TimeRange `json:"created_at,omitempty"`
    Role      string    `json:"role,omitempty"`
}

type TimeRange struct {
    Start *time.Time `json:"start,omitempty"`
    End   *time.Time `json:"end,omitempty"`
}
```

#### 3.2.3 MongoDB Repository实现
```go
// MongoUserRepository MongoDB用户Repository实现
type MongoUserRepository struct {
    db           *mongo.Database
    collection   *mongo.Collection
    queryBuilder QueryBuilder
}

// NewMongoUserRepository 创建MongoDB用户Repository实例
func NewMongoUserRepository(db *mongo.Database) UserRepository {
    return &MongoUserRepository{
        db:           db,
        collection:   db.Collection("users"),
        queryBuilder: NewMongoQueryBuilder(),
    }
}

// Create 创建用户
func (r *MongoUserRepository) Create(ctx context.Context, user *User) error {
    user.ID = primitive.NewObjectID().Hex()
    user.CreatedAt = time.Now()
    user.UpdatedAt = time.Now()
    
    _, err := r.collection.InsertOne(ctx, user)
    if err != nil {
        if mongo.IsDuplicateKeyError(err) {
            return NewRepositoryError("DUPLICATE_KEY", "用户已存在", err)
        }
        return NewRepositoryError("INTERNAL_ERROR", "创建用户失败", err)
    }
    
    return nil
}

// GetByID 根据ID获取用户
func (r *MongoUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
    var user User
    err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&user)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return nil, nil // 用户不存在
        }
        return nil, NewRepositoryError("INTERNAL_ERROR", "查询用户失败", err)
    }
    
    return &user, nil
}

// GetByEmail 根据邮箱获取用户
func (r *MongoUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    var user User
    err := r.collection.FindOne(ctx, bson.M{"email": email}).Decode(&user)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return nil, nil
        }
        return nil, NewRepositoryError("INTERNAL_ERROR", "根据邮箱查询用户失败", err)
    }
    
    return &user, nil
}

// ExistsByEmail 检查邮箱是否存在
func (r *MongoUserRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) {
    count, err := r.collection.CountDocuments(ctx, bson.M{"email": email})
    if err != nil {
        return false, NewRepositoryError("INTERNAL_ERROR", "检查邮箱存在性失败", err)
    }
    
    return count > 0, nil
}

// SearchUsers 搜索用户
func (r *MongoUserRepository) SearchUsers(ctx context.Context, keyword string, filters UserFilter) ([]*User, error) {
    filter := bson.M{}
    
    // 关键词搜索
    if keyword != "" {
        filter["$or"] = []bson.M{
            {"username": bson.M{"$regex": keyword, "$options": "i"}},
            {"email": bson.M{"$regex": keyword, "$options": "i"}},
        }
    }
    
    // 状态过滤
    if filters.Status != "" {
        filter["status"] = filters.Status
    }
    
    // 时间范围过滤
    if filters.CreatedAt.Start != nil || filters.CreatedAt.End != nil {
        timeFilter := bson.M{}
        if filters.CreatedAt.Start != nil {
            timeFilter["$gte"] = *filters.CreatedAt.Start
        }
        if filters.CreatedAt.End != nil {
            timeFilter["$lte"] = *filters.CreatedAt.End
        }
        filter["created_at"] = timeFilter
    }
    
    cursor, err := r.collection.Find(ctx, filter)
    if err != nil {
        return nil, NewRepositoryError("INTERNAL_ERROR", "搜索用户失败", err)
    }
    defer cursor.Close(ctx)
    
    var users []*User
    if err = cursor.All(ctx, &users); err != nil {
        return nil, NewRepositoryError("INTERNAL_ERROR", "解析搜索结果失败", err)
    }
    
    return users, nil
}

// Transaction 事务操作
func (r *MongoUserRepository) Transaction(ctx context.Context, fn func(ctx context.Context, repo UserRepository) error) error {
    return r.db.Client().UseSession(ctx, func(sc mongo.SessionContext) error {
        if err := sc.StartTransaction(); err != nil {
            return err
        }
        defer sc.EndSession(ctx)

        // 在事务上下文中执行操作
        if err := fn(sc, r); err != nil {
            sc.AbortTransaction(sc)
            return err
        }

        return sc.CommitTransaction(sc)
    })
}
```

#### 3.2.4 Repository错误处理
```go
// RepositoryError Repository层错误类型
type RepositoryError struct {
    Type    string `json:"type"`
    Message string `json:"message"`
    Cause   error  `json:"-"`
}

func (e *RepositoryError) Error() string {
    return e.Message
}

func NewRepositoryError(errorType, message string, cause error) *RepositoryError {
    return &RepositoryError{
        Type:    errorType,
        Message: message,
        Cause:   cause,
    }
}

// 错误类型常量
const (
    ErrorTypeDuplicateKey = "DUPLICATE_KEY"
    ErrorTypeNotFound     = "NOT_FOUND"
    ErrorTypeInternalError = "INTERNAL_ERROR"
    ErrorTypeValidation   = "VALIDATION_ERROR"
)
```

#### 3.2.5 Repository工厂模式
```go
// RepositoryFactory Repository工厂接口
type RepositoryFactory interface {
    CreateUserRepository() UserRepository
    CreateProjectRepository() ProjectRepository
    CreateRoleRepository() RoleRepository
    Close() error
    Health(ctx context.Context) error
}

// MongoRepositoryFactory MongoDB Repository工厂实现
type MongoRepositoryFactory struct {
    database *mongo.Database
}

func NewMongoRepositoryFactory(database *mongo.Database) RepositoryFactory {
    return &MongoRepositoryFactory{
        database: database,
    }
}

func (f *MongoRepositoryFactory) CreateUserRepository() UserRepository {
    return NewMongoUserRepository(f.database)
}

func (f *MongoRepositoryFactory) CreateProjectRepository() ProjectRepository {
    return NewMongoProjectRepository(f.database)
}

func (f *MongoRepositoryFactory) Health(ctx context.Context) error {
    return f.database.Client().Ping(ctx, nil)
}
```

### 3.3 Service层设计
- **功能职责**：业务逻辑处理、流程控制、数据转换、事务协调
- **接口定义**：对外提供的业务接口规范
- **内部结构**：业务逻辑的组织和实现
- **依赖关系**：依赖Repository接口，不直接操作数据库
- **关键算法**：业务规则和处理逻辑
- **性能考虑**：业务逻辑优化和缓存策略

**Service层实现示例**：
```go
// UserService 用户服务接口
type UserService interface {
    CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error)
    GetUser(ctx context.Context, userID string) (*User, error)
    UpdateUser(ctx context.Context, userID string, updates *UpdateUserRequest) error
    DeleteUser(ctx context.Context, userID string) error
}

// UserServiceImpl 用户服务实现
type UserServiceImpl struct {
    userRepo     repository.UserRepository
    emailService EmailService
    logger       Logger
}

func (s *UserServiceImpl) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
    // 1. 参数验证（业务逻辑）
    if err := s.validateCreateUserRequest(req); err != nil {
        return nil, NewServiceError("VALIDATION_ERROR", err.Error())
    }
    
    // 2. 业务规则检查
    exists, err := s.userRepo.ExistsByEmail(ctx, req.Email)
    if err != nil {
        return nil, NewServiceError("INTERNAL_ERROR", "检查邮箱失败")
    }
    if exists {
        return nil, NewServiceError("BUSINESS_ERROR", "邮箱已存在")
    }
    
    // 3. 数据转换和处理
    user := &User{
        Username: req.Username,
        Email:    req.Email,
        Password: s.hashPassword(req.Password),
        Status:   "active",
    }
    
    // 4. 通过Repository保存数据
    if err := s.userRepo.Create(ctx, user); err != nil {
        return nil, NewServiceError("INTERNAL_ERROR", "创建用户失败")
    }
    
    // 5. 后续业务处理（发送邮件等）
    go s.emailService.SendWelcomeEmail(user.Email)
    
    return &CreateUserResponse{
        UserID:   user.ID,
        Username: user.Username,
        Email:    user.Email,
    }, nil
}
```

### 3.4 Controller层设计
- **功能职责**：HTTP请求处理、参数解析、响应格式化、错误处理
- **接口定义**：RESTful API接口规范
- **内部结构**：路由处理和中间件组织
- **依赖关系**：依赖Service接口，不直接操作Repository
- **关键算法**：请求路由和响应处理
- **性能考虑**：请求处理优化和限流策略

**Controller层实现示例**：
```go
// UserController 用户控制器
type UserController struct {
    userService service.UserService
    validator   *validator.Validate
}

// CreateUser 创建用户API
func (c *UserController) CreateUser(ctx *gin.Context) {
    var req service.CreateUserRequest
    
    // 1. 参数绑定和验证
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{
            "error": "参数格式错误",
            "details": err.Error(),
        })
        return
    }
    
    // 2. 参数验证
    if err := c.validator.Struct(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{
            "error": "参数验证失败",
            "details": err.Error(),
        })
        return
    }
    
    // 3. 调用Service层处理业务逻辑
    resp, err := c.userService.CreateUser(ctx.Request.Context(), &req)
    if err != nil {
        // 4. 错误处理和响应
        c.handleServiceError(ctx, err)
        return
    }
    
    // 5. 成功响应
    ctx.JSON(http.StatusCreated, gin.H{
        "message": "用户创建成功",
        "data": resp,
    })
}

// handleServiceError 处理Service层错误
func (c *UserController) handleServiceError(ctx *gin.Context, err error) {
    if serviceErr, ok := err.(*service.ServiceError); ok {
        switch serviceErr.Type {
        case "VALIDATION_ERROR":
            ctx.JSON(http.StatusBadRequest, gin.H{"error": serviceErr.Message})
        case "BUSINESS_ERROR":
            ctx.JSON(http.StatusConflict, gin.H{"error": serviceErr.Message})
        case "NOT_FOUND":
            ctx.JSON(http.StatusNotFound, gin.H{"error": serviceErr.Message})
        default:
            ctx.JSON(http.StatusInternalServerError, gin.H{"error": "内部服务器错误"})
        }
    } else {
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "内部服务器错误"})
    }
}
```

## 4. 数据架构

### 4.1 数据模型
- **概念模型**：业务概念和实体关系
- **逻辑模型**：数据库表结构设计
- **物理模型**：存储实现和优化策略

### 4.2 数据流
- **数据来源**：数据的输入来源和格式
- **处理流程**：数据的处理和转换过程
- **存储策略**：数据的存储和归档策略

## 5. 技术选型

### 5.1 开发技术栈
- **编程语言**：选择的编程语言和版本
- **开发框架**：使用的开发框架和库
- **数据库**：数据库类型和版本选择
- **中间件**：消息队列、缓存等中间件
- **Repository实现**：
  - **ORM框架**：用于对象关系映射的框架选择
  - **查询构建器**：用于复杂查询构建的工具选择
  - **事务管理**：事务处理和管理工具
  - **缓存实现**：数据缓存实现方案

### 5.2 选型理由
- **技术成熟度**：技术的成熟度和稳定性
- **团队熟悉度**：团队对技术的掌握程度
- **社区支持**：技术的社区活跃度和支持
- **性能表现**：技术的性能特点和适用场景

## 6. 质量属性设计

### 6.1 性能设计
- **性能目标**：响应时间、吞吐量等指标
- **性能策略**：缓存、异步处理等优化策略
- **性能测试**：性能测试方案和基准

### 6.2 可用性设计
- **可用性目标**：系统可用性指标要求
- **容错机制**：故障检测和恢复机制
- **备份策略**：数据备份和灾难恢复

### 6.3 安全性设计
- **安全威胁**：识别的安全威胁和风险
- **安全措施**：采取的安全防护措施
- **合规要求**：需要满足的合规标准

## 7. 部署和运维

### 7.1 部署架构
- **环境规划**：开发、测试、生产环境
- **部署策略**：蓝绿部署、滚动更新等
- **容器化**：Docker容器化方案

### 7.2 监控和运维
- **监控指标**：关键性能和业务指标
- **日志管理**：日志收集、存储和分析
- **告警机制**：异常检测和告警通知

## 8. 风险和挑战

### 8.1 技术风险
- **风险识别**：潜在的技术风险点
- **影响评估**：风险对系统的影响程度
- **应对措施**：风险缓解和应对策略

### 8.2 实施挑战
- **技术挑战**：实施过程中的技术难点
- **资源挑战**：人力、时间、成本等资源约束
- **解决方案**：挑战的解决思路和方案

## 9. 青羽项目架构最佳实践

### 9.1 分层架构实施指南

#### 9.1.1 层级职责严格分离
**原则**：每一层只能调用下一层的接口，不能跨层调用

**正确示例**：
```
API → Service → Repository → Database
```

**错误示例**：
```
API → Repository (跨过Service层)
Service → Database (跨过Repository层)
```

**实施要点**：
- API层只处理HTTP请求响应，不包含业务逻辑
- Service层专注业务逻辑，通过Repository接口访问数据
- Repository层封装所有数据访问操作，包括索引管理
- 每层都要有清晰的错误处理机制

#### 9.1.2 依赖注入配置
**应用启动时的依赖配置示例**：
```go
// main.go 或 初始化文件
func initializeServices() error {
    // 1. 初始化数据库连接
    db, err := initMongoDB()
    if err != nil {
        return err
    }
    
    // 2. 创建Repository工厂
    repoFactory := repository.NewMongoRepositoryFactory(db)
    
    // 3. 创建Repository实例
    userRepo := repoFactory.CreateUserRepository()
    projectRepo := repoFactory.CreateProjectRepository()
    
    // 4. 创建Service实例（注入Repository）
    userService := service.NewUserService(userRepo)
    projectService := service.NewProjectService(projectRepo)
    
    // 5. 创建Controller实例（注入Service）
    userController := controller.NewUserController(userService)
    projectController := controller.NewProjectController(projectService)
    
    // 6. 注册路由
    router := gin.New()
    registerRoutes(router, userController, projectController)
    
    return nil
}
```

### 9.2 错误处理最佳实践

#### 9.2.1 分层错误处理策略
```go
// Repository层：数据访问错误
type RepositoryError struct {
    Type    string `json:"type"`    // DUPLICATE_KEY, NOT_FOUND, INTERNAL_ERROR
    Message string `json:"message"`
    Cause   error  `json:"-"`
}

// Service层：业务逻辑错误
type ServiceError struct {
    Type      string `json:"type"`    // VALIDATION_ERROR, BUSINESS_ERROR, NOT_FOUND
    Message   string `json:"message"`
    Service   string `json:"service"`
    Timestamp time.Time `json:"timestamp"`
}

// Controller层：HTTP响应错误
func (c *BaseController) HandleError(ctx *gin.Context, err error) {
    switch e := err.(type) {
    case *service.ServiceError:
        switch e.Type {
        case "VALIDATION_ERROR":
            ctx.JSON(http.StatusBadRequest, gin.H{"error": e.Message})
        case "BUSINESS_ERROR":
            ctx.JSON(http.StatusConflict, gin.H{"error": e.Message})
        case "NOT_FOUND":
            ctx.JSON(http.StatusNotFound, gin.H{"error": e.Message})
        default:
            ctx.JSON(http.StatusInternalServerError, gin.H{"error": "内部服务器错误"})
        }
    default:
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "内部服务器错误"})
    }
}
```

### 9.3 数据库操作规范

#### 9.3.1 索引管理规范
**原则**：索引管理应该在Repository层，而不是Service层

**正确实现**：
```go
// repository/mongodb/project_repository_mongo.go
type MongoProjectIndexManager struct {
    collection *mongo.Collection
}

func (m *MongoProjectIndexManager) EnsureIndexes(ctx context.Context) error {
    indexModels := []mongo.IndexModel{
        {Keys: bson.M{"owner_id": 1}},
        {Keys: bson.M{"status": 1}},
        {Keys: bson.M{"owner_id": 1, "status": 1}},
    }
    _, err := m.collection.Indexes().CreateMany(ctx, indexModels)
    return err
}

// service层在初始化时调用
func (s *ProjectService) Initialize(ctx context.Context) error {
    return s.indexManager.EnsureIndexes(ctx)
}
```

#### 9.3.2 事务处理规范
```go
// Repository层提供事务支持
func (r *MongoUserRepository) Transaction(ctx context.Context, fn func(ctx context.Context, repo UserRepository) error) error {
    return r.db.Client().UseSession(ctx, func(sc mongo.SessionContext) error {
        if err := sc.StartTransaction(); err != nil {
            return err
        }
        defer sc.EndSession(ctx)

        if err := fn(sc, r); err != nil {
            sc.AbortTransaction(sc)
            return err
        }

        return sc.CommitTransaction(sc)
    })
}

// Service层使用事务
func (s *UserService) CreateUserWithProfile(ctx context.Context, req *CreateUserRequest) error {
    return s.userRepo.Transaction(ctx, func(txCtx context.Context, repo UserRepository) error {
        // 在事务中执行多个操作
        user := &User{...}
        if err := repo.Create(txCtx, user); err != nil {
            return err
        }
        
        profile := &UserProfile{UserID: user.ID, ...}
        return s.profileRepo.Create(txCtx, profile)
    })
}
```

### 9.4 测试策略

#### 9.4.1 单元测试最佳实践
```go
// Service层单元测试示例
func TestUserService_CreateUser(t *testing.T) {
    // 1. 创建Mock Repository
    mockRepo := &MockUserRepository{}
    
    // 2. 创建Service实例
    service := NewUserService(mockRepo)
    
    // 3. 设置Mock期望
    mockRepo.On("ExistsByEmail", mock.Anything, "test@example.com").Return(false, nil)
    mockRepo.On("Create", mock.Anything, mock.AnythingOfType("*User")).Return(nil)
    
    // 4. 执行测试
    req := &CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
    
    resp, err := service.CreateUser(context.Background(), req)
    
    // 5. 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    assert.Equal(t, "testuser", resp.Username)
    
    // 6. 验证Mock调用
    mockRepo.AssertExpectations(t)
}

// Mock Repository实现
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

func (m *MockUserRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) {
    args := m.Called(ctx, email)
    return args.Bool(0), args.Error(1)
}
```

### 9.5 性能优化指南

#### 9.5.1 Repository层缓存策略
```go
// 带缓存的Repository实现
type CachedUserRepository struct {
    baseRepo UserRepository
    cache    Cache
    ttl      time.Duration
}

func (r *CachedUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
    // 1. 先查缓存
    cacheKey := fmt.Sprintf("user:%s", id)
    if cached, err := r.cache.Get(cacheKey); err == nil {
        var user User
        if err := json.Unmarshal(cached, &user); err == nil {
            return &user, nil
        }
    }
    
    // 2. 缓存未命中，查数据库
    user, err := r.baseRepo.GetByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    if user != nil {
        if data, err := json.Marshal(user); err == nil {
            r.cache.Set(cacheKey, data, r.ttl)
        }
    }
    
    return user, nil
}
```

#### 9.5.2 查询优化策略
```go
// 复杂查询的优化实现
func (r *MongoUserRepository) SearchUsersOptimized(ctx context.Context, req *SearchRequest) ([]*User, error) {
    pipeline := []bson.M{}
    
    // 1. 匹配阶段 - 尽早过滤
    matchStage := bson.M{}
    if req.Status != "" {
        matchStage["status"] = req.Status
    }
    if req.Keyword != "" {
        matchStage["$text"] = bson.M{"$search": req.Keyword}
    }
    if len(matchStage) > 0 {
        pipeline = append(pipeline, bson.M{"$match": matchStage})
    }
    
    // 2. 排序阶段 - 利用索引
    if req.SortBy != "" {
        sortOrder := 1
        if req.SortDesc {
            sortOrder = -1
        }
        pipeline = append(pipeline, bson.M{"$sort": bson.M{req.SortBy: sortOrder}})
    }
    
    // 3. 分页阶段
    if req.Offset > 0 {
        pipeline = append(pipeline, bson.M{"$skip": req.Offset})
    }
    if req.Limit > 0 {
        pipeline = append(pipeline, bson.M{"$limit": req.Limit})
    }
    
    // 4. 投影阶段 - 只返回需要的字段
    if len(req.Fields) > 0 {
        projection := bson.M{}
        for _, field := range req.Fields {
            projection[field] = 1
        }
        pipeline = append(pipeline, bson.M{"$project": projection})
    }
    
    cursor, err := r.collection.Aggregate(ctx, pipeline)
    if err != nil {
        return nil, err
    }
    defer cursor.Close(ctx)
    
    var users []*User
    return users, cursor.All(ctx, &users)
}
```

### 9.6 代码组织规范

#### 9.6.1 目录结构规范
```
Qingyu_backend/
├── api/v1/                 # API版本控制
├── config/                 # 配置管理
├── controller/             # 控制器层
│   ├── user_controller.go
│   └── project_controller.go
├── service/                # 服务层
│   ├── interfaces/         # 服务接口定义
│   ├── user/              # 用户服务实现
│   └── project/           # 项目服务实现
├── repository/             # 数据访问层
│   ├── interfaces/         # Repository接口定义
│   ├── mongodb/           # MongoDB实现
│   ├── base/              # 基础Repository
│   └── user_repository.go
├── models/                 # 数据模型
│   ├── user/
│   └── project/
├── middleware/             # 中间件
├── utils/                  # 工具函数
└── test/                   # 测试文件
```

#### 9.6.2 命名规范
- **接口命名**：以业务实体名 + Repository/Service 结尾
  - `UserRepository`, `ProjectService`
- **实现命名**：以具体技术 + 业务实体名 + Repository/Service 结尾
  - `MongoUserRepository`, `UserServiceImpl`
- **方法命名**：使用动词开头，清晰表达操作意图
  - `CreateUser`, `GetUserByEmail`, `UpdateUserStatus`
- **错误命名**：以Error结尾，包含错误类型
  - `ValidationError`, `BusinessError`, `RepositoryError`

### 9.7 部署和运维规范

#### 9.7.1 健康检查实现
```go
// 分层健康检查
func (s *UserService) Health(ctx context.Context) error {
    // 检查依赖的Repository健康状态
    return s.userRepo.Health(ctx)
}

func (r *MongoUserRepository) Health(ctx context.Context) error {
    // 检查数据库连接
    return r.db.Client().Ping(ctx, nil)
}

// 应用级健康检查
func HealthCheck(ctx *gin.Context) {
    health := map[string]string{
        "status": "ok",
        "timestamp": time.Now().Format(time.RFC3339),
    }
    
    // 检查各个服务健康状态
    if err := userService.Health(ctx.Request.Context()); err != nil {
        health["user_service"] = "error: " + err.Error()
        health["status"] = "error"
    } else {
        health["user_service"] = "ok"
    }
    
    if health["status"] == "ok" {
        ctx.JSON(http.StatusOK, health)
    } else {
        ctx.JSON(http.StatusServiceUnavailable, health)
    }
}
```

#### 9.7.2 监控和日志
```go
// 结构化日志记录
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
    logger := s.logger.WithFields(logrus.Fields{
        "operation": "CreateUser",
        "user_email": req.Email,
        "request_id": ctx.Value("request_id"),
    })
    
    logger.Info("开始创建用户")
    
    resp, err := s.createUserInternal(ctx, req)
    if err != nil {
        logger.WithError(err).Error("创建用户失败")
        return nil, err
    }
    
    logger.WithField("user_id", resp.UserID).Info("用户创建成功")
    return resp, nil
}

// 性能监控
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        metrics.RecordDuration("user_service.create_user", duration)
    }()
    
    return s.createUserInternal(ctx, req)
}
```

## 10. 演进规划

### 10.1 短期规划（3-6个月）
- **架构重构目标**：
  - 完成所有Service层的Repository模式重构
  - 建立统一的错误处理机制
  - 实现完整的单元测试覆盖
  - 建立CI/CD流水线

- **实施计划**：
  1. **第1个月**：重构核心业务模块（用户、项目管理）
  2. **第2个月**：重构文档和AI模块
  3. **第3个月**：重构阅读模块
  4. **第4-5个月**：完善测试和监控
  5. **第6个月**：性能优化和部署优化

- **里程碑**：
  - 所有Service层不再直接操作数据库
  - 单元测试覆盖率达到80%以上
  - 建立完整的健康检查和监控体系

### 10.2 长期规划（1-2年）
- **远期愿景**：
  - 微服务架构演进
  - 支持多数据库和分布式部署
  - 实现自动化运维和智能监控
  - 建立完整的开发者生态

- **技术趋势**：
  - 容器化和Kubernetes部署
  - 服务网格（Service Mesh）
  - 事件驱动架构
  - 云原生技术栈

- **架构演进**：
  - 从单体架构向微服务架构演进
  - 引入消息队列和事件总线
  - 实现数据库读写分离和分片
  - 建立统一的API网关

## 11. 附录

### 11.1 术语表
- **Repository模式**：数据访问层的设计模式，将数据访问逻辑封装在Repository接口中
- **依赖注入**：通过构造函数或方法参数注入依赖对象，而不是在类内部创建
- **分层架构**：将应用程序分为多个层次，每层有明确的职责和依赖关系
- **事务**：一组数据库操作的原子单元，要么全部成功，要么全部失败
- **索引**：数据库中用于提高查询性能的数据结构
- **缓存**：临时存储数据以提高访问速度的技术
- **健康检查**：定期检查系统组件状态的机制
- **Mock对象**：用于测试的模拟对象，可以预设行为和验证调用

### 11.2 参考资料
- [Clean Architecture - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Repository Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/repository.html)
- [Go语言设计模式](https://github.com/tmrts/go-patterns)
- [MongoDB Go Driver文档](https://pkg.go.dev/go.mongodb.org/mongo-driver)
- [Gin Web Framework](https://gin-gonic.com/docs/)
- [Testify测试框架](https://github.com/stretchr/testify)

### 11.3 最佳实践
- **SOLID原则**：单一职责、开闭原则、里氏替换、接口隔离、依赖倒置
- **DRY原则**：Don't Repeat Yourself，避免代码重复
- **KISS原则**：Keep It Simple, Stupid，保持简单
- **YAGNI原则**：You Aren't Gonna Need It，不要过度设计
- **测试驱动开发**：先写测试，再写实现代码
- **持续集成**：频繁集成代码，及早发现问题
- **代码审查**：通过同行审查提高代码质量

### 11.4 变更记录
| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0 | 2024-01-XX | 初始版本，基础架构规范 | 架构团队 |
| 1.1 | 2024-01-XX | 增加Repository层详细设计和实例 | 架构团队 |
| 1.2 | 2024-01-XX | 添加青羽项目最佳实践指南 | 架构团队 |
| 1.3 | 2024-01-XX | 完善错误处理和测试策略 | 架构团队 |

### 11.5 青羽项目架构检查清单

#### 11.5.1 Service层检查清单
- [ ] Service不直接操作数据库
- [ ] Service通过Repository接口访问数据
- [ ] Service包含业务逻辑验证
- [ ] Service有统一的错误处理
- [ ] Service支持依赖注入
- [ ] Service有对应的单元测试

#### 11.5.2 Repository层检查清单
- [ ] Repository接口定义清晰
- [ ] Repository实现与具体数据库分离
- [ ] Repository包含错误处理
- [ ] Repository支持事务操作
- [ ] Repository有索引管理
- [ ] Repository有健康检查

#### 11.5.3 Controller层检查清单
- [ ] Controller只处理HTTP请求响应
- [ ] Controller不包含业务逻辑
- [ ] Controller有参数验证
- [ ] Controller有统一的错误响应格式
- [ ] Controller有适当的HTTP状态码
- [ ] Controller有请求日志记录

#### 11.5.4 代码质量检查清单
- [ ] 代码遵循命名规范
- [ ] 代码有适当的注释
- [ ] 代码有错误处理
- [ ] 代码有单元测试
- [ ] 代码通过静态分析
- [ ] 代码通过代码审查

### 11.6 常见问题解答

#### Q1: 为什么要使用Repository模式？
**A**: Repository模式提供了数据访问的抽象层，使得：
- 业务逻辑与数据访问分离
- 便于单元测试（可以mock Repository）
- 支持多种数据库实现
- 提高代码的可维护性和可扩展性

#### Q2: Service层应该包含哪些内容？
**A**: Service层应该包含：
- 业务逻辑处理
- 参数验证
- 业务规则检查
- 事务协调
- 错误处理
- 不应该包含数据库操作和HTTP处理

#### Q3: 如何处理跨Service的事务？
**A**: 可以通过以下方式处理：
- 在Repository层提供事务支持
- 使用分布式事务（如两阶段提交）
- 使用事件驱动架构
- 使用Saga模式

#### Q4: 如何进行性能优化？
**A**: 性能优化策略包括：
- 在Repository层实现缓存
- 优化数据库查询和索引
- 使用连接池
- 实现异步处理
- 使用CDN和负载均衡

#### Q5: 如何保证代码质量？
**A**: 代码质量保证措施：
- 编写单元测试和集成测试
- 进行代码审查
- 使用静态代码分析工具
- 遵循编码规范
- 持续集成和持续部署
```

### 3.2 快速架构文档模板

**适用场景**：简单系统或概念验证的快速架构设计

```markdown
# [系统名称]架构设计（快速版）

## 1. 系统概述
- 系统功能和目标
- 主要用户和场景

## 2. 架构概览
- 整体架构图
- 核心组件说明

## 3. 技术选型
- 主要技术栈
- 选型理由

## 4. 部署方案
- 部署架构
- 环境要求

## 5. 关键设计决策
- 重要的设计决策
- 权衡考虑

## 6. 风险和注意事项
- 主要风险点
- 缓解措施
```

## 4. 架构设计质量标准

### 4.1 完整性标准
- **需求覆盖**：架构设计应完整覆盖功能和非功能需求
- **视图完整**：包含逻辑、物理、运行时等多个架构视图
- **文档齐全**：提供完整的设计文档和说明
- **可追溯性**：设计决策可追溯到需求和约束

### 4.2 一致性标准
- **内部一致**：架构各部分设计保持一致
- **外部一致**：与企业架构和技术标准保持一致
- **接口一致**：组件间接口设计规范统一
- **数据一致**：数据模型和格式保持一致

### 4.3 可行性标准
- **技术可行**：选择的技术方案成熟可靠
- **资源可行**：在现有资源约束下可实现
- **时间可行**：在项目时间计划内可完成
- **风险可控**：识别的风险有相应的应对措施

### 4.4 可维护性标准
- **模块化**：系统采用良好的模块化设计
- **可扩展**：架构支持功能和性能扩展
- **可测试**：架构设计便于测试和验证
- **文档化**：提供充分的文档和注释

## 5. 架构评审流程

### 5.1 评审阶段
1. **概念架构评审**：评审架构概念和总体方案
2. **详细架构评审**：评审详细的架构设计
3. **实现架构评审**：评审架构的具体实现
4. **部署架构评审**：评审部署和运维方案

### 5.2 评审参与者
- **架构师**：主导架构设计和评审
- **技术专家**：提供专业技术意见
- **项目经理**：确保架构符合项目目标
- **运维工程师**：评估运维可行性
- **安全专家**：评估安全风险和措施

### 5.3 评审标准
- **业务对齐**：架构是否支持业务目标
- **技术合理**：技术选型是否合理
- **质量保证**：是否满足质量属性要求
- **风险可控**：风险是否识别和控制
- **可实施性**：是否具备实施条件

## 6. 架构管理和治理

### 6.1 架构治理原则
- **标准化**：建立和维护架构标准
- **合规性**：确保架构符合企业标准
- **一致性**：保持架构的一致性
- **演进性**：支持架构的持续演进

### 6.2 架构变更管理
- **变更申请**：正式的架构变更申请流程
- **影响评估**：评估变更对系统的影响
- **审批流程**：变更的审批和确认流程
- **实施跟踪**：变更实施的跟踪和验证

### 6.3 架构度量和监控
- **架构指标**：定义架构质量的度量指标
- **监控机制**：建立架构监控和报告机制
- **持续改进**：基于监控结果持续改进架构
- **知识管理**：积累和分享架构知识和经验

## 7. 工具和方法

### 7.1 架构建模工具
- **UML工具**：用于架构图和模型设计
- **架构描述语言**：如ArchiMate等
- **图形工具**：如Visio、Draw.io等
- **协作平台**：支持团队协作的在线工具

### 7.2 架构分析方法
- **ATAM**：架构权衡分析方法
- **SAAM**：软件架构分析方法
- **质量属性场景**：质量属性的场景化分析
- **架构评估**：系统化的架构评估方法

### 7.3 文档管理
- **版本控制**：使用Git等工具进行版本管理
- **文档生成**：自动化文档生成和更新
- **知识库**：建立架构知识库和最佳实践
- **培训材料**：架构培训和知识传递材料

## 8. 附录

### 8.1 架构模式库
- 常用的架构模式和应用场景
- 模式的优缺点和适用条件
- 模式的实现指导和示例

### 8.2 技术选型指南
- 技术选型的评估标准
- 常用技术的对比分析
- 技术选型的决策流程

### 8.3 最佳实践
- 架构设计的最佳实践
- 常见问题和解决方案
- 成功案例和经验分享