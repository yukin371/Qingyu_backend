# 路由层设计规范

## 1. 需求概述

### 1.1 功能描述
路由层是青羽写作系统的前端门户，负责接收和分发所有HTTP请求，将请求路由到相应的API处理函数。路由层定义了系统的API结构和访问路径，并集成了必要的中间件来处理认证、日志记录、错误处理等横切关注点。

### 1.2 业务价值
- **统一入口**：为所有API提供统一的访问入口和路径规范
- **安全保障**：通过中间件实现认证和授权，保障API安全
- **可维护性**：清晰的路由结构提高系统可维护性
- **可扩展性**：模块化的路由组织便于功能扩展

### 1.3 用户场景
- 用户通过前端应用访问后端API
- 第三方应用通过API集成青羽写作系统功能
- 系统管理员监控API访问和使用情况

### 1.4 功能边界
- 仅负责HTTP请求的路由和分发
- 不包含具体的业务逻辑处理
- 不直接与数据库交互
- 主要关注点是路由注册和中间件配置

## 2. 架构设计

### 2.1 整体架构
```
┌─────────────────┐
│   HTTP Request  │ ← 客户端请求
├─────────────────┤
│   Router Layer  │ ← 路由层（本文档关注点）
├─────────────────┤
│   Middleware    │ ← 中间件（认证、日志等）
├─────────────────┤
│   API Layer     │ ← API处理函数
├─────────────────┤
│   Service Layer │ ← 业务逻辑
└─────────────────┘
```

### 2.2 模块划分
- **根路由**：处理根路径和全局配置
- **API版本路由**：管理不同版本的API
- **功能模块路由**：按功能模块组织的子路由
- **中间件管理**：全局和局部中间件配置

## 3. 详细设计

### 3.1 Router层设计
- **路由分组策略**：
  - 按API版本分组：`/api/v1/`
  - 按功能模块分组：`/api/v1/{module}/`
  - 按资源类型分组：`/api/v1/{module}/{resource}/`

- **中间件应用顺序**：
  1. 日志中间件（记录请求）
  2. 跨域中间件（CORS）
  3. 认证中间件（JWT验证）
  4. 权限中间件（访问控制）
  5. 请求限流中间件
  6. 错误处理中间件

- **路径命名规范**：
  - 使用RESTful风格
  - 资源名称使用复数形式
  - 使用小写字母和连字符
  - 避免使用动词，使用HTTP方法表达操作

- **参数提取方式**：
  - 路径参数：`/api/v1/documents/:id`
  - 查询参数：`/api/v1/documents?limit=10&offset=0`
  - 请求体：JSON格式

### 3.2 路由注册结构

```go
// 主路由注册函数
func RegisterRoutes(r *gin.Engine) {
    // 全局中间件
    r.Use(middleware.Logger())
    r.Use(middleware.CORS())
    r.Use(middleware.Recovery())

    // API版本分组
    v1 := r.Group("/api/v1")
    {
        // 无需认证的路由
        public := v1.Group("/")
        {
            // 注册公开路由
            system.RegisterPublicRoutes(public)
        }

        // 需要认证的路由
        authenticated := v1.Group("/")
        authenticated.Use(middleware.JWTAuth())
        {
            // 注册各模块路由
            document.RegisterRoutes(authenticated)
            ai.RegisterRoutes(authenticated)
            // 其他模块路由...
        }
    }
}
```

### 3.3 文档模块路由设计

```go
// 文档模块路由注册
func RegisterRoutes(r *gin.RouterGroup) {
    // 文档路由组
    docRouter := r.Group("/document")
    {
        // 文档相关路由
        d := api.NewDocumentApi()
        v := api.NewVersionApi()
        p := api.NewProjectApi()
        
        // 项目相关路由
        docRouter.POST("/projects", p.Create)
        docRouter.GET("/projects", p.List)
        docRouter.GET("/projects/:id", p.Get)
        docRouter.PUT("/projects/:id", p.Update)
        docRouter.DELETE("/projects/:id", p.Delete)
        
        // 基础文档操作
        docRouter.POST("/", d.Create)
        docRouter.GET("/", d.List)
        docRouter.GET("/doc/:id", d.Get)
        docRouter.PUT("/doc/:id", d.Update)
        docRouter.DELETE("/doc/:id", d.Delete)

        // 版本相关路由
        versionRouter := docRouter.Group("/version")
        {
            versionRouter.POST("/:projectId/:nodeId", v.CreateVersion)
            versionRouter.GET("/:projectId/:nodeId/versions", v.ListVersions)
            versionRouter.POST("/:projectId/:nodeId/rollback", v.Rollback)
            // 其他版本相关路由...
        }
    }
}
```

### 3.4 AI模块路由设计

```go
// AI模块路由注册
func RegisterRoutes(r *gin.RouterGroup) {
    // AI路由组
    aiRouter := r.Group("/ai")
    {
        // AI相关路由
        a := api.NewAIApi()
        
        // 对话相关路由
        aiRouter.POST("/chat", a.Chat)
        aiRouter.POST("/chat/stream", a.StreamChat)
        
        // 内容生成相关路由
        aiRouter.POST("/generate", a.Generate)
        aiRouter.POST("/analyze", a.Analyze)
        
        // 其他AI相关路由...
    }
}
```

## 4. 中间件设计

### 4.1 认证中间件
```go
// JWT认证中间件
func JWTAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "未提供认证令牌"})
            c.Abort()
            return
        }
        
        // 验证JWT令牌
        claims, err := jwt.ParseToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的认证令牌"})
            c.Abort()
            return
        }
        
        // 将用户信息存入上下文
        c.Set("userId", claims.UserID)
        c.Set("userRole", claims.Role)
        
        c.Next()
    }
}
```

### 4.2 日志中间件
```go
// 请求日志中间件
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        method := c.Request.Method
        
        // 处理请求
        c.Next()
        
        // 计算耗时
        latency := time.Since(start)
        statusCode := c.Writer.Status()
        
        // 记录日志
        log.Printf("[%s] %s %s %d %s", method, path, statusCode, latency)
    }
}
```

### 4.3 错误处理中间件
```go
// 全局错误处理中间件
func Recovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // 记录错误日志
                log.Printf("系统异常: %v", err)
                
                // 返回友好的错误信息
                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "服务器内部错误",
                    "code": "INTERNAL_ERROR"
                })
            }
        }()
        
        c.Next()
    }
}
```

## 5. 安全设计

### 5.1 路由安全策略
- **认证保护**：所有非公开API都需要JWT认证
- **HTTPS强制**：生产环境强制使用HTTPS
- **CSRF防护**：实现CSRF令牌验证
- **请求限流**：基于IP和用户ID的请求限流

### 5.2 输入验证
- 路径参数验证
- 查询参数验证
- 请求体格式和内容验证

### 5.3 错误处理原则
- 不暴露敏感信息
- 统一错误响应格式
- 详细日志记录但简洁用户反馈

## 6. 性能考虑

### 6.1 路由优化
- 路由树优化
- 中间件执行顺序优化
- 路由缓存

### 6.2 负载均衡
- 支持水平扩展
- 会话保持策略
- 负载均衡配置

## 7. 测试设计

### 7.1 路由测试
- 路由注册测试
- 路径匹配测试
- 参数提取测试

### 7.2 中间件测试
- 认证中间件测试
- 日志中间件测试
- 错误处理中间件测试

## 8. 部署和运维

### 8.1 部署配置
- 端口配置
- TLS配置
- 超时设置

### 8.2 监控指标
- 请求计数
- 响应时间
- 错误率
- 路由使用频率

## 9. 扩展性设计

### 9.1 API版本管理
- 版本升级策略
- 向后兼容性保证
- 废弃流程

### 9.2 动态路由
- 支持运行时路由注册
- 插件化路由扩展
- 配置驱动的路由管理