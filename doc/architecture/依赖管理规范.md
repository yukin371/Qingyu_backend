# 青羽后端依赖管理规范

## 接口与实现依赖原则

### 1. 基本原则

遵循**依赖倒置原则（Dependency Inversion Principle）**：
- 高层模块不应该依赖低层模块，两者都应该依赖抽象
- 抽象不应该依赖细节，细节应该依赖抽象

### 2. 当前架构

```
service/interfaces/base/     ← 接口定义（抽象）
    ├─ BaseService
    ├─ Event
    ├─ EventBus
    └─ EventHandler

service/base/                ← 具体实现
    ├─ BaseEvent
    ├─ SimpleEventBus
    ├─ ServiceContainer
    └─ 类型别名（指向接口）
```

### 3. 依赖规范

#### 🎯 推荐做法（严格模式）

```go
// ✅ 服务层实现
import (
    baseInterface "Qingyu_backend/service/interfaces/base"
    "Qingyu_backend/service/base"  // 仅用于具体实现
)

type MyService struct {
    eventBus baseInterface.EventBus  // 字段类型使用接口
}

func NewMyService(eventBus baseInterface.EventBus) *MyService {
    return &MyService{
        eventBus: eventBus,  // 构造函数接受接口
    }
}

func (s *MyService) doSomething(ctx context.Context) {
    // 使用具体实现创建事件
    event := &base.BaseEvent{
        EventType: "my.event",
        EventData: data,
    }
    s.eventBus.PublishAsync(ctx, event)
}
```

#### ⚡ 当前做法（务实模式）

```go
// ⚠️ 当前实现（通过类型别名使用接口）
import "Qingyu_backend/service/base"

type MyService struct {
    eventBus base.EventBus  // 实际上是 baseInterface.EventBus
}

func NewMyService(eventBus base.EventBus) *MyService {
    return &MyService{eventBus: eventBus}
}

func (s *MyService) doSomething(ctx context.Context) {
    event := &base.BaseEvent{...}
    s.eventBus.PublishAsync(ctx, event)
}
```

**说明**：
- 通过 `service/base` 中的类型别名 `type EventBus = baseInterface.EventBus`
- 实际上仍在使用接口类型
- 简化了导入，但架构边界不够清晰

### 4. 不同场景的选择

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 新服务开发 | 严格模式 | 保持架构清晰 |
| 现有服务 | 务实模式 | 避免大规模重构 |
| 测试代码 | 严格模式 | 便于 Mock |
| 初始化代码（main.go） | 务实模式 | 需要创建具体实现 |

### 5. 迁移建议

如果要从务实模式迁移到严格模式，建议：

1. **优先级**：
   - P0: 新开发的服务必须使用严格模式
   - P1: 核心服务逐步重构
   - P2: 测试代码优先改造
   - P3: 其他服务按需改造

2. **迁移步骤**：
   ```go
   // Step 1: 添加接口导入
   import (
       baseInterface "Qingyu_backend/service/interfaces/base"
       "Qingyu_backend/service/base"
   )
   
   // Step 2: 修改字段类型
   type MyService struct {
       eventBus baseInterface.EventBus  // base.EventBus → baseInterface.EventBus
   }
   
   // Step 3: 修改构造函数签名
   func NewMyService(eventBus baseInterface.EventBus) *MyService {...}
   
   // Step 4: 保持实现代码不变（因为类型兼容）
   ```

3. **影响范围**：
   - 字段声明
   - 函数签名
   - 导入语句
   - ⚠️ 实现代码无需修改（类型兼容）

### 6. 总结

**当前状态**：
- ✅ 通过类型别名实际使用了接口
- ⚠️ 但依赖了实现包，架构不够清晰
- ✅ 务实可用，适合当前阶段

**未来方向**：
- 🎯 逐步迁移到严格模式
- 🎯 新代码必须遵循接口优先原则
- 🎯 保持向后兼容，避免破坏性变更

---

**版本**: v1.0
**最后更新**: 2025-10-24
**维护者**: 青羽后端架构团队

