# 青羽共享服务性能优化指南

## 文档概述

本文档提供青羽后端共享服务的完整性能优化指南，涵盖应用层、数据库层、网络层和系统层的优化策略。

**版本**: v1.0  
**适用范围**: 青羽共享服务 API v1.0  
**文档更新**: 2025-10-04

---

## 目录

- [性能目标](#性能目标)
- [性能基准测试](#性能基准测试)
- [应用层优化](#应用层优化)
- [数据库优化](#数据库优化)
- [缓存策略](#缓存策略)
- [网络优化](#网络优化)
- [系统优化](#系统优化)
- [监控和分析](#监控和分析)
- [性能调优案例](#性能调优案例)

---

## 性能目标

### 1. 响应时间目标

| 端点类型 | P50 | P95 | P99 | 说明 |
|---------|-----|-----|-----|------|
| 读接口（查询） | < 50ms | < 100ms | < 200ms | GET请求 |
| 写接口（创建/更新）| < 100ms | < 300ms | < 500ms | POST/PUT请求 |
| 复杂查询 | < 200ms | < 500ms | < 1000ms | 涉及多表查询 |
| 文件上传 | < 1s | < 3s | < 5s | 10MB以内文件 |

### 2. 吞吐量目标

| 场景 | 单机QPS | 集群QPS | 说明 |
|------|--------|---------|------|
| 简单查询 | 5,000+ | 15,000+ | 余额查询、用户信息 |
| 写操作 | 2,000+ | 6,000+ | 充值、消费、转账 |
| 复杂查询 | 1,000+ | 3,000+ | 交易记录、统计 |
| 文件操作 | 100+ | 300+ | 上传、下载 |

### 3. 资源使用目标

| 资源 | 单机目标 | 告警阈值 | 说明 |
|------|---------|---------|------|
| CPU | < 60% | 80% | 平均使用率 |
| 内存 | < 70% | 85% | 包含缓存 |
| 磁盘IO | < 70% | 85% | IOPS和带宽 |
| 网络 | < 50% | 70% | 带宽使用 |

### 4. 可用性目标

| 指标 | 目标 | 说明 |
|------|------|------|
| 可用性 | 99.9% | 年停机时间 < 8.76小时 |
| 错误率 | < 0.1% | 5xx错误 |
| 响应超时率 | < 1% | 超过5秒的请求 |

---

## 性能基准测试

### 1. 基准测试工具

#### 使用wrk进行压测
```bash
# 安装wrk
git clone https://github.com/wg/wrk.git
cd wrk
make

# 基础测试（10线程，100连接，持续30秒）
wrk -t10 -c100 -d30s http://localhost:8080/api/v1/shared/wallet/balance \
  -H "Authorization: Bearer $TOKEN"

# 输出示例：
# Running 30s test @ http://localhost:8080/api/v1/shared/wallet/balance
#   10 threads and 100 connections
#   Thread Stats   Avg      Stdev     Max   +/- Stdev
#     Latency    45.23ms   12.34ms  120.45ms   78.23%
#     Req/Sec     2.21k     234.12     2.89k    67.89%
#   662345 requests in 30.00s, 125.34MB read
# Requests/sec:  22078.17
# Transfer/sec:      4.18MB
```

#### 使用ab进行测试
```bash
# Apache Bench测试
ab -n 10000 -c 100 -H "Authorization: Bearer $TOKEN" \
  http://localhost:8080/api/v1/shared/wallet/balance

# 关键指标：
# Requests per second: 5234.56 [#/sec]
# Time per request: 19.103 [ms] (mean)
# Time per request: 0.191 [ms] (mean, across all concurrent requests)
```

#### 使用vegeta进行测试
```bash
# 安装vegeta
go install github.com/tsenart/vegeta@latest

# 创建测试目标文件
echo "GET http://localhost:8080/api/v1/shared/wallet/balance" > targets.txt
echo "Authorization: Bearer $TOKEN" >> targets.txt

# 运行测试（50 QPS，持续30秒）
vegeta attack -targets=targets.txt -rate=50 -duration=30s | \
  vegeta report -type=text

# 输出：
# Requests      [total, rate, throughput]  1500, 50.03, 49.98
# Duration      [total, attack, wait]      30.018s, 29.983s, 35.123ms
# Latencies     [mean, 50, 95, 99, max]    45.234ms, 42.123ms, 67.234ms, 89.234ms, 156.234ms
# Bytes In      [total, mean]              375000, 250.00
# Bytes Out     [total, mean]              0, 0.00
# Success       [ratio]                    100.00%
# Status Codes  [code:count]               200:1500
```

### 2. Go性能分析

#### CPU Profiling
```go
// 启用pprof
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // ... 应用代码
}
```

```bash
# 收集30秒CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 交互式分析
(pprof) top10        # 查看CPU占用前10的函数
(pprof) list main.handler  # 查看具体函数的代码
(pprof) web          # 生成调用图（需要graphviz）

# 生成火焰图
go tool pprof -http=:8080 cpu.prof
```

#### Memory Profiling
```bash
# 收集内存profile
go tool pprof http://localhost:6060/debug/pprof/heap

# 查看内存分配
(pprof) top10
(pprof) list allocatingFunc
(pprof) web

# 内存泄漏检测
go tool pprof -alloc_space http://localhost:6060/debug/pprof/heap
go tool pprof -inuse_space http://localhost:6060/debug/pprof/heap
```

#### Goroutine分析
```bash
# 查看goroutine数量
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# 生成goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

### 3. 数据库性能测试

```bash
# MongoDB性能测试
mongosh Qingyu_writer --eval '
// 启用profiling
db.setProfilingLevel(2, { slowms: 100 })

// 查看慢查询
db.system.profile.find().sort({ts:-1}).limit(10).pretty()

// 分析查询计划
db.wallets.find({user_id: "user_123"}).explain("executionStats")
'

# 索引效率分析
mongosh Qingyu_writer --eval '
db.wallets.getIndexes()
db.wallets.stats().indexSizes
'
```

---

## 应用层优化

### 1. 代码优化

#### 1.1 避免不必要的内存分配
```go
// ❌ 不推荐：频繁的字符串拼接
func buildMessage(items []string) string {
    result := ""
    for _, item := range items {
        result += item + ", "  // 每次都创建新字符串
    }
    return result
}

// ✅ 推荐：使用strings.Builder
func buildMessage(items []string) string {
    var builder strings.Builder
    builder.Grow(len(items) * 20)  // 预分配容量
    for i, item := range items {
        if i > 0 {
            builder.WriteString(", ")
        }
        builder.WriteString(item)
    }
    return builder.String()
}
```

#### 1.2 使用对象池
```go
import "sync"

// 缓冲区池
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

func processData(data []byte) {
    // 从池中获取缓冲区
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf)  // 使用后归还
    
    // 使用buf处理数据
    copy(buf, data)
    // ...
}
```

#### 1.3 减少反射使用
```go
// ❌ 不推荐：过度使用反射
func process(v interface{}) {
    val := reflect.ValueOf(v)
    // 反射操作很慢
}

// ✅ 推荐：使用类型断言或泛型
func process(v interface{}) {
    switch v := v.(type) {
    case string:
        // 直接处理
    case int:
        // 直接处理
    }
}
```

#### 1.4 并发优化
```go
// 使用goroutine池限制并发数
type WorkerPool struct {
    workers   int
    taskQueue chan Task
}

func NewWorkerPool(workers int) *WorkerPool {
    wp := &WorkerPool{
        workers:   workers,
        taskQueue: make(chan Task, workers*2),
    }
    
    // 启动worker
    for i := 0; i < workers; i++ {
        go wp.worker()
    }
    
    return wp
}

func (wp *WorkerPool) worker() {
    for task := range wp.taskQueue {
        task.Execute()
    }
}

func (wp *WorkerPool) Submit(task Task) {
    wp.taskQueue <- task
}
```

### 2. 数据结构优化

#### 2.1 选择合适的数据结构
```go
// 场景1：频繁查找 → 使用map
userCache := make(map[string]*User, 10000)

// 场景2：有序遍历 → 使用slice
sortedUsers := make([]*User, 0, 1000)

// 场景3：唯一性检查 → 使用map[string]struct{}
uniqueIDs := make(map[string]struct{})
```

#### 2.2 预分配容量
```go
// ❌ 不推荐：未预分配
users := make([]User, 0)
for i := 0; i < 10000; i++ {
    users = append(users, User{})  // 多次扩容
}

// ✅ 推荐：预分配容量
users := make([]User, 0, 10000)
for i := 0; i < 10000; i++ {
    users = append(users, User{})  // 无需扩容
}
```

### 3. 序列化优化

#### 3.1 使用高效的序列化库
```go
import (
    "github.com/json-iterator/go"  // 比标准库快2-3倍
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

// 序列化
data, _ := json.Marshal(obj)

// 反序列化
json.Unmarshal(data, &obj)
```

#### 3.2 减少序列化开销
```go
// 使用omitempty减少输出
type User struct {
    ID       string `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email,omitempty"`  // 空值不序列化
    Phone    string `json:"phone,omitempty"`
}
```

### 4. 错误处理优化

```go
// ❌ 不推荐：频繁创建error
func validate(data string) error {
    if len(data) == 0 {
        return fmt.Errorf("data is empty")  // 每次都创建新error
    }
    return nil
}

// ✅ 推荐：使用预定义error
var (
    ErrEmptyData = errors.New("data is empty")
    ErrInvalidFormat = errors.New("invalid format")
)

func validate(data string) error {
    if len(data) == 0 {
        return ErrEmptyData  // 复用error
    }
    return nil
}
```

---

## 数据库优化

### 1. 索引优化

#### 1.1 创建必要的索引
```javascript
// MongoDB索引优化

// 用户查询索引
db.users.createIndex({ "username": 1 }, { unique: true })
db.users.createIndex({ "email": 1 }, { unique: true })

// 钱包查询索引
db.wallets.createIndex({ "user_id": 1 }, { unique: true })
db.wallets.createIndex({ "status": 1, "balance": -1 })

// 交易查询索引（复合索引）
db.transactions.createIndex(
    { "user_id": 1, "created_at": -1 },
    { name: "user_transactions_idx" }
)

// 部分索引（只索引活跃用户）
db.transactions.createIndex(
    { "user_id": 1, "created_at": -1 },
    { 
        partialFilterExpression: { 
            created_at: { $gt: new Date("2024-01-01") }
        }
    }
)
```

#### 1.2 索引分析和优化
```javascript
// 分析查询计划
db.transactions.find({user_id: "user_123"})
    .sort({created_at: -1})
    .explain("executionStats")

// 关键指标：
// - executionTimeMillis: 执行时间（应该< 100ms）
// - totalDocsExamined: 扫描文档数（应该≈返回文档数）
// - totalKeysExamined: 扫描索引数（应该≈返回文档数）

// 查看索引使用情况
db.transactions.aggregate([
    { $indexStats: {} }
])
```

### 2. 查询优化

#### 2.1 使用投影减少数据传输
```go
// ❌ 不推荐：返回所有字段
cursor, _ := collection.Find(ctx, bson.M{"user_id": userID})

// ✅ 推荐：只返回需要的字段
opts := options.Find().SetProjection(bson.M{
    "id": 1,
    "amount": 1,
    "created_at": 1,
})
cursor, _ := collection.Find(ctx, bson.M{"user_id": userID}, opts)
```

#### 2.2 使用批量操作
```go
// ❌ 不推荐：逐个插入
for _, item := range items {
    collection.InsertOne(ctx, item)  // N次网络往返
}

// ✅ 推荐：批量插入
documents := make([]interface{}, len(items))
for i, item := range items {
    documents[i] = item
}
collection.InsertMany(ctx, documents)  // 1次网络往返
```

#### 2.3 使用聚合管道优化
```go
// 使用聚合管道进行统计
pipeline := mongo.Pipeline{
    // 匹配条件
    {{Key: "$match", Value: bson.M{"user_id": userID}}},
    // 分组统计
    {{Key: "$group", Value: bson.M{
        "_id": "$type",
        "total": bson.M{"$sum": "$amount"},
        "count": bson.M{"$sum": 1},
    }}},
    // 排序
    {{Key: "$sort", Value: bson.M{"total": -1}}},
}

cursor, _ := collection.Aggregate(ctx, pipeline)
```

### 3. 连接池优化

```go
// MongoDB连接池配置
clientOptions := options.Client().
    ApplyURI("mongodb://localhost:27017").
    SetMaxPoolSize(100).        // 最大连接数
    SetMinPoolSize(10).          // 最小连接数
    SetMaxConnIdleTime(60 * time.Second).  // 连接最大空闲时间
    SetConnectTimeout(10 * time.Second).   // 连接超时
    SetSocketTimeout(30 * time.Second)     // 操作超时

client, _ := mongo.Connect(context.Background(), clientOptions)
```

### 4. 数据模型优化

#### 4.1 嵌入vs引用
```javascript
// 场景1：一对少（1:N，N<100）→ 嵌入
{
    "_id": "user_123",
    "username": "testuser",
    "addresses": [  // 嵌入地址
        {
            "street": "Main St",
            "city": "Beijing"
        }
    ]
}

// 场景2：一对多（1:N，N>100）→ 引用
// 用户文档
{
    "_id": "user_123",
    "username": "testuser"
}

// 交易文档（单独集合）
{
    "_id": "tx_456",
    "user_id": "user_123",  // 引用用户
    "amount": 100
}
```

---

## 缓存策略

### 1. 多级缓存架构

```
请求 → 本地缓存（内存）→ Redis → 数据库
         ↓                ↓        ↓
       毫秒级            10ms     100ms
```

### 2. 本地缓存实现

```go
import (
    "github.com/patrickmn/go-cache"
    "time"
)

// 创建本地缓存
var localCache = cache.New(5*time.Minute, 10*time.Minute)

// 缓存用户信息
func GetUser(userID string) (*User, error) {
    // 1. 尝试从本地缓存获取
    if cached, found := localCache.Get("user:" + userID); found {
        return cached.(*User), nil
    }
    
    // 2. 从数据库获取
    user, err := db.FindUser(userID)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入本地缓存
    localCache.Set("user:" + userID, user, cache.DefaultExpiration)
    
    return user, nil
}
```

### 3. Redis缓存实现

```go
import (
    "github.com/go-redis/redis/v8"
    "encoding/json"
    "time"
)

var rdb = redis.NewClient(&redis.Options{
    Addr:         "localhost:6379",
    PoolSize:     100,
    MinIdleConns: 10,
})

// 缓存查询结果
func GetTransactions(userID string, page int) ([]Transaction, error) {
    cacheKey := fmt.Sprintf("transactions:%s:%d", userID, page)
    
    // 1. 尝试从Redis获取
    cached, err := rdb.Get(ctx, cacheKey).Result()
    if err == nil {
        var transactions []Transaction
        json.Unmarshal([]byte(cached), &transactions)
        return transactions, nil
    }
    
    // 2. 从数据库查询
    transactions, err := db.FindTransactions(userID, page)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入Redis
    data, _ := json.Marshal(transactions)
    rdb.Set(ctx, cacheKey, data, 5*time.Minute)
    
    return transactions, nil
}
```

### 4. 缓存策略

#### 4.1 Cache-Aside（旁路缓存）
```go
// 读操作
func Get(key string) (interface{}, error) {
    // 1. 读缓存
    val, err := cache.Get(key)
    if err == nil {
        return val, nil
    }
    
    // 2. 读数据库
    val, err = db.Get(key)
    if err != nil {
        return nil, err
    }
    
    // 3. 写缓存
    cache.Set(key, val)
    return val, nil
}

// 写操作
func Update(key string, val interface{}) error {
    // 1. 写数据库
    err := db.Update(key, val)
    if err != nil {
        return err
    }
    
    // 2. 删除缓存
    cache.Delete(key)
    return nil
}
```

#### 4.2 Read-Through（读穿透）
```go
// 缓存层自动加载数据
type CacheLoader interface {
    Load(key string) (interface{}, error)
}

type ReadThroughCache struct {
    cache  *cache.Cache
    loader CacheLoader
}

func (c *ReadThroughCache) Get(key string) (interface{}, error) {
    // 缓存命中
    if val, found := c.cache.Get(key); found {
        return val, nil
    }
    
    // 缓存未命中，自动加载
    val, err := c.loader.Load(key)
    if err != nil {
        return nil, err
    }
    
    c.cache.Set(key, val, cache.DefaultExpiration)
    return val, nil
}
```

#### 4.3 Write-Through（写穿透）
```go
// 写操作同时更新缓存和数据库
func Set(key string, val interface{}) error {
    // 1. 写缓存
    cache.Set(key, val)
    
    // 2. 写数据库
    return db.Set(key, val)
}
```

### 5. 缓存问题处理

#### 5.1 缓存穿透（查询不存在的数据）
```go
// 解决方案：缓存空值
func GetUser(userID string) (*User, error) {
    // 尝试从缓存获取
    if cached, found := cache.Get("user:" + userID); found {
        if cached == nil {  // 缓存了空值
            return nil, ErrUserNotFound
        }
        return cached.(*User), nil
    }
    
    // 从数据库查询
    user, err := db.FindUser(userID)
    if err == ErrUserNotFound {
        // 缓存空值（较短过期时间）
        cache.Set("user:" + userID, nil, 1*time.Minute)
        return nil, err
    }
    
    if err != nil {
        return nil, err
    }
    
    // 缓存正常值
    cache.Set("user:" + userID, user, 5*time.Minute)
    return user, nil
}
```

#### 5.2 缓存雪崩（大量缓存同时失效）
```go
// 解决方案：随机过期时间
func SetWithRandomExpiration(key string, val interface{}) {
    // 基础过期时间 + 随机时间（0-60秒）
    expiration := 5*time.Minute + time.Duration(rand.Intn(60))*time.Second
    cache.Set(key, val, expiration)
}
```

#### 5.3 缓存击穿（热点key失效）
```go
// 解决方案：使用互斥锁
var locks = make(map[string]*sync.Mutex)
var locksMu sync.Mutex

func GetUserWithLock(userID string) (*User, error) {
    cacheKey := "user:" + userID
    
    // 尝试从缓存获取
    if cached, found := cache.Get(cacheKey); found {
        return cached.(*User), nil
    }
    
    // 获取锁
    locksMu.Lock()
    lock, exists := locks[cacheKey]
    if !exists {
        lock = &sync.Mutex{}
        locks[cacheKey] = lock
    }
    locksMu.Unlock()
    
    // 加锁（只有一个goroutine查询数据库）
    lock.Lock()
    defer lock.Unlock()
    
    // 再次检查缓存（可能已被其他goroutine填充）
    if cached, found := cache.Get(cacheKey); found {
        return cached.(*User), nil
    }
    
    // 从数据库查询
    user, err := db.FindUser(userID)
    if err != nil {
        return nil, err
    }
    
    // 写入缓存
    cache.Set(cacheKey, user, 5*time.Minute)
    return user, nil
}
```

---

## 网络优化

### 1. HTTP/2优化

```go
// 启用HTTP/2
server := &http.Server{
    Addr:    ":8080",
    Handler: router,
    // HTTP/2会自动启用（如果使用TLS）
    TLSConfig: &tls.Config{
        NextProtos: []string{"h2", "http/1.1"},
    },
}

// 使用TLS启动（HTTP/2需要）
server.ListenAndServeTLS("cert.pem", "key.pem")
```

### 2. 连接池优化

```go
// HTTP客户端连接池
var httpClient = &http.Client{
    Timeout: 30 * time.Second,
    Transport: &http.Transport{
        MaxIdleConns:        100,              // 最大空闲连接
        MaxIdleConnsPerHost: 10,               // 每个host最大空闲连接
        MaxConnsPerHost:     50,               // 每个host最大连接
        IdleConnTimeout:     90 * time.Second, // 空闲连接超时
        DisableCompression:  false,            // 启用压缩
        DisableKeepAlives:   false,            // 启用Keep-Alive
    },
}
```

### 3. Gzip压缩

```go
import "github.com/gin-contrib/gzip"

// 启用Gzip中间件
router.Use(gzip.Gzip(gzip.DefaultCompression))

// 或使用自定义压缩级别
router.Use(gzip.Gzip(gzip.BestSpeed))  // 最快速度
router.Use(gzip.Gzip(gzip.BestCompression))  // 最高压缩率
```

### 4. 请求合并

```go
// 批量API设计
type BatchRequest struct {
    UserIDs []string `json:"user_ids"`
}

// 一次请求获取多个用户
func GetUsersBatch(c *gin.Context) {
    var req BatchRequest
    c.BindJSON(&req)
    
    users := make([]*User, 0, len(req.UserIDs))
    for _, id := range req.UserIDs {
        user, _ := getUserFromCache(id)
        users = append(users, user)
    }
    
    c.JSON(200, gin.H{"users": users})
}
```

---

## 系统优化

### 1. Go运行时优化

#### 1.1 GOMAXPROCS配置
```go
import "runtime"

func init() {
    // 设置为CPU核心数
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    // 或根据容器限制设置
    // runtime.GOMAXPROCS(4)
}
```

#### 1.2 GC调优
```bash
# 环境变量配置
export GOGC=100  # GC触发阈值（默认100，即内存增长100%触发GC）
export GOMEMLIMIT=8GiB  # 内存限制（Go 1.19+）

# 更激进的GC（减少内存占用）
export GOGC=50

# 更宽松的GC（提高性能）
export GOGC=200
```

```go
// 运行时调整GC
import "runtime/debug"

// 设置GC目标百分比
debug.SetGCPercent(50)

// 手动触发GC（不推荐频繁使用）
runtime.GC()
```

### 2. 操作系统优化

#### 2.1 文件描述符限制
```bash
# 查看当前限制
ulimit -n

# 临时提高限制
ulimit -n 65536

# 永久修改（/etc/security/limits.conf）
* soft nofile 65536
* hard nofile 65536
```

#### 2.2 网络参数优化
```bash
# /etc/sysctl.conf

# TCP连接队列大小
net.core.somaxconn = 4096
net.ipv4.tcp_max_syn_backlog = 8192

# TIME_WAIT socket重用
net.ipv4.tcp_tw_reuse = 1

# 增加本地端口范围
net.ipv4.ip_local_port_range = 10000 65000

# TCP keepalive
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 3

# 应用配置
sudo sysctl -p
```

### 3. Docker优化

```dockerfile
# 多阶段构建减小镜像体积
FROM golang:1.24-alpine AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 go build -ldflags="-w -s" -o app main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/app .

# 资源限制
ENV GOMAXPROCS=4
ENV GOMEMLIMIT=4GiB

CMD ["./app"]
```

```yaml
# docker-compose.yml 资源限制
services:
  backend:
    image: qingyu-backend
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 8G
        reservations:
          cpus: '2.0'
          memory: 4G
```

---

## 监控和分析

### 1. 性能监控指标

#### 1.1 应用层指标
```go
import "github.com/prometheus/client_golang/prometheus"

// 定义指标
var (
    requestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request latencies in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint", "status"},
    )
    
    requestCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
)

// 注册指标
func init() {
    prometheus.MustRegister(requestDuration)
    prometheus.MustRegister(requestCounter)
}

// 使用中间件记录指标
func PrometheusMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start).Seconds()
        status := fmt.Sprintf("%d", c.Writer.Status())
        
        requestDuration.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
            status,
        ).Observe(duration)
        
        requestCounter.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
            status,
        ).Inc()
    }
}
```

#### 1.2 系统指标监控
```bash
# 使用node_exporter收集系统指标
docker run -d \
  --name=node-exporter \
  -p 9100:9100 \
  prom/node-exporter

# 监控指标：
# - CPU使用率
# - 内存使用率
# - 磁盘IO
# - 网络流量
```

### 2. 日志分析

#### 2.1 结构化日志
```go
import "go.uber.org/zap"

logger, _ := zap.NewProduction()
defer logger.Sync()

// 记录性能日志
logger.Info("request processed",
    zap.String("method", "POST"),
    zap.String("path", "/api/v1/wallet/recharge"),
    zap.Duration("duration", 123*time.Millisecond),
    zap.Int("status", 200),
    zap.String("user_id", "user_123"),
)
```

#### 2.2 日志分析脚本
```bash
#!/bin/bash
# analyze_performance.sh

LOG_FILE="/var/log/qingyu/app.log"

echo "===== 性能分析报告 ====="

# 平均响应时间
echo "平均响应时间:"
jq -r 'select(.duration) | .duration' $LOG_FILE | \
  awk '{sum+=$1; count++} END {print sum/count "ms"}'

# 95分位响应时间
echo "95分位响应时间:"
jq -r 'select(.duration) | .duration' $LOG_FILE | \
  sort -n | awk 'BEGIN{count=0} {arr[count++]=$1} END{print arr[int(count*0.95)] "ms"}'

# 慢请求（>500ms）
echo "慢请求数量:"
jq -r 'select(.duration > 500) | .path' $LOG_FILE | wc -l

# 错误率
echo "错误率:"
total=$(jq -r 'select(.status) | .status' $LOG_FILE | wc -l)
errors=$(jq -r 'select(.status >= 500) | .status' $LOG_FILE | wc -l)
echo "scale=2; $errors * 100 / $total" | bc | awk '{print $1 "%"}'
```

### 3. APM工具集成

```go
// 使用OpenTelemetry
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func handleRequest(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("qingyu-backend")
    
    // 创建span
    ctx, span := tracer.Start(ctx, "handleRequest")
    defer span.End()
    
    // 数据库操作
    _, dbSpan := tracer.Start(ctx, "database.query")
    result := queryDatabase()
    dbSpan.End()
    
    // 返回响应
    c.JSON(200, result)
}
```

---

## 性能调优案例

### 案例1：API响应时间优化

**问题**：钱包交易记录查询慢（P95 > 1s）

**分析**：
```bash
# 1. 查看慢查询日志
mongosh Qingyu_writer --eval '
db.system.profile.find({millis: {$gt: 500}}).sort({ts:-1}).limit(10)
'

# 2. 分析查询计划
db.transactions.find({user_id: "user_123"})
    .sort({created_at: -1})
    .limit(10)
    .explain("executionStats")

# 发现：扫描了10000个文档，但只返回10个
```

**解决方案**：
```javascript
// 创建复合索引
db.transactions.createIndex(
    { "user_id": 1, "created_at": -1 },
    { name: "user_time_idx" }
)

// 优化后：扫描10个文档，返回10个
// 响应时间：从1000ms降到20ms
```

### 案例2：内存使用优化

**问题**：应用内存使用持续增长

**分析**：
```bash
# 1. 收集内存profile
go tool pprof http://localhost:6060/debug/pprof/heap

# 2. 查看内存分配
(pprof) top10
# 发现：大量[]byte分配在JSON序列化

# 3. 查看具体代码
(pprof) list serializeResponse
```

**解决方案**：
```go
// 使用对象池
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 4096)
    },
}

func serializeResponse(data interface{}) ([]byte, error) {
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf[:0])  // 归还时重置长度
    
    // 使用buf进行序列化
    return json.Marshal(data)
}

// 内存使用：从2GB降到500MB
```

### 案例3：数据库连接池优化

**问题**：高并发时数据库连接耗尽

**分析**：
```bash
# 监控连接池
db.serverStatus().connections
# 发现：current接近available（连接池满）
```

**解决方案**：
```go
// 调整连接池配置
clientOptions := options.Client().
    ApplyURI("mongodb://localhost:27017").
    SetMaxPoolSize(200).        // 从100提高到200
    SetMinPoolSize(20).          // 从10提高到20
    SetMaxConnIdleTime(30 * time.Second)  // 从60s降到30s

// 同时优化查询，减少连接占用时间
// 使用context.WithTimeout限制查询时间
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

result := collection.Find(ctx, filter)

// QPS：从2000提高到5000
```

### 案例4：缓存命中率优化

**问题**：缓存命中率低（< 60%）

**分析**：
```bash
# Redis监控
redis-cli info stats | grep keyspace_hits
redis-cli info stats | grep keyspace_misses

# 计算命中率
hit_rate = hits / (hits + misses) * 100%
# 结果：55%
```

**解决方案**：
```go
// 1. 延长热点数据缓存时间
func cacheUser(user *User) {
    // 根据访问频率动态调整过期时间
    expiration := 5 * time.Minute
    if user.IsVIP {
        expiration = 30 * time.Minute  // VIP用户缓存更久
    }
    cache.Set("user:" + user.ID, user, expiration)
}

// 2. 预热热点数据
func warmupCache() {
    // 应用启动时预加载热点数据
    hotUsers := getHotUsers()  // 获取活跃用户
    for _, user := range hotUsers {
        cacheUser(user)
    }
}

// 3. 使用多级缓存
// 本地缓存（L1）→ Redis（L2）→ 数据库

// 缓存命中率：从55%提高到85%
```

---

## 性能优化检查清单

### 应用层
- [ ] 避免不必要的内存分配
- [ ] 使用对象池复用对象
- [ ] 减少反射使用
- [ ] 并发goroutine数量限制
- [ ] 预分配slice/map容量
- [ ] 使用高效的序列化库
- [ ] 预定义常用error

### 数据库层
- [ ] 创建必要的索引
- [ ] 使用投影减少数据传输
- [ ] 批量操作代替逐个操作
- [ ] 优化查询条件
- [ ] 使用聚合管道
- [ ] 配置合适的连接池
- [ ] 数据模型优化（嵌入vs引用）

### 缓存层
- [ ] 实现多级缓存
- [ ] 选择合适的缓存策略
- [ ] 处理缓存穿透/雪崩/击穿
- [ ] 设置合理的过期时间
- [ ] 监控缓存命中率

### 网络层
- [ ] 启用HTTP/2
- [ ] 配置连接池
- [ ] 启用Gzip压缩
- [ ] 批量API设计
- [ ] CDN加速（静态资源）

### 系统层
- [ ] GOMAXPROCS配置
- [ ] GC调优
- [ ] 文件描述符限制
- [ ] 网络参数优化
- [ ] Docker资源限制

### 监控层
- [ ] 应用性能指标（Prometheus）
- [ ] 系统资源监控
- [ ] 日志分析
- [ ] APM工具集成
- [ ] 告警配置

---

## 附录

### A. 性能测试脚本

```bash
#!/bin/bash
# performance_test.sh

API_URL="http://localhost:8080"
TOKEN="your_token_here"

echo "===== 性能测试报告 ====="

# 1. 简单查询测试
echo "1. 余额查询QPS:"
wrk -t4 -c50 -d10s \
  -H "Authorization: Bearer $TOKEN" \
  "$API_URL/api/v1/shared/wallet/balance" | \
  grep "Requests/sec"

# 2. 写操作测试
echo "2. 充值操作QPS:"
wrk -t4 -c50 -d10s \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -s post.lua \
  "$API_URL/api/v1/shared/wallet/recharge"

# 3. 复杂查询测试
echo "3. 交易记录查询QPS:"
wrk -t4 -c50 -d10s \
  -H "Authorization: Bearer $TOKEN" \
  "$API_URL/api/v1/shared/wallet/transactions"

echo "===== 测试完成 ====="
```

### B. 性能优化工具

| 工具 | 用途 | 说明 |
|------|------|------|
| wrk | HTTP压测 | 高性能HTTP基准测试工具 |
| ab | HTTP压测 | Apache Bench |
| vegeta | HTTP压测 | Go编写的HTTP负载测试工具 |
| pprof | Go性能分析 | CPU/内存profiling |
| Prometheus | 监控 | 指标收集和查询 |
| Grafana | 可视化 | 监控数据可视化 |
| Jaeger | 链路追踪 | 分布式追踪系统 |

### C. 参考资料

- **Go性能优化**：https://github.com/golang/go/wiki/Performance
- **MongoDB性能最佳实践**：https://docs.mongodb.com/manual/administration/performance/
- **Prometheus监控**：https://prometheus.io/docs/
- **OpenTelemetry**：https://opentelemetry.io/docs/

---

**文档版本**: v1.0  
**最后更新**: 2025-10-04  
**维护团队**: 青羽性能优化团队

