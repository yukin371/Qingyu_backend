# 青羽共享服务部署指南

## 文档概述

本文档提供青羽后端共享服务的完整部署指南，涵盖从开发环境到生产环境的全流程部署。

**版本**: v1.0  
**适用范围**: 青羽共享服务 API v1.0  
**文档更新**: 2025-10-04

---

## 目录

- [环境要求](#环境要求)
- [快速部署](#快速部署)
- [详细部署步骤](#详细部署步骤)
- [配置说明](#配置说明)
- [Docker部署](#docker部署)
- [生产环境部署](#生产环境部署)
- [监控和日志](#监控和日志)
- [故障排查](#故障排查)
- [维护和升级](#维护和升级)

---

## 环境要求

### 1. 系统要求

#### 开发环境
| 组件 | 最低版本 | 推荐版本 |
|------|---------|---------|
| 操作系统 | Linux/macOS/Windows | Linux (Ubuntu 20.04+) |
| CPU | 2核 | 4核+ |
| 内存 | 4GB | 8GB+ |
| 磁盘 | 20GB | 50GB+ |

#### 生产环境
| 组件 | 最低配置 | 推荐配置 |
|------|---------|---------|
| 操作系统 | Linux | Ubuntu 22.04 LTS / CentOS 8+ |
| CPU | 4核 | 8核+ |
| 内存 | 8GB | 16GB+ |
| 磁盘 | 50GB SSD | 100GB+ SSD |
| 网络 | 100Mbps | 1Gbps+ |

### 2. 软件依赖

#### 核心依赖
```bash
# Go语言环境
Go 1.24.1 或更高版本

# 数据库
MongoDB 5.0+

# 缓存（可选，生产环境推荐）
Redis 6.0+

# 版本控制
Git 2.0+
```

#### 开发工具（可选）
```bash
# 代码检查
golangci-lint 1.50+

# 包管理
go mod (内置于Go)

# 构建工具
Make (GNU Make 4.0+)
```

### 3. 网络要求

#### 端口配置
| 端口 | 服务 | 说明 |
|------|------|------|
| 8080 | API服务 | HTTP API端口 |
| 27017 | MongoDB | 数据库端口 |
| 6379 | Redis | 缓存端口（可选）|

#### 防火墙规则
```bash
# 允许API端口
sudo ufw allow 8080/tcp

# MongoDB（仅内网）
sudo ufw allow from 10.0.0.0/8 to any port 27017

# Redis（仅内网）
sudo ufw allow from 10.0.0.0/8 to any port 6379
```

---

## 快速部署

### 1. 一键部署脚本（开发环境）

```bash
#!/bin/bash
# quick_deploy.sh - 快速部署脚本

echo "===== 青羽后端快速部署 ====="

# 1. 检查Go环境
if ! command -v go &> /dev/null; then
    echo "错误：未安装Go，请先安装Go 1.24.1+"
    exit 1
fi

# 2. 克隆项目
git clone https://github.com/yukin371/Qingyu_backend.git
cd Qingyu_backend

# 3. 安装依赖
echo "安装依赖..."
go mod download

# 4. 配置文件
echo "创建配置文件..."
cp config.yaml.example config.yaml
# 根据需要修改config.yaml

# 5. 启动MongoDB（Docker方式）
echo "启动MongoDB..."
docker run -d \
  --name qingyu-mongodb \
  -p 27017:27017 \
  -e MONGO_INITDB_DATABASE=Qingyu_writer \
  mongo:5.0

# 6. 编译项目
echo "编译项目..."
go build -o qingyu-backend main.go

# 7. 运行服务
echo "启动服务..."
./qingyu-backend

echo "===== 部署完成 ====="
echo "API服务运行在: http://localhost:8080"
```

### 2. 验证部署

```bash
# 检查服务状态
curl http://localhost:8080/health

# 预期响应
{
  "status": "ok",
  "timestamp": "2025-10-04T12:00:00Z"
}
```

---

## 详细部署步骤

### 步骤1：安装Go环境

#### Linux (Ubuntu/Debian)
```bash
# 下载Go
wget https://go.dev/dl/go1.24.1.linux-amd64.tar.gz

# 解压
sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.24.1.linux-amd64.tar.gz

# 配置环境变量
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
echo 'export GOPATH=$HOME/go' >> ~/.bashrc
source ~/.bashrc

# 验证安装
go version
```

#### macOS
```bash
# 使用Homebrew安装
brew install go@1.24

# 或下载安装包
# https://go.dev/dl/go1.24.1.darwin-amd64.pkg
```

#### Windows
```powershell
# 下载安装包并安装
# https://go.dev/dl/go1.24.1.windows-amd64.msi

# 验证安装
go version
```

### 步骤2：安装MongoDB

#### Linux (Ubuntu)
```bash
# 导入MongoDB公钥
wget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add -

# 添加MongoDB源
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list

# 更新并安装
sudo apt-get update
sudo apt-get install -y mongodb-org

# 启动MongoDB
sudo systemctl start mongod
sudo systemctl enable mongod

# 验证
sudo systemctl status mongod
```

#### macOS
```bash
# 使用Homebrew
brew tap mongodb/brew
brew install mongodb-community@5.0

# 启动MongoDB
brew services start mongodb-community@5.0
```

#### Docker方式（推荐用于开发）
```bash
# 运行MongoDB容器
docker run -d \
  --name qingyu-mongodb \
  -p 27017:27017 \
  -v qingyu-mongo-data:/data/db \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=password \
  -e MONGO_INITDB_DATABASE=Qingyu_writer \
  mongo:5.0

# 验证
docker ps | grep qingyu-mongodb
```

### 步骤3：安装Redis（可选）

#### Linux (Ubuntu)
```bash
# 安装Redis
sudo apt-get update
sudo apt-get install -y redis-server

# 启动Redis
sudo systemctl start redis-server
sudo systemctl enable redis-server

# 验证
redis-cli ping
# 预期输出: PONG
```

#### Docker方式
```bash
# 运行Redis容器
docker run -d \
  --name qingyu-redis \
  -p 6379:6379 \
  redis:6-alpine

# 验证
docker exec -it qingyu-redis redis-cli ping
```

### 步骤4：克隆项目

```bash
# 克隆仓库
git clone https://github.com/yukin371/Qingyu_backend.git

# 进入项目目录
cd Qingyu_backend

# 查看当前分支
git branch

# 切换到稳定分支（如果需要）
git checkout main
```

### 步骤5：安装项目依赖

```bash
# 下载Go模块依赖
go mod download

# 验证依赖
go mod verify

# 查看依赖树（可选）
go mod graph
```

### 步骤6：配置应用

#### 创建配置文件
```bash
# 复制配置模板
cp config.yaml.example config.yaml

# 或创建新配置
cat > config.yaml << 'EOF'
# 青羽写作系统配置文件

# 数据库配置
database:
  uri: "mongodb://localhost:27017"
  name: "Qingyu_writer"
  connect_timeout: 10s
  max_pool_size: 100
  min_pool_size: 10
  max_conn_idle_time: 60s
  retry_writes: true
  retry_reads: true

# 服务器配置
server:
  port: "8080"
  mode: "release"  # debug or release

# JWT配置
jwt:
  secret: "your_strong_secret_key_here"  # 请修改为强密钥
  expiration_hours: 24

# AI配置
ai:
  api_key: ""
  base_url: "https://generativelanguage.googleapis.com/v1beta"
  model: "gemini-1.5-flash"
  max_tokens: 2000
  temperature: 0.7
EOF
```

#### 环境变量配置（可选）
```bash
# 创建.env文件
cat > .env << 'EOF'
# 数据库
MONGO_URI=mongodb://localhost:27017
MONGO_DB_NAME=Qingyu_writer

# JWT
JWT_SECRET=your_strong_secret_key_here
JWT_EXPIRATION_HOURS=24

# 服务器
SERVER_PORT=8080
SERVER_MODE=release

# 日志
LOG_LEVEL=info
LOG_FILE=./logs/qingyu.log
EOF
```

### 步骤7：初始化数据库

```bash
# 创建数据库初始化脚本
cat > scripts/init_db.sh << 'EOF'
#!/bin/bash

echo "初始化数据库..."

# 连接MongoDB并创建索引
mongosh Qingyu_writer --eval '
// 用户集合索引
db.users.createIndex({ "username": 1 }, { unique: true })
db.users.createIndex({ "email": 1 }, { unique: true })

// 钱包集合索引
db.wallets.createIndex({ "user_id": 1 }, { unique: true })
db.wallets.createIndex({ "status": 1 })

// 交易集合索引
db.transactions.createIndex({ "user_id": 1, "created_at": -1 })
db.transactions.createIndex({ "type": 1, "created_at": -1 })

// 提现集合索引
db.withdraw_requests.createIndex({ "user_id": 1, "created_at": -1 })
db.withdraw_requests.createIndex({ "status": 1, "created_at": -1 })

// 文件集合索引
db.files.createIndex({ "owner_id": 1, "created_at": -1 })
db.files.createIndex({ "category": 1 })

print("索引创建完成！")
'

echo "数据库初始化完成！"
EOF

# 执行初始化
chmod +x scripts/init_db.sh
./scripts/init_db.sh
```

### 步骤8：编译项目

```bash
# 开发环境编译
go build -o qingyu-backend main.go

# 生产环境编译（优化）
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
  -ldflags="-w -s" \
  -o qingyu-backend \
  main.go

# 查看编译结果
ls -lh qingyu-backend
```

### 步骤9：运行服务

#### 开发模式
```bash
# 直接运行
go run main.go

# 或使用编译后的二进制
./qingyu-backend

# 后台运行
nohup ./qingyu-backend > logs/app.log 2>&1 &
```

#### 使用systemd（生产环境推荐）
```bash
# 创建systemd服务文件
sudo cat > /etc/systemd/system/qingyu-backend.service << 'EOF'
[Unit]
Description=Qingyu Backend Service
After=network.target mongod.service

[Service]
Type=simple
User=qingyu
WorkingDirectory=/opt/qingyu-backend
ExecStart=/opt/qingyu-backend/qingyu-backend
Restart=on-failure
RestartSec=10s

# 环境变量
Environment="GIN_MODE=release"

# 资源限制
LimitNOFILE=65536
LimitNPROC=32768

# 日志
StandardOutput=append:/var/log/qingyu/app.log
StandardError=append:/var/log/qingyu/error.log

[Install]
WantedBy=multi-user.target
EOF

# 重载systemd
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start qingyu-backend

# 设置开机自启
sudo systemctl enable qingyu-backend

# 查看状态
sudo systemctl status qingyu-backend
```

### 步骤10：验证部署

```bash
# 健康检查
curl http://localhost:8080/health

# 注册测试用户
curl -X POST http://localhost:8080/api/v1/shared/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "Test123456"
  }'

# 登录测试
curl -X POST http://localhost:8080/api/v1/shared/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "Test123456"
  }'
```

---

## 配置说明

### 1. 数据库配置

#### MongoDB连接字符串
```yaml
database:
  # 基本连接
  uri: "mongodb://localhost:27017"
  
  # 带认证的连接
  uri: "mongodb://username:password@localhost:27017"
  
  # 副本集连接
  uri: "mongodb://host1:27017,host2:27017,host3:27017/?replicaSet=myReplicaSet"
  
  # MongoDB Atlas（云服务）
  uri: "mongodb+srv://username:password@cluster.mongodb.net"
  
  # 数据库名称
  name: "Qingyu_writer"
  
  # 连接池配置
  max_pool_size: 100      # 最大连接数
  min_pool_size: 10       # 最小连接数
  max_conn_idle_time: 60s # 连接最大空闲时间
  connect_timeout: 10s    # 连接超时
```

### 2. 服务器配置

```yaml
server:
  # 监听端口
  port: "8080"
  
  # 运行模式
  mode: "release"  # debug, release, test
  
  # 读超时（可选）
  read_timeout: 60s
  
  # 写超时（可选）
  write_timeout: 60s
  
  # 最大请求体大小（可选）
  max_multipart_memory: 10MB
```

### 3. JWT配置

```yaml
jwt:
  # 密钥（生产环境必须修改）
  secret: "your_strong_secret_key_here"
  
  # Token过期时间（小时）
  expiration_hours: 24
  
  # 刷新Token过期时间（可选）
  refresh_expiration_hours: 168  # 7天
  
  # 发行者（可选）
  issuer: "qingyu-backend"
```

**生成强密钥**：
```bash
# 使用openssl生成随机密钥
openssl rand -base64 32

# 或使用Go代码生成
go run -c 'import "crypto/rand"; import "encoding/base64"; b := make([]byte, 32); rand.Read(b); println(base64.StdEncoding.EncodeToString(b))'
```

### 4. 日志配置（代码中配置）

```go
// 日志级别：debug, info, warn, error
LOG_LEVEL=info

// 日志文件路径
LOG_FILE=./logs/qingyu.log

// 日志格式：json, console
LOG_FORMAT=json

// 日志轮转
LOG_MAX_SIZE=100      # MB
LOG_MAX_BACKUPS=10    # 保留文件数
LOG_MAX_AGE=30        # 天
LOG_COMPRESS=true     # 是否压缩
```

### 5. 性能调优配置

```yaml
# Go运行时配置（环境变量）
GOMAXPROCS=4          # CPU核心数
GOGC=100              # GC触发阈值百分比

# 数据库连接池
database:
  max_pool_size: 100
  min_pool_size: 10

# 限流配置
rate_limit:
  enabled: true
  requests_per_minute: 60
```

---

## Docker部署

### 1. 创建Dockerfile

```dockerfile
# Dockerfile
FROM golang:1.24.1-alpine AS builder

# 安装必要工具
RUN apk add --no-cache git make

# 设置工作目录
WORKDIR /app

# 复制go mod文件
COPY go.mod go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY . .

# 编译
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s" \
    -o qingyu-backend \
    main.go

# 最终镜像
FROM alpine:latest

# 安装必要工具
RUN apk --no-cache add ca-certificates tzdata

# 设置时区
ENV TZ=Asia/Shanghai

# 创建用户
RUN addgroup -g 1000 qingyu && \
    adduser -D -u 1000 -G qingyu qingyu

# 工作目录
WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /app/qingyu-backend .
COPY --from=builder /app/config.yaml .

# 创建日志目录
RUN mkdir -p /app/logs && chown -R qingyu:qingyu /app

# 切换用户
USER qingyu

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# 启动命令
CMD ["./qingyu-backend"]
```

### 2. 创建docker-compose.yml

```yaml
# docker-compose.yml
version: '3.8'

services:
  # MongoDB数据库
  mongodb:
    image: mongo:5.0
    container_name: qingyu-mongodb
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: Qingyu_writer
    ports:
      - "27017:27017"
    volumes:
      - mongodb-data:/data/db
      - ./scripts/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    networks:
      - qingyu-network
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis缓存
  redis:
    image: redis:6-alpine
    container_name: qingyu-redis
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - qingyu-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # 后端服务
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: qingyu-backend
    restart: always
    ports:
      - "8080:8080"
    environment:
      - GIN_MODE=release
      - MONGO_URI=mongodb://admin:password@mongodb:27017
      - MONGO_DB_NAME=Qingyu_writer
      - JWT_SECRET=your_strong_secret_key_here
    volumes:
      - ./logs:/app/logs
      - ./config.yaml:/app/config.yaml:ro
    depends_on:
      mongodb:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - qingyu-network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  mongodb-data:
    driver: local
  redis-data:
    driver: local

networks:
  qingyu-network:
    driver: bridge
```

### 3. Docker部署命令

```bash
# 构建镜像
docker-compose build

# 启动所有服务
docker-compose up -d

# 查看日志
docker-compose logs -f backend

# 查看服务状态
docker-compose ps

# 停止服务
docker-compose down

# 停止并删除数据
docker-compose down -v
```

### 4. Docker常用命令

```bash
# 进入容器
docker exec -it qingyu-backend sh

# 查看日志
docker logs -f qingyu-backend

# 重启服务
docker restart qingyu-backend

# 查看资源使用
docker stats qingyu-backend

# 导出镜像
docker save -o qingyu-backend.tar qingyu-backend:latest

# 导入镜像
docker load -i qingyu-backend.tar
```

---

## 生产环境部署

### 1. 架构设计

```
            ┌─────────────┐
            │  负载均衡   │
            │   (Nginx)   │
            └──────┬──────┘
                   │
        ┌──────────┼──────────┐
        │          │          │
    ┌───▼───┐  ┌──▼───┐  ┌───▼───┐
    │ 后端1  │  │ 后端2 │  │ 后端3  │
    │:8080  │  │:8080 │  │:8080  │
    └───┬───┘  └──┬───┘  └───┬───┘
        │         │          │
        └─────────┼──────────┘
                  │
        ┌─────────▼─────────┐
        │    MongoDB副本集   │
        │  Primary/Secondary │
        └──────────┬─────────┘
                   │
        ┌──────────▼─────────┐
        │   Redis主从/集群   │
        └────────────────────┘
```

### 2. Nginx配置

```nginx
# /etc/nginx/sites-available/qingyu-backend

upstream qingyu_backend {
    # 负载均衡策略
    least_conn;  # 最少连接数
    
    server 10.0.1.10:8080 weight=3 max_fails=3 fail_timeout=30s;
    server 10.0.1.11:8080 weight=3 max_fails=3 fail_timeout=30s;
    server 10.0.1.12:8080 weight=2 max_fails=3 fail_timeout=30s backup;
    
    # 保持连接
    keepalive 32;
}

server {
    listen 80;
    listen [::]:80;
    server_name api.qingyu.com;
    
    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name api.qingyu.com;
    
    # SSL证书
    ssl_certificate /etc/nginx/ssl/qingyu.crt;
    ssl_certificate_key /etc/nginx/ssl/qingyu.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # 日志
    access_log /var/log/nginx/qingyu-access.log;
    error_log /var/log/nginx/qingyu-error.log;
    
    # 限流
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    limit_req zone=api_limit burst=20 nodelay;
    
    # 请求体大小限制
    client_max_body_size 10M;
    
    # 超时设置
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
    
    # API路由
    location /api/ {
        proxy_pass http://qingyu_backend;
        
        # 代理头
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 保持连接
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        
        # 缓存（可选）
        # proxy_cache api_cache;
        # proxy_cache_valid 200 5m;
    }
    
    # 健康检查
    location /health {
        proxy_pass http://qingyu_backend;
        access_log off;
    }
    
    # 静态文件（如果有）
    location /static/ {
        alias /var/www/qingyu/static/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }
}
```

### 3. MongoDB副本集配置

```bash
# 初始化副本集
mongosh --host primary-host:27017 --eval '
rs.initiate({
  _id: "qingyu-rs",
  members: [
    { _id: 0, host: "primary-host:27017", priority: 2 },
    { _id: 1, host: "secondary-host-1:27017", priority: 1 },
    { _id: 2, host: "secondary-host-2:27017", priority: 1 }
  ]
})
'

# 查看副本集状态
mongosh --host primary-host:27017 --eval 'rs.status()'

# 应用配置更新
database:
  uri: "mongodb://primary-host:27017,secondary-host-1:27017,secondary-host-2:27017/?replicaSet=qingyu-rs"
  name: "Qingyu_writer"
```

### 4. 安全加固

#### 4.1 应用层安全
```bash
# 1. 修改默认端口
server:
  port: "8888"  # 使用非标准端口

# 2. 启用HTTPS（通过Nginx）
# 见上面Nginx配置

# 3. 限制请求来源
# 使用防火墙规则

# 4. 定期更新依赖
go get -u ./...
go mod tidy
```

#### 4.2 数据库安全
```bash
# 1. 启用认证
mongosh admin --eval '
db.createUser({
  user: "qingyu_admin",
  pwd: "strong_password_here",
  roles: [{role: "readWrite", db: "Qingyu_writer"}]
})
'

# 2. 绑定到内网IP
# /etc/mongod.conf
net:
  bindIp: 127.0.0.1,10.0.1.10

# 3. 启用加密连接
security:
  authorization: enabled
```

#### 4.3 系统安全
```bash
# 1. 创建专用用户
sudo useradd -r -s /bin/false qingyu

# 2. 设置文件权限
sudo chown -R qingyu:qingyu /opt/qingyu-backend
sudo chmod 750 /opt/qingyu-backend
sudo chmod 640 /opt/qingyu-backend/config.yaml

# 3. 配置SELinux/AppArmor
# 根据实际情况配置
```

### 5. 备份策略

#### 数据库备份
```bash
#!/bin/bash
# backup_mongodb.sh

BACKUP_DIR="/backup/mongodb"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="qingyu_backup_$DATE"

# 创建备份
mongodump \
  --uri="mongodb://username:password@localhost:27017/Qingyu_writer" \
  --out="$BACKUP_DIR/$BACKUP_FILE" \
  --gzip

# 保留最近7天的备份
find $BACKUP_DIR -type d -mtime +7 -exec rm -rf {} \;

# 上传到云存储（可选）
# aws s3 sync $BACKUP_DIR/$BACKUP_FILE s3://qingyu-backups/
```

#### 配置文件备份
```bash
#!/bin/bash
# backup_config.sh

BACKUP_DIR="/backup/config"
DATE=$(date +%Y%m%d)

# 备份配置文件
tar -czf "$BACKUP_DIR/config_$DATE.tar.gz" \
  /opt/qingyu-backend/config.yaml \
  /etc/systemd/system/qingyu-backend.service \
  /etc/nginx/sites-available/qingyu-backend
```

### 6. 监控配置（见下一章节）

---

## 监控和日志

### 1. 应用监控

#### 健康检查端点
```go
// 在main.go中添加健康检查
router.GET("/health", func(c *gin.Context) {
    c.JSON(200, gin.H{
        "status": "ok",
        "timestamp": time.Now().Format(time.RFC3339),
        "version": "1.0.0",
    })
})

// 详细健康检查
router.GET("/health/detailed", func(c *gin.Context) {
    // 检查数据库连接
    dbHealth := checkDatabaseHealth()
    // 检查Redis连接
    redisHealth := checkRedisHealth()
    
    c.JSON(200, gin.H{
        "status": "ok",
        "timestamp": time.Now().Format(time.RFC3339),
        "components": gin.H{
            "database": dbHealth,
            "redis": redisHealth,
        },
    })
})
```

#### 监控脚本
```bash
#!/bin/bash
# monitor.sh - 简单的监控脚本

API_URL="http://localhost:8080/health"
LOG_FILE="/var/log/qingyu/monitor.log"

while true; do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_URL)
    TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
    
    if [ "$STATUS" -eq 200 ]; then
        echo "[$TIMESTAMP] OK - API is healthy (HTTP $STATUS)" >> $LOG_FILE
    else
        echo "[$TIMESTAMP] ERROR - API is down (HTTP $STATUS)" >> $LOG_FILE
        # 发送告警（可选）
        # send_alert "API is down"
    fi
    
    sleep 60
done
```

### 2. 日志管理

#### 结构化日志配置
```go
// 使用zap logger
logger, _ := zap.NewProduction()
defer logger.Sync()

// 记录请求
logger.Info("API request",
    zap.String("method", "POST"),
    zap.String("path", "/api/v1/auth/login"),
    zap.String("remote_addr", "192.168.1.1"),
    zap.Duration("duration", 100*time.Millisecond),
)
```

#### 日志轮转配置
```bash
# /etc/logrotate.d/qingyu-backend

/var/log/qingyu/*.log {
    daily
    rotate 30
    compress
    delaycompress
    notifempty
    missingok
    create 0640 qingyu qingyu
    sharedscripts
    postrotate
        systemctl reload qingyu-backend > /dev/null 2>&1 || true
    endscript
}
```

### 3. 性能监控

#### CPU和内存监控
```bash
# 使用top查看实时状态
top -p $(pgrep qingyu-backend)

# 或使用htop
htop -p $(pgrep qingyu-backend)

# 持续监控脚本
#!/bin/bash
while true; do
    ps -p $(pgrep qingyu-backend) -o pid,pcpu,pmem,cmd
    sleep 5
done
```

#### 请求统计
```bash
# 分析Nginx访问日志
# 请求量统计
awk '{print $4}' /var/log/nginx/qingyu-access.log | cut -d: -f2 | sort | uniq -c

# 响应时间分析
awk '{print $NF}' /var/log/nginx/qingyu-access.log | sort -n | awk '{arr[NR]=$1} END {print "95th:", arr[int(NR*0.95)]}'

# 状态码统计
awk '{print $9}' /var/log/nginx/qingyu-access.log | sort | uniq -c | sort -rn
```

### 4. 告警配置

#### 简单告警脚本
```bash
#!/bin/bash
# alert.sh

SLACK_WEBHOOK="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
EMAIL="ops@qingyu.com"

send_alert() {
    MESSAGE=$1
    
    # 发送到Slack
    curl -X POST $SLACK_WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"$MESSAGE\"}"
    
    # 发送邮件
    echo "$MESSAGE" | mail -s "Qingyu Backend Alert" $EMAIL
}

# 使用示例
# send_alert "API is down!"
```

---

## 故障排查

### 1. 常见问题

#### 问题1：服务无法启动
```bash
# 检查端口占用
sudo lsof -i :8080

# 检查配置文件
./qingyu-backend --validate-config

# 查看详细日志
./qingyu-backend --log-level=debug

# 检查权限
ls -l qingyu-backend
chmod +x qingyu-backend
```

#### 问题2：数据库连接失败
```bash
# 测试MongoDB连接
mongosh --host localhost:27017

# 检查MongoDB状态
sudo systemctl status mongod

# 查看MongoDB日志
sudo tail -f /var/log/mongodb/mongod.log

# 测试网络连通性
telnet localhost 27017
nc -zv localhost 27017
```

#### 问题3：内存占用过高
```bash
# 查看内存使用
ps aux | grep qingyu-backend

# 生成内存profiling
curl http://localhost:8080/debug/pprof/heap > heap.prof
go tool pprof -http=:6060 heap.prof

# 调整GOGC参数
GOGC=50 ./qingyu-backend  # 更频繁的GC
```

#### 问题4：请求超时
```bash
# 检查网络延迟
ping mongodb-host

# 检查慢查询
mongosh Qingyu_writer --eval 'db.setProfilingLevel(2)'
mongosh Qingyu_writer --eval 'db.system.profile.find().sort({ts:-1}).limit(10)'

# 增加超时时间
database:
  connect_timeout: 30s
```

### 2. 调试技巧

#### 启用debug模式
```bash
# 临时启用
GIN_MODE=debug ./qingyu-backend

# 或修改配置
server:
  mode: "debug"
```

#### 使用pprof性能分析
```go
// 在main.go中添加
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```

```bash
# 访问pprof
http://localhost:6060/debug/pprof/

# CPU profiling
go tool pprof http://localhost:6060/debug/pprof/profile

# 内存profiling
go tool pprof http://localhost:6060/debug/pprof/heap
```

### 3. 日志分析

```bash
# 查找错误日志
grep -i error /var/log/qingyu/app.log | tail -100

# 统计错误类型
grep -i error /var/log/qingyu/app.log | awk '{print $5}' | sort | uniq -c

# 查看特定用户的请求
grep "user_id=user_123" /var/log/qingyu/app.log

# 实时监控日志
tail -f /var/log/qingyu/app.log | grep -i error
```

---

## 维护和升级

### 1. 版本升级流程

```bash
# 1. 备份当前版本
cd /opt/qingyu-backend
tar -czf backup_$(date +%Y%m%d).tar.gz .

# 2. 停止服务
sudo systemctl stop qingyu-backend

# 3. 拉取新代码
git fetch origin
git checkout v2.0.0

# 4. 更新依赖
go mod download

# 5. 编译新版本
go build -o qingyu-backend-new main.go

# 6. 数据库迁移（如果需要）
./scripts/migrate.sh

# 7. 替换二进制文件
mv qingyu-backend qingyu-backend.old
mv qingyu-backend-new qingyu-backend

# 8. 启动服务
sudo systemctl start qingyu-backend

# 9. 验证
curl http://localhost:8080/health

# 10. 如果失败，回滚
# sudo systemctl stop qingyu-backend
# mv qingyu-backend.old qingyu-backend
# sudo systemctl start qingyu-backend
```

### 2. 滚动更新（多实例环境）

```bash
#!/bin/bash
# rolling_update.sh

SERVERS=("10.0.1.10" "10.0.1.11" "10.0.1.12")
BINARY="/opt/qingyu-backend/qingyu-backend"

for server in "${SERVERS[@]}"; do
    echo "Updating $server..."
    
    # 1. 从负载均衡移除
    # nginx_remove_upstream $server
    
    # 2. 停止服务
    ssh $server "sudo systemctl stop qingyu-backend"
    
    # 3. 更新二进制
    scp qingyu-backend $server:$BINARY
    
    # 4. 启动服务
    ssh $server "sudo systemctl start qingyu-backend"
    
    # 5. 健康检查
    for i in {1..10}; do
        if curl -s http://$server:8080/health > /dev/null; then
            echo "$server is healthy"
            break
        fi
        sleep 3
    done
    
    # 6. 添加回负载均衡
    # nginx_add_upstream $server
    
    echo "$server updated successfully"
    sleep 10
done
```

### 3. 数据库维护

```bash
# 索引优化
mongosh Qingyu_writer --eval 'db.getCollectionNames().forEach(function(col) {
    print("Indexes for " + col);
    printjson(db[col].getIndexes());
})'

# 清理过期数据
mongosh Qingyu_writer --eval '
db.transactions.deleteMany({
    created_at: {$lt: new Date(Date.now() - 365*24*60*60*1000)}
})
'

# 压缩数据
mongosh admin --eval 'db.runCommand({compact: "transactions"})'
```

### 4. 定期任务

```bash
# 创建crontab任务
crontab -e

# 添加以下内容：

# 每天凌晨2点备份数据库
0 2 * * * /opt/qingyu-backend/scripts/backup_mongodb.sh

# 每周日凌晨3点清理日志
0 3 * * 0 /opt/qingyu-backend/scripts/cleanup_logs.sh

# 每小时检查服务状态
0 * * * * /opt/qingyu-backend/scripts/health_check.sh

# 每天凌晨4点重启服务（可选）
0 4 * * * sudo systemctl restart qingyu-backend
```

---

## 附录

### A. 环境检查清单

```bash
#!/bin/bash
# check_env.sh - 环境检查脚本

echo "===== 环境检查 ====="

# 检查Go版本
echo -n "Go版本: "
go version || echo "未安装"

# 检查MongoDB
echo -n "MongoDB状态: "
mongosh --eval "db.version()" --quiet || echo "未运行"

# 检查Redis
echo -n "Redis状态: "
redis-cli ping || echo "未运行"

# 检查端口
echo -n "端口8080: "
lsof -i :8080 > /dev/null && echo "已占用" || echo "可用"

# 检查磁盘空间
echo "磁盘空间:"
df -h | grep -E "/$|/var|/opt"

# 检查内存
echo "内存使用:"
free -h

echo "===== 检查完成 ====="
```

### B. 快速命令参考

```bash
# 服务管理
sudo systemctl start qingyu-backend    # 启动
sudo systemctl stop qingyu-backend     # 停止
sudo systemctl restart qingyu-backend  # 重启
sudo systemctl status qingyu-backend   # 状态

# 日志查看
sudo journalctl -u qingyu-backend -f   # 实时日志
sudo journalctl -u qingyu-backend -n 100  # 最近100行

# 数据库操作
mongosh Qingyu_writer                  # 连接数据库
mongodump --db=Qingyu_writer           # 备份
mongorestore --db=Qingyu_writer        # 恢复

# 性能分析
curl http://localhost:6060/debug/pprof/  # pprof首页
top -p $(pgrep qingyu-backend)         # CPU/内存
```

### C. 常用配置模板

已在前面章节提供。

### D. 联系支持

- **技术文档**: https://docs.qingyu.com
- **问题反馈**: ops@qingyu.com
- **GitHub Issues**: https://github.com/yukin371/Qingyu_backend/issues

---

**文档版本**: v1.0  
**最后更新**: 2025-10-04  
**维护团队**: 青羽运维团队

