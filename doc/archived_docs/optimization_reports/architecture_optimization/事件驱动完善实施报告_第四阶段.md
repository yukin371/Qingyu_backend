# 事件驱动架构完善 - 阶段四完成报告

**日期**: 2025-01-07
**状态**: ✅ 阶段四已完成
**实施人**: AI Assistant

## 概述

根据《事件驱动架构完善计划》，本次实施完成了**阶段四：错误处理和重试机制**，为事件驱动系统提供了完整的错误恢复能力。

## 完成的工作

### ✅ 4.1 重试策略接口（`service/events/retry_policy.go`）

**实现的重试策略**：

#### 1. ExponentialBackoffPolicy - 指数退避策略
```go
type ExponentialBackoffPolicy struct {
    MaxRetries    int           // 最大重试次数
    InitialDelay  time.Duration // 初始延迟
    MaxDelay      time.Duration // 最大延迟
    Multiplier    float64       // 延迟倍数（默认2.0）
    Randomization float64       // 随机化因子（默认0.1，避免惊群效应）
}
```

**特点**：
- 每次重试延迟按指数增长（1s → 2s → 4s → 8s...）
- 支持最大延迟限制
- 支持10%的随机化（避免多个客户端同时重试）

#### 2. FixedDelayPolicy - 固定延迟策略
```go
type FixedDelayPolicy struct {
    MaxRetries int
    Delay      time.Duration
}
```

**特点**：
- 每次重试使用固定延迟
- 简单可靠

#### 3. LinearBackoffPolicy - 线性退避策略
```go
type LinearBackoffPolicy struct {
    MaxRetries   int
    InitialDelay time.Duration
    Increment    time.Duration
    MaxDelay     time.Duration
}
```

**特点**：
- 每次重试延迟线性增长（1s → 2s → 3s → 4s...）
- 支持最大延迟限制

**核心接口**：
```go
type RetryPolicy interface {
    ShouldRetry(err error, attempt int) bool
    GetDelay(attempt int) time.Duration
    MaxRetries() int
}
```

### ✅ 4.2 重试队列（`service/events/retry_queue.go`）

**核心接口**：
```go
type RetryQueue interface {
    Add(ctx context.Context, event base.Event, handlerName string, err error, attempt int) error
    Get(ctx context.Context, limit int64) ([]*RetryItem, error)
    MarkSuccess(ctx context.Context, itemID string) error
    MarkFailed(ctx context.Context, itemID string) error
    UpdateAttempt(ctx context.Context, itemID string, nextRetryTime time.Time, attempt int) error
    Count(ctx context.Context) (int64, error)
    Cleanup(ctx context.Context, before time.Time) (int64, error)
    Health(ctx context.Context) error
}
```

**MongoDB 实现**：

**数据结构**：
```go
type RetryItem struct {
    ID             string    // 重试项ID
    EventType      string    // 事件类型
    EventData      interface{} // 事件数据
    EventSource    string    // 事件来源
    EventTimestamp time.Time // 事件时间戳
    HandlerName    string    // 处理器名称
    Error          string    // 错误信息
    Attempt        int       // 当前重试次数
    MaxRetries     int       // 最大重试次数
    NextRetry      time.Time // 下次重试时间
    CreatedAt      time.Time // 创建时间
    UpdatedAt      time.Time // 更新时间
}
```

**索引设计**：
```javascript
// 下次重试时间索引（用于查询待重试项）
{ next_retry: 1 }

// TTL 索引（自动删除超过7天的项）
{ created_at: 1 } (expireAfterSeconds: 7*24*3600)

// 处理器名称索引
{ handler_name: 1 }

// 复合索引
{ next_retry: 1, attempt: 1 }
```

**集成死信队列**：
- 当重试次数达到上限时，自动将项移入死信队列
- 通过构造函数注入 `DeadLetterQueue` 依赖

### ✅ 4.3 死信队列（`service/events/dead_letter_queue.go`）

**核心接口**：
```go
type DeadLetterQueue interface {
    Add(ctx context.Context, item *RetryItem) error
    List(ctx context.Context, limit, offset int64) ([]*DeadLetterItem, error)
    Get(ctx context.Context, id string) (*DeadLetterItem, error)
    Reprocess(ctx context.Context, id string) error
    Delete(ctx context.Context, id string) error
    Count(ctx context.Context) (int64, error)
    Cleanup(ctx context.Context, before time.Time) (int64, error)
    Health(ctx context.Context) error
}
```

**数据结构**：
```go
type DeadLetterItem struct {
    ID             string                 // 死信项ID
    EventType      string                 // 事件类型
    EventData      interface{}            // 事件数据
    EventSource    string                 // 事件来源
    EventTimestamp time.Time              // 事件时间戳
    HandlerName    string                 // 处理器名称
    Error          string                 // 错误信息
    Attempt        int                    // 重试次数
    Reason         string                 // 失败原因
    Processed      bool                   // 是否已处理
    CreatedAt      time.Time              // 创建时间
    ProcessedAt    *time.Time             // 处理时间
    Metadata       map[string]interface{} // 元数据
}
```

**索引设计**：
```javascript
// 创建时间索引
{ created_at: -1 }

// 处理状态索引
{ processed: 1 }

// 事件类型索引
{ event_type: 1 }

// TTL 索引（保留30天）
{ created_at: 1 } (expireAfterSeconds: 30*24*3600)
```

**功能**：
- 保存最终失败的事件
- 支持手动重新处理
- 自动清理30天前的项

### ✅ 4.4 后台重试处理器（`service/events/retry_worker.go`）

**核心功能**：
```go
type RetryWorker struct {
    retryQueue      RetryQueue
    deadLetterQueue DeadLetterQueue
    retryPolicy     RetryPolicy
    eventBus        base.EventBus
    checkInterval   time.Duration  // 检查间隔（默认10秒）
    batchSize       int64          // 批量大小（默认100）
}
```

**工作流程**：
```
1. 定期检查（默认10秒）
      ↓
2. 获取需要重试的项（最多100个）
      ↓
3. 逐个处理重试项
      ↓
4. 重建事件并重新发布
      ↓
5. 成功 → 从重试队列删除
      ↓
6. 失败 → 判断是否继续重试
      ↓
7. 达到上限 → 移入死信队列
      ↓
8. 未达上限 → 更新下次重试时间
```

**特点**：
- 优雅的启动和停止机制
- 批量处理优化
- 完整的日志记录
- 自动清理机制

## 架构流程

### 完整的错误处理流程

```
┌─────────────┐
│ Event Bus   │
└──────┬──────┘
       │
       ├─► Handler 成功 ✓
       │
       └─► Handler 失败 ✗
              │
              ▼
       ┌──────────────┐
       │ 判断是否重试  │
       └──────┬───────┘
              │
         ┌────┴────┐
         │         │
      应重试    不应重试
         │         │
         ▼         ▼
   ┌─────────┐ ┌──────────────┐
   │重试队列  │ │  死信队列    │
   └────┬────┘ └──────────────┘
        │
        ▼
   ┌──────────────┐
   │后台重试处理器 │
   └──────┬───────┘
          │
     ┌────┴────┐
     │         │
   成功      失败
     │         │
     ▼         ▼
  删除项   移入死信队列
```

## 使用示例

### 示例1：创建重试系统

```go
// 1. 创建死信队列
dlq := events.NewMongoDeadLetterQueue(database)

// 2. 创建重试队列（注入死信队列）
retryQueue := events.NewMongoRetryQueue(database, dlq)

// 3. 创建重试策略
retryPolicy := events.NewExponentialBackoffPolicy(
    3,                      // 最大重试3次
    1*time.Second,          // 初始延迟1秒
    60*time.Second,         // 最大延迟60秒
)

// 4. 创建后台重试处理器
worker := events.NewRetryWorker(
    retryQueue,
    dlq,
    retryPolicy,
    eventBus,
    10*time.Second,         // 每10秒检查一次
    100,                    // 每次处理100个
)

// 5. 启动后台处理器
worker.Start(context.Background())

// 6. 优雅停止（应用关闭时）
worker.Stop()
```

### 示例2：创建带重试的处理器

```go
// 创建原始处理器
originalHandler := events.NewSocialStatisticsHandler()

// 包装为可重试的处理器
retryableHandler := events.NewRetryableEventHandler(
    originalHandler,
    retryQueue,
    retryPolicy,
    3,  // 最大重试3次
)

// 订阅事件（使用带重试的处理器）
eventBus.Subscribe("like.added", retryableHandler)
```

### 示例3：手动处理死信队列

```go
// 列出死信队列中的项
items, _ := dlq.List(ctx, 100, 0)

for _, item := range items {
    fmt.Printf("死信项: %s, 类型: %s, 错误: %s\n",
        item.ID, item.EventType, item.Error)
}

// 重新处理某个项
err := dlq.Reprocess(ctx, itemID)
if err != nil {
    log.Printf("重新处理失败: %v", err)
}

// 删除某个项
err = dlq.Delete(ctx, itemID)
```

## 数据库集合

### retry_queue 集合

```javascript
{
  _id: "retry_xxx",
  event_type: "like.added",
  event_data: { ... },
  event_source: "SocialService",
  event_timestamp: ISODate("2025-01-07T10:00:00Z"),
  handler_name: "SocialStatisticsHandler",
  error: "connection timeout",
  attempt: 1,
  max_retries: 3,
  next_retry: ISODate("2025-01-07T10:00:02Z"),
  created_at: ISODate("2025-01-07T10:00:00Z"),
  updated_at: ISODate("2025-01-07T10:00:01Z")
}
```

### dead_letter_queue 集合

```javascript
{
  _id: "dlq_xxx",
  event_type: "comment.created",
  event_data: { ... },
  event_source: "SocialService",
  event_timestamp: ISODate("2025-01-07T10:00:00Z"),
  handler_name: "CommentNotificationHandler",
  error: "email service unavailable",
  attempt: 3,
  reason: "重试 3 次后仍然失败",
  processed: false,
  created_at: ISODate("2025-01-07T10:00:05Z"),
  metadata: { }
}
```

## 配置参数

### 重试策略配置

| 参数 | 默认值 | 说明 |
|------|--------|------|
| MaxRetries | 3 | 最大重试次数 |
| InitialDelay | 1秒 | 初始延迟 |
| MaxDelay | 60秒 | 最大延迟 |
| Multiplier | 2.0 | 延迟倍数 |
| Randomization | 0.1 | 随机化因子（10%） |

### 后台处理器配置

| 参数 | 默认值 | 说明 |
|------|--------|------|
| checkInterval | 10秒 | 检查重试队列的间隔 |
| batchSize | 100 | 每次处理的数量 |

### TTL 配置

| 集合 | TTL | 说明 |
|------|-----|------|
| retry_queue | 7天 | 自动删除超过7天的重试项 |
| dead_letter_queue | 30天 | 自动删除超过30天的死信项 |

## 新增文件清单

| 文件路径 | 说明 | 代码行数 |
|---------|------|---------|
| `service/events/retry_policy.go` | 重试策略接口和实现 | ~150行 |
| `service/events/retry_queue.go` | MongoDB重试队列实现 | ~220行 |
| `service/events/dead_letter_queue.go` | MongoDB死信队列实现 | ~200行 |
| `service/events/retry_worker.go` | 后台重试处理器 | ~200行 |
| **总计** | **4个新文件** | **~770行** |

## 性能指标

### 预期性能

| 指标 | 目标值 | 备注 |
|------|--------|------|
| 重试队列写入延迟 | < 5ms | 单个事件 |
| 死信队列写入延迟 | < 5ms | 单个事件 |
| 后台处理吞吐 | > 100 events/s | 批量处理 |
| 内存占用 | < 50MB | 后台处理器 |

### 优化措施

- ✅ 批量查询优化
- ✅ 索引优化（next_retry）
- ✅ TTL 自动清理
- ✅ 连接池复用

## 监控指标

### 建议监控的指标

1. **重试队列大小**
   ```go
   count, _ := retryQueue.Count(ctx)
   ```

2. **死信队列大小**
   ```go
   count, _ := deadLetterQueue.Count(ctx)
   ```

3. **重试成功率**
   ```go
   // 成功移除 / 总添加数
   ```

4. **平均重试次数**
   ```go
   // 总重试次数 / 成功处理的事件数
   ```

## 下一步工作

### 短期（1周内）

1. **创建单元测试**
   - 测试重试策略
   - 测试重试队列
   - 测试死信队列
   - 测试后台处理器

2. **集成到现有系统**
   - 将现有的事件处理器包装为可重试的
   - 在应用启动时启动后台重试处理器

### 中期（2-4周）

1. **阶段五：监控和可观测性**
   - 添加 Prometheus 指标
   - 集成 OpenTelemetry 追踪
   - 完善日志记录

2. **性能优化**
   - 性能测试
   - 瓶颈分析
   - 优化调整

### 长期（1-2个月）

1. **阶段六：事件版本管理**
2. **阶段七：分布式事件总线**

## 总结

阶段四的完成，为事件驱动系统提供了完整的错误恢复能力：

✅ **3种重试策略**：指数退避、固定延迟、线性退避
✅ **完整的重试队列**：MongoDB 实现，支持持久化和查询
✅ **死信队列**：保存最终失败的事件，支持手动重处理
✅ **后台处理器**：自动重试失败的事件
✅ **优雅的降级**：失败不影响主流程

这些改进确保了：
- **事件处理的可靠性**：失败自动重试
- **系统的健壮性**：错误隔离
- **可维护性**：死信队列便于排查问题
- **可观测性**：完整的日志记录

---

**报告生成时间**: 2025-01-07
**验证人**: AI Assistant
**状态**: ✅ 阶段四完成，可进入下一阶段
