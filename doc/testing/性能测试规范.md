# 性能测试规范

**版本**: 1.0  
**更新日期**: 2025-10-17  
**维护者**: 青羽后端团队

---

## 📖 概述

本文档定义青羽后端性能测试的标准和最佳实践，包括基准测试、压力测试、负载测试的规范。

---

## 🎯 性能测试目标

### 关键指标

| 指标 | 目标值 | 警告值 | 关键值 |
|------|-------|-------|-------|
| **API响应时间** | < 100ms | < 500ms | < 1s |
| **数据库查询** | < 50ms | < 200ms | < 500ms |
| **并发用户数** | 1000+ | 500+ | 100+ |
| **吞吐量** | 1000 req/s | 500 req/s | 100 req/s |
| **错误率** | < 0.1% | < 1% | < 5% |
| **CPU使用率** | < 70% | < 85% | < 95% |
| **内存使用率** | < 70% | < 85% | < 95% |

---

## 1. Go基准测试

### 1.1 基本基准测试

**位置**: `test/performance/xxx_benchmark_test.go`

```go
// test/performance/bookstore_benchmark_test.go
package performance_test

import (
    "context"
    "testing"
    
    "Qingyu_backend/service/bookstore"
    "Qingyu_backend/test/fixtures"
)

func BenchmarkBookstoreService_ListBooks(b *testing.B) {
    // Setup
    service := setupBookstoreService()
    ctx := context.Background()
    
    // Reset timer to exclude setup time
    b.ResetTimer()
    
    // Run benchmark
    for i := 0; i < b.N; i++ {
        _, err := service.ListBooks(ctx, 20, 0)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkBookstoreService_GetBookByID(b *testing.B) {
    service := setupBookstoreService()
    ctx := context.Background()
    bookID := "test-book-id"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := service.GetBookByID(ctx, bookID)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

### 1.2 并行基准测试

```go
func BenchmarkBookstoreService_ListBooks_Parallel(b *testing.B) {
    service := setupBookstoreService()
    
    b.RunParallel(func(pb *testing.PB) {
        ctx := context.Background()
        for pb.Next() {
            _, err := service.ListBooks(ctx, 20, 0)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}
```

### 1.3 子基准测试

```go
func BenchmarkBookstoreService_Search(b *testing.B) {
    service := setupBookstoreService()
    ctx := context.Background()
    
    benchmarks := []struct {
        name     string
        keyword  string
        pageSize int
    }{
        {"Small", "test", 10},
        {"Medium", "test", 50},
        {"Large", "test", 100},
    }
    
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                service.SearchBooks(ctx, bm.keyword, bm.pageSize, 0)
            }
        })
    }
}
```

### 1.4 运行基准测试

```bash
# 运行所有基准测试
go test -bench=. ./test/performance/...

# 运行特定基准测试
go test -bench=BenchmarkBookstore ./test/performance/...

# 运行多次取平均值
go test -bench=. -benchtime=10s ./test/performance/...

# 指定迭代次数
go test -bench=. -benchtime=100x ./test/performance/...

# 显示内存分配
go test -bench=. -benchmem ./test/performance/...

# 生成CPU分析
go test -bench=. -cpuprofile=cpu.prof ./test/performance/...

# 生成内存分析
go test -bench=. -memprofile=mem.prof ./test/performance/...
```

---

## 2. 性能分析（Profiling）

### 2.1 CPU分析

```bash
# 生成CPU profile
go test -bench=BenchmarkBookstore -cpuprofile=cpu.prof ./test/performance/

# 分析profile
go tool pprof cpu.prof

# 常用命令
(pprof) top          # 查看最耗CPU的函数
(pprof) list <func>  # 查看函数详细信息
(pprof) web          # 生成可视化图表（需要graphviz）
(pprof) pdf          # 导出PDF报告
```

### 2.2 内存分析

```bash
# 生成内存profile
go test -bench=. -memprofile=mem.prof ./test/performance/

# 分析内存分配
go tool pprof -alloc_space mem.prof

# 分析内存使用
go tool pprof -inuse_space mem.prof
```

### 2.3 Trace分析

```bash
# 生成trace
go test -bench=. -trace=trace.out ./test/performance/

# 查看trace
go tool trace trace.out
```

### 2.4 实时性能监控

```go
// 在服务中启用pprof
import _ "net/http/pprof"

func main() {
    // 启动pprof服务器
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 启动主服务
    // ...
}
```

访问性能数据：
```bash
# CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile

# Heap profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

---

## 3. 压力测试

### 3.1 使用wrk

```bash
# 安装wrk
# Ubuntu/Debian
sudo apt-get install wrk

# macOS
brew install wrk

# 基本压力测试
wrk -t12 -c400 -d30s http://localhost:8080/api/v1/books

# 参数说明
# -t12: 12个线程
# -c400: 400个并发连接
# -d30s: 持续30秒

# 使用Lua脚本
wrk -t12 -c400 -d30s -s post.lua http://localhost:8080/api/v1/books
```

**Lua脚本示例** (`post.lua`):
```lua
wrk.method = "POST"
wrk.body   = '{"title":"Test Book","author":"Test Author"}'
wrk.headers["Content-Type"] = "application/json"
wrk.headers["Authorization"] = "Bearer your-token"
```

### 3.2 使用Apache Bench (ab)

```bash
# 安装ab
# Ubuntu/Debian
sudo apt-get install apache2-utils

# macOS (自带)

# 基本测试
ab -n 10000 -c 100 http://localhost:8080/api/v1/books

# POST请求
ab -n 1000 -c 100 -p post.json -T application/json http://localhost:8080/api/v1/books

# 带认证
ab -n 1000 -c 100 -H "Authorization: Bearer token" http://localhost:8080/api/v1/books
```

### 3.3 使用Hey

```bash
# 安装hey
go install github.com/rakyll/hey@latest

# 基本测试
hey -n 10000 -c 100 http://localhost:8080/api/v1/books

# POST请求
hey -n 1000 -c 100 -m POST -H "Content-Type: application/json" \
    -d '{"title":"Test"}' http://localhost:8080/api/v1/books

# 生成报告
hey -n 10000 -c 100 -o csv http://localhost:8080/api/v1/books > results.csv
```

---

## 4. 负载测试

### 4.1 使用k6

```bash
# 安装k6
# Ubuntu/Debian
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6

# macOS
brew install k6
```

**k6测试脚本**:
```javascript
// test/performance/load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
    stages: [
        { duration: '2m', target: 100 },  // Ramp up to 100 users
        { duration: '5m', target: 100 },  // Stay at 100 users
        { duration: '2m', target: 200 },  // Ramp up to 200 users
        { duration: '5m', target: 200 },  // Stay at 200 users
        { duration: '2m', target: 0 },    // Ramp down to 0 users
    ],
    thresholds: {
        http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
        http_req_failed: ['rate<0.01'],   // Error rate must be less than 1%
    },
};

export default function () {
    // 测试书店列表API
    let response = http.get('http://localhost:8080/api/v1/books');
    
    check(response, {
        'status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
    });
    
    sleep(1);
    
    // 测试书籍详情API
    response = http.get('http://localhost:8080/api/v1/books/1');
    
    check(response, {
        'status is 200': (r) => r.status === 200,
    });
    
    sleep(1);
}
```

运行k6测试：
```bash
# 运行负载测试
k6 run test/performance/load_test.js

# 生成HTML报告
k6 run --out json=results.json test/performance/load_test.js
```

---

## 5. 数据库性能测试

### 5.1 MongoDB基准测试

```go
func BenchmarkMongoDB_Insert(b *testing.B) {
    collection := getTestCollection()
    ctx := context.Background()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        doc := bson.M{
            "title":  fmt.Sprintf("Book %d", i),
            "author": "Test Author",
            "price":  99.99,
        }
        _, err := collection.InsertOne(ctx, doc)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkMongoDB_Find(b *testing.B) {
    collection := getTestCollection()
    ctx := context.Background()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        var result bson.M
        err := collection.FindOne(ctx, bson.M{"title": "Test Book"}).Decode(&result)
        if err != nil && err != mongo.ErrNoDocuments {
            b.Fatal(err)
        }
    }
}

func BenchmarkMongoDB_Aggregate(b *testing.B) {
    collection := getTestCollection()
    ctx := context.Background()
    
    pipeline := mongo.Pipeline{
        bson.D{{"$match", bson.D{{"price", bson.D{{"$gte", 50}}}}}},
        bson.D{{"$group", bson.D{
            {"_id", "$author"},
            {"count", bson.D{{"$sum", 1}}},
        }}},
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        cursor, err := collection.Aggregate(ctx, pipeline)
        if err != nil {
            b.Fatal(err)
        }
        cursor.Close(ctx)
    }
}
```

---

## 6. 性能优化建议

### 6.1 代码层面

✅ **使用连接池**:
```go
// MongoDB连接池配置
clientOptions := options.Client().
    ApplyURI(mongoURI).
    SetMaxPoolSize(100).
    SetMinPoolSize(10)
```

✅ **使用缓存**:
```go
// Redis缓存
func (s *BookService) GetBook(id string) (*Book, error) {
    // 先从缓存获取
    book, err := s.cache.Get(id)
    if err == nil {
        return book, nil
    }
    
    // 缓存未命中，从数据库获取
    book, err = s.repo.GetByID(id)
    if err != nil {
        return nil, err
    }
    
    // 写入缓存
    s.cache.Set(id, book, 5*time.Minute)
    return book, nil
}
```

✅ **批量操作**:
```go
// 批量插入而非循环插入
docs := make([]interface{}, 1000)
for i := 0; i < 1000; i++ {
    docs[i] = Book{Title: fmt.Sprintf("Book %d", i)}
}
collection.InsertMany(ctx, docs)
```

### 6.2 数据库层面

✅ **创建索引**:
```go
// 为常用查询字段创建索引
indexModel := mongo.IndexModel{
    Keys: bson.D{
        {"title", 1},
        {"author", 1},
    },
}
collection.Indexes().CreateOne(ctx, indexModel)
```

✅ **查询优化**:
```go
// 只查询需要的字段
opts := options.Find().SetProjection(bson.D{
    {"title", 1},
    {"author", 1},
    {"price", 1},
})
cursor, _ := collection.Find(ctx, filter, opts)
```

### 6.3 架构层面

✅ **水平扩展**: 添加更多服务实例  
✅ **负载均衡**: 使用Nginx/HAProxy  
✅ **数据库分片**: MongoDB Sharding  
✅ **读写分离**: 主从复制  
✅ **CDN加速**: 静态资源使用CDN  

---

## 7. 性能监控

### 7.1 Prometheus + Grafana

```go
// 集成Prometheus metrics
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
)

// 在路由中启用metrics
r.GET("/metrics", gin.WrapH(promhttp.Handler()))
```

---

## 8. 性能测试报告模板

### 8.1 测试环境

```markdown
## 测试环境

- **服务器配置**: 4核8GB
- **数据库**: MongoDB 5.0
- **Go版本**: 1.21
- **并发数**: 100/500/1000
- **测试时间**: 2024-10-17
```

### 8.2 测试结果

```markdown
## 测试结果

### API响应时间

| API | 平均响应时间 | P95 | P99 | QPS |
|-----|------------|-----|-----|-----|
| GET /books | 45ms | 120ms | 250ms | 1200 |
| GET /books/:id | 20ms | 50ms | 100ms | 2500 |
| POST /books | 80ms | 200ms | 400ms | 800 |

### 并发测试

| 并发数 | 成功率 | 平均响应时间 | 错误率 |
|-------|-------|------------|--------|
| 100 | 100% | 50ms | 0% |
| 500 | 99.8% | 180ms | 0.2% |
| 1000 | 98.5% | 450ms | 1.5% |
```

---

## 📚 相关资源

- [测试组织规范](./测试组织规范.md)
- [API测试指南](./API测试指南.md)
- [测试最佳实践](./测试最佳实践.md)
- [Go性能优化文档](https://golang.org/doc/diagnostics.html)

---

**最后更新**: 2025-10-17  
**维护者**: 青羽后端团队

