# 测试最佳实践

**版本**: 1.0  
**更新日期**: 2025-10-17  
**维护者**: 青羽后端团队

---

## 📖 概述

本文档汇总青羽后端测试的最佳实践、常见陷阱和解决方案，帮助团队编写高质量的测试代码。

---

## 1. 测试金字塔原则

```
        /\
       /  \      E2E Tests (少量)
      /────\     
     /      \    Integration Tests (适量)
    /────────\   
   /          \  Unit Tests (大量)
  /────────────\ 
```

### 推荐比例

- **单元测试**: 70%
- **集成测试**: 20%
- **端到端测试**: 10%

### 原因

- 单元测试快速、稳定、易调试
- 集成测试覆盖组件交互
- 端到端测试验证用户流程

---

## 2. 测试命名规范

### ✅ 好的命名

```go
// 模式：TestServiceName_MethodName_Scenario_ExpectedResult
func TestUserService_Register_WithValidData_ReturnsUser(t *testing.T) {}
func TestUserService_Register_WithDuplicateEmail_ReturnsError(t *testing.T) {}
func TestUserService_Login_WithInvalidPassword_ReturnsAuthError(t *testing.T) {}

// 集成测试
func TestUserRepository_Create_Integration(t *testing.T) {}

// 端到端测试
func TestE2E_UserRegistrationAndLogin(t *testing.T) {}

// 基准测试
func BenchmarkUserService_Register(b *testing.B) {}
```

### ❌ 不好的命名

```go
func TestRegister(t *testing.T) {}         // 太模糊
func Test1(t *testing.T) {}               // 无意义
func TestUserServiceRegister(t *testing.T) {} // 缺少场景描述
```

---

## 3. AAA测试模式

### Arrange - Act - Assert

```go
func TestUserService_Register_Success(t *testing.T) {
    // ===== Arrange (准备) =====
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)
    
    req := &RegisterRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
    
    mockRepo.On("Create", mock.Anything).Return(nil)
    
    // ===== Act (执行) =====
    resp, err := service.Register(context.Background(), req)
    
    // ===== Assert (断言) =====
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    assert.Equal(t, "testuser", resp.Username)
    mockRepo.AssertExpectations(t)
}
```

---

## 4. Mock使用最佳实践

### 4.1 使用接口

✅ **DO**:
```go
// 定义接口
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByEmail(ctx context.Context, email string) (*User, error)
}

// Service依赖接口
type UserService struct {
    repo UserRepository  // 接口类型
}

// 测试时Mock接口
type MockUserRepository struct {
    mock.Mock
}
```

❌ **DON'T**:
```go
// Service直接依赖具体实现
type UserService struct {
    repo *MongoUserRepository  // 具体类型，难以测试
}
```

### 4.2 精确的Mock期望

✅ **DO**:
```go
// 精确匹配参数
mockRepo.On("Create", mock.MatchedBy(func(user *User) bool {
    return user.Email == "test@example.com" &&
           user.Username == "testuser"
})).Return(nil)

// 验证调用次数
mockRepo.AssertNumberOfCalls(t, "Create", 1)
```

❌ **DON'T**:
```go
// 过于宽松的匹配
mockRepo.On("Create", mock.Anything).Return(nil)  // 任何参数都接受
```

### 4.3 清理Mock

```go
func TestUserService_MultipleTests(t *testing.T) {
    tests := []struct {
        name string
        test func(*testing.T)
    }{
        {"Test1", testCase1},
        {"Test2", testCase2},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 每个子测试创建新的Mock
            mockRepo := new(MockUserRepository)
            defer mockRepo.AssertExpectations(t)
            
            tt.test(t)
        })
    }
}
```

---

## 5. 表驱动测试

### ✅ 好的表驱动测试

```go
func TestUserService_Register_ValidationErrors(t *testing.T) {
    tests := []struct {
        name        string
        request     *RegisterRequest
        expectError string
    }{
        {
            name: "空用户名",
            request: &RegisterRequest{
                Username: "",
                Email:    "test@example.com",
                Password: "password123",
            },
            expectError: "用户名不能为空",
        },
        {
            name: "无效邮箱格式",
            request: &RegisterRequest{
                Username: "testuser",
                Email:    "invalid-email",
                Password: "password123",
            },
            expectError: "邮箱格式无效",
        },
        {
            name: "密码太短",
            request: &RegisterRequest{
                Username: "testuser",
                Email:    "test@example.com",
                Password: "123",
            },
            expectError: "密码至少6位",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Arrange
            service := NewUserService(nil)
            
            // Act
            _, err := service.Register(context.Background(), tt.request)
            
            // Assert
            assert.Error(t, err)
            assert.Contains(t, err.Error(), tt.expectError)
        })
    }
}
```

### 优势

- ✅ 减少代码重复
- ✅ 易于添加新测试用例
- ✅ 测试用例清晰可读
- ✅ 失败时准确定位问题

---

## 6. 测试隔离

### 6.1 数据隔离

✅ **DO**:
```go
func TestUserRepository_Create(t *testing.T) {
    // 每个测试使用独立的数据
    user := &User{
        ID:       uuid.New(),  // 唯一ID
        Username: "testuser_" + uuid.New().String(),  // 唯一用户名
        Email:    fmt.Sprintf("test_%s@example.com", uuid.New().String()),
    }
    
    err := repo.Create(context.Background(), user)
    assert.NoError(t, err)
    
    // 测试结束后清理
    defer repo.Delete(context.Background(), user.ID)
}
```

❌ **DON'T**:
```go
// 多个测试共享相同数据
var globalUser = &User{
    Username: "testuser",  // 固定值会冲突
    Email:    "test@example.com",
}
```

### 6.2 状态隔离

✅ **DO**:
```go
func TestService_Method(t *testing.T) {
    // 每个测试创建新实例
    service := NewService()
    // 测试逻辑
}
```

❌ **DON'T**:
```go
// 全局变量会导致测试相互影响
var globalService = NewService()

func TestService_Method1(t *testing.T) {
    globalService.DoSomething()  // 修改全局状态
}

func TestService_Method2(t *testing.T) {
    // 依赖Method1的状态，不稳定
}
```

---

## 7. 测试数据管理

### 7.1 使用工厂模式

```go
// test/fixtures/user_factory.go
type UserFactory struct {
    counter int
}

func NewUserFactory() *UserFactory {
    return &UserFactory{counter: 0}
}

func (f *UserFactory) Create() *User {
    f.counter++
    return &User{
        ID:       uuid.New(),
        Username: fmt.Sprintf("user%d", f.counter),
        Email:    fmt.Sprintf("user%d@example.com", f.counter),
        Status:   "active",
    }
}

func (f *UserFactory) CreateAdmin() *User {
    user := f.Create()
    user.Role = "admin"
    return user
}

func (f *UserFactory) CreateBatch(count int) []*User {
    users := make([]*User, count)
    for i := 0; i < count; i++ {
        users[i] = f.Create()
    }
    return users
}
```

### 7.2 使用Builder模式

```go
type UserBuilder struct {
    user *User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{
            ID:     uuid.New(),
            Status: "active",
        },
    }
}

func (b *UserBuilder) WithUsername(username string) *UserBuilder {
    b.user.Username = username
    return b
}

func (b *UserBuilder) WithEmail(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) AsAdmin() *UserBuilder {
    b.user.Role = "admin"
    return b
}

func (b *UserBuilder) Build() *User {
    return b.user
}

// 使用
user := NewUserBuilder().
    WithUsername("testuser").
    WithEmail("test@example.com").
    AsAdmin().
    Build()
```

---

## 8. 错误处理测试

### 8.1 测试所有错误路径

```go
func TestUserService_Register(t *testing.T) {
    tests := []struct {
        name        string
        setup       func(*MockUserRepository)
        expectError bool
        errorMsg    string
    }{
        {
            name: "成功注册",
            setup: func(m *MockUserRepository) {
                m.On("ExistsByEmail", mock.Anything).Return(false, nil)
                m.On("Create", mock.Anything).Return(nil)
            },
            expectError: false,
        },
        {
            name: "邮箱已存在",
            setup: func(m *MockUserRepository) {
                m.On("ExistsByEmail", mock.Anything).Return(true, nil)
            },
            expectError: true,
            errorMsg:    "邮箱已被注册",
        },
        {
            name: "数据库错误",
            setup: func(m *MockUserRepository) {
                m.On("ExistsByEmail", mock.Anything).Return(false, errors.New("db error"))
            },
            expectError: true,
            errorMsg:    "db error",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo := new(MockUserRepository)
            tt.setup(mockRepo)
            
            service := NewUserService(mockRepo)
            _, err := service.Register(context.Background(), &RegisterRequest{})
            
            if tt.expectError {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.errorMsg)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

---

## 9. 并发测试

### 9.1 测试竞态条件

```go
func TestCache_ConcurrentAccess(t *testing.T) {
    cache := NewCache()
    
    // 并发写入
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(key int) {
            defer wg.Done()
            cache.Set(fmt.Sprintf("key%d", key), key)
        }(i)
    }
    wg.Wait()
    
    // 并发读取
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(key int) {
            defer wg.Done()
            val, _ := cache.Get(fmt.Sprintf("key%d", key))
            assert.Equal(t, key, val)
        }(i)
    }
    wg.Wait()
}
```

### 9.2 使用竞态检测器

```bash
# 运行测试时启用竞态检测
go test -race ./...

# 在CI/CD中强制使用
go test -race -short ./...
```

---

## 10. 测试覆盖率

### 10.1 目标覆盖率

| 组件 | 最低覆盖率 | 推荐覆盖率 |
|------|----------|----------|
| 核心业务逻辑 | 80% | 90%+ |
| Service层 | 75% | 85% |
| Repository层 | 70% | 85% |
| API层 | 60% | 75% |
| 工具函数 | 80% | 95% |

### 10.2 生成覆盖率报告

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率
go tool cover -func=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html

# 只显示未覆盖的代码
go tool cover -html=coverage.out | grep -v "100.0%"
```

### 10.3 覆盖率不是一切

⚠️ **警告**：
- 100%覆盖率 ≠ 没有bug
- 关注测试质量，不只是数量
- 测试边界条件和错误路径

---

## 11. 常见陷阱和解决方案

### 11.1 时间依赖

❌ **问题**:
```go
func TestCreateUser(t *testing.T) {
    user := CreateUser()
    
    // 这个测试会在跨午夜时失败
    assert.Equal(t, time.Now().Day(), user.CreatedAt.Day())
}
```

✅ **解决**:
```go
// 使用时间注入
type Clock interface {
    Now() time.Time
}

type UserService struct {
    clock Clock
}

// 测试时使用固定时钟
type FixedClock struct {
    fixedTime time.Time
}

func (c *FixedClock) Now() time.Time {
    return c.fixedTime
}
```

### 11.2 随机性

❌ **问题**:
```go
func TestRandomFunction(t *testing.T) {
    result := GenerateRandomString(10)
    assert.Equal(t, "randomtext", result)  // 不稳定
}
```

✅ **解决**:
```go
// 注入随机源
func GenerateRandomString(length int, rand *rand.Rand) string {
    // 使用注入的随机源
}

// 测试时使用固定种子
func TestRandomFunction(t *testing.T) {
    rand := rand.New(rand.NewSource(42))  // 固定种子
    result := GenerateRandomString(10, rand)
    assert.Equal(t, "expectedval", result)
}
```

### 11.3 外部依赖

❌ **问题**:
```go
func TestSendEmail(t *testing.T) {
    // 依赖真实的邮件服务，不稳定
    err := SendEmail("test@example.com", "subject", "body")
    assert.NoError(t, err)
}
```

✅ **解决**:
```go
// 使用Mock
type EmailService interface {
    Send(to, subject, body string) error
}

type MockEmailService struct {
    mock.Mock
}

func (m *MockEmailService) Send(to, subject, body string) error {
    args := m.Called(to, subject, body)
    return args.Error(0)
}
```

---

## 12. CI/CD集成

### 12.1 GitHub Actions示例

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.21
      
      - name: Cache dependencies
        uses: actions/cache@v2
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
      
      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
      
      - name: Upload coverage
        uses: codecov/codecov-action@v2
        with:
          files: ./coverage.out
          flags: unittests
```

---

## 13. 测试文档

### 13.1 文档化复杂测试

```go
// TestUserService_Register_ComplexScenario 测试用户注册的复杂场景
//
// 测试步骤：
// 1. 验证邮箱唯一性检查
// 2. 密码加密
// 3. 创建用户记录
// 4. 发送欢迎邮件
// 5. 创建初始钱包
//
// 预期结果：
// - 用户成功创建
// - 邮件已发送
// - 钱包已初始化为0余额
func TestUserService_Register_ComplexScenario(t *testing.T) {
    // 测试实现
}
```

---

## 14. 测试维护

### 14.1 定期清理

- ✅ 删除过时的测试
- ✅ 重构重复的测试代码
- ✅ 更新测试以反映业务变化
- ✅ 修复flaky测试（不稳定测试）

### 14.2 测试审查清单

- [ ] 测试命名清晰描述场景
- [ ] 使用AAA模式组织代码
- [ ] Mock设置和验证正确
- [ ] 测试数据独立且可重复
- [ ] 覆盖正常和异常路径
- [ ] 清理测试数据
- [ ] 没有硬编码值
- [ ] 测试运行快速稳定

---

## 📚 相关资源

- [测试组织规范](./测试组织规范.md)
- [API测试指南](./API测试指南.md)
- [性能测试规范](./性能测试规范.md)
- [共享服务测试文档](./共享服务测试文档.md)
- [Go Testing文档](https://golang.org/pkg/testing/)
- [Testify文档](https://github.com/stretchr/testify)

---

**最后更新**: 2025-10-17  
**维护者**: 青羽后端团队

