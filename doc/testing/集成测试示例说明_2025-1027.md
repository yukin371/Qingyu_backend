# 集成测试示例说明

**创建日期**: 2025-10-27  
**测试策略**: 基于Repository(90%) + Service(88%)的扎实基础

---

## 🎯 集成测试目标

集成测试用于验证：
1. 多个层级（API → Service → Repository → Database）的协作
2. 端到端的业务流程
3. 数据一致性
4. 真实场景下的系统行为

---

## 📝 示例1: 评论+点赞完整流程

### 测试场景

```go
func TestIntegration_CommentAndLikeFlow(t *testing.T) {
    /*
    测试流程:
    1. 用户A发表评论
    2. 用户B点赞该评论
    3. 验证评论点赞数增加
    4. 用户B取消点赞
    5. 验证评论点赞数减少
    6. 用户A删除评论
    7. 验证评论已删除（软删除）
    */
    
    // Setup - 创建测试环境
    ctx := context.Background()
    testDB := setupTestDatabase(t)
    defer cleanupTestDatabase(t, testDB)
    
    // 创建Service（使用真实的Repository）
    commentRepo := mongodb.NewMongoCommentRepository(testDB)
    likeRepo := mongodb.NewMongoLikeRepository(testDB)
    sensitiveRepo := mongodb.NewMongoSensitiveWordRepository(testDB)
    eventBus := events.NewSimpleEventBus()
    
    commentService := reading.NewCommentService(commentRepo, sensitiveRepo, eventBus)
    likeService := reading.NewLikeService(likeRepo, commentRepo, eventBus)
    
    // Test Data
    userA := "user_alice"
    userB := "user_bob"
    bookID := "book_test_123"
    
    // Step 1: 用户A发表评论
    t.Log("Step 1: 用户A发表评论")
    comment, err := commentService.PublishComment(
        ctx,
        userA,
        bookID,
        "",
        "这是一条测试评论，内容充实有价值",
        5,
    )
    require.NoError(t, err)
    require.NotNil(t, comment)
    require.NotEmpty(t, comment.ID.Hex())
    assert.Equal(t, 0, comment.LikeCount)
    t.Logf("✓ 评论已创建，ID: %s", comment.ID.Hex())
    
    commentID := comment.ID.Hex()
    
    // Step 2: 用户B点赞该评论
    t.Log("Step 2: 用户B点赞评论")
    err = likeService.LikeComment(ctx, userB, commentID)
    require.NoError(t, err)
    t.Logf("✓ 用户B点赞成功")
    
    // Step 3: 验证评论点赞数增加
    t.Log("Step 3: 验证点赞数")
    updatedComment, err := commentRepo.GetByID(ctx, commentID)
    require.NoError(t, err)
    assert.Equal(t, 1, updatedComment.LikeCount)
    t.Logf("✓ 评论点赞数: %d", updatedComment.LikeCount)
    
    // 验证点赞记录存在
    isLiked, err := likeRepo.IsLiked(ctx, userB, reader.LikeTargetTypeComment, commentID)
    require.NoError(t, err)
    assert.True(t, isLiked)
    t.Logf("✓ 点赞记录已保存")
    
    // Step 4: 用户B取消点赞
    t.Log("Step 4: 用户B取消点赞")
    err = likeService.UnlikeComment(ctx, userB, commentID)
    require.NoError(t, err)
    t.Logf("✓ 取消点赞成功")
    
    // Step 5: 验证评论点赞数减少
    t.Log("Step 5: 验证点赞数减少")
    finalComment, err := commentRepo.GetByID(ctx, commentID)
    require.NoError(t, err)
    assert.Equal(t, 0, finalComment.LikeCount)
    t.Logf("✓ 评论点赞数: %d", finalComment.LikeCount)
    
    // 验证点赞记录已删除
    isLikedAfter, err := likeRepo.IsLiked(ctx, userB, reader.LikeTargetTypeComment, commentID)
    require.NoError(t, err)
    assert.False(t, isLikedAfter)
    t.Logf("✓ 点赞记录已删除")
    
    // Step 6: 用户A删除评论
    t.Log("Step 6: 用户A删除评论")
    err = commentService.DeleteComment(ctx, userA, commentID)
    require.NoError(t, err)
    t.Logf("✓ 评论已删除")
    
    // Step 7: 验证评论状态
    t.Log("Step 7: 验证软删除")
    deletedComment, err := commentRepo.GetByID(ctx, commentID)
    require.NoError(t, err)
    assert.Equal(t, "deleted", deletedComment.Status)
    t.Logf("✓ 评论状态: %s", deletedComment.Status)
    
    t.Log("======================================")
    t.Log("✅ 集成测试通过：评论+点赞完整流程")
    t.Log("======================================")
}
```

### 测试验证点

✅ **数据一致性**:
- 点赞后评论的like_count正确增加
- 取消点赞后like_count正确减少
- 点赞记录与评论计数同步

✅ **业务逻辑**:
- 评论创建成功
- 点赞/取消点赞操作正确
- 软删除功能正常

✅ **跨Service交互**:
- LikeService正确调用CommentRepository更新计数
- 数据在多个Repository之间保持一致

---

## 📝 示例2: 幂等性验证

### 测试场景

```go
func TestIntegration_LikeIdempotency(t *testing.T) {
    /*
    测试幂等性:
    1. 用户点赞书籍
    2. 用户重复点赞（应该不报错）
    3. 验证只有一条点赞记录
    4. 用户取消点赞
    5. 用户重复取消点赞（应该不报错）
    6. 验证点赞记录已删除
    */
    
    ctx := context.Background()
    testDB := setupTestDatabase(t)
    defer cleanupTestDatabase(t, testDB)
    
    // 创建Service
    likeRepo := mongodb.NewMongoLikeRepository(testDB)
    commentRepo := mongodb.NewMongoCommentRepository(testDB)
    eventBus := events.NewSimpleEventBus()
    likeService := reading.NewLikeService(likeRepo, commentRepo, eventBus)
    
    userID := "user_test"
    bookID := "book_test_456"
    
    // Step 1: 第一次点赞
    t.Log("Step 1: 第一次点赞")
    err := likeService.LikeBook(ctx, userID, bookID)
    require.NoError(t, err)
    t.Logf("✓ 第一次点赞成功")
    
    // Step 2: 重复点赞（幂等）
    t.Log("Step 2: 重复点赞")
    err = likeService.LikeBook(ctx, userID, bookID)
    require.NoError(t, err) // 不应该报错
    t.Logf("✓ 重复点赞不报错（幂等性）")
    
    // Step 3: 验证只有一条记录
    t.Log("Step 3: 验证点赞记录")
    count, err := likeRepo.CountUserLikes(ctx, userID)
    require.NoError(t, err)
    assert.Equal(t, int64(1), count)
    t.Logf("✓ 点赞记录数: %d", count)
    
    // Step 4: 取消点赞
    t.Log("Step 4: 取消点赞")
    err = likeService.UnlikeBook(ctx, userID, bookID)
    require.NoError(t, err)
    t.Logf("✓ 取消点赞成功")
    
    // Step 5: 重复取消点赞（幂等）
    t.Log("Step 5: 重复取消点赞")
    err = likeService.UnlikeBook(ctx, userID, bookID)
    require.NoError(t, err) // 不应该报错
    t.Logf("✓ 重复取消点赞不报错（幂等性）")
    
    // Step 6: 验证记录已删除
    t.Log("Step 6: 验证记录已删除")
    countAfter, err := likeRepo.CountUserLikes(ctx, userID)
    require.NoError(t, err)
    assert.Equal(t, int64(0), countAfter)
    t.Logf("✓ 点赞记录数: %d", countAfter)
    
    t.Log("======================================")
    t.Log("✅ 集成测试通过：幂等性验证")
    t.Log("======================================")
}
```

### 幂等性验证点

✅ **重复点赞**:
- 第一次点赞成功
- 第二次点赞不报错
- 只创建一条点赞记录

✅ **重复取消点赞**:
- 第一次取消成功
- 第二次取消不报错
- 点赞记录被正确删除

---

## 📝 示例3: 敏感词过滤

### 测试场景

```go
func TestIntegration_SensitiveWordFilter(t *testing.T) {
    /*
    测试敏感词过滤:
    1. 添加敏感词到数据库
    2. 发表包含敏感词的评论
    3. 验证评论被拒绝或进入待审核
    4. 发表正常评论
    5. 验证评论通过
    */
    
    ctx := context.Background()
    testDB := setupTestDatabase(t)
    defer cleanupTestDatabase(t, testDB)
    
    // 创建Service
    commentRepo := mongodb.NewMongoCommentRepository(testDB)
    sensitiveRepo := mongodb.NewMongoSensitiveWordRepository(testDB)
    eventBus := events.NewSimpleEventBus()
    commentService := reading.NewCommentService(commentRepo, sensitiveRepo, eventBus)
    
    // Step 1: 添加敏感词
    t.Log("Step 1: 添加敏感词")
    sensitiveWord := &audit.SensitiveWord{
        Word:      "违规词",
        Level:     2,
        IsEnabled: true,
    }
    err := sensitiveRepo.Create(ctx, sensitiveWord)
    require.NoError(t, err)
    t.Logf("✓ 敏感词已添加")
    
    // Step 2: 发表包含敏感词的评论
    t.Log("Step 2: 发表包含敏感词的评论")
    badComment, err := commentService.PublishComment(
        ctx,
        "user_test",
        "book_123",
        "",
        "这条评论包含违规词的内容",
        4,
    )
    require.NoError(t, err) // 创建成功，但状态为rejected
    assert.NotEqual(t, "approved", badComment.Status)
    assert.Contains(t, []string{"rejected", "pending"}, badComment.Status)
    t.Logf("✓ 评论状态: %s", badComment.Status)
    
    // Step 3: 发表正常评论
    t.Log("Step 3: 发表正常评论")
    goodComment, err := commentService.PublishComment(
        ctx,
        "user_test",
        "book_123",
        "",
        "这是一条正常的评论内容，没有问题",
        5,
    )
    require.NoError(t, err)
    assert.Equal(t, "approved", goodComment.Status)
    t.Logf("✓ 评论状态: %s", goodComment.Status)
    
    t.Log("======================================")
    t.Log("✅ 集成测试通过：敏感词过滤")
    t.Log("======================================")
}
```

---

## 🛠️ 测试辅助函数

### 数据库设置

```go
func setupTestDatabase(t *testing.T) *mongo.Database {
    // 连接到测试MongoDB
    client, err := mongo.Connect(context.Background(), options.Client().ApplyURI("mongodb://localhost:27017"))
    require.NoError(t, err)
    
    // 创建独立的测试数据库（使用时间戳）
    dbName := fmt.Sprintf("qingyu_integration_test_%d", time.Now().Unix())
    testDB := client.Database(dbName)
    
    t.Logf("✓ 测试数据库已创建: %s", dbName)
    
    return testDB
}

func cleanupTestDatabase(t *testing.T, db *mongo.Database) {
    err := db.Drop(context.Background())
    if err != nil {
        t.Logf("⚠ 清理测试数据库失败: %v", err)
    } else {
        t.Logf("✓ 测试数据库已清理: %s", db.Name())
    }
}
```

---

## 📊 集成测试vs单元测试

| 特性 | Repository层 | Service层 | 集成测试 |
|------|-------------|----------|---------|
| **数据库** | 真实MongoDB | Mock Repository | 真实MongoDB |
| **依赖** | 真实连接 | Mock | 真实Service |
| **测试内容** | DB操作 | 业务逻辑 | 端到端流程 |
| **速度** | 中等 | 快 | 较慢 |
| **隔离性** | 独立DB | 完全隔离 | 独立DB |
| **覆盖范围** | 数据层 | 逻辑层 | 全栈 |

---

## 🎯 运行建议

### 开发阶段
```bash
# 快速运行单元测试（Service层）
go test ./test/service/... -v

# 运行Repository测试
go test ./test/repository/... -v
```

### 集成阶段
```bash
# 运行集成测试
go test ./test/integration/... -v -timeout 5m

# 运行所有测试
go test ./test/... -v -timeout 10m
```

### CI/CD
```bash
# 完整测试 + 覆盖率
go test ./... -cover -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

---

## ✅ 测试完成标准

集成测试应该验证：

- [ ] 完整的业务流程（评论→点赞→删除）
- [ ] 数据一致性（多个Repository之间）
- [ ] 幂等性（重复操作不出错）
- [ ] 业务规则（敏感词过滤）
- [ ] 权限控制（用户只能操作自己的数据）
- [ ] 事件发布（操作触发事件）
- [ ] 错误处理（异常情况处理正确）

---

## 📚 参考

- `test/repository/` - Repository层测试示例
- `test/service/` - Service层测试示例
- `test/integration/reader_api_integration_test.go` - 现有集成测试

---

**创建时间**: 2025-10-27  
**适用项目**: Qingyu Backend  
**测试策略**: Repository + Service + Integration

