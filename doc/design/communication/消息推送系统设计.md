# 消息推送系统（Push/邮件/短信）设计

## 1. 需求概述
- **功能描述**：设计多渠道消息推送系统，支持Push通知、邮件和短信推送
- **业务价值**：提升用户活跃度，及时传达重要信息，增强用户粘性
- **用户场景**：系统通知、营销推送、安全提醒、业务通知
- **功能边界**：消息模板管理、推送渠道管理、用户偏好设置、推送统计分析

## 2. 架构设计

### 2.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client Apps   │    │   Web Frontend  │    │   Admin Panel   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                        API Gateway                              │
└─────────────────────────────────────────────────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                    Message Push Service                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   Router    │  │     API     │  │  Middleware │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                      Service Layer                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ Push Service│  │Template Svc │  │Statistics   │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                    Repository Layer                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │Message Repo │  │Template Repo│  │  User Repo  │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                      Data Layer                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   MongoDB   │  │    Redis    │  │  Message    │             │
│  │             │  │   (Cache)   │  │   Queue     │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                   External Services                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   FCM/APNs  │  │   Email     │  │    SMS      │             │
│  │  (Push)     │  │  Provider   │  │  Provider   │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

- **消息管理模块**：消息创建、发送、状态跟踪
- **模板管理模块**：消息模板CRUD、变量替换、多语言支持
- **渠道管理模块**：推送渠道配置、优先级管理、故障转移
- **用户偏好模块**：推送偏好设置、免打扰时间、订阅管理
- **统计分析模块**：发送统计、到达率分析、用户行为追踪

### 2.3 数据流向

```
消息触发 → 消息队列 → 模板渲染 → 渠道选择 → 外部服务 → 状态回调 → 统计更新
```

### 2.4 技术选型

- **消息队列**：Redis Streams / RabbitMQ
- **缓存系统**：Redis
- **数据库**：MongoDB
- **Push服务**：Firebase Cloud Messaging (FCM) / Apple Push Notification Service (APNs)
- **邮件服务**：SendGrid / Amazon SES
- **短信服务**：Twilio / 阿里云短信服务
- **监控工具**：Prometheus + Grafana

## 3. 详细设计

### 3.1 Router层设计
```go
// 消息推送相关路由
func SetupPushRoutes(router *gin.Engine, api *api.PushAPI) {
    v1 := router.Group("/api/v1/push")
    {
        // 消息管理
        v1.POST("/messages", api.SendMessage)
        v1.GET("/messages/:id", api.GetMessage)
        v1.GET("/messages", api.ListMessages)
        v1.PUT("/messages/:id/status", api.UpdateMessageStatus)
        
        // 模板管理
        v1.POST("/templates", api.CreateTemplate)
        v1.GET("/templates/:id", api.GetTemplate)
        v1.PUT("/templates/:id", api.UpdateTemplate)
        v1.DELETE("/templates/:id", api.DeleteTemplate)
        v1.GET("/templates", api.ListTemplates)
        
        // 用户偏好
        v1.GET("/preferences/:user_id", api.GetUserPreferences)
        v1.PUT("/preferences/:user_id", api.UpdateUserPreferences)
        
        // 统计分析
        v1.GET("/statistics/overview", api.GetStatisticsOverview)
        v1.GET("/statistics/messages/:id", api.GetMessageStatistics)
    }
}
```

### 3.2 API层设计
```go
type PushAPI struct {
    pushService     service.PushService
    templateService service.TemplateService
    statsService    service.StatisticsService
}

// 发送消息
func (api *PushAPI) SendMessage(c *gin.Context) {
    var req SendMessageRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    message, err := api.pushService.SendMessage(c.Request.Context(), &req)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, gin.H{"data": message})
}

// 请求/响应结构
type SendMessageRequest struct {
    TemplateID   string                 `json:"template_id" binding:"required"`
    Recipients   []string               `json:"recipients" binding:"required"`
    Channels     []string               `json:"channels" binding:"required"`
    Variables    map[string]interface{} `json:"variables"`
    ScheduleTime *time.Time             `json:"schedule_time"`
    Priority     int                    `json:"priority"`
}
```

### 3.3 Service层设计
```go
type PushService interface {
    SendMessage(ctx context.Context, req *SendMessageRequest) (*model.Message, error)
    GetMessage(ctx context.Context, id string) (*model.Message, error)
    ListMessages(ctx context.Context, filter *MessageFilter) (*PagedResult[*model.Message], error)
    UpdateMessageStatus(ctx context.Context, id string, status MessageStatus) error
}

type pushServiceImpl struct {
    messageRepo     repository.MessageRepository
    templateRepo    repository.TemplateRepository
    userRepo        repository.UserRepository
    channelManager  *ChannelManager
    queue          MessageQueue
    logger         *zap.Logger
}

func (s *pushServiceImpl) SendMessage(ctx context.Context, req *SendMessageRequest) (*model.Message, error) {
    // 1. 验证模板
    template, err := s.templateRepo.GetByID(ctx, req.TemplateID)
    if err != nil {
        return nil, err
    }
    
    // 2. 创建消息记录
    message := &model.Message{
        ID:           primitive.NewObjectID(),
        TemplateID:   req.TemplateID,
        Recipients:   req.Recipients,
        Channels:     req.Channels,
        Variables:    req.Variables,
        Status:       MessageStatusPending,
        CreatedAt:    time.Now(),
    }
    
    if err := s.messageRepo.Create(ctx, message); err != nil {
        return nil, err
    }
    
    // 3. 加入消息队列
    if req.ScheduleTime != nil && req.ScheduleTime.After(time.Now()) {
        // 延时消息
        err = s.queue.ScheduleMessage(message, *req.ScheduleTime)
    } else {
        // 立即发送
        err = s.queue.EnqueueMessage(message)
    }
    
    if err != nil {
        s.logger.Error("Failed to enqueue message", zap.Error(err))
        return nil, err
    }
    
    return message, nil
}
```

### 3.4 Repository层设计
```go
type MessageRepository interface {
    Create(ctx context.Context, message *model.Message) error
    GetByID(ctx context.Context, id string) (*model.Message, error)
    Update(ctx context.Context, message *model.Message) error
    List(ctx context.Context, filter *MessageFilter) (*PagedResult[*model.Message], error)
    UpdateStatus(ctx context.Context, id string, status MessageStatus) error
    GetStatistics(ctx context.Context, filter *StatisticsFilter) (*MessageStatistics, error)
}

type TemplateRepository interface {
    Create(ctx context.Context, template *model.Template) error
    GetByID(ctx context.Context, id string) (*model.Template, error)
    Update(ctx context.Context, template *model.Template) error
    Delete(ctx context.Context, id string) error
    List(ctx context.Context, filter *TemplateFilter) (*PagedResult[*model.Template], error)
}

type UserPreferenceRepository interface {
    GetByUserID(ctx context.Context, userID string) (*model.UserPreference, error)
    Update(ctx context.Context, preference *model.UserPreference) error
    Create(ctx context.Context, preference *model.UserPreference) error
}
```

### 3.5 Model层设计
```go
type Message struct {
    ID           primitive.ObjectID     `bson:"_id,omitempty" json:"id"`
    TemplateID   string                 `bson:"template_id" json:"template_id"`
    Recipients   []string               `bson:"recipients" json:"recipients"`
    Channels     []string               `bson:"channels" json:"channels"`
    Variables    map[string]interface{} `bson:"variables" json:"variables"`
    Status       MessageStatus          `bson:"status" json:"status"`
    SentAt       *time.Time             `bson:"sent_at,omitempty" json:"sent_at,omitempty"`
    DeliveredAt  *time.Time             `bson:"delivered_at,omitempty" json:"delivered_at,omitempty"`
    FailureReason string                `bson:"failure_reason,omitempty" json:"failure_reason,omitempty"`
    CreatedAt    time.Time              `bson:"created_at" json:"created_at"`
    UpdatedAt    time.Time              `bson:"updated_at" json:"updated_at"`
}

type Template struct {
    ID          primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Name        string             `bson:"name" json:"name"`
    Type        TemplateType       `bson:"type" json:"type"`
    Subject     string             `bson:"subject,omitempty" json:"subject,omitempty"`
    Content     string             `bson:"content" json:"content"`
    Variables   []string           `bson:"variables" json:"variables"`
    Channels    []string           `bson:"channels" json:"channels"`
    IsActive    bool               `bson:"is_active" json:"is_active"`
    CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
    UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}

type UserPreference struct {
    ID              primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    UserID          string             `bson:"user_id" json:"user_id"`
    PushEnabled     bool               `bson:"push_enabled" json:"push_enabled"`
    EmailEnabled    bool               `bson:"email_enabled" json:"email_enabled"`
    SMSEnabled      bool               `bson:"sms_enabled" json:"sms_enabled"`
    QuietHours      *QuietHours        `bson:"quiet_hours,omitempty" json:"quiet_hours,omitempty"`
    Categories      map[string]bool    `bson:"categories" json:"categories"`
    CreatedAt       time.Time          `bson:"created_at" json:"created_at"`
    UpdatedAt       time.Time          `bson:"updated_at" json:"updated_at"`
}

type QuietHours struct {
    StartTime string `bson:"start_time" json:"start_time"` // "22:00"
    EndTime   string `bson:"end_time" json:"end_time"`     // "08:00"
    Timezone  string `bson:"timezone" json:"timezone"`     // "Asia/Shanghai"
}

// 枚举类型
type MessageStatus string
const (
    MessageStatusPending   MessageStatus = "pending"
    MessageStatusSending   MessageStatus = "sending"
    MessageStatusSent      MessageStatus = "sent"
    MessageStatusDelivered MessageStatus = "delivered"
    MessageStatusFailed    MessageStatus = "failed"
)

type TemplateType string
const (
    TemplateTypePush  TemplateType = "push"
    TemplateTypeEmail TemplateType = "email"
    TemplateTypeSMS   TemplateType = "sms"
)
```

## 4. 数据设计

### 4.1 数据模型
```javascript
// MongoDB Collections

// 消息集合
db.messages = {
    _id: ObjectId,
    template_id: String,
    recipients: [String],
    channels: [String],
    variables: Object,
    status: String, // pending, sending, sent, delivered, failed
    sent_at: Date,
    delivered_at: Date,
    failure_reason: String,
    created_at: Date,
    updated_at: Date,
    // 索引
    indexes: [
        { template_id: 1 },
        { status: 1, created_at: -1 },
        { recipients: 1 },
        { created_at: -1 }
    ]
}

// 模板集合
db.templates = {
    _id: ObjectId,
    name: String,
    type: String, // push, email, sms
    subject: String, // 邮件主题或推送标题
    content: String, // 支持变量替换 {{variable}}
    variables: [String], // 模板变量列表
    channels: [String], // 支持的推送渠道
    is_active: Boolean,
    created_at: Date,
    updated_at: Date,
    // 索引
    indexes: [
        { name: 1 },
        { type: 1, is_active: 1 },
        { is_active: 1, created_at: -1 }
    ]
}

// 用户偏好集合
db.user_preferences = {
    _id: ObjectId,
    user_id: String,
    push_enabled: Boolean,
    email_enabled: Boolean,
    sms_enabled: Boolean,
    quiet_hours: {
        start_time: String, // "22:00"
        end_time: String,   // "08:00"
        timezone: String    // "Asia/Shanghai"
    },
    categories: Object, // {"system": true, "marketing": false}
    created_at: Date,
    updated_at: Date,
    // 索引
    indexes: [
        { user_id: 1 } // 唯一索引
    ]
}

// 推送统计集合
db.push_statistics = {
    _id: ObjectId,
    message_id: ObjectId,
    channel: String,
    recipient: String,
    status: String, // sent, delivered, failed, clicked, opened
    timestamp: Date,
    error_message: String,
    // 索引
    indexes: [
        { message_id: 1 },
        { channel: 1, timestamp: -1 },
        { status: 1, timestamp: -1 }
    ]
}
```

### 4.2 缓存设计
```javascript
// Redis 缓存结构

// 用户偏好缓存
"user_pref:{user_id}" = {
    push_enabled: true,
    email_enabled: true,
    sms_enabled: false,
    quiet_hours: {...},
    categories: {...}
}

// 模板缓存
"template:{template_id}" = {
    name: "welcome_email",
    type: "email",
    content: "Welcome {{username}}!",
    variables: ["username"],
    channels: ["email"]
}

// 消息队列 (Redis Streams)
"message_queue" = [
    {
        id: "1234567890-0",
        data: {
            message_id: "...",
            template_id: "...",
            recipients: [...],
            channels: [...],
            variables: {...}
        }
    }
]

// 限流缓存
"rate_limit:{user_id}:{channel}" = {
    count: 10,
    window: 3600, // 1小时
    ttl: 3600
}
```

### 4.3 数据库索引策略
- **消息表**：按状态和创建时间复合索引，按模板ID索引
- **模板表**：按类型和状态复合索引，按名称唯一索引
- **用户偏好表**：按用户ID唯一索引
- **统计表**：按消息ID索引，按渠道和时间复合索引

## 5. 接口设计

### 5.1 RESTful API
```yaml
# 消息管理API
POST /api/v1/push/messages
  - 发送消息
  - Body: SendMessageRequest
  - Response: Message

GET /api/v1/push/messages/{id}
  - 获取消息详情
  - Response: Message

GET /api/v1/push/messages
  - 获取消息列表
  - Query: page, size, status, template_id
  - Response: PagedResult<Message>

PUT /api/v1/push/messages/{id}/status
  - 更新消息状态
  - Body: {status: string}

# 模板管理API
POST /api/v1/push/templates
  - 创建模板
  - Body: CreateTemplateRequest
  - Response: Template

GET /api/v1/push/templates/{id}
  - 获取模板详情
  - Response: Template

PUT /api/v1/push/templates/{id}
  - 更新模板
  - Body: UpdateTemplateRequest
  - Response: Template

DELETE /api/v1/push/templates/{id}
  - 删除模板

GET /api/v1/push/templates
  - 获取模板列表
  - Query: page, size, type, is_active
  - Response: PagedResult<Template>

# 用户偏好API
GET /api/v1/push/preferences/{user_id}
  - 获取用户推送偏好
  - Response: UserPreference

PUT /api/v1/push/preferences/{user_id}
  - 更新用户推送偏好
  - Body: UpdatePreferenceRequest
  - Response: UserPreference

# 统计分析API
GET /api/v1/push/statistics/overview
  - 获取推送统计概览
  - Query: start_date, end_date, channel
  - Response: StatisticsOverview

GET /api/v1/push/statistics/messages/{id}
  - 获取消息统计详情
  - Response: MessageStatistics
```

### 5.2 WebHook接口
```yaml
# 第三方服务回调接口
POST /api/v1/push/webhooks/fcm
  - FCM推送状态回调
  - Body: FCMWebhookPayload

POST /api/v1/push/webhooks/email
  - 邮件服务状态回调
  - Body: EmailWebhookPayload

POST /api/v1/push/webhooks/sms
  - 短信服务状态回调
  - Body: SMSWebhookPayload
```

## 6. 安全设计

### 6.1 认证授权
- **API认证**：JWT Token认证
- **权限控制**：基于RBAC的权限管理
- **接口限流**：按用户和IP进行限流
- **数据加密**：敏感数据AES加密存储

### 6.2 数据安全
- **个人信息保护**：用户手机号、邮箱等敏感信息加密存储
- **消息内容安全**：支持消息内容加密传输
- **访问日志**：记录所有API访问日志
- **数据备份**：定期备份重要数据

### 6.3 防护措施
- **防重放攻击**：WebHook接口签名验证
- **防刷机制**：消息发送频率限制
- **异常监控**：异常请求实时告警
- **黑名单机制**：支持用户和IP黑名单

## 7. 测试设计

### 7.1 单元测试
- **Service层测试**：业务逻辑单元测试，覆盖率>90%
- **Repository层测试**：数据访问层测试
- **工具函数测试**：模板渲染、消息格式化等

### 7.2 集成测试
- **API接口测试**：所有REST API接口测试
- **消息队列测试**：消息入队出队测试
- **第三方服务测试**：推送服务集成测试

### 7.3 性能测试
- **并发测试**：高并发消息发送测试
- **压力测试**：系统极限性能测试
- **稳定性测试**：长时间运行稳定性测试

## 8. 部署和运维

### 8.1 部署架构
```
┌─────────────────┐    ┌─────────────────┐
│   Load Balancer │    │   API Gateway   │
└─────────────────┘    └─────────────────┘
         │                       │
┌─────────────────────────────────────────┐
│          Push Service Cluster           │
│  ┌─────────────┐  ┌─────────────┐      │
│  │  Instance 1 │  │  Instance 2 │  ... │
│  └─────────────┘  └─────────────┘      │
└─────────────────────────────────────────┘
         │                       │
┌─────────────────┐    ┌─────────────────┐
│     MongoDB     │    │      Redis      │
│    (Replica)    │    │   (Cluster)     │
└─────────────────┘    └─────────────────┘
```

### 8.2 监控告警
- **系统监控**：CPU、内存、磁盘使用率
- **业务监控**：消息发送成功率、延迟统计
- **错误监控**：异常日志实时告警
- **性能监控**：API响应时间、吞吐量

### 8.3 日志管理
- **结构化日志**：使用JSON格式记录日志
- **日志分级**：DEBUG、INFO、WARN、ERROR
- **日志聚合**：使用ELK Stack进行日志收集分析
- **日志轮转**：定期清理历史日志

## 9. 风险评估

### 9.1 技术风险
- **第三方服务依赖**：推送服务不可用风险
  - 缓解措施：多渠道备份，故障转移机制
- **消息队列积压**：高峰期消息处理延迟
  - 缓解措施：水平扩展，优先级队列
- **数据库性能**：大量数据查询性能问题
  - 缓解措施：读写分离，索引优化

### 9.2 业务风险
- **消息发送失败**：影响用户体验
  - 缓解措施：重试机制，失败通知
- **用户投诉**：过度推送导致用户反感
  - 缓解措施：频率控制，偏好设置
- **合规风险**：个人信息保护法规
  - 缓解措施：数据加密，用户授权

### 9.3 运维风险
- **服务宕机**：单点故障风险
  - 缓解措施：高可用部署，健康检查
- **数据丢失**：重要数据丢失风险
  - 缓解措施：定期备份，异地容灾

## 10. 实施计划

### 10.1 开发阶段
- **第一阶段**（2周）：基础架构搭建，核心模型设计
- **第二阶段**（3周）：消息发送功能，模板管理
- **第三阶段**（2周）：用户偏好，统计分析
- **第四阶段**（1周）：测试优化，文档完善

### 10.2 测试阶段
- **单元测试**（1周）：代码覆盖率达到90%以上
- **集成测试**（1周）：端到端功能测试
- **性能测试**（1周）：压力测试，性能调优

### 10.3 上线阶段
- **灰度发布**（1周）：小范围用户测试
- **全量发布**（1周）：正式上线，监控观察
- **运维优化**（持续）：根据运行情况持续优化

---
*本文档为设计模板，需要根据实际需求进行详细设计*