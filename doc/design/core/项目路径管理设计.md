# 项目路径管理设计

## 1. 需求概述

### 1.1 功能描述
路径管理是青羽写作系统中用于管理项目文件结构和导航路径的核心功能模块。该功能提供项目、节点（文件夹/文件）和文档的层次化管理，支持树形结构的文件组织方式，为用户提供清晰的项目结构导航和文件管理功能。

### 1.2 业务价值
- **结构化管理**：提供清晰的项目文件层次结构管理
- **导航便利**：支持快速定位和访问项目中的任意文件或文档
- **组织灵活**：支持文件夹和文件的自由组织和重新排列
- **权限控制**：基于路径的访问权限管理

### 1.3 用户场景
- 创建新项目并设置基本结构
- 在项目中创建文件夹和文件节点
- 调整文件和文件夹的层次结构
- 通过路径快速导航到指定文档
- 管理文档的显示顺序

### 1.4 功能边界
- 支持项目、节点、文档的三层数据模型
- 支持文件夹和文件两种节点类型
- 支持节点的排序和层次调整
- 不包含文件内容的版本管理（由版本控制模块负责）

## 2. 架构设计

### 2.1 整体架构
```
┌─────────────────┐
│   Frontend      │ ← 文件树导航界面
├─────────────────┤
│   Router        │ ← 路由层：/api/v1/path/*
├─────────────────┤
│   API Layer     │ ← HTTP接口处理
├─────────────────┤
│   Service Layer │ ← 业务逻辑处理
├─────────────────┤
│   Model Layer   │ ← 数据模型定义
├─────────────────┤
│   MongoDB       │ ← 数据持久化
└─────────────────┘
```

### 2.2 模块划分

- **ProjectAPI**：项目管理HTTP接口
- **NodeAPI**：节点管理HTTP接口
- **DocumentAPI**：文档管理HTTP接口
- **PathService**：路径业务逻辑服务
- **TreeService**：树形结构管理服务

### 2.3 数据流向
1. 客户端发送路径管理操作请求
2. Router层路由到对应API处理函数
3. API层验证参数并调用Service层
4. Service层执行业务逻辑并操作Model层
5. Model层与MongoDB交互
6. 返回结果并更新文件树结构

### 2.4 技术选型
- **Web框架**：Gin
- **数据库**：MongoDB
- **树形结构**：邻接列表模型
- **认证**：JWT中间件
- **日志**：Zap

## 3. 详细设计

### 3.1 Router层设计
```go
// router/path/path.go
func InitPathRouter(router *gin.RouterGroup) {
    projectApi := api.NewProjectApi()
    nodeApi := api.NewNodeApi()
    documentApi := api.NewDocumentApi()
    
    pathGroup := router.Group("/path")
    pathGroup.Use(middleware.AuthMiddleware())
    {
        // 项目管理
        pathGroup.POST("/project", projectApi.CreateProject)
        pathGroup.GET("/project/:id", projectApi.GetProject)
        pathGroup.PUT("/project/:id", projectApi.UpdateProject)
        pathGroup.DELETE("/project/:id", projectApi.DeleteProject)
        pathGroup.GET("/project/user/:userId", projectApi.ListUserProjects)
        
        // 节点管理
        pathGroup.POST("/node", nodeApi.CreateNode)
        pathGroup.GET("/node/:id", nodeApi.GetNode)
        pathGroup.PUT("/node/:id", nodeApi.UpdateNode)
        pathGroup.DELETE("/node/:id", nodeApi.DeleteNode)
        pathGroup.GET("/node/project/:projectId", nodeApi.GetProjectTree)
        pathGroup.PUT("/node/:id/move", nodeApi.MoveNode)
        pathGroup.PUT("/node/:id/order", nodeApi.UpdateNodeOrder)
        
        // 文档管理
        pathGroup.POST("/document", documentApi.CreateDocument)
        pathGroup.GET("/document/:id", documentApi.GetDocument)
        pathGroup.PUT("/document/:id", documentApi.UpdateDocument)
        pathGroup.DELETE("/document/:id", documentApi.DeleteDocument)
    }
}
```

### 3.2 API层设计
```go
// api/v1/path/project.go
type ProjectApi struct {
    pathService *service.PathService
}

// CreateProject 创建项目
func (api *ProjectApi) CreateProject(c *gin.Context) {
    var req CreateProjectRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage("参数验证失败", c)
        return
    }
    
    userID := c.GetString("userID")
    project, err := api.pathService.CreateProject(userID, &req)
    if err != nil {
        response.FailWithMessage(err.Error(), c)
        return
    }
    
    response.OkWithData(project, c)
}

// api/v1/path/node.go
type NodeApi struct {
    pathService *service.PathService
    treeService *service.TreeService
}

// GetProjectTree 获取项目文件树
func (api *NodeApi) GetProjectTree(c *gin.Context) {
    projectID := c.Param("projectId")
    userID := c.GetString("userID")
    
    tree, err := api.treeService.BuildProjectTree(userID, projectID)
    if err != nil {
        response.FailWithMessage(err.Error(), c)
        return
    }
    
    response.OkWithData(tree, c)
}

// MoveNode 移动节点
func (api *NodeApi) MoveNode(c *gin.Context) {
    nodeID := c.Param("id")
    var req MoveNodeRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage("参数验证失败", c)
        return
    }
    
    userID := c.GetString("userID")
    err := api.treeService.MoveNode(userID, nodeID, req.NewParentID, req.NewOrder)
    if err != nil {
        response.FailWithMessage(err.Error(), c)
        return
    }
    
    response.Ok(c)
}
```

### 3.3 Service层设计
```go
// service/path/path.go
type PathService struct {
    // 依赖注入
}

func (s *PathService) CreateProject(userID string, req *CreateProjectRequest) (*models.Project, error) {
    // 1. 权限验证
    if err := s.validateUserPermission(userID); err != nil {
        return nil, err
    }
    
    // 2. 业务逻辑处理
    project := &models.Project{
        OwnerID:     userID,
        Name:        req.Name,
        Description: req.Description,
        Status:      req.Status,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    // 3. 数据持久化
    if err := s.saveProject(project); err != nil {
        return nil, err
    }
    
    // 4. 创建根节点
    if err := s.createRootNode(project.ID, userID); err != nil {
        return nil, err
    }
    
    return project, nil
}

// service/path/tree.go
type TreeService struct {
    pathService *PathService
}

func (s *TreeService) BuildProjectTree(userID, projectID string) (*ProjectTree, error) {
    // 1. 权限验证
    if err := s.validateProjectAccess(userID, projectID); err != nil {
        return nil, err
    }
    
    // 2. 获取所有节点
    nodes, err := s.getProjectNodes(projectID)
    if err != nil {
        return nil, err
    }
    
    // 3. 构建树形结构
    tree := &ProjectTree{
        ProjectID: projectID,
        Root:      nil,
    }
    
    // 4. 使用邻接列表构建树
    nodeMap := make(map[string]*TreeNode)
    var rootNodes []*TreeNode
    
    // 创建所有节点
    for _, node := range nodes {
        treeNode := &TreeNode{
            ID:           node.ID,
            Name:         node.Name,
            Type:         node.Type,
            RelativePath: node.RelativePath,
            Order:        node.Order,
            Children:     []*TreeNode{},
        }
        nodeMap[node.ID] = treeNode
        
        if node.ParentID == "" {
            rootNodes = append(rootNodes, treeNode)
        }
    }
    
    // 建立父子关系
    for _, node := range nodes {
        if node.ParentID != "" {
            if parent, exists := nodeMap[node.ParentID]; exists {
                parent.Children = append(parent.Children, nodeMap[node.ID])
            }
        }
    }
    
    // 排序子节点
    for _, treeNode := range nodeMap {
        sort.Slice(treeNode.Children, func(i, j int) bool {
            return treeNode.Children[i].Order < treeNode.Children[j].Order
        })
    }
    
    if len(rootNodes) > 0 {
        tree.Root = rootNodes[0]
    }
    
    return tree, nil
}
```

### 3.4 Model层设计
```go
// models/path/project.go
type ProjectStatus string

const (
    ProjectStatusPublic  ProjectStatus = "public"
    ProjectStatusPrivate ProjectStatus = "private"
)

type Project struct {
    ID          string        `bson:"_id,omitempty" json:"id"`
    OwnerID     string        `bson:"owner_id" json:"ownerId"`
    Name        string        `bson:"name" json:"name"`
    Status      ProjectStatus `bson:"status" json:"status"`
    Description string        `bson:"description,omitempty" json:"description,omitempty"`
    CreatedAt   time.Time     `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time     `bson:"updated_at" json:"updatedAt"`
    DeletedAt   *time.Time    `bson:"deleted_at,omitempty" json:"deletedAt,omitempty"`
}

// models/path/node.go
type NodeType string

const (
    NodeTypeFolder NodeType = "folder"
    NodeTypeFile   NodeType = "file"
)

type Node struct {
    ID           string    `bson:"_id,omitempty" json:"id"`
    ProjectID    string    `bson:"project_id" json:"projectId"`
    ParentID     string    `bson:"parent_id,omitempty" json:"parentId,omitempty"`
    Type         NodeType  `bson:"type" json:"type"`
    Name         string    `bson:"name" json:"name"`
    Slug         string    `bson:"slug" json:"slug"`
    RelativePath string    `bson:"relative_path" json:"relativePath"`
    Order        int       `bson:"order" json:"order"`
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
    UpdatedAt    time.Time `bson:"updated_at" json:"updatedAt"`
    DeletedAt    *time.Time `bson:"deleted_at,omitempty" json:"deletedAt,omitempty"`
    // 运行时字段，不存储到数据库
    Children []*Node `bson:"-" json:"children,omitempty"`
}

// models/path/document.go
type Document struct {
    ID        string    `bson:"_id,omitempty" json:"id"`
    NodeID    string    `bson:"node_id" json:"nodeId"`
    Title     string    `bson:"title" json:"title"`
    Content   string    `bson:"content" json:"content"`
    CreatedBy string    `bson:"created_by" json:"createdBy"`
    CreatedAt time.Time `bson:"created_at" json:"createdAt"`
    UpdatedAt time.Time `bson:"updated_at" json:"updatedAt"`
    DeletedAt *time.Time `bson:"deleted_at,omitempty" json:"deletedAt,omitempty"`
}

// models/path/tree.go
type ProjectTree struct {
    ProjectID string    `json:"projectId"`
    Root      *TreeNode `json:"root"`
}

type TreeNode struct {
    ID           string      `json:"id"`
    Name         string      `json:"name"`
    Type         NodeType    `json:"type"`
    RelativePath string      `json:"relativePath"`
    Order        int         `json:"order"`
    Children     []*TreeNode `json:"children"`
}
```

## 4. 数据设计

### 4.1 数据库设计

#### 4.1.1 集合设计
- **projects**：存储项目信息
- **nodes**：存储节点信息（文件夹和文件）
- **documents**：存储文档内容

#### 4.1.2 索引设计
```javascript
// projects集合索引
db.projects.createIndex({ "owner_id": 1 })
db.projects.createIndex({ "owner_id": 1, "name": 1 })
db.projects.createIndex({ "status": 1 })

// nodes集合索引
db.nodes.createIndex({ "project_id": 1 })
db.nodes.createIndex({ "project_id": 1, "parent_id": 1 })
db.nodes.createIndex({ "project_id": 1, "parent_id": 1, "order": 1 })
db.nodes.createIndex({ "relative_path": 1 })

// documents集合索引
db.documents.createIndex({ "node_id": 1 })
db.documents.createIndex({ "created_by": 1 })
```

#### 4.1.3 数据约束
- 项目名称在同一用户下不能重复
- 节点名称在同一父节点下不能重复
- 相对路径在同一项目内必须唯一
- 文档与节点一对一关联

### 4.2 数据迁移策略
- 支持从旧版本数据结构平滑迁移
- 提供数据导入导出功能
- 支持批量数据操作

## 5. API设计

### 5.1 项目管理API

#### 5.1.1 创建项目
```
POST /api/v1/path/project
Content-Type: application/json
Authorization: Bearer <token>

{
    "name": "string",
    "description": "string",
    "status": "public|private"
}

Response:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": "string",
        "ownerId": "string",
        "name": "string",
        "description": "string",
        "status": "public",
        "createdAt": "2024-01-01T00:00:00Z",
        "updatedAt": "2024-01-01T00:00:00Z"
    }
}
```

#### 5.1.2 获取项目列表
```
GET /api/v1/path/project/user/{userId}?page=1&size=20
Authorization: Bearer <token>

Response:
{
    "code": 200,
    "message": "success",
    "data": {
        "list": [Project],
        "total": 100,
        "page": 1,
        "size": 20
    }
}
```

### 5.2 节点管理API

#### 5.2.1 创建节点
```
POST /api/v1/path/node
Content-Type: application/json
Authorization: Bearer <token>

{
    "projectId": "string",
    "parentId": "string",
    "type": "folder|file",
    "name": "string",
    "order": 1
}
```

#### 5.2.2 获取项目树
```
GET /api/v1/path/node/project/{projectId}
Authorization: Bearer <token>

Response:
{
    "code": 200,
    "message": "success",
    "data": {
        "projectId": "string",
        "root": {
            "id": "string",
            "name": "string",
            "type": "folder",
            "relativePath": "/",
            "order": 0,
            "children": [TreeNode]
        }
    }
}
```

#### 5.2.3 移动节点
```
PUT /api/v1/path/node/{id}/move
Content-Type: application/json
Authorization: Bearer <token>

{
    "newParentId": "string",
    "newOrder": 1
}
```

## 6. 安全设计

### 6.1 认证授权
- 使用JWT中间件进行用户身份验证
- 基于项目所有权控制访问权限
- 支持项目级别的权限控制（所有者、协作者、只读）

### 6.2 数据安全
- 输入参数验证和过滤
- MongoDB注入防护
- XSS攻击防护
- 敏感数据加密存储

### 6.3 API安全
- 请求频率限制
- 参数长度限制
- 路径遍历攻击防护

## 7. 测试设计

### 7.1 单元测试
- Service层业务逻辑测试
- Model层数据操作测试
- 树形结构构建测试

### 7.2 集成测试
- API接口测试
- 数据库操作测试
- 权限验证测试

### 7.3 性能测试
- 大型项目树构建性能
- 节点移动操作性能
- 并发操作测试

### 7.4 测试用例
```go
func TestCreateProject(t *testing.T) {
    // 测试正常创建项目
    // 测试重复名称创建
    // 测试权限验证
}

func TestBuildProjectTree(t *testing.T) {
    // 测试空项目树构建
    // 测试复杂项目树构建
    // 测试性能边界
}

func TestMoveNode(t *testing.T) {
    // 测试正常移动节点
    // 测试循环引用检测
    // 测试路径更新
}
```

## 8. 部署和运维

### 8.1 部署要求
- MongoDB 4.4+
- Go 1.19+
- 内存：最少2GB，推荐4GB
- 存储：根据项目数量和文档大小确定

### 8.2 监控指标
- API响应时间
- 数据库查询性能
- 内存使用情况
- 错误率统计

### 8.3 日志记录
- 用户操作日志
- 系统错误日志
- 性能监控日志
- 安全审计日志

### 8.4 备份策略
- 数据库定期备份
- 配置文件备份
- 增量备份策略

## 9. 风险评估

### 9.1 技术风险
- **数据一致性风险**：节点删除时子节点和文档的清理
  - 缓解措施：实现软删除和级联清理机制
- **性能风险**：大型项目树构建性能问题
  - 缓解措施：实现懒加载和分页机制
- **并发风险**：多用户同时操作同一项目
  - 缓解措施：实现乐观锁机制

### 9.2 业务风险
- **数据丢失风险**：用户误删重要项目或文档
  - 缓解措施：实现回收站功能和数据恢复机制
- **权限风险**：未授权用户访问他人项目
  - 缓解措施：严格的权限验证和审计日志

### 9.3 运维风险
- **存储风险**：文档内容存储空间不足
  - 缓解措施：实现文档压缩和云存储迁移
- **备份风险**：数据备份失败或恢复困难
  - 缓解措施：多重备份策略和定期恢复测试

## 10. 实施计划

### 10.1 开发阶段
1. **第一阶段**（1-2周）：基础数据模型和项目管理API开发
2. **第二阶段**（2-3周）：节点管理和树形结构功能
3. **第三阶段**（1-2周）：文档管理和路径操作功能
4. **第四阶段**（1周）：安全加固和性能优化
5. **第五阶段**（1周）：测试和文档完善

### 10.2 测试阶段
- 单元测试：与开发并行进行
- 集成测试：第四阶段完成后
- 用户验收测试：第五阶段

### 10.3 上线计划
- 灰度发布：先向部分用户开放
- 全量发布：灰度测试通过后
- 监控和优化：上线后持续进行

### 10.4 里程碑
- M1：项目管理功能完成
- M2：节点管理功能完成
- M3：文档管理功能完成
- M4：测试和优化完成
- M5：正式上线
