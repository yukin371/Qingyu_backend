# 文档版本管理

## 设计概述

本版本控制系统支持单文件版本管理和批量提交功能，能够一次性修改多个文件并形成一个统一的历史提交记录。

## 数据模型

### 1) 核心模型（基于现有 version.go）

```go
// 文档模型（增加CurrentCommitID字段）
type Document struct {
    ...
    CurrentCommitID string                 `bson:"current_commit_id,omitempty" json:"currentCommitId,omitempty"` // 当前最新提交ID
}

// 提交记录 - 新增模型，支持批量提交
type Commit struct {
    ID        string                 `bson:"_id,omitempty" json:"id"`
    ProjectID string                 `bson:"project_id" json:"projectId"`
    AuthorID  string                 `bson:"author_id" json:"authorId"` // 用户ID或"ai"
    Message   string                 `bson:"message" json:"message"`    // 提交说明
    Files     []string               `bson:"files" json:"files"`        // 本次提交涉及的文件NodeID列表
    ParentCommit string              `bson:"parent_commit,omitempty" json:"parentCommit,omitempty"` // 父提交ID
    Metadata  map[string]interface{} `bson:"metadata,omitempty" json:"metadata,omitempty"` // AI模型信息等
    CreatedAt time.Time              `bson:"created_at" json:"createdAt"`
}

// 文件修订记录（改进版）
type FileRevision struct {
    ID            string                 `bson:"_id,omitempty" json:"id"`
    ProjectID     string                 `bson:"project_id" json:"projectId"`
    NodeID        string                 `bson:"node_id" json:"nodeId"`
    CommitID      string                 `bson:"commit_id" json:"commitId"`      // 关联的提交ID
    Version       int                    `bson:"version" json:"version"`         // 文件版本号（从1开始）
    AuthorID      string                 `bson:"author_id" json:"authorId"`      // 用户ID或"ai"
    Message       string                 `bson:"message,omitempty" json:"message,omitempty"` // 文件级别的说明
    Snapshot      string                 `bson:"snapshot,omitempty" json:"snapshot,omitempty"` // 全文快照
    ParentVersion int                    `bson:"parent_version" json:"parentVersion"` // 前一个版本号
    StorageRef    string                 `bson:"storage_ref,omitempty" json:"storageRef,omitempty"` // 外部存储引用
    Compressed    bool                   `bson:"compressed,omitempty" json:"compressed,omitempty"`  // 是否压缩
    Metadata      map[string]interface{} `bson:"metadata,omitempty" json:"metadata,omitempty"`
    CreatedAt     time.Time              `bson:"created_at" json:"createdAt"`
}

// 补丁/候选变更
type FilePatch struct {
    ID          string                 `bson:"_id,omitempty" json:"id"`
    ProjectID   string                 `bson:"project_id" json:"projectId"`
    NodeID      string                 `bson:"node_id" json:"nodeId"`
    BaseVersion int                    `bson:"base_version" json:"baseVersion"`
    DiffFormat  string                 `bson:"diff_format" json:"diffFormat"`    // unified|json-patch
    DiffPayload string                 `bson:"diff_payload" json:"diffPayload"`  // 原始diff内容
    CreatedBy   string                 `bson:"created_by" json:"createdBy"`      // ai|user:ID
    Status      string                 `bson:"status" json:"status"`             // pending|approved|rejected|applied
    Preview     string                 `bson:"preview,omitempty" json:"preview,omitempty"` // 预览合并结果
    Metadata    map[string]interface{} `bson:"metadata,omitempty" json:"metadata,omitempty"`
    CreatedAt   time.Time              `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time              `bson:"updated_at" json:"updatedAt"`
}
```

### 2) 批量提交支持

**核心特性：**

- 支持一次性修改多个文件形成一个历史提交
- 每个提交记录包含多个文件的修订
- 保持文件级别的版本号独立递增
- 提供项目级别的提交历史视图

**实现策略：**

1. **原子性提交**：使用MongoDB事务确保批量操作的原子性
2. **版本一致性**：每个文件维护独立的版本号，但共享同一个提交ID
3. **冲突检测**：在提交前检查所有涉及文件的版本冲突
4. **回滚支持**：可以回滚整个提交或单个文件

## 存储策略

### 阶段化实现（从简单到复杂）

**初期（快照存储）：**

- 每次提交保存完整文件快照
- 在 `documents` 集合记录当前内容与版本号
- `file_revisions` 保存历史快照，按 `project_id, node_id, version` 建索引
- `commits` 集合记录批量提交信息

**中期（差异存储）：**

- 保存 diff 到 `file_patches`，周期性生成基线快照
- 支持增量快照和对象存储引用
- 优化存储空间使用

**长期（大规模）：**

- 使用对象存储（S3/兼容服务）保存大文本快照
- 支持分片和按需拉取
- 实现智能压缩和去重

## 并发与冲突处理

### 1) 乐观并发控制

- 客户端提交时携带 `expectedVersions`（每个文件的期望版本）
- 服务端使用原子更新检查版本匹配
- 支持部分成功提交（某些文件成功，某些冲突）

### 2) 批量冲突处理

```go
type BatchCommitRequest struct {
    ProjectID        string                    `json:"projectId"`
    AuthorID         string                    `json:"authorId"`
    Message          string                    `json:"message"`
    Files            []FileChange              `json:"files"`
    ConflictStrategy string                    `json:"conflictStrategy"` // abort|partial|patch
}

type FileChange struct {
    NodeID          string `json:"nodeId"`
    Content         string `json:"content"`
    ExpectedVersion int    `json:"expectedVersion"`
    Message         string `json:"message,omitempty"` // 文件级别说明
}
```

### 3) 冲突解决策略

- **abort**: 任何文件冲突则整个提交失败
- **partial**: 成功的文件提交，冲突的文件返回错误
- **patch**: 冲突文件自动创建补丁等待审核

## API 设计

### 1) 批量提交相关API

> **POST /api/v1/document/commit**

- 描述：批量提交多个文件的修改
- 请求体：

```json
{
    "projectId": "string",
    "authorId": "string", 
    "message": "string",
    "conflictStrategy": "abort|partial|patch",
    "files": [
        {
            "nodeId": "string",
            "content": "string", 
            "expectedVersion": 1,
            "message": "string"
        }
    ]
}
```

- 响应：提交记录或冲突错误

> **GET /api/v1/document/project/:projectId/commits**

- 描述：获取项目的提交历史
- 查询参数：limit, offset, author
- 响应：提交列表

> **GET /api/v1/document/commit/:commitId**

- 描述：获取特定提交的详细信息
- 响应：提交详情及包含的文件列表

> **POST /api/v1/document/commit/:commitId/rollback**

- 描述：回滚整个提交
- 请求体：`{ "authorId": "string", "message": "string" }`

### 2) 单文件版本管理API

> **POST /api/v1/document/:nodeId/version**

- 描述：创建单个文件的新版本
- 请求体：`{ "authorId": "string", "message": "string", "content": "string", "expectedVersion": 1 }`
- 响应：新版本信息或冲突错误

> **GET /api/v1/document/:nodeId/versions**

- 描述：获取文件的版本历史
- 查询参数：limit, offset
- 响应：版本列表

> **GET /api/v1/document/:nodeId/version/:version**

- 描述：获取文件的特定版本内容
- 响应：版本详情和内容

> **POST /api/v1/document/:nodeId/rollback**

- 描述：回滚文件到指定版本
- 请求体：`{ "authorId": "string", "targetVersion": 1, "message": "string" }`

### 3) 补丁管理API

> **POST /api/v1/document/:nodeId/patch**

- 描述：提交候选补丁
- 请求体：`{ "authorId": "string", "baseVersion": 1, "diffFormat": "unified", "diffPayload": "string", "message": "string" }`

> **GET /api/v1/document/project/:projectId/patches**

- 描述：获取项目的待审核补丁
- 查询参数：status, limit, offset
- 响应：补丁列表

> **POST /api/v1/document/patch/:patchId/apply**

- 描述：应用补丁（需要管理员权限）
- 请求体：`{ "authorId": "string", "message": "string" }`

> **GET /api/v1/document/:nodeId/diff**

- 描述：比较两个版本的差异
- 查询参数：from, to, format
- 响应：差异内容

### 4) 错误码定义

| 错误码 | 描述 | HTTP状态码 |
|--------|------|------------|
| 200 | 操作成功 | 200 |
| 409 | 版本冲突 | 409 |
| 404 | 文档或版本不存在 | 404 |
| 400 | 请求参数错误 | 400 |
| 403 | 权限不足 | 403 |
| 500 | 服务端错误 | 500 |

## 索引与性能优化

### 1) MongoDB 索引策略

**核心索引：**

```javascript
// 提交记录索引
db.commits.createIndex({ "project_id": 1, "created_at": -1 })
db.commits.createIndex({ "project_id": 1, "author_id": 1, "created_at": -1 })

// 文件修订索引  
db.file_revisions.createIndex({ "project_id": 1, "node_id": 1, "version": -1 })
db.file_revisions.createIndex({ "project_id": 1, "node_id": 1, "created_at": -1 })
db.file_revisions.createIndex({ "commit_id": 1 })

// 补丁索引
db.file_patches.createIndex({ "project_id": 1, "node_id": 1, "status": 1, "created_at": -1 })
db.file_patches.createIndex({ "project_id": 1, "status": 1, "created_at": -1 })

// 文档当前版本索引
db.documents.createIndex({ "project_id": 1, "node_id": 1 }, { unique: true })
```

### 2) 分页策略

- **小数据量**：使用 `limit/skip`
- **大数据量**：基于 `created_at` 或 `version` 的游标分页
- **提交历史**：按时间倒序分页，支持作者筛选

### 3) 缓存策略

- 热点文件的最新版本内容缓存
- 项目提交历史的分页缓存
- 文件版本列表缓存

## 数据保留与归档

### 1) 保留策略（可配置）

```go
type RetentionPolicy struct {
    MaxVersions    int           `json:"maxVersions"`    // 最大保留版本数
    MaxAge         time.Duration `json:"maxAge"`         // 最大保留时间
    PermanentTags  []string      `json:"permanentTags"`  // 永久保留标签
    ArchiveEnabled bool          `json:"archiveEnabled"` // 是否启用归档
}
```

### 2) 归档机制

- **基本策略**：保留最近 N 个版本或 M 个月的版本
- **标记保留**：支持标记重要版本为永久保留
- **外部存储**：归档前将快照上传到对象存储
- **清理任务**：定期后台任务处理过期版本

### 3) 备份与恢复

- **数据库备份**：结合 MongoDB 定期备份
- **对象存储备份**：备份外部存储的快照数据
- **增量备份**：支持基于时间点的增量备份

## 权限与审计

### 1) 权限控制

```go
type VersionPermission struct {
    UserID      string   `json:"userId"`
    ProjectID   string   `json:"projectId"`
    Permissions []string `json:"permissions"` // read, write, admin
}

// 权限检查
const (
    PermissionRead  = "read"   // 读取版本历史
    PermissionWrite = "write"  // 创建版本、提交
    PermissionAdmin = "admin"  // 应用补丁、管理版本
)
```

### 2) 审计日志

- 记录所有版本操作的详细信息
- 包含用户ID、IP地址、操作类型、时间戳
- 支持审计日志的查询和导出

### 3) 补丁审批流程

- **提交者**：创建 `pending` 状态的补丁
- **审核者**：具有 `admin` 权限的用户审核
- **自动审核**：基于规则的自动审核（如AI生成的小幅修改）

## 实现优先级

### Phase 1: 基础版本控制

- [ ] 实现 `Commit` 和改进的 `FileRevision` 模型
- [ ] 基础的单文件版本管理API
- [ ] 快照存储策略
- [ ] 基本的冲突检测

### Phase 2: 批量提交

- [ ] 批量提交API实现
- [ ] MongoDB事务支持
- [ ] 批量冲突处理
- [ ] 提交历史查询

### Phase 3: 高级功能

- [ ] 补丁系统完善
- [ ] 差异存储优化
- [ ] 权限和审计系统
- [ ] 性能优化和缓存

## 设计决策

### 为什么选择这种设计？

1. **快照式存储优先**
   - 初期采用快照式实现以降低实现复杂度并保证数据完整性
   - 简单可靠，便于调试和故障恢复
   - 为后续差异存储优化预留接口

2. **乐观并发控制**
   - 使用 `expectedVersion` 避免复杂的分布式锁
   - 与多数现代编辑器交互方式一致
   - 提供更好的用户体验和性能

3. **批量提交支持**
   - **原子性**：多文件修改要么全部成功，要么全部失败
   - **一致性**：保证项目状态的逻辑一致性
   - **可追溯性**：完整的变更历史记录
   - **协作友好**：支持团队协作的工作流

4. **补丁系统设计**
   - 设计中保留 diff/patch 的抽象以便未来支持协同编辑
   - 支持 AI 自动提议与人工审核两种工作流
   - 提供灵活的审批和应用机制

5. **分阶段实现**
   - 优先实现核心功能，逐步完善高级特性
   - 保证系统的可扩展性和向后兼容性
   - 降低开发风险和复杂度

## 技术实现指南

### 1) 数据库事务处理

```go
// 批量提交的事务处理示例
func (s *VersionService) CreateCommit(ctx context.Context, req *CreateCommitRequest) error {
    session, err := s.db.StartSession()
    if err != nil {
        return err
    }
    defer session.EndSession(ctx)
    
    return mongo.WithSession(ctx, session, func(sc mongo.SessionContext) error {
        // 1. 验证所有文件的 expectedVersion
        for _, change := range req.Changes {
            if err := s.validateVersion(sc, change); err != nil {
                return err
            }
        }
        
        // 2. 创建提交记录
        commit := &Commit{
            ID:        primitive.NewObjectID(),
            ProjectID: req.ProjectID,
            AuthorID:  req.AuthorID,
            Message:   req.Message,
            CreatedAt: time.Now(),
        }
        if err := s.createCommit(sc, commit); err != nil {
            return err
        }
        
        // 3. 创建文件修订记录
        for _, change := range req.Changes {
            revision := &FileRevision{
                ID:        primitive.NewObjectID(),
                CommitID:  commit.ID,
                ProjectID: req.ProjectID,
                NodeID:    change.NodeID,
                Version:   change.NewVersion,
                Content:   change.Content,
                CreatedAt: time.Now(),
            }
            if err := s.createRevision(sc, revision); err != nil {
                return err
            }
        }
        
        // 4. 更新文档当前版本
        for _, change := range req.Changes {
            if err := s.updateDocumentVersion(sc, change); err != nil {
                return err
            }
        }
        
        return nil
    })
}
```

### 2) 冲突检测与处理

```go
type ConflictResolver struct {
    strategy ConflictStrategy
}

type ConflictStrategy int

const (
    StrategyReject ConflictStrategy = iota  // 拒绝冲突的修改
    StrategyMerge                           // 尝试自动合并
    StrategyOverwrite                       // 强制覆盖
)

func (r *ConflictResolver) ResolveConflicts(conflicts []FileConflict) (*Resolution, error) {
    switch r.strategy {
    case StrategyReject:
        return &Resolution{Success: false, Conflicts: conflicts}, nil
    case StrategyMerge:
        return r.attemptAutoMerge(conflicts)
    case StrategyOverwrite:
        return &Resolution{Success: true, Overwritten: true}, nil
    default:
        return nil, errors.New("unknown conflict strategy")
    }
}
```

### 3) 性能优化建议

- **连接池**：合理配置 MongoDB 连接池大小
- **批量操作**：使用 `BulkWrite` 进行批量数据库操作
- **索引优化**：根据查询模式创建合适的复合索引
- **缓存策略**：对热点数据进行适当缓存
- **分页优化**：大数据量查询使用游标分页

## 总结

本版本控制系统设计支持**一次修改多个文件形成一个历史提交**，主要特性包括：

✅ **批量提交支持**：通过 `Commit` 模型实现多文件原子性提交  
✅ **事务保证**：使用 MongoDB 事务确保数据一致性  
✅ **冲突处理**：完善的冲突检测和解决机制  
✅ **版本追溯**：完整的变更历史和回滚能力  
✅ **权限控制**：细粒度的权限管理和审计日志  
✅ **性能优化**：合理的索引策略和缓存机制  
✅ **可扩展性**：分阶段实现，支持未来功能扩展  

该设计与项目现有结构完全兼容，可以逐步实施，优先实现核心功能后再完善高级特性。

## 关联文档
- 软件需求规格说明书(SRS) ../软件需求规格说明书(SRS).md
- 架构设计说明书 ../架构设计说明书.md
- API 接口总览 ../API接口总览.md
- 数据库设计说明书 ../数据库设计说明书.md
- 测试计划与用例 ../测试计划与用例.md
- 部署与运维指南 ../部署与运维指南.md
- 安全设计与威胁建模 ../安全设计与威胁建模.md
- 日志与监控 ../日志与监控.md
- 需求追踪矩阵 ../需求追踪矩阵.md
