# 内容审核规则引擎设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ✅ 已实现，补充设计文档

---

## 1. 为什么需要这个设计

### 1.1 业务背景

规则引擎是内容审核系统的核心组件，负责：
- 灵活配置和管理审核规则
- 支持多种类型的检测规则（正则、长度、频率等）
- 规则的动态添加、删除和启用/禁用
- 规则优先级管理
- 扩展性强，支持自定义规则

### 1.2 实际实现情况

规则引擎已完整实现，包含：
- **RuleEngine**: 规则引擎核心，管理所有规则
- **Rule接口**: 统一的规则接口定义
- **内置规则**: RegexRule, LengthRule, FrequencyRule等7种规则
- **规则优先级**: 支持规则优先级排序
- **规则启用控制**: 可动态启用/禁用规则

**实现文件**：
- `service/audit/rule_engine.go` - 规则引擎实现
- `service/audit/content_audit_service.go` - 使用规则引擎的审核服务

---

## 2. 架构设计

### 2.1 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                  ContentAuditService                     │
│  ┌────────────────────────────────────────────────────┐ │
│  │              DFA Filter (敏感词)                    │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────┐ │
│  │              RuleEngine (规则引擎)                  │ │
│  │  ┌──────────┬───────────┬────────────┬──────────┐ │ │
│  │  │RegexRule │LengthRule │FrequencyRule│URLRule   │ │ │
│  │  └──────────┴───────────┴────────────┴──────────┘ │ │
│  │  ┌──────────┬───────────┬────────────┐            │ │
│  │  │PhoneRule │EmailRule  │QQWeChatRule│            │ │
│  │  └──────────┴───────────┴────────────┘            │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓
                   Violations (违规列表)
```

### 2.2 组件职责

| 组件 | 职责 |
|------|------|
| RuleEngine | 管理所有规则，执行规则检查，收集违规结果 |
| Rule接口 | 定义统一的规则行为接口 |
| 具体规则实现 | 实现特定的检测逻辑（正则、长度等） |
| ContentAuditService | 调用规则引擎，整合检测结果 |

---

## 3. 核心接口设计

### 3.1 Rule接口

```go
// Rule 审核规则接口
type Rule interface {
    // Check 检查内容，返回违规详情列表
    Check(content string) []audit.ViolationDetail
    
    // GetName 获取规则名称
    GetName() string
    
    // GetPriority 获取规则优先级（数字越大优先级越高）
    GetPriority() int
    
    // IsEnabled 是否启用
    IsEnabled() bool
}
```

### 3.2 RuleEngine结构

```go
type RuleEngine struct {
    rules []Rule  // 规则列表
}

// NewRuleEngine 创建规则引擎
func NewRuleEngine() *RuleEngine {
    return &RuleEngine{
        rules: make([]Rule, 0),
    }
}

// AddRule 添加规则
func (e *RuleEngine) AddRule(rule Rule)

// RemoveRule 移除规则
func (e *RuleEngine) RemoveRule(name string)

// Check 检查内容
func (e *RuleEngine) Check(content string) []audit.ViolationDetail

// GetRules 获取所有规则
func (e *RuleEngine) GetRules() []Rule
```

---

## 4. 内置规则实现

### 4.1 RegexRule（正则表达式规则）

#### 4.1.1 结构定义

```go
type RegexRule struct {
    Name        string
    Description string
    Pattern     *regexp.Regexp  // 正则表达式模式
    Category    string           // 违规分类
    Level       int              // 严重等级
    Enabled     bool
    Priority    int
}
```

#### 4.1.2 检测逻辑

```go
func (r *RegexRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)

    matches := r.Pattern.FindAllStringIndex(content, -1)
    for _, match := range matches {
        violation := audit.ViolationDetail{
            Type:        "regex_match",
            Category:    r.Category,
            Level:       r.Level,
            Description: r.Description,
            Position:    match[0],
            Context:     extractContext(content, match[0], match[1]),
            Keywords:    []string{content[match[0]:match[1]]},
        }
        violations = append(violations, violation)
    }

    return violations
}
```

#### 4.1.3 使用示例

```go
// 检测连续多个问号（可能是恶意）
questionRule := &RegexRule{
    Name:        "excessive_questions",
    Description: "连续问号过多",
    Pattern:     regexp.MustCompile(`\?{3,}`),
    Category:    "spam",
    Level:       2,
    Enabled:     true,
    Priority:    50,
}
ruleEngine.AddRule(questionRule)
```

---

### 4.2 LengthRule（长度规则）

#### 4.2.1 结构定义

```go
type LengthRule struct {
    Name        string
    Description string
    MinLength   int   // 最小长度
    MaxLength   int   // 最大长度
    Category    string
    Level       int
    Enabled     bool
    Priority    int
}
```

#### 4.2.2 检测逻辑

```go
func (r *LengthRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    length := len([]rune(content))  // 使用rune计数，支持中文
    
    if r.MinLength > 0 && length < r.MinLength {
        violations = append(violations, audit.ViolationDetail{
            Type:        "length_violation",
            Category:    r.Category,
            Level:       r.Level,
            Description: fmt.Sprintf("%s (最小长度: %d, 实际: %d)", r.Description, r.MinLength, length),
        })
    }
    
    if r.MaxLength > 0 && length > r.MaxLength {
        violations = append(violations, audit.ViolationDetail{
            Type:        "length_violation",
            Category:    r.Category,
            Level:       r.Level,
            Description: fmt.Sprintf("%s (最大长度: %d, 实际: %d)", r.Description, r.MaxLength, length),
        })
    }
    
    return violations
}
```

#### 4.2.3 使用示例

```go
// 检测过短内容
minLengthRule := &LengthRule{
    Name:        "min_content_length",
    Description: "内容过短",
    MinLength:   10,
    MaxLength:   0,  // 0表示不限制
    Category:    "quality",
    Level:       1,
    Enabled:     true,
    Priority:    30,
}
ruleEngine.AddRule(minLengthRule)
```

---

### 4.3 FrequencyRule（频率规则）

检测重复词汇过多。

#### 4.3.1 结构定义

```go
type FrequencyRule struct {
    Name          string
    Description   string
    MaxFrequency  float64  // 最大重复频率 (0-1)
    MinWordLength int      // 最小词长
    Category      string
    Level         int
    Enabled       bool
    Priority      int
}
```

#### 4.3.2 检测逻辑

```go
func (r *FrequencyRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    // 分词并统计
    words := segmentWords(content)
    totalWords := len(words)
    if totalWords == 0 {
        return violations
    }
    
    wordCount := make(map[string]int)
    for _, word := range words {
        if len([]rune(word)) >= r.MinWordLength {
            wordCount[word]++
        }
    }
    
    // 检查频率
    for word, count := range wordCount {
        frequency := float64(count) / float64(totalWords)
        if frequency > r.MaxFrequency {
            violations = append(violations, audit.ViolationDetail{
                Type:        "frequency_violation",
                Category:    r.Category,
                Level:       r.Level,
                Description: fmt.Sprintf("%s (词汇: %s, 频率: %.2f%%)", r.Description, word, frequency*100),
                Keywords:    []string{word},
            })
        }
    }
    
    return violations
}
```

---

### 4.4 URLRule（URL检测规则）

检测内容中的URL链接。

#### 4.4.1 结构定义

```go
type URLRule struct {
    Name        string
    Description string
    Category    string
    Level       int
    Enabled     bool
    Priority    int
}
```

#### 4.4.2 检测逻辑

```go
func (r *URLRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    // URL正则表达式
    urlPattern := regexp.MustCompile(`https?://[^\s]+|www\.[^\s]+`)
    matches := urlPattern.FindAllStringIndex(content, -1)
    
    for _, match := range matches {
        url := content[match[0]:match[1]]
        violations = append(violations, audit.ViolationDetail{
            Type:        "url_detected",
            Category:    r.Category,
            Level:       r.Level,
            Description: r.Description,
            Position:    match[0],
            Context:     extractContext(content, match[0], match[1]),
            Keywords:    []string{url},
        })
    }
    
    return violations
}
```

---

### 4.5 PhoneRule（电话号码检测规则）

#### 4.5.1 检测逻辑

```go
func (r *PhoneRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    // 手机号正则（支持中国大陆、港澳台等）
    phonePatterns := []*regexp.Regexp{
        regexp.MustCompile(`1[3-9]\d{9}`),           // 中国大陆
        regexp.MustCompile(`\d{3}-\d{4}-\d{4}`),     // 带分隔符
        regexp.MustCompile(`\+86\s?\d{11}`),         // 带国家代码
    }
    
    for _, pattern := range phonePatterns {
        matches := pattern.FindAllStringIndex(content, -1)
        for _, match := range matches {
            phone := content[match[0]:match[1]]
            violations = append(violations, audit.ViolationDetail{
                Type:        "phone_detected",
                Category:    r.Category,
                Level:       r.Level,
                Description: r.Description,
                Position:    match[0],
                Context:     extractContext(content, match[0], match[1]),
                Keywords:    []string{phone},
            })
        }
    }
    
    return violations
}
```

---

### 4.6 EmailRule（邮箱检测规则）

#### 4.6.1 检测逻辑

```go
func (r *EmailRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    // 邮箱正则
    emailPattern := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
    matches := emailPattern.FindAllStringIndex(content, -1)
    
    for _, match := range matches {
        email := content[match[0]:match[1]]
        violations = append(violations, audit.ViolationDetail{
            Type:        "email_detected",
            Category:    r.Category,
            Level:       r.Level,
            Description: r.Description,
            Position:    match[0],
            Context:     extractContext(content, match[0], match[1]),
            Keywords:    []string{email},
        })
    }
    
    return violations
}
```

---

### 4.7 QQWeChatRule（QQ/微信号检测规则）

#### 4.7.1 检测逻辑

```go
func (r *QQWeChatRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    // QQ号正则（5-11位数字）
    qqPattern := regexp.MustCompile(`(?i)qq[:：]?\s*\d{5,11}`)
    qqMatches := qqPattern.FindAllStringIndex(content, -1)
    
    for _, match := range qqMatches {
        qq := content[match[0]:match[1]]
        violations = append(violations, audit.ViolationDetail{
            Type:        "contact_detected",
            Category:    r.Category,
            Level:       r.Level,
            Description: "检测到QQ号",
            Position:    match[0],
            Context:     extractContext(content, match[0], match[1]),
            Keywords:    []string{qq},
        })
    }
    
    // 微信号正则
    wechatPattern := regexp.MustCompile(`(?i)(?:微信|wechat|wx)[:：]?\s*[a-zA-Z0-9_-]{6,20}`)
    wechatMatches := wechatPattern.FindAllStringIndex(content, -1)
    
    for _, match := range wechatMatches {
        wechat := content[match[0]:match[1]]
        violations = append(violations, audit.ViolationDetail{
            Type:        "contact_detected",
            Category:    r.Category,
            Level:       r.Level,
            Description: "检测到微信号",
            Position:    match[0],
            Context:     extractContext(content, match[0], match[1]),
            Keywords:    []string{wechat},
        })
    }
    
    return violations
}
```

---

## 5. 规则管理

### 5.1 规则添加和删除

```go
// 添加规则
func (e *RuleEngine) AddRule(rule Rule) {
    e.rules = append(e.rules, rule)
}

// 删除规则
func (e *RuleEngine) RemoveRule(name string) {
    newRules := make([]Rule, 0)
    for _, rule := range e.rules {
        if rule.GetName() != name {
            newRules = append(newRules, rule)
        }
    }
    e.rules = newRules
}

// 获取所有规则
func (e *RuleEngine) GetRules() []Rule {
    return e.rules
}
```

### 5.2 规则执行

```go
// Check 检查内容
func (e *RuleEngine) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)

    for _, rule := range e.rules {
        // 跳过禁用的规则
        if !rule.IsEnabled() {
            continue
        }

        // 执行规则检查
        ruleViolations := rule.Check(content)
        violations = append(violations, ruleViolations...)
    }

    return violations
}
```

### 5.3 规则优先级排序

```go
// SortRulesByPriority 按优先级排序规则
func (e *RuleEngine) SortRulesByPriority() {
    sort.Slice(e.rules, func(i, j int) bool {
        return e.rules[i].GetPriority() > e.rules[j].GetPriority()
    })
}
```

---

## 6. 默认规则加载

```go
// loadDefaultRules 加载默认规则
func (s *ContentAuditService) loadDefaultRules() {
    // 1. URL检测
    s.ruleEngine.AddRule(&URLRule{
        Name:        "url_detection",
        Description: "检测到URL链接",
        Category:    "ad",
        Level:       2,
        Enabled:     true,
        Priority:    70,
    })
    
    // 2. 电话号码检测
    s.ruleEngine.AddRule(&PhoneRule{
        Name:        "phone_detection",
        Description: "检测到电话号码",
        Category:    "ad",
        Level:       2,
        Enabled:     true,
        Priority:    70,
    })
    
    // 3. 邮箱检测
    s.ruleEngine.AddRule(&EmailRule{
        Name:        "email_detection",
        Description: "检测到邮箱地址",
        Category:    "ad",
        Level:       2,
        Enabled:     true,
        Priority:    70,
    })
    
    // 4. QQ/微信检测
    s.ruleEngine.AddRule(&QQWeChatRule{
        Name:        "contact_detection",
        Description: "检测到联系方式",
        Category:    "ad",
        Level:       3,
        Enabled:     true,
        Priority:    80,
    })
    
    // 5. 内容长度检查
    s.ruleEngine.AddRule(&LengthRule{
        Name:        "min_length_check",
        Description: "内容过短",
        MinLength:   10,
        Category:    "quality",
        Level:       1,
        Enabled:     true,
        Priority:    30,
    })
    
    // 6. 重复词汇检查
    s.ruleEngine.AddRule(&FrequencyRule{
        Name:          "word_frequency_check",
        Description:   "重复词汇过多",
        MaxFrequency:  0.3,  // 30%
        MinWordLength: 2,
        Category:      "spam",
        Level:         2,
        Enabled:       true,
        Priority:      50,
    })
    
    // 7. 连续标点检查
    s.ruleEngine.AddRule(&RegexRule{
        Name:        "excessive_punctuation",
        Description: "连续标点过多",
        Pattern:     regexp.MustCompile(`[!！?？。，,]{5,}`),
        Category:    "spam",
        Level:       2,
        Enabled:     true,
        Priority:    40,
    })
}
```

---

## 7. 规则扩展

### 7.1 自定义规则示例

```go
// CustomKeywordRule 自定义关键词规则
type CustomKeywordRule struct {
    Name        string
    Description string
    Keywords    []string  // 关键词列表
    Category    string
    Level       int
    Enabled     bool
    Priority    int
}

func (r *CustomKeywordRule) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)
    
    contentLower := strings.ToLower(content)
    for _, keyword := range r.Keywords {
        keywordLower := strings.ToLower(keyword)
        index := strings.Index(contentLower, keywordLower)
        
        if index != -1 {
            violations = append(violations, audit.ViolationDetail{
                Type:        "keyword_match",
                Category:    r.Category,
                Level:       r.Level,
                Description: r.Description,
                Position:    index,
                Context:     extractContext(content, index, index+len(keyword)),
                Keywords:    []string{keyword},
            })
        }
    }
    
    return violations
}

func (r *CustomKeywordRule) GetName() string {
    return r.Name
}

func (r *CustomKeywordRule) GetPriority() int {
    return r.Priority
}

func (r *CustomKeywordRule) IsEnabled() bool {
    return r.Enabled
}
```

### 7.2 使用自定义规则

```go
// 添加自定义规则
customRule := &CustomKeywordRule{
    Name:        "brand_keywords",
    Description: "检测到品牌关键词",
    Keywords:    []string{"淘宝", "京东", "拼多多"},
    Category:    "ad",
    Level:       2,
    Enabled:     true,
    Priority:    60,
}
ruleEngine.AddRule(customRule)
```

---

## 8. 性能优化

### 8.1 规则缓存

```go
type RuleEngine struct {
    rules         []Rule
    enabledRules  []Rule  // 缓存启用的规则
    lastUpdate    time.Time
}

// RefreshEnabledRules 刷新启用的规则缓存
func (e *RuleEngine) RefreshEnabledRules() {
    enabledRules := make([]Rule, 0)
    for _, rule := range e.rules {
        if rule.IsEnabled() {
            enabledRules = append(enabledRules, rule)
        }
    }
    e.enabledRules = enabledRules
    e.lastUpdate = time.Now()
}

// Check 使用缓存的启用规则
func (e *RuleEngine) Check(content string) []audit.ViolationDetail {
    violations := make([]audit.ViolationDetail, 0)

    for _, rule := range e.enabledRules {
        ruleViolations := rule.Check(content)
        violations = append(violations, ruleViolations...)
    }

    return violations
}
```

### 8.2 并发检测

```go
// CheckConcurrent 并发检测
func (e *RuleEngine) CheckConcurrent(content string) []audit.ViolationDetail {
    violationsChan := make(chan []audit.ViolationDetail, len(e.enabledRules))
    var wg sync.WaitGroup

    for _, rule := range e.enabledRules {
        wg.Add(1)
        go func(r Rule) {
            defer wg.Done()
            ruleViolations := r.Check(content)
            if len(ruleViolations) > 0 {
                violationsChan <- ruleViolations
            }
        }(rule)
    }

    go func() {
        wg.Wait()
        close(violationsChan)
    }()

    // 收集所有违规结果
    violations := make([]audit.ViolationDetail, 0)
    for ruleViolations := range violationsChan {
        violations = append(violations, ruleViolations...)
    }

    return violations
}
```

---

## 9. 与v2.1架构的关系

### 9.1 在审核系统中的位置

```
ContentAuditService
  ├─ DFAFilter (敏感词检测)
  └─ RuleEngine (规则引擎)
      ├─ RegexRule
      ├─ LengthRule
      ├─ FrequencyRule
      ├─ URLRule
      ├─ PhoneRule
      ├─ EmailRule
      └─ QQWeChatRule
```

### 9.2 与其他组件的协作

1. **DFAFilter**: 专门检测敏感词
2. **RuleEngine**: 检测其他违规内容
3. **ContentAuditService**: 整合两者的检测结果

---

## 10. 未来扩展

### 10.1 规则配置化

```go
// RuleConfig 规则配置
type RuleConfig struct {
    ID          string                 `bson:"_id,omitempty" json:"id"`
    Name        string                 `bson:"name" json:"name"`
    Type        string                 `bson:"type" json:"type"`  // regex/length/frequency等
    Config      map[string]interface{} `bson:"config" json:"config"`
    Category    string                 `bson:"category" json:"category"`
    Level       int                    `bson:"level" json:"level"`
    IsEnabled   bool                   `bson:"isEnabled" json:"isEnabled"`
    Priority    int                    `bson:"priority" json:"priority"`
    CreatedAt   time.Time              `bson:"createdAt" json:"createdAt"`
    UpdatedAt   time.Time              `bson:"updatedAt" json:"updatedAt"`
}

// LoadRulesFromConfig 从配置加载规则
func (e *RuleEngine) LoadRulesFromConfig(configs []RuleConfig) error {
    for _, config := range configs {
        rule, err := createRuleFromConfig(config)
        if err != nil {
            return err
        }
        e.AddRule(rule)
    }
    return nil
}
```

### 10.2 规则版本化

```go
type RuleVersion struct {
    RuleID    string    `bson:"ruleId" json:"ruleId"`
    Version   int       `bson:"version" json:"version"`
    Config    RuleConfig `bson:"config" json:"config"`
    CreatedAt time.Time `bson:"createdAt" json:"createdAt"`
    CreatedBy string    `bson:"createdBy" json:"createdBy"`
}
```

### 10.3 ML模型规则

```go
// MLModelRule ML模型规则
type MLModelRule struct {
    Name        string
    Description string
    ModelID     string     // ML模型ID
    Threshold   float64    // 置信度阈值
    Category    string
    Level       int
    Enabled     bool
    Priority    int
}

func (r *MLModelRule) Check(content string) []audit.ViolationDetail {
    // 调用ML模型API
    prediction, confidence, err := callMLModel(r.ModelID, content)
    if err != nil {
        return []audit.ViolationDetail{}
    }
    
    if confidence > r.Threshold {
        return []audit.ViolationDetail{{
            Type:        "ml_model_prediction",
            Category:    r.Category,
            Level:       r.Level,
            Description: fmt.Sprintf("%s (置信度: %.2f%%)", prediction, confidence*100),
        }}
    }
    
    return []audit.ViolationDetail{}
}
```

---

## 11. 实现参考

### 11.1 代码文件路径

- **规则引擎实现**: `service/audit/rule_engine.go`
- **使用示例**: `service/audit/content_audit_service.go`

### 11.2 关键实现特性

1. ✅ **接口驱动设计**: 统一的Rule接口
2. ✅ **可扩展性**: 轻松添加新规则
3. ✅ **规则优先级**: 支持规则优先级排序
4. ✅ **动态启用/禁用**: 可动态控制规则
5. ✅ **7种内置规则**: 覆盖常见检测场景
6. ✅ **性能优化**: 支持规则缓存和并发检测

---

**文档状态**: ✅ 已完成  
**最后审核**: 2025-10-21  
**下一次审核**: 随代码变更同步更新

