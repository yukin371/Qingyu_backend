# 配置系统设计

## 1. 需求概述

### 1.1 功能描述
配置系统是青羽写作系统的核心基础设施，负责管理应用程序的所有配置信息，包括数据库连接、服务器设置、JWT认证、AI服务配置等。系统支持多种配置源、热重载、环境变量覆盖和配置验证等功能。

### 1.2 业务价值
- **统一配置管理**：提供统一的配置接口，简化配置管理和维护
- **环境适配性**：支持不同环境（开发、测试、生产）的配置切换
- **运行时灵活性**：支持配置热重载，无需重启应用即可更新配置
- **安全性保障**：提供配置验证和敏感信息保护机制

### 1.3 用户场景
- 开发人员需要快速配置本地开发环境
- 运维人员需要在不同环境间切换配置
- 系统管理员需要动态调整系统参数
- 安全管理员需要管理敏感配置信息

### 1.4 功能边界
- **包含功能**：配置加载、验证、热重载、环境变量覆盖、多数据库支持
- **不包含功能**：配置加密存储、分布式配置中心、配置版本管理

## 2. 架构设计

### 2.1 整体架构
### 2.2 模块划分
- **配置定义模块**：定义配置结构体和类型
- **配置加载模块**：从各种源加载配置数据
- **配置验证模块**：验证配置的有效性和完整性
- **配置管理模块**：提供配置的CRUD操作和生命周期管理

## 3. 详细设计

### 3.1 配置结构设计

#### 3.1.1 主配置结构
```go
type Config struct {
    Database *DatabaseConfig     `mapstructure:"database"`
    Server   *ServerConfig       `mapstructure:"server"`
    JWT      *JWTConfig         `mapstructure:"jwt"`
    AI       *AIConfig          `mapstructure:"ai"`
    External *ExternalAPIConfig `mapstructure:"external"`
}
```

#### 3.1.2 数据库配置结构
```go
type DatabaseConfig struct {
    Type        string                 `mapstructure:"type"`
    Primary     DatabaseConnection     `mapstructure:"primary"`
    Replicas    []DatabaseConnection   `mapstructure:"replicas"`
    Indexing    IndexingConfig         `mapstructure:"indexing"`
    Validation  ValidationConfig       `mapstructure:"validation"`
    Sync        SynchronizationConfig  `mapstructure:"sync"`
}
```

#### 3.1.3 多数据库支持
支持 MongoDB、PostgreSQL、MySQL 三种数据库类型：
- **MongoDB配置**：URI、数据库名、连接池配置
- **PostgreSQL配置**：主机、端口、用户名、密码、SSL配置
- **MySQL配置**：主机、端口、字符集、连接池配置

### 3.2 配置加载机制

#### 3.2.1 配置源优先级
1. **命令行参数** (最高优先级)
2. **环境变量**
3. **配置文件**
4. **默认值** (最低优先级)

#### 3.2.2 配置文件格式
支持 YAML 格式配置文件：
```yaml
# 数据库配置
database:
  type: "mongodb"
  primary:
    mongodb:
      uri: "mongodb://localhost:27017"
      database: "qingyu"
      max_pool_size: 100
      min_pool_size: 10

# 服务器配置
server:
  port: "8080"
  mode: "debug"

# JWT配置
jwt:
  secret: "qingyu_secret_key"
  expiration_hours: 24
```

#### 3.2.3 环境变量覆盖
支持通过环境变量覆盖配置：
- 前缀：`QINGYU_`
- 分隔符：`_`
- 示例：`QINGYU_DATABASE_PRIMARY_MONGODB_URI`

### 3.3 配置验证机制

#### 3.3.1 结构验证
使用 `validator` 库进行结构验证：
```go
func ValidateConfig(cfg *Config) error {
    if err := validate.Struct(cfg); err != nil {
        return fmt.Errorf("config validation failed: %w", err)
    }
    return validateConfigDetails(cfg)
}
```

#### 3.3.2 业务逻辑验证
- **数据库配置验证**：连接字符串格式、必填字段检查
- **服务器配置验证**：端口范围、模式有效性
- **JWT配置验证**：密钥强度、过期时间合理性
- **AI配置验证**：API密钥格式、参数范围

### 3.4 配置热重载机制

#### 3.4.1 文件监听
使用 `fsnotify` 监听配置文件变化：
```go
func WatchConfig(onChange func()) {
    v.WatchConfig()
    v.OnConfigChange(func(e fsnotify.Event) {
        fmt.Println("Config file changed:", e.Name)
        if onChange != nil {
            onChange()
        }
    })
}
```

#### 3.4.2 重载处理器
支持注册多个重载处理器：
```go
func RegisterReloadHandler(name string, handler func()) {
    reloadMutex.Lock()
    defer reloadMutex.Unlock()
    reloadHandlers[name] = handler
}
```

### 3.5 配置管理器设计

#### 3.5.1 数据库配置管理器
```go
type DatabaseConfigManager struct {
    config     *DatabaseConfig
    configPath string
}

func (m *DatabaseConfigManager) UpdateConfig(config *DatabaseConfig) error
func (m *DatabaseConfigManager) EnableMigration(secondary DatabaseConnection) error
func (m *DatabaseConfigManager) EnableSync(syncConfig SynchronizationConfig) error
```

#### 3.5.2 Viper集成管理器
```go
type ViperConfigManager struct {
    viper *viper.Viper
}

func (m *ViperConfigManager) LoadFromFile(configPath string) error
func (m *ViperConfigManager) LoadDatabaseConfig() (*DatabaseConfig, error)
func (m *ViperConfigManager) WatchConfig(onChange func(*Config))
```

## 4. 技术实现

### 4.1 核心依赖
- **Viper**：配置管理库，支持多种格式和配置源
- **fsnotify**：文件系统监听库，用于配置热重载
- **validator**：结构体验证库，用于配置验证
- **yaml.v3**：YAML解析库

### 4.2 关键技术点

#### 4.2.1 mapstructure标签
使用 `mapstructure` 标签确保配置正确映射：
```go
type IndexingConfig struct {
    AutoCreate bool `yaml:"auto_create" mapstructure:"auto_create"`
    Background bool `yaml:"background" mapstructure:"background"`
}
```

#### 4.2.2 默认值设置

通过 Viper 设置默认值：
```go
func setDefaults() {
    v.SetDefault("database.primary.mongodb.max_pool_size", 100)
    v.SetDefault("database.primary.mongodb.min_pool_size", 5)
    v.SetDefault("server.port", "8080")
    v.SetDefault("server.mode", "debug")
}
```

#### 4.2.3 并发安全

使用读写锁保护配置重载处理器：
```go
var (
    reloadHandlers = make(map[string]func())
    reloadMutex    sync.RWMutex
)
```

## 5. 配置文件规范

### 5.1 文件命名

- 主配置文件：`config.yaml`
- 环境特定配置：`config.{env}.yaml`
- 示例配置：`config.example.yaml`

### 5.2 配置分组

- **database**：数据库相关配置
- **server**：服务器相关配置
- **jwt**：JWT认证配置
- **ai**：AI服务配置
- **external**：外部API配置

### 5.3 注释规范

- 每个配置项都应有中文注释
- 敏感配置项应标注安全提示
- 提供配置示例和取值范围

## 6. 使用示例

### 6.1 基本使用

```go
// 加载配置
config, err := LoadConfig("./config")
if err != nil {
    log.Fatal("Failed to load config:", err)
}

// 访问配置
dbConfig := config.Database
serverPort := config.Server.Port
```

### 6.2 配置热重载

```go
// 注册重载处理器
RegisterReloadHandler("database", func() {
    // 重新初始化数据库连接
    reinitDatabase()
})

// 启用热重载
EnableHotReload()
```

### 6.3 环境变量覆盖

```bash
# 设置环境变量
export QINGYU_DATABASE_PRIMARY_MONGODB_URI="mongodb://prod:27017"
export QINGYU_SERVER_PORT="8080"
export QINGYU_JWT_SECRET="production_secret"
```

## 7. 最佳实践

### 7.1 配置安全

- 敏感信息使用环境变量
- 生产环境禁用调试模式
- 定期轮换密钥和令牌

### 7.2 配置管理

- 使用版本控制管理配置模板
- 不同环境使用不同配置文件
- 配置变更需要经过审核

### 7.3 性能优化

- 缓存解析后的配置对象
- 避免频繁的配置文件读取
- 合理设置配置监听间隔

## 8. 错误处理

### 8.1 配置加载错误
- 配置文件不存在：使用默认配置并记录警告
- 配置格式错误：返回详细错误信息
- 配置验证失败：返回验证错误详情

### 8.2 配置热重载错误
- 文件监听失败：记录错误但不影响应用运行
- 重载处理器异常：捕获异常并记录日志
- 配置验证失败：保持原有配置不变

## 9. 测试策略

### 9.1 单元测试
- 配置加载功能测试
- 配置验证功能测试
- 默认值设置测试
- 环境变量覆盖测试

### 9.2 集成测试
- 配置文件格式兼容性测试
- 配置热重载功能测试
- 多环境配置切换测试

### 9.3 性能测试
- 配置加载性能测试
- 配置监听资源消耗测试
- 并发访问配置测试

## 10. 扩展性设计

### 10.1 新配置类型支持
通过扩展 Config 结构体添加新的配置类型：
```go
type Config struct {
    // 现有配置...
    Cache    *CacheConfig    `mapstructure:"cache"`
    Logging  *LoggingConfig  `mapstructure:"logging"`
}
```

### 10.2 新配置源支持
通过实现配置源接口支持新的配置来源：
```go
type ConfigSource interface {
    Load() (map[string]interface{}, error)
    Watch(callback func()) error
}
```

### 10.3 配置中心集成
预留配置中心集成接口，支持分布式配置管理：
```go
type ConfigCenter interface {
    Pull(key string) (interface{}, error)
    Push(key string, value interface{}) error
    Subscribe(key string, callback func(interface{})) error
}
```

## 11. 实际应用案例

### 11.1 配置结构映射问题解决
在实际开发中遇到的 `mapstructure` 标签问题：

**问题描述**：
配置文件中的 `auto_create: true` 无法正确映射到 Go 结构体的 `AutoCreate` 字段。

**根本原因**：
结构体只有 `yaml` 标签，缺少 `mapstructure` 标签，导致 Viper 无法正确进行映射。

**解决方案**：
```go
// 修复前
type IndexingConfig struct {
    AutoCreate bool `yaml:"auto_create"`
    Background bool `yaml:"background"`
}

// 修复后
type IndexingConfig struct {
    AutoCreate bool `yaml:"auto_create" mapstructure:"auto_create"`
    Background bool `yaml:"background" mapstructure:"background"`
}
```

**技术要点**：
- Viper 使用两步解析：YAML → map[string]interface{} → Go struct
- 第一步使用 YAML 库，第二步使用 mapstructure 库
- 必须同时提供 `yaml` 和 `mapstructure` 标签

### 11.2 配置验证最佳实践
```go
func validateConfigDetails(cfg *Config) error {
    // 数据库配置验证
    if cfg.Database.Type == "" {
        return errors.New("database type is required")
    }
    
    // 服务器端口验证
    if port, err := strconv.Atoi(cfg.Server.Port); err != nil || port < 1 || port > 65535 {
        return errors.New("invalid server port")
    }
    
    // JWT密钥强度验证
    if len(cfg.JWT.Secret) < 32 {
        return errors.New("JWT secret must be at least 32 characters")
    }
    
    return nil
}
```

## 12. 维护指南

### 12.1 配置更新流程
1. **需求分析**：确定新配置项的必要性和影响范围
2. **结构设计**：更新配置结构体，添加必要的标签
3. **默认值设置**：为新配置项设置合理的默认值
4. **验证逻辑**：添加相应的配置验证逻辑
5. **文档更新**：更新配置文档和示例
6. **测试验证**：编写测试用例验证新配置功能

### 12.2 故障排查指南
- **配置加载失败**：检查文件路径、格式、权限
- **配置映射错误**：检查 `mapstructure` 标签是否正确
- **配置验证失败**：检查配置值是否符合验证规则
- **热重载异常**：检查文件监听权限和处理器逻辑

### 12.3 性能监控
- 监控配置加载时间
- 监控配置文件监听资源消耗
- 监控配置验证性能
- 监控热重载触发频率
