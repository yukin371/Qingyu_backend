# 版本管理服务重构设计

> **版本**: v2.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ⚠️ 需要重构

---

## 1. 为什么需要重构

### 1.1 当前问题

**现有实现**：`service/project/version_service.go`

**严重架构问题**：
```go
// ⚠️ 问题代码
type VersionService struct{}  // 空结构体，没有依赖注入

func fileCol() *mongo.Collection    { return global.DB.Collection("novel_files") }
func contentCol() *mongo.Collection { return global.DB.Collection("document_contents") }
func revCol() *mongo.Collection     { return global.DB.Collection("file_revisions") }
```

**问题清单**：
1. ❌ **直接使用global.DB**：违反依赖注入原则
2. ❌ **没有Repository层**：Service直接操作MongoDB
3. ❌ **使用旧数据模型**：Commit/FileRevision/FilePatch，与新架构Version不一致
4. ❌ **没有事件发布**：无法与其他服务协同
5. ❌ **难以测试**：依赖全局变量，无法进行单元测试
6. ❌ **混合新旧模型**：同时存在Version和FileRevision

### 1.2 重构目标

1. ✅ 遵循Repository模式，Service只处理业务逻辑
2. ✅ 使用依赖注入，便于测试和维护
3. ✅ 对齐新架构Version模型
4. ✅ 添加事件发布机制
5. ✅ 支持GridFS大文件存储
6. ✅ 实现乐观锁版本控制
7. ✅ 提供版本对比和回滚功能

---

## 2. 新架构设计

### 2.1 架构对比

**旧架构**：
```
VersionService → global.DB → MongoDB
     ↓
   (没有Repository层，直接操作数据库)
```

**新架构**：
```
VersionService → VersionRepository → MongoDB
     ↓                    ↓
  EventBus           GridFS (大文件)
```

### 2.2 分层设计

```
┌─────────────────────────────────────────────┐
│         API Layer (接口层)                   │
│              VersionApi                      │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│       Service Layer (业务逻辑层)             │
│           VersionService                     │
│  - createVersion()                           │
│  - getVersionHistory()                       │
│  - compareVersions()                         │
│  - rollbackToVersion()                       │
│  - pruneOldVersions()                        │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│    Repository Layer (数据访问层)             │
│         VersionRepository                    │
│  - Create()                                  │
│  - GetByID()                                 │
│  - GetByDocumentID()                         │
│  - Delete()                                  │
│  - SaveContent() (GridFS)                    │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│         Data Layer (数据层)                  │
│  MongoDB Collection  +  GridFS               │
└─────────────────────────────────────────────┘
```

---

## 3. 数据模型设计（新架构）

### 3.1 Version模型

```go
type Version struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    DocumentID  string    `bson:"document_id" json:"documentId" validate:"required"`
    VersionNum  int       `bson:"version_num" json:"versionNum"`                 // 版本号（递增）
    Content     string    `bson:"content" json:"content"`                        // 内容（小于16MB）
    GridFSID    string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"` // GridFS ID（大文件）
    ContentType string    `bson:"content_type" json:"contentType"`               // 内容类型
    WordCount   int       `bson:"word_count" json:"wordCount"`                   // 字数
    Comment     string    `bson:"comment,omitempty" json:"comment,omitempty"`    // 版本说明
    CreatedBy   string    `bson:"created_by" json:"createdBy"`                   // 创建人
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`                   // 创建时间
    IsAutoSave  bool      `bson:"is_auto_save" json:"isAutoSave"`                // 是否自动保存
    
    // 版本元数据
    Size        int64     `bson:"size" json:"size"`                              // 内容大小（字节）
    MD5         string    `bson:"md5" json:"md5"`                                // 内容MD5（用于去重）
    ParentID    string    `bson:"parent_id,omitempty" json:"parentId,omitempty"` // 父版本ID（用于版本链）
}
```

### 3.2 字段说明

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| ID | string | 否 | 版本唯一标识 |
| DocumentID | string | 是 | 关联的文档ID |
| VersionNum | int | 是 | 版本号（从1开始递增） |
| Content | string | 否 | 内容文本（< 16MB存MongoDB，>= 16MB存GridFS） |
| GridFSID | string | 否 | GridFS文件ID（大文件） |
| ContentType | string | 否 | 内容类型（text/markdown/html等） |
| WordCount | int | 否 | 字数统计 |
| Comment | string | 否 | 版本说明/备注 |
| CreatedBy | string | 是 | 创建人ID |
| CreatedAt | time.Time | 是 | 创建时间 |
| IsAutoSave | bool | 否 | 是否自动保存（区分手动/自动版本） |
| Size | int64 | 否 | 内容大小（字节） |
| MD5 | string | 否 | 内容MD5（用于去重） |
| ParentID | string | 否 | 父版本ID（版本链） |

### 3.3 业务方法

```go
// GetVersionLabel 获取版本标签
func (v *Version) GetVersionLabel() string {
    if v.IsAutoSave {
        return fmt.Sprintf("v%d (自动保存)", v.VersionNum)
    }
    return fmt.Sprintf("v%d", v.VersionNum)
}

// IsLargeFile 是否大文件
func (v *Version) IsLargeFile() bool {
    return v.GridFSID != ""
}

// Validate 验证版本数据
func (v *Version) Validate() error {
    if v.DocumentID == "" {
        return fmt.Errorf("文档ID不能为空")
    }
    if v.VersionNum <= 0 {
        return fmt.Errorf("版本号必须大于0")
    }
    if v.Content == "" && v.GridFSID == "" {
        return fmt.Errorf("内容或GridFS ID必须有一个")
    }
    return nil
}
```

### 3.4 索引策略

```javascript
// MongoDB索引
db.versions.createIndex({ "document_id": 1, "version_num": -1 })  // 查询文档的版本历史
db.versions.createIndex({ "document_id": 1, "created_at": -1 })   // 按时间查询版本
db.versions.createIndex({ "created_by": 1, "created_at": -1 })    // 查询用户创建的版本
db.versions.createIndex({ "md5": 1 })                              // MD5去重
db.versions.createIndex({ "is_auto_save": 1, "created_at": -1 })  // 清理自动保存版本
```

---

## 4. Repository接口设计

### 4.1 VersionRepository接口

```go
package interfaces

type VersionRepository interface {
    // Create 创建版本
    Create(ctx context.Context, version *Version) error
    
    // GetByID 根据ID获取版本
    GetByID(ctx context.Context, id string) (*Version, error)
    
    // GetByDocumentID 获取文档的所有版本
    GetByDocumentID(ctx context.Context, documentID string, limit int) ([]*Version, error)
    
    // GetLatestVersion 获取文档的最新版本
    GetLatestVersion(ctx context.Context, documentID string) (*Version, error)
    
    // GetVersionByNum 根据版本号获取版本
    GetVersionByNum(ctx context.Context, documentID string, versionNum int) (*Version, error)
    
    // Delete 删除版本
    Delete(ctx context.Context, id string) error
    
    // DeleteByDocumentID 删除文档的所有版本
    DeleteByDocumentID(ctx context.Context, documentID string) error
    
    // PruneAutoSaveVersions 清理旧的自动保存版本
    PruneAutoSaveVersions(ctx context.Context, documentID string, keepCount int) error
    
    // GetNextVersionNum 获取下一个版本号
    GetNextVersionNum(ctx context.Context, documentID string) (int, error)
    
    // SaveContentToGridFS 保存内容到GridFS（大文件）
    SaveContentToGridFS(ctx context.Context, content []byte) (string, error)
    
    // GetContentFromGridFS 从GridFS获取内容
    GetContentFromGridFS(ctx context.Context, gridfsID string) ([]byte, error)
    
    // DeleteFromGridFS 从GridFS删除文件
    DeleteFromGridFS(ctx context.Context, gridfsID string) error
    
    // Health 健康检查
    Health(ctx context.Context) error
}
```

### 4.2 MongoDB实现

```go
// repository/mongodb/version/version_repository_mongo.go
package version

type MongoVersionRepository struct {
    collection   *mongo.Collection
    gridFSBucket *gridfs.Bucket
    queryBuilder infrastructure.QueryBuilder
}

func NewMongoVersionRepository(db *mongo.Database) *MongoVersionRepository {
    bucket, _ := gridfs.NewBucket(db, options.GridFSBucket().SetName("versions"))
    
    return &MongoVersionRepository{
        collection:   db.Collection("versions"),
        gridFSBucket: bucket,
        queryBuilder: mongodb.NewMongoQueryBuilder(),
    }
}

// Create 创建版本
func (r *MongoVersionRepository) Create(ctx context.Context, version *Version) error {
    // 1. 验证
    if err := version.Validate(); err != nil {
        return err
    }
    
    // 2. 生成ID
    if version.ID == "" {
        version.ID = primitive.NewObjectID().Hex()
    }
    
    // 3. 设置创建时间
    if version.CreatedAt.IsZero() {
        version.CreatedAt = time.Now()
    }
    
    // 4. 计算MD5（用于去重）
    if version.Content != "" {
        version.MD5 = fmt.Sprintf("%x", md5.Sum([]byte(version.Content)))
        version.Size = int64(len(version.Content))
    }
    
    // 5. 处理大文件
    const MAX_INLINE_SIZE = 16 * 1024 * 1024 // 16MB
    if len(version.Content) >= MAX_INLINE_SIZE {
        // 保存到GridFS
        gridfsID, err := r.SaveContentToGridFS(ctx, []byte(version.Content))
        if err != nil {
            return fmt.Errorf("保存到GridFS失败: %w", err)
        }
        
        version.GridFSID = gridfsID
        version.Content = ""  // 清空Content，节省空间
    }
    
    // 6. 插入数据库
    _, err := r.collection.InsertOne(ctx, version)
    if err != nil {
        // 如果保存了GridFS，需要清理
        if version.GridFSID != "" {
            r.DeleteFromGridFS(ctx, version.GridFSID)
        }
        return fmt.Errorf("创建版本失败: %w", err)
    }
    
    return nil
}

// GetByDocumentID 获取文档的所有版本
func (r *MongoVersionRepository) GetByDocumentID(ctx context.Context, documentID string, limit int) ([]*Version, error) {
    filter := bson.M{"document_id": documentID}
    opts := options.Find().
        SetSort(bson.D{{Key: "version_num", Value: -1}}).  // 降序，最新的在前
        SetLimit(int64(limit))
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("查询版本失败: %w", err)
    }
    defer cursor.Close(ctx)
    
    var versions []*Version
    if err = cursor.All(ctx, &versions); err != nil {
        return nil, fmt.Errorf("解析版本数据失败: %w", err)
    }
    
    return versions, nil
}

// GetNextVersionNum 获取下一个版本号
func (r *MongoVersionRepository) GetNextVersionNum(ctx context.Context, documentID string) (int, error) {
    opts := options.FindOne().SetSort(bson.D{{Key: "version_num", Value: -1}})
    
    var latest Version
    err := r.collection.FindOne(ctx, bson.M{"document_id": documentID}, opts).Decode(&latest)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return 1, nil  // 第一个版本
        }
        return 0, err
    }
    
    return latest.VersionNum + 1, nil
}

// SaveContentToGridFS 保存内容到GridFS
func (r *MongoVersionRepository) SaveContentToGridFS(ctx context.Context, content []byte) (string, error) {
    uploadStream, err := r.gridFSBucket.OpenUploadStream("")
    if err != nil {
        return "", err
    }
    defer uploadStream.Close()
    
    _, err = uploadStream.Write(content)
    if err != nil {
        return "", err
    }
    
    return uploadStream.FileID.(primitive.ObjectID).Hex(), nil
}

// GetContentFromGridFS 从GridFS获取内容
func (r *MongoVersionRepository) GetContentFromGridFS(ctx context.Context, gridfsID string) ([]byte, error) {
    objectID, err := primitive.ObjectIDFromHex(gridfsID)
    if err != nil {
        return nil, err
    }
    
    downloadStream, err := r.gridFSBucket.OpenDownloadStream(objectID)
    if err != nil {
        return nil, err
    }
    defer downloadStream.Close()
    
    return io.ReadAll(downloadStream)
}
```

---

## 5. Service层设计（新架构）

### 5.1 VersionService结构

```go
// service/project/version_service.go (重构后)
package project

type VersionService struct {
    versionRepo      interfaces.VersionRepository
    documentRepo     interfaces.DocumentRepository
    documentContentRepo interfaces.DocumentContentRepository
    eventBus         base.EventBus
    validator        base.Validator
    serviceName      string
}

func NewVersionService(
    versionRepo interfaces.VersionRepository,
    documentRepo interfaces.DocumentRepository,
    documentContentRepo interfaces.DocumentContentRepository,
    eventBus base.EventBus,
) *VersionService {
    return &VersionService{
        versionRepo:         versionRepo,
        documentRepo:        documentRepo,
        documentContentRepo: documentContentRepo,
        eventBus:            eventBus,
        validator:           base.NewBaseValidator(),
        serviceName:         "VersionService",
    }
}
```

### 5.2 核心业务方法

```go
// CreateVersion 创建新版本（手动保存）
func (s *VersionService) CreateVersion(ctx context.Context, req *CreateVersionRequest) (*CreateVersionResponse, error) {
    // 1. 验证请求
    if err := s.validator.Struct(req); err != nil {
        return nil, errors.NewValidationError("参数验证失败").WithDetails(err.Error())
    }
    
    // 2. 获取文档
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil || doc == nil {
        return nil, errors.NewNotFoundError("文档不存在")
    }
    
    // 3. 获取文档内容
    content, err := s.documentContentRepo.GetByDocumentID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewInternalError("获取文档内容失败").WithCause(err)
    }
    
    // 4. 获取下一个版本号
    nextVersionNum, err := s.versionRepo.GetNextVersionNum(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewInternalError("获取版本号失败").WithCause(err)
    }
    
    // 5. 创建版本
    version := &Version{
        DocumentID:  req.DocumentID,
        VersionNum:  nextVersionNum,
        Content:     content.Content,
        ContentType: content.ContentType,
        WordCount:   content.WordCount,
        Comment:     req.Comment,
        CreatedBy:   req.UserID,
        IsAutoSave:  false,  // 手动保存
    }
    
    // 6. 保存版本
    if err := s.versionRepo.Create(ctx, version); err != nil {
        return nil, errors.NewInternalError("创建版本失败").WithCause(err)
    }
    
    // 7. 发布事件
    event := &base.BaseEvent{
        EventType: "version.created",
        EventData: map[string]interface{}{
            "version_id":   version.ID,
            "document_id":  version.DocumentID,
            "version_num":  version.VersionNum,
            "created_by":   version.CreatedBy,
            "is_auto_save": version.IsAutoSave,
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    // 8. 返回响应
    return &CreateVersionResponse{
        VersionID:  version.ID,
        VersionNum: version.VersionNum,
        CreatedAt:  version.CreatedAt,
    }, nil
}

// AutoSaveVersion 自动保存版本
func (s *VersionService) AutoSaveVersion(ctx context.Context, documentID string, userID string) error {
    // 1. 获取文档内容
    content, err := s.documentContentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return err
    }
    
    // 2. 检查是否与最新版本相同（避免重复保存）
    latestVersion, _ := s.versionRepo.GetLatestVersion(ctx, documentID)
    if latestVersion != nil {
        latestMD5 := latestVersion.MD5
        currentMD5 := fmt.Sprintf("%x", md5.Sum([]byte(content.Content)))
        if latestMD5 == currentMD5 {
            return nil  // 内容未变化，不保存
        }
    }
    
    // 3. 获取下一个版本号
    nextVersionNum, err := s.versionRepo.GetNextVersionNum(ctx, documentID)
    if err != nil {
        return err
    }
    
    // 4. 创建自动保存版本
    version := &Version{
        DocumentID:  documentID,
        VersionNum:  nextVersionNum,
        Content:     content.Content,
        ContentType: content.ContentType,
        WordCount:   content.WordCount,
        CreatedBy:   userID,
        IsAutoSave:  true,  // 自动保存
    }
    
    // 5. 保存版本
    if err := s.versionRepo.Create(ctx, version); err != nil {
        return err
    }
    
    // 6. 清理旧的自动保存版本（保留最近10个）
    go s.versionRepo.PruneAutoSaveVersions(context.Background(), documentID, 10)
    
    return nil
}

// GetVersionHistory 获取版本历史
func (s *VersionService) GetVersionHistory(ctx context.Context, documentID string, limit int) ([]*VersionInfo, error) {
    // 1. 查询版本
    versions, err := s.versionRepo.GetByDocumentID(ctx, documentID, limit)
    if err != nil {
        return nil, err
    }
    
    // 2. 转换为响应格式
    result := make([]*VersionInfo, len(versions))
    for i, v := range versions {
        result[i] = &VersionInfo{
            VersionID:   v.ID,
            VersionNum:  v.VersionNum,
            VersionLabel: v.GetVersionLabel(),
            WordCount:   v.WordCount,
            Comment:     v.Comment,
            CreatedBy:   v.CreatedBy,
            CreatedAt:   v.CreatedAt,
            Size:        v.Size,
        }
    }
    
    return result, nil
}

// CompareVersions 对比两个版本
func (s *VersionService) CompareVersions(ctx context.Context, versionID1, versionID2 string) (*VersionCompareResult, error) {
    // 1. 获取两个版本
    v1, err := s.versionRepo.GetByID(ctx, versionID1)
    if err != nil || v1 == nil {
        return nil, errors.NewNotFoundError("版本1不存在")
    }
    
    v2, err := s.versionRepo.GetByID(ctx, versionID2)
    if err != nil || v2 == nil {
        return nil, errors.NewNotFoundError("版本2不存在")
    }
    
    // 2. 获取内容
    content1, err := s.getVersionContent(ctx, v1)
    if err != nil {
        return nil, err
    }
    
    content2, err := s.getVersionContent(ctx, v2)
    if err != nil {
        return nil, err
    }
    
    // 3. 计算差异（使用diff算法）
    diff := computeDiff(content1, content2)
    
    // 4. 返回结果
    return &VersionCompareResult{
        Version1:     v1,
        Version2:     v2,
        Diff:         diff,
        WordCountDiff: v2.WordCount - v1.WordCount,
    }, nil
}

// RollbackToVersion 回滚到指定版本
func (s *VersionService) RollbackToVersion(ctx context.Context, documentID string, versionNum int, userID string) error {
    // 1. 获取目标版本
    targetVersion, err := s.versionRepo.GetVersionByNum(ctx, documentID, versionNum)
    if err != nil || targetVersion == nil {
        return errors.NewNotFoundError("目标版本不存在")
    }
    
    // 2. 获取版本内容
    content, err := s.getVersionContent(ctx, targetVersion)
    if err != nil {
        return err
    }
    
    // 3. 更新文档内容
    err = s.documentContentRepo.UpdateContent(ctx, documentID, content)
    if err != nil {
        return errors.NewInternalError("更新文档内容失败").WithCause(err)
    }
    
    // 4. 创建新版本（标记为回滚）
    nextVersionNum, _ := s.versionRepo.GetNextVersionNum(ctx, documentID)
    newVersion := &Version{
        DocumentID:  documentID,
        VersionNum:  nextVersionNum,
        Content:     content,
        ContentType: targetVersion.ContentType,
        WordCount:   targetVersion.WordCount,
        Comment:     fmt.Sprintf("回滚到版本 v%d", versionNum),
        CreatedBy:   userID,
        ParentID:    targetVersion.ID,
    }
    
    s.versionRepo.Create(ctx, newVersion)
    
    // 5. 发布事件
    event := &base.BaseEvent{
        EventType: "version.rollback",
        EventData: map[string]interface{}{
            "document_id":     documentID,
            "target_version":  versionNum,
            "new_version_num": nextVersionNum,
            "rolled_back_by":  userID,
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}

// getVersionContent 获取版本内容（处理GridFS）
func (s *VersionService) getVersionContent(ctx context.Context, version *Version) (string, error) {
    if version.Content != "" {
        return version.Content, nil
    }
    
    if version.GridFSID != "" {
        contentBytes, err := s.versionRepo.GetContentFromGridFS(ctx, version.GridFSID)
        if err != nil {
            return "", err
        }
        return string(contentBytes), nil
    }
    
    return "", fmt.Errorf("版本内容为空")
}
```

---

## 6. 事件设计

### 6.1 版本事件

```go
// 版本创建事件
type VersionCreatedEvent struct {
    VersionID   string
    DocumentID  string
    VersionNum  int
    CreatedBy   string
    IsAutoSave  bool
    Timestamp   time.Time
}

// 版本回滚事件
type VersionRollbackEvent struct {
    DocumentID      string
    TargetVersion   int
    NewVersionNum   int
    RolledBackBy    string
    Timestamp       time.Time
}

// 版本删除事件
type VersionDeletedEvent struct {
    VersionID   string
    DocumentID  string
    VersionNum  int
    DeletedBy   string
    Timestamp   time.Time
}
```

---

## 7. 迁移策略

### 7.1 数据迁移

```go
// MigrateOldVersions 迁移旧版本数据
func MigrateOldVersions(ctx context.Context, oldDB, newDB *mongo.Database) error {
    // 1. 查询所有旧版本（FileRevision）
    oldCollection := oldDB.Collection("file_revisions")
    cursor, err := oldCollection.Find(ctx, bson.M{})
    if err != nil {
        return err
    }
    defer cursor.Close(ctx)
    
    // 2. 转换并插入新版本
    newCollection := newDB.Collection("versions")
    for cursor.Next(ctx) {
        var oldVersion FileRevision
        if err := cursor.Decode(&oldVersion); err != nil {
            continue
        }
        
        // 转换为新版本
        newVersion := &Version{
            DocumentID:  oldVersion.NodeID,
            VersionNum:  oldVersion.Version,
            Content:     oldVersion.Snapshot,
            CreatedBy:   oldVersion.AuthorID,
            CreatedAt:   oldVersion.CreatedAt,
            Comment:     oldVersion.Message,
        }
        
        newCollection.InsertOne(ctx, newVersion)
    }
    
    return nil
}
```

### 7.2 渐进式迁移

**阶段1**：创建新Repository和Service，保持旧代码可用
```
旧Service (global.DB) → MongoDB
新Service (Repository) → MongoDB
```

**阶段2**：新功能使用新Service，旧功能逐步迁移
```
新功能 → 新Service → Repository → MongoDB
旧功能 → 旧Service → global.DB → MongoDB
```

**阶段3**：完全迁移，删除旧代码
```
所有功能 → 新Service → Repository → MongoDB
删除旧Service
```

---

## 8. 性能优化

### 8.1 版本去重

```go
// 基于MD5去重，避免重复保存相同内容
func (s *VersionService) CreateVersionWithDeduplication(ctx context.Context, version *Version) error {
    // 计算内容MD5
    md5Hash := fmt.Sprintf("%x", md5.Sum([]byte(version.Content)))
    
    // 查找是否已存在相同内容的版本
    existing, _ := s.versionRepo.FindByMD5(ctx, version.DocumentID, md5Hash)
    if existing != nil {
        // 内容相同，不创建新版本，返回已存在版本
        return nil
    }
    
    version.MD5 = md5Hash
    return s.versionRepo.Create(ctx, version)
}
```

### 8.2 版本压缩

```go
// 对旧版本进行压缩存储
func (s *VersionService) CompressOldVersions(ctx context.Context, documentID string, olderThanDays int) error {
    cutoffDate := time.Now().AddDate(0, 0, -olderThanDays)
    
    versions, _ := s.versionRepo.GetVersionsOlderThan(ctx, documentID, cutoffDate)
    
    for _, v := range versions {
        if v.Content != "" && !v.IsLargeFile() {
            // 压缩内容
            compressed := compressContent(v.Content)
            v.Content = compressed
            v.ContentType = "compressed"
            
            s.versionRepo.Update(ctx, v.ID, v)
        }
    }
    
    return nil
}
```

### 8.3 自动清理策略

```go
// 自动清理旧的自动保存版本（每天凌晨执行）
func (s *VersionService) ScheduleAutoSaveCleanup() {
    ticker := time.NewTicker(24 * time.Hour)
    
    go func() {
        for range ticker.C {
            // 清理超过30天的自动保存版本
            s.CleanupOldAutoSaveVersions(context.Background(), 30)
        }
    }()
}

func (s *VersionService) CleanupOldAutoSaveVersions(ctx context.Context, olderThanDays int) error {
    cutoffDate := time.Now().AddDate(0, 0, -olderThanDays)
    
    // 查询并删除
    return s.versionRepo.DeleteOldAutoSaves(ctx, cutoffDate)
}
```

---

## 9. 实现参考

### 9.1 需要创建的文件

**Repository层**：
- `repository/interfaces/version/VersionRepository_interface.go` - Repository接口
- `repository/mongodb/version/version_repository_mongo.go` - MongoDB实现

**Service层**：
- `service/project/version_service.go` - 重构后的Service（替换现有文件）
- `service/project/version_dto.go` - DTO定义

**迁移工具**：
- `migration/migrate_versions.go` - 数据迁移脚本

### 9.2 删除的旧代码

**删除以下旧模型**（保留兼容期后）：
- `models/document/version.go` 中的 Commit, FileRevision, FilePatch

**删除以下全局函数**：
```go
func fileCol() *mongo.Collection    { return global.DB.Collection("novel_files") }
func contentCol() *mongo.Collection { return global.DB.Collection("document_contents") }
func revCol() *mongo.Collection     { return global.DB.Collection("file_revisions") }
func patchCol() *mongo.Collection   { return global.DB.Collection("file_patches") }
func commitCol() *mongo.Collection  { return global.DB.Collection("commits") }
```

---

## 10. 测试策略

### 10.1 单元测试

```go
func TestVersionService_CreateVersion(t *testing.T) {
    // 1. 创建Mock依赖
    mockVersionRepo := &MockVersionRepository{}
    mockDocumentRepo := &MockDocumentRepository{}
    mockEventBus := &MockEventBus{}
    
    // 2. 创建Service
    service := NewVersionService(mockVersionRepo, mockDocumentRepo, nil, mockEventBus)
    
    // 3. 设置Mock期望
    mockVersionRepo.On("GetNextVersionNum", mock.Anything, "doc123").Return(1, nil)
    mockVersionRepo.On("Create", mock.Anything, mock.AnythingOfType("*Version")).Return(nil)
    
    // 4. 执行测试
    req := &CreateVersionRequest{
        DocumentID: "doc123",
        UserID:     "user456",
        Comment:    "测试版本",
    }
    
    resp, err := service.CreateVersion(context.Background(), req)
    
    // 5. 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    assert.Equal(t, 1, resp.VersionNum)
    
    // 6. 验证Mock调用
    mockVersionRepo.AssertExpectations(t)
}
```

---

## 11. 总结

### 11.1 重构收益

1. ✅ **架构一致性**：对齐新架构，符合Repository模式
2. ✅ **可测试性**：依赖注入，便于单元测试
3. ✅ **可维护性**：代码结构清晰，职责分明
4. ✅ **可扩展性**：支持GridFS大文件、版本压缩等
5. ✅ **事件驱动**：与其他服务协同
6. ✅ **性能优化**：版本去重、自动清理等

### 11.2 实施计划

**第一周**：
- 创建VersionRepository接口和MongoDB实现
- 实现GridFS集成
- 编写单元测试

**第二周**：
- 重构VersionService
- 添加事件发布
- 数据迁移脚本

**第三周**：
- 渐进式迁移
- 性能测试和优化
- 删除旧代码

---

**文档状态**: ✅ 已完成  
**最后审核**: 2025-10-21  
**优先级**: ⚠️ P0 - 需要立即重构

