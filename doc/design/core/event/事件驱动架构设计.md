# äº‹ä»¶é©±åŠ¨æ¶æ„è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-21  
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è®¾è®¡é’ç¾½å¹³å°çš„äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ŒåŒ…æ‹¬EventBuså¢å¼ºã€å¼ºåˆ¶äº‹ä»¶æ–¹æ³•å®šä¹‰ã€æ ¸å¿ƒä¸šåŠ¡äº‹ä»¶ã€äº‹ä»¶å¤„ç†å™¨æ³¨å†Œæœºåˆ¶ç­‰ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **è§£è€¦æ¨¡å—**ï¼šé€šè¿‡äº‹ä»¶å®ç°æ¨¡å—é—´æ¾è€¦åˆ
2. **å¼ºåˆ¶è§„èŒƒ**ï¼šServiceæ¥å£å¼ºåˆ¶å®šä¹‰äº‹ä»¶æ–¹æ³•
3. **å¯æ‰©å±•**ï¼šæ˜“äºæ·»åŠ æ–°çš„äº‹ä»¶å¤„ç†å™¨
4. **å¯è¿½è¸ª**ï¼šå®Œæ•´çš„äº‹ä»¶å‘å¸ƒå’Œæ¶ˆè´¹æ—¥å¿—

---

## ä¸€ã€EventBuså¢å¼ºè®¾è®¡

### 1.1 EventBusæ¥å£æ‰©å±•

```go
package base

type EventBus interface {
    // åŸºç¡€æ–¹æ³•
    Subscribe(eventType string, handler EventHandler) error
    Unsubscribe(eventType string, handlerName string) error
    Publish(ctx context.Context, event Event) error
    PublishAsync(ctx context.Context, event Event) error
    
    // æ–°å¢ï¼šæ‰¹é‡è®¢é˜…
    SubscribeBatch(subscriptions map[string][]EventHandler) error
    
    // æ–°å¢ï¼šäº‹ä»¶æŒä¹…åŒ–
    PublishPersistent(ctx context.Context, event Event) error
    
    // æ–°å¢ï¼šäº‹ä»¶é‡æ”¾
    ReplayEvents(ctx context.Context, eventType string, from, to time.Time) error
    
    // æ–°å¢ï¼šäº‹ä»¶è¿‡æ»¤
    SubscribeWithFilter(eventType string, handler EventHandler, filter EventFilter) error
}

type EventFilter func(event Event) bool
```

### 1.2 åŸºäºRabbitMQçš„EventBuså®ç°

```go
package eventbus

type RabbitMQEventBus struct {
    conn    *amqp.Connection
    channel *amqp.Channel
    handlers map[string][]EventHandler
    exchange string
    mu       sync.RWMutex
}

func NewRabbitMQEventBus(url, exchange string) (*RabbitMQEventBus, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    // å£°æ˜exchange
    err = channel.ExchangeDeclare(
        exchange,
        "topic",
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return nil, err
    }
    
    return &RabbitMQEventBus{
        conn:     conn,
        channel:  channel,
        handlers: make(map[string][]EventHandler),
        exchange: exchange,
    }, nil
}

func (bus *RabbitMQEventBus) Publish(ctx context.Context, event Event) error {
    body, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return bus.channel.Publish(
        bus.exchange,
        event.GetEventType(), // routing key
        false,
        false,
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
            Timestamp:   time.Now(),
        },
    )
}

func (bus *RabbitMQEventBus) Subscribe(eventType string, handler EventHandler) error {
    bus.mu.Lock()
    defer bus.mu.Unlock()
    
    // å£°æ˜é˜Ÿåˆ—
    queueName := fmt.Sprintf("%s.%s", eventType, handler.GetHandlerName())
    queue, err := bus.channel.QueueDeclare(
        queueName,
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // ç»‘å®šé˜Ÿåˆ—åˆ°exchange
    err = bus.channel.QueueBind(
        queue.Name,
        eventType,
        bus.exchange,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // å¼€å§‹æ¶ˆè´¹
    msgs, err := bus.channel.Consume(
        queue.Name,
        handler.GetHandlerName(),
        false,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // å¯åŠ¨æ¶ˆè´¹goroutine
    go bus.consumeMessages(msgs, handler)
    
    bus.handlers[eventType] = append(bus.handlers[eventType], handler)
    
    return nil
}

func (bus *RabbitMQEventBus) consumeMessages(msgs <-chan amqp.Delivery, handler EventHandler) {
    for msg := range msgs {
        var event base.BaseEvent
        if err := json.Unmarshal(msg.Body, &event); err != nil {
            log.Error("è§£æäº‹ä»¶å¤±è´¥", "error", err)
            msg.Nack(false, false)
            continue
        }
        
        ctx := context.Background()
        if err := handler.Handle(ctx, &event); err != nil {
            log.Error("å¤„ç†äº‹ä»¶å¤±è´¥", "handler", handler.GetHandlerName(), "error", err)
            msg.Nack(false, true) // é‡æ–°å…¥é˜Ÿ
        } else {
            msg.Ack(false)
        }
    }
}
```

---

## äºŒã€å¼ºåˆ¶äº‹ä»¶æ–¹æ³•å®šä¹‰

### 2.1 Serviceæ¥å£è§„èŒƒ

```go
// æ‰€æœ‰Serviceæ¥å£å¿…é¡»åŒ…å«äº‹ä»¶æ–¹æ³•

type UserService interface {
    base.BaseService
    
    // ä¸šåŠ¡æ–¹æ³•
    CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error)
    GetUser(ctx context.Context, userID string) (*User, error)
    
    // å¼ºåˆ¶äº‹ä»¶æ–¹æ³•
    OnUserCreated(ctx context.Context, event *UserCreatedEvent) error
    OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error
}

type ReadingTaskService interface {
    base.BaseService
    
    // ä¸šåŠ¡æ–¹æ³•
    CompleteTask(ctx context.Context, userID, taskID string) error
    
    // å¼ºåˆ¶äº‹ä»¶æ–¹æ³•
    OnUserBehavior(ctx context.Context, event *UserBehaviorEvent) error
}
```

### 2.2 äº‹ä»¶æ–¹æ³•å‘½åçº¦å®š

| æ¨¡å¼ | ç¤ºä¾‹ | è¯´æ˜ |
|------|------|------|
| `On{Event}` | `OnUserCreated` | å¤„ç†æŸä¸ªäº‹ä»¶ |
| `Handle{Event}` | `HandleOrderCreated` | å¤‡é€‰å‘½å |

---

## ä¸‰ã€æ ¸å¿ƒä¸šåŠ¡äº‹ä»¶å®šä¹‰

### 3.1 ç”¨æˆ·æ¨¡å—äº‹ä»¶

```go
// UserCreatedEvent ç”¨æˆ·åˆ›å»ºäº‹ä»¶
type UserCreatedEvent struct {
    UserID    string    `json:"userId"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Role      string    `json:"role"`
    CreatedAt time.Time `json:"createdAt"`
}

// UserLevelUpEvent ç”¨æˆ·å‡çº§äº‹ä»¶
type UserLevelUpEvent struct {
    UserID      string    `json:"userId"`
    OldLevel    int       `json:"oldLevel"`
    NewLevel    int       `json:"newLevel"`
    LeveledUpAt time.Time `json:"leveledUpAt"`
}

// AchievementUnlockedEvent æˆå°±è§£é”äº‹ä»¶
type AchievementUnlockedEvent struct {
    UserID        string    `json:"userId"`
    AchievementID string    `json:"achievementId"`
    Title         string    `json:"title"`
    UnlockedAt    time.Time `json:"unlockedAt"`
}
```

### 3.2 å†™ä½œæ¨¡å—äº‹ä»¶

```go
// ChapterSubmittedEvent ç« èŠ‚æäº¤äº‹ä»¶
type ChapterSubmittedEvent struct {
    ChapterID   string    `json:"chapterId"`
    BookID      string    `json:"bookId"`
    AuthorID    string    `json:"authorId"`
    WordCount   int       `json:"wordCount"`
    SubmittedAt time.Time `json:"submittedAt"`
}

// ChapterApprovedEvent ç« èŠ‚å®¡æ ¸é€šè¿‡äº‹ä»¶
type ChapterApprovedEvent struct {
    ChapterID  string    `json:"chapterId"`
    BookID     string    `json:"bookId"`
    AuthorID   string    `json:"authorId"`
    ReviewerID string    `json:"reviewerId"`
    ApprovedAt time.Time `json:"approvedAt"`
}

// DocumentVersionCreatedEvent æ–‡æ¡£ç‰ˆæœ¬åˆ›å»ºäº‹ä»¶
type DocumentVersionCreatedEvent struct {
    ProjectID   string    `json:"projectId"`
    DocumentID  string    `json:"documentID"`
    VersionID   string    `json:"versionId"`
    Content     string    `json:"content"`
    ContentType string    `json:"contentType"` // chapter, character, setting
    CreatedAt   time.Time `json:"createdAt"`
}
```

### 3.3 é˜…è¯»æ¨¡å—äº‹ä»¶

```go
// BookPurchasedEvent ä¹¦ç±è´­ä¹°äº‹ä»¶
type BookPurchasedEvent struct {
    UserID      string    `json:"userId"`
    BookID      string    `json:"bookId"`
    ChapterID   string    `json:"chapterId"`
    Amount      float64   `json:"amount"`
    PurchasedAt time.Time `json:"purchasedAt"`
}

// ChapterReadEvent ç« èŠ‚é˜…è¯»äº‹ä»¶
type ChapterReadEvent struct {
    UserID     string    `json:"userId"`
    BookID     string    `json:"bookId"`
    ChapterID  string    `json:"chapterId"`
    Duration   int       `json:"duration"` // é˜…è¯»æ—¶é•¿ï¼ˆç§’ï¼‰
    ReadAt     time.Time `json:"readAt"`
}

// CommentCreatedEvent è¯„è®ºåˆ›å»ºäº‹ä»¶
type CommentCreatedEvent struct {
    CommentID string    `json:"commentId"`
    UserID    string    `json:"userId"`
    BookID    string    `json:"bookId"`
    ChapterID string    `json:"chapterId"`
    Content   string    `json:"content"`
    CreatedAt time.Time `json:"createdAt"`
}
```

### 3.4 é’±åŒ…æ¨¡å—äº‹ä»¶

```go
// TransactionCompletedEvent äº¤æ˜“å®Œæˆäº‹ä»¶
type TransactionCompletedEvent struct {
    TransactionID string    `json:"transactionId"`
    UserID        string    `json:"userId"`
    Type          string    `json:"type"` // recharge, consume, transfer
    Amount        float64   `json:"amount"`
    Balance       float64   `json:"balance"`
    CompletedAt   time.Time `json:"completedAt"`
}

// WithdrawRequestedEvent æç°ç”³è¯·äº‹ä»¶
type WithdrawRequestedEvent struct {
    WithdrawID  string    `json:"withdrawId"`
    UserID      string    `json:"userId"`
    Amount      float64   `json:"amount"`
    RequestedAt time.Time `json:"requestedAt"`
}
```

### 3.5 AIæ¨¡å—äº‹ä»¶

```go
// ChatSessionCreatedEvent èŠå¤©ä¼šè¯åˆ›å»ºäº‹ä»¶
type ChatSessionCreatedEvent struct {
    SessionID string    `json:"sessionId"`
    UserID    string    `json:"userId"`
    ProjectID string    `json:"projectId"`
    CreatedAt time.Time `json:"createdAt"`
}

// GenerationCompletedEvent AIç”Ÿæˆå®Œæˆäº‹ä»¶
type GenerationCompletedEvent struct {
    RequestID   string    `json:"requestId"`
    UserID      string    `json:"userId"`
    Model       string    `json:"model"`
    TokensUsed  int       `json:"tokensUsed"`
    CompletedAt time.Time `json:"completedAt"`
}
```

---

## å››ã€äº‹ä»¶å¤„ç†å™¨æ³¨å†Œæœºåˆ¶

### 4.1 è‡ªåŠ¨å‘ç°ä¸æ³¨å†Œ

```go
// EventHandlerRegistry äº‹ä»¶å¤„ç†å™¨æ³¨å†Œè¡¨
type EventHandlerRegistry struct {
    eventBus base.EventBus
    handlers map[string][]base.EventHandler
    mu       sync.RWMutex
}

func NewEventHandlerRegistry(eventBus base.EventBus) *EventHandlerRegistry {
    return &EventHandlerRegistry{
        eventBus: eventBus,
        handlers: make(map[string][]base.EventHandler),
    }
}

// RegisterHandler æ³¨å†Œå¤„ç†å™¨
func (r *EventHandlerRegistry) RegisterHandler(handler base.EventHandler) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    for _, eventType := range handler.GetSupportedEventTypes() {
        r.handlers[eventType] = append(r.handlers[eventType], handler)
        
        if err := r.eventBus.Subscribe(eventType, handler); err != nil {
            return err
        }
    }
    
    return nil
}

// RegisterServiceHandlers æ³¨å†ŒServiceçš„æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨
func (r *EventHandlerRegistry) RegisterServiceHandlers(service interface{}) error {
    // é€šè¿‡åå°„å‘ç°Serviceå®ç°çš„äº‹ä»¶æ–¹æ³•
    // è‡ªåŠ¨æ³¨å†Œä¸ºEventHandler
    
    // ç¤ºä¾‹ï¼šæ³¨å†ŒUserServiceçš„äº‹ä»¶æ–¹æ³•
    if userService, ok := service.(UserService); ok {
        // OnUserCreated
        handler := &UserCreatedHandler{service: userService}
        r.RegisterHandler(handler)
        
        // OnTaskCompleted
        handler2 := &TaskCompletedHandler{service: userService}
        r.RegisterHandler(handler2)
    }
    
    return nil
}
```

### 4.2 å¤„ç†å™¨ä¼˜å…ˆçº§

```go
type PrioritizedEventHandler struct {
    base.EventHandler
    Priority int // æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
}

func (r *EventHandlerRegistry) RegisterWithPriority(handler base.EventHandler, priority int) error {
    // æŒ‰ä¼˜å…ˆçº§æ’åºå¤„ç†å™¨
    // ...
}
```

### 4.3 å¹¶è¡Œä¸ä¸²è¡Œæ‰§è¡Œ

```go
type EventExecutionMode int

const (
    ExecutionModeSerial   EventExecutionMode = iota // ä¸²è¡Œ
    ExecutionModeParallel                            // å¹¶è¡Œ
)

func (r *EventHandlerRegistry) SubscribeWithMode(
    eventType string,
    handler base.EventHandler,
    mode EventExecutionMode,
) error {
    // æ ¹æ®modeå†³å®šæ‰§è¡Œæ–¹å¼
    // ...
}
```

### 4.4 é”™è¯¯éš”ç¦»

```go
func (bus *RabbitMQEventBus) consumeMessages(msgs <-chan amqp.Delivery, handler EventHandler) {
    for msg := range msgs {
        // ä½¿ç”¨goroutineéš”ç¦»é”™è¯¯
        go func(m amqp.Delivery) {
            defer func() {
                if r := recover(); r != nil {
                    log.Error("äº‹ä»¶å¤„ç†panic", "handler", handler.GetHandlerName(), "panic", r)
                    m.Nack(false, true)
                }
            }()
            
            var event base.BaseEvent
            if err := json.Unmarshal(m.Body, &event); err != nil {
                log.Error("è§£æäº‹ä»¶å¤±è´¥", "error", err)
                m.Nack(false, false) // ä¸é‡æ–°å…¥é˜Ÿ
                return
            }
            
            ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
            defer cancel()
            
            if err := handler.Handle(ctx, &event); err != nil {
                log.Error("å¤„ç†äº‹ä»¶å¤±è´¥",
                    "handler", handler.GetHandlerName(),
                    "event_type", event.GetEventType(),
                    "error", err)
                m.Nack(false, true) // é‡æ–°å…¥é˜Ÿ
            } else {
                m.Ack(false)
            }
        }(msg)
    }
}
```

---

## äº”ã€äº‹ä»¶ä½¿ç”¨ç¤ºä¾‹

### 5.1 å‘å¸ƒäº‹ä»¶

```go
// Serviceå±‚å‘å¸ƒäº‹ä»¶
func (s *ProjectService) CreateProject(ctx context.Context, req *CreateProjectRequest) (*CreateProjectResponse, error) {
    // 1. ä¸šåŠ¡é€»è¾‘
    project := &document.Project{
        AuthorID: req.AuthorID,
        Title:    req.Title,
        // ...
    }
    
    if err := s.projectRepo.Create(ctx, project); err != nil {
        return nil, err
    }
    
    // 2. å‘å¸ƒäº‹ä»¶ï¼ˆå¼ºåˆ¶ï¼‰
    event := &ProjectCreatedEvent{
        ProjectID: project.ID,
        AuthorID:  project.AuthorID,
        Title:     project.Title,
        CreatedAt: time.Now(),
    }
    
    if err := s.eventBus.PublishAsync(ctx, event); err != nil {
        log.Error("å‘å¸ƒé¡¹ç›®åˆ›å»ºäº‹ä»¶å¤±è´¥", "error", err)
        // ä¸å½±å“ä¸»æµç¨‹ï¼Œä½†éœ€è¦è®°å½•
    }
    
    return &CreateProjectResponse{
        ProjectID: project.ID,
    }, nil
}
```

### 5.2 å¤„ç†äº‹ä»¶

```go
// User Level Serviceè®¢é˜…TaskCompletedEvent
type UserLevelServiceImpl struct {
    userLevelRepo UserLevelRepository
    eventBus      base.EventBus
}

func (s *UserLevelServiceImpl) OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error {
    // 1. å¢åŠ ç»éªŒå€¼
    if err := s.AddExperience(ctx, event.UserID, event.RewardExp, fmt.Sprintf("task_%s", event.TaskID)); err != nil {
        return err
    }
    
    // 2. æ£€æŸ¥å‡çº§
    levelUp, newLevel, err := s.CheckLevelUp(ctx, event.UserID)
    if err != nil {
        log.Error("æ£€æŸ¥å‡çº§å¤±è´¥", "error", err)
    }
    
    if levelUp {
        // 3. å‘å¸ƒå‡çº§äº‹ä»¶
        upgradeEvent := &UserLevelUpEvent{
            UserID:      event.UserID,
            OldLevel:    newLevel.Level - 1,
            NewLevel:    newLevel.Level,
            LeveledUpAt: time.Now(),
        }
        s.eventBus.PublishAsync(ctx, upgradeEvent)
    }
    
    return nil
}

// GetSupportedEventTypes å®ç°EventHandleræ¥å£
func (s *UserLevelServiceImpl) GetSupportedEventTypes() []string {
    return []string{"task.completed", "user.behavior"}
}

// GetHandlerName å®ç°EventHandleræ¥å£
func (s *UserLevelServiceImpl) GetHandlerName() string {
    return "UserLevelService"
}

// Handle å®ç°EventHandleræ¥å£
func (s *UserLevelServiceImpl) Handle(ctx context.Context, event base.Event) error {
    switch event.GetEventType() {
    case "task.completed":
        return s.OnTaskCompleted(ctx, event.GetEventData().(*TaskCompletedEvent))
    case "user.behavior":
        return s.OnUserBehavior(ctx, event.GetEventData().(*UserBehaviorEvent))
    default:
        return fmt.Errorf("ä¸æ”¯æŒçš„äº‹ä»¶ç±»å‹: %s", event.GetEventType())
    }
}
```

---

## å…­ã€å®æ–½å»ºè®®

### 6.1 è¿ç§»æ­¥éª¤

1. **é˜¶æ®µ1**ï¼šå®ç°RabbitMQ EventBus
2. **é˜¶æ®µ2**ï¼šå®šä¹‰æ ¸å¿ƒä¸šåŠ¡äº‹ä»¶
3. **é˜¶æ®µ3**ï¼šåœ¨Serviceæ¥å£ä¸­æ·»åŠ äº‹ä»¶æ–¹æ³•
4. **é˜¶æ®µ4**ï¼šå®ç°äº‹ä»¶å¤„ç†å™¨
5. **é˜¶æ®µ5**ï¼šæ³¨å†Œäº‹ä»¶å¤„ç†å™¨
6. **é˜¶æ®µ6**ï¼šç›‘æ§å’Œä¼˜åŒ–

### 6.2 æœ€ä½³å®è·µ

1. **äº‹ä»¶å‘½å**ï¼šä½¿ç”¨`æ¨¡å—.åŠ¨ä½œ`æ ¼å¼ï¼Œå¦‚`user.created`ã€`task.completed`
2. **äº‹ä»¶ç²’åº¦**ï¼šä¸è¦è¿‡ç»†ï¼Œèšç„¦æ ¸å¿ƒä¸šåŠ¡äº‹ä»¶
3. **å¹‚ç­‰æ€§**ï¼šäº‹ä»¶å¤„ç†å™¨å¿…é¡»æ˜¯å¹‚ç­‰çš„
4. **é”™è¯¯å¤„ç†**ï¼šè®°å½•è¯¦ç»†æ—¥å¿—ï¼Œæ”¯æŒé‡è¯•
5. **ç›‘æ§**ï¼šç›‘æ§äº‹ä»¶å‘å¸ƒå’Œæ¶ˆè´¹æƒ…å†µ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-21  
**è´Ÿè´£äºº**: æ¶æ„ç»„  
**å®¡æ ¸çŠ¶æ€**: å¾…è¯„å®¡

