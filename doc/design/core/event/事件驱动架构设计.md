# 事件驱动架构设计

> **文档版本**: v1.0  
> **创建时间**: 2025-10-21  
> **实施状态**: 设计阶段

## 📋 文档概述

本文档设计青羽平台的事件驱动架构，包括EventBus增强、强制事件方法定义、核心业务事件、事件处理器注册机制等。

## 🎯 设计目标

1. **解耦模块**：通过事件实现模块间松耦合
2. **强制规范**：Service接口强制定义事件方法
3. **可扩展**：易于添加新的事件处理器
4. **可追踪**：完整的事件发布和消费日志

---

## 一、EventBus增强设计

### 1.1 EventBus接口扩展

```go
package base

type EventBus interface {
    // 基础方法
    Subscribe(eventType string, handler EventHandler) error
    Unsubscribe(eventType string, handlerName string) error
    Publish(ctx context.Context, event Event) error
    PublishAsync(ctx context.Context, event Event) error
    
    // 新增：批量订阅
    SubscribeBatch(subscriptions map[string][]EventHandler) error
    
    // 新增：事件持久化
    PublishPersistent(ctx context.Context, event Event) error
    
    // 新增：事件重放
    ReplayEvents(ctx context.Context, eventType string, from, to time.Time) error
    
    // 新增：事件过滤
    SubscribeWithFilter(eventType string, handler EventHandler, filter EventFilter) error
}

type EventFilter func(event Event) bool
```

### 1.2 基于RabbitMQ的EventBus实现

```go
package eventbus

type RabbitMQEventBus struct {
    conn    *amqp.Connection
    channel *amqp.Channel
    handlers map[string][]EventHandler
    exchange string
    mu       sync.RWMutex
}

func NewRabbitMQEventBus(url, exchange string) (*RabbitMQEventBus, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    // 声明exchange
    err = channel.ExchangeDeclare(
        exchange,
        "topic",
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return nil, err
    }
    
    return &RabbitMQEventBus{
        conn:     conn,
        channel:  channel,
        handlers: make(map[string][]EventHandler),
        exchange: exchange,
    }, nil
}

func (bus *RabbitMQEventBus) Publish(ctx context.Context, event Event) error {
    body, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return bus.channel.Publish(
        bus.exchange,
        event.GetEventType(), // routing key
        false,
        false,
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
            Timestamp:   time.Now(),
        },
    )
}

func (bus *RabbitMQEventBus) Subscribe(eventType string, handler EventHandler) error {
    bus.mu.Lock()
    defer bus.mu.Unlock()
    
    // 声明队列
    queueName := fmt.Sprintf("%s.%s", eventType, handler.GetHandlerName())
    queue, err := bus.channel.QueueDeclare(
        queueName,
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 绑定队列到exchange
    err = bus.channel.QueueBind(
        queue.Name,
        eventType,
        bus.exchange,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 开始消费
    msgs, err := bus.channel.Consume(
        queue.Name,
        handler.GetHandlerName(),
        false,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 启动消费goroutine
    go bus.consumeMessages(msgs, handler)
    
    bus.handlers[eventType] = append(bus.handlers[eventType], handler)
    
    return nil
}

func (bus *RabbitMQEventBus) consumeMessages(msgs <-chan amqp.Delivery, handler EventHandler) {
    for msg := range msgs {
        var event base.BaseEvent
        if err := json.Unmarshal(msg.Body, &event); err != nil {
            log.Error("解析事件失败", "error", err)
            msg.Nack(false, false)
            continue
        }
        
        ctx := context.Background()
        if err := handler.Handle(ctx, &event); err != nil {
            log.Error("处理事件失败", "handler", handler.GetHandlerName(), "error", err)
            msg.Nack(false, true) // 重新入队
        } else {
            msg.Ack(false)
        }
    }
}
```

---

## 二、强制事件方法定义

### 2.1 Service接口规范

```go
// 所有Service接口必须包含事件方法

type UserService interface {
    base.BaseService
    
    // 业务方法
    CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error)
    GetUser(ctx context.Context, userID string) (*User, error)
    
    // 强制事件方法
    OnUserCreated(ctx context.Context, event *UserCreatedEvent) error
    OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error
}

type ReadingTaskService interface {
    base.BaseService
    
    // 业务方法
    CompleteTask(ctx context.Context, userID, taskID string) error
    
    // 强制事件方法
    OnUserBehavior(ctx context.Context, event *UserBehaviorEvent) error
}
```

### 2.2 事件方法命名约定

| 模式 | 示例 | 说明 |
|------|------|------|
| `On{Event}` | `OnUserCreated` | 处理某个事件 |
| `Handle{Event}` | `HandleOrderCreated` | 备选命名 |

---

## 三、核心业务事件定义

### 3.1 用户模块事件

```go
// UserCreatedEvent 用户创建事件
type UserCreatedEvent struct {
    UserID    string    `json:"userId"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Role      string    `json:"role"`
    CreatedAt time.Time `json:"createdAt"`
}

// UserLevelUpEvent 用户升级事件
type UserLevelUpEvent struct {
    UserID      string    `json:"userId"`
    OldLevel    int       `json:"oldLevel"`
    NewLevel    int       `json:"newLevel"`
    LeveledUpAt time.Time `json:"leveledUpAt"`
}

// AchievementUnlockedEvent 成就解锁事件
type AchievementUnlockedEvent struct {
    UserID        string    `json:"userId"`
    AchievementID string    `json:"achievementId"`
    Title         string    `json:"title"`
    UnlockedAt    time.Time `json:"unlockedAt"`
}
```

### 3.2 写作模块事件

```go
// ChapterSubmittedEvent 章节提交事件
type ChapterSubmittedEvent struct {
    ChapterID   string    `json:"chapterId"`
    BookID      string    `json:"bookId"`
    AuthorID    string    `json:"authorId"`
    WordCount   int       `json:"wordCount"`
    SubmittedAt time.Time `json:"submittedAt"`
}

// ChapterApprovedEvent 章节审核通过事件
type ChapterApprovedEvent struct {
    ChapterID  string    `json:"chapterId"`
    BookID     string    `json:"bookId"`
    AuthorID   string    `json:"authorId"`
    ReviewerID string    `json:"reviewerId"`
    ApprovedAt time.Time `json:"approvedAt"`
}

// DocumentVersionCreatedEvent 文档版本创建事件
type DocumentVersionCreatedEvent struct {
    ProjectID   string    `json:"projectId"`
    DocumentID  string    `json:"documentID"`
    VersionID   string    `json:"versionId"`
    Content     string    `json:"content"`
    ContentType string    `json:"contentType"` // chapter, character, setting
    CreatedAt   time.Time `json:"createdAt"`
}
```

### 3.3 阅读模块事件

```go
// BookPurchasedEvent 书籍购买事件
type BookPurchasedEvent struct {
    UserID      string    `json:"userId"`
    BookID      string    `json:"bookId"`
    ChapterID   string    `json:"chapterId"`
    Amount      float64   `json:"amount"`
    PurchasedAt time.Time `json:"purchasedAt"`
}

// ChapterReadEvent 章节阅读事件
type ChapterReadEvent struct {
    UserID     string    `json:"userId"`
    BookID     string    `json:"bookId"`
    ChapterID  string    `json:"chapterId"`
    Duration   int       `json:"duration"` // 阅读时长（秒）
    ReadAt     time.Time `json:"readAt"`
}

// CommentCreatedEvent 评论创建事件
type CommentCreatedEvent struct {
    CommentID string    `json:"commentId"`
    UserID    string    `json:"userId"`
    BookID    string    `json:"bookId"`
    ChapterID string    `json:"chapterId"`
    Content   string    `json:"content"`
    CreatedAt time.Time `json:"createdAt"`
}
```

### 3.4 钱包模块事件

```go
// TransactionCompletedEvent 交易完成事件
type TransactionCompletedEvent struct {
    TransactionID string    `json:"transactionId"`
    UserID        string    `json:"userId"`
    Type          string    `json:"type"` // recharge, consume, transfer
    Amount        float64   `json:"amount"`
    Balance       float64   `json:"balance"`
    CompletedAt   time.Time `json:"completedAt"`
}

// WithdrawRequestedEvent 提现申请事件
type WithdrawRequestedEvent struct {
    WithdrawID  string    `json:"withdrawId"`
    UserID      string    `json:"userId"`
    Amount      float64   `json:"amount"`
    RequestedAt time.Time `json:"requestedAt"`
}
```

### 3.5 AI模块事件

```go
// ChatSessionCreatedEvent 聊天会话创建事件
type ChatSessionCreatedEvent struct {
    SessionID string    `json:"sessionId"`
    UserID    string    `json:"userId"`
    ProjectID string    `json:"projectId"`
    CreatedAt time.Time `json:"createdAt"`
}

// GenerationCompletedEvent AI生成完成事件
type GenerationCompletedEvent struct {
    RequestID   string    `json:"requestId"`
    UserID      string    `json:"userId"`
    Model       string    `json:"model"`
    TokensUsed  int       `json:"tokensUsed"`
    CompletedAt time.Time `json:"completedAt"`
}
```

---

## 四、事件处理器注册机制

### 4.1 自动发现与注册

```go
// EventHandlerRegistry 事件处理器注册表
type EventHandlerRegistry struct {
    eventBus base.EventBus
    handlers map[string][]base.EventHandler
    mu       sync.RWMutex
}

func NewEventHandlerRegistry(eventBus base.EventBus) *EventHandlerRegistry {
    return &EventHandlerRegistry{
        eventBus: eventBus,
        handlers: make(map[string][]base.EventHandler),
    }
}

// RegisterHandler 注册处理器
func (r *EventHandlerRegistry) RegisterHandler(handler base.EventHandler) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    for _, eventType := range handler.GetSupportedEventTypes() {
        r.handlers[eventType] = append(r.handlers[eventType], handler)
        
        if err := r.eventBus.Subscribe(eventType, handler); err != nil {
            return err
        }
    }
    
    return nil
}

// RegisterServiceHandlers 注册Service的所有事件处理器
func (r *EventHandlerRegistry) RegisterServiceHandlers(service interface{}) error {
    // 通过反射发现Service实现的事件方法
    // 自动注册为EventHandler
    
    // 示例：注册UserService的事件方法
    if userService, ok := service.(UserService); ok {
        // OnUserCreated
        handler := &UserCreatedHandler{service: userService}
        r.RegisterHandler(handler)
        
        // OnTaskCompleted
        handler2 := &TaskCompletedHandler{service: userService}
        r.RegisterHandler(handler2)
    }
    
    return nil
}
```

### 4.2 处理器优先级

```go
type PrioritizedEventHandler struct {
    base.EventHandler
    Priority int // 数字越小优先级越高
}

func (r *EventHandlerRegistry) RegisterWithPriority(handler base.EventHandler, priority int) error {
    // 按优先级排序处理器
    // ...
}
```

### 4.3 并行与串行执行

```go
type EventExecutionMode int

const (
    ExecutionModeSerial   EventExecutionMode = iota // 串行
    ExecutionModeParallel                            // 并行
)

func (r *EventHandlerRegistry) SubscribeWithMode(
    eventType string,
    handler base.EventHandler,
    mode EventExecutionMode,
) error {
    // 根据mode决定执行方式
    // ...
}
```

### 4.4 错误隔离

```go
func (bus *RabbitMQEventBus) consumeMessages(msgs <-chan amqp.Delivery, handler EventHandler) {
    for msg := range msgs {
        // 使用goroutine隔离错误
        go func(m amqp.Delivery) {
            defer func() {
                if r := recover(); r != nil {
                    log.Error("事件处理panic", "handler", handler.GetHandlerName(), "panic", r)
                    m.Nack(false, true)
                }
            }()
            
            var event base.BaseEvent
            if err := json.Unmarshal(m.Body, &event); err != nil {
                log.Error("解析事件失败", "error", err)
                m.Nack(false, false) // 不重新入队
                return
            }
            
            ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
            defer cancel()
            
            if err := handler.Handle(ctx, &event); err != nil {
                log.Error("处理事件失败",
                    "handler", handler.GetHandlerName(),
                    "event_type", event.GetEventType(),
                    "error", err)
                m.Nack(false, true) // 重新入队
            } else {
                m.Ack(false)
            }
        }(msg)
    }
}
```

---

## 五、事件使用示例

### 5.1 发布事件

```go
// Service层发布事件
func (s *ProjectService) CreateProject(ctx context.Context, req *CreateProjectRequest) (*CreateProjectResponse, error) {
    // 1. 业务逻辑
    project := &document.Project{
        AuthorID: req.AuthorID,
        Title:    req.Title,
        // ...
    }
    
    if err := s.projectRepo.Create(ctx, project); err != nil {
        return nil, err
    }
    
    // 2. 发布事件（强制）
    event := &ProjectCreatedEvent{
        ProjectID: project.ID,
        AuthorID:  project.AuthorID,
        Title:     project.Title,
        CreatedAt: time.Now(),
    }
    
    if err := s.eventBus.PublishAsync(ctx, event); err != nil {
        log.Error("发布项目创建事件失败", "error", err)
        // 不影响主流程，但需要记录
    }
    
    return &CreateProjectResponse{
        ProjectID: project.ID,
    }, nil
}
```

### 5.2 处理事件

```go
// User Level Service订阅TaskCompletedEvent
type UserLevelServiceImpl struct {
    userLevelRepo UserLevelRepository
    eventBus      base.EventBus
}

func (s *UserLevelServiceImpl) OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error {
    // 1. 增加经验值
    if err := s.AddExperience(ctx, event.UserID, event.RewardExp, fmt.Sprintf("task_%s", event.TaskID)); err != nil {
        return err
    }
    
    // 2. 检查升级
    levelUp, newLevel, err := s.CheckLevelUp(ctx, event.UserID)
    if err != nil {
        log.Error("检查升级失败", "error", err)
    }
    
    if levelUp {
        // 3. 发布升级事件
        upgradeEvent := &UserLevelUpEvent{
            UserID:      event.UserID,
            OldLevel:    newLevel.Level - 1,
            NewLevel:    newLevel.Level,
            LeveledUpAt: time.Now(),
        }
        s.eventBus.PublishAsync(ctx, upgradeEvent)
    }
    
    return nil
}

// GetSupportedEventTypes 实现EventHandler接口
func (s *UserLevelServiceImpl) GetSupportedEventTypes() []string {
    return []string{"task.completed", "user.behavior"}
}

// GetHandlerName 实现EventHandler接口
func (s *UserLevelServiceImpl) GetHandlerName() string {
    return "UserLevelService"
}

// Handle 实现EventHandler接口
func (s *UserLevelServiceImpl) Handle(ctx context.Context, event base.Event) error {
    switch event.GetEventType() {
    case "task.completed":
        return s.OnTaskCompleted(ctx, event.GetEventData().(*TaskCompletedEvent))
    case "user.behavior":
        return s.OnUserBehavior(ctx, event.GetEventData().(*UserBehaviorEvent))
    default:
        return fmt.Errorf("不支持的事件类型: %s", event.GetEventType())
    }
}
```

---

## 六、实施建议

### 6.1 迁移步骤

1. **阶段1**：实现RabbitMQ EventBus
2. **阶段2**：定义核心业务事件
3. **阶段3**：在Service接口中添加事件方法
4. **阶段4**：实现事件处理器
5. **阶段5**：注册事件处理器
6. **阶段6**：监控和优化

### 6.2 最佳实践

1. **事件命名**：使用`模块.动作`格式，如`user.created`、`task.completed`
2. **事件粒度**：不要过细，聚焦核心业务事件
3. **幂等性**：事件处理器必须是幂等的
4. **错误处理**：记录详细日志，支持重试
5. **监控**：监控事件发布和消费情况

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21  
**负责人**: 架构组  
**审核状态**: 待评审

