# 统一错误处理中间件设计

## 概述

统一错误处理中间件是青羽后端项目中负责处理所有HTTP请求和响应错误的核心组件。它提供了一套完整的错误处理机制，包括错误分类、错误转换、错误响应构建、日志记录等功能。

## 设计目标

1. **统一性**：提供统一的错误格式和处理方式
2. **可追溯性**：支持完整的错误追踪和上下文信息
3. **可扩展性**：支持自定义错误类型和处理逻辑
4. **性能优化**：高效的错误处理和响应构建
5. **开发友好**：提供简单易用的错误处理API

## 架构设计

### 核心组件

#### 1. 统一错误结构 (`UnifiedError`)

```go
type UnifiedError struct {
    // 基本信息
    ID       string        `json:"id"`
    Code     string        `json:"code"`
    Category ErrorCategory `json:"category"`
    Level    ErrorLevel    `json:"level"`
    Message  string        `json:"message"`
    Details  string        `json:"details,omitempty"`

    // 上下文信息
    Service   string `json:"service,omitempty"`
    Operation string `json:"operation,omitempty"`
    UserID    string `json:"user_id,omitempty"`
    RequestID string `json:"request_id,omitempty"`
    TraceID   string `json:"trace_id,omitempty"`

    // 技术细节
    Cause    error                  `json:"-"`
    Stack    string                 `json:"stack,omitempty"`
    Metadata map[string]interface{} `json:"metadata,omitempty"`

    // HTTP相关
    Timestamp  time.Time `json:"timestamp"`
    HTTPStatus int       `json:"http_status"`
    Retryable  bool      `json:"retryable"`
}
```

#### 2. 错误分类 (`ErrorCategory`)

```go
type ErrorCategory string

const (
    CategoryValidation ErrorCategory = "validation"  // 验证错误
    CategoryBusiness   ErrorCategory = "business"    // 业务错误
    CategorySystem     ErrorCategory = "system"      // 系统错误
    CategoryExternal   ErrorCategory = "external"    // 外部服务错误
    CategoryNetwork    ErrorCategory = "network"     // 网络错误
    CategoryAuth       ErrorCategory = "auth"        // 认证错误
    CategoryDatabase   ErrorCategory = "database"    // 数据库错误
    CategoryCache      ErrorCategory = "cache"       // 缓存错误
)
```

#### 3. 错误级别 (`ErrorLevel`)

```go
type ErrorLevel string

const (
    LevelInfo     ErrorLevel = "info"      // 信息级别
    LevelWarning  ErrorLevel = "warning"   // 警告级别
    LevelError    ErrorLevel = "error"     // 错误级别
    LevelCritical ErrorLevel = "critical"  // 严重级别
)
```

#### 4. 错误工厂 (`ErrorFactory`)

为不同服务提供预配置的错误创建工厂：

```go
var (
    AIServiceFactory        = NewErrorFactory("ai-service")
    UserServiceFactory      = NewErrorFactory("user-service")
    DocumentServiceFactory  = NewErrorFactory("document-service")
    BookstoreServiceFactory = NewErrorFactory("bookstore-service")
    ReaderServiceFactory    = NewErrorFactory("reader-service")
    WriterServiceFactory    = NewErrorFactory("writer-service")
)
```

#### 5. 错误转换器 (`ErrorConverter`)

负责将不同类型的错误转换为统一格式：

- `ConvertRepositoryError`: 转换Repository层错误
- `ConvertServiceError`: 转换Service层错误
- `ConvertGenericError`: 转换通用错误
- `ConvertPanic`: 转换panic为错误

#### 6. 错误处理器 (`ErrorHandler`)

处理HTTP错误响应：

- `HandleError`: 处理普通错误
- `HandlePanic`: 处理panic
- 自动添加请求上下文信息
- 构建统一的错误响应格式

## 中间件实现

### 错误处理中间件

```go
func ErrorMiddleware(service string) gin.HandlerFunc {
    handler := NewErrorHandler(true, false)

    return func(c *gin.Context) {
        defer func() {
            if r := recover(); r != nil {
                handler.HandlePanic(c, r, service, c.Request.URL.Path)
                c.Abort()
            }
        }()

        c.Next()

        // 检查是否有错误
        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            handler.HandleError(c, err, service, c.Request.URL.Path)
            c.Abort()
        }
    }
}
```

### 业务错误处理中间件

```go
func BusinessErrorMiddleware(service string) gin.HandlerFunc {
    handler := NewErrorHandler(true, false)

    return func(c *gin.Context) {
        c.Next()

        // 检查响应状态码
        if c.Writer.Status() >= 400 {
            // 如果已经设置了错误状态码但没有响应体，创建默认错误
            if c.Writer.Size() <= 0 {
                err := &UnifiedError{
                    ID:         generateErrorID(),
                    Code:       http.StatusText(c.Writer.Status()),
                    Category:   CategorySystem,
                    Level:      LevelError,
                    Message:    "Request failed",
                    Service:    service,
                    HTTPStatus: c.Writer.Status(),
                }

                response := handler.buildErrorResponse(err)
                c.JSON(c.Writer.Status(), response)
            }
        }
    }
}
```

## 使用方法

### 1. 在Service层使用

```go
func (s *UserService) CreateUser(user *models.User) error {
    if user.Username == "" {
        return UserServiceFactory.ValidationError(
            "INVALID_USERNAME",
            "Username is required"
        )
    }

    if user.Email == "" {
        return UserServiceFactory.ValidationError(
            "INVALID_EMAIL",
            "Email is required"
        )
    }

    // 业务逻辑...
    if userAlreadyExists {
        return UserServiceFactory.BusinessError(
            "USER_EXISTS",
            "User already exists",
            user.Username
        )
    }

    // 数据库操作...
    if err := s.userRepo.Save(user); err != nil {
        return UserServiceFactory.DatabaseError(
            "SAVE_USER_FAILED",
            "Failed to save user to database",
            err
        )
    }

    return nil
}
```

### 2. 在API层使用

```go
func (api *UserApi) CreateUser(c *gin.Context) {
    var user models.User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }

    if err := api.userService.CreateUser(&user); err != nil {
        // 错误会自动被中间件处理并转换为统一格式
        c.Error(err)
        return
    }

    c.JSON(201, gin.H{"message": "User created successfully"})
}
```

### 3. 在中间件中使用

```go
func main() {
    router := gin.New()

    // 添加全局错误处理中间件
    router.Use(middleware.ErrorMiddleware("user-service"))

    // API路由
    userGroup := router.Group("/api/v1/user")
    {
        userGroup.POST("/register", userApi.Register)
        userGroup.POST("/login", userApi.Login)
    }

    router.Run(":8080")
}
```

## 错误响应格式

### 标准错误响应

```json
{
    "success": false,
    "error": {
        "code": "VALIDATION_ERROR",
        "message": "Username is required",
        "details": "Username cannot be empty",
        "category": "validation",
        "level": "warning"
    },
    "request_id": "req_1640995200000000000",
    "trace_id": "trace_1640995200000000000",
    "timestamp": "2024-01-01T00:00:00Z",
    "metadata": {
        "field": "username",
        "value": ""
    }
}
```

### 开发环境错误响应

```json
{
    "success": false,
    "error": {
        "code": "DATABASE_ERROR",
        "message": "Failed to save user to database",
        "details": "connection timeout",
        "category": "database",
        "level": "error"
    },
    "request_id": "req_1640995200000000000",
    "trace_id": "trace_1640995200000000000",
    "timestamp": "2024-01-01T00:00:00Z",
    "metadata": {
        "operation": "insert",
        "collection": "users"
    },
    "stack": "goroutine 1 [running]:\n...",
    "cause": "mongo: connection timeout"
}
```

## 高级功能

### 1. 错误链管理

```go
// 创建错误链
chain := errors.NewErrorChain()

// 添加错误
chain.Add(validationErr).
      Add(businessErr).
      Add(systemErr)

// 检查是否有错误
if chain.HasErrors() {
    // 处理错误链
    for _, err := range chain.GetErrors() {
        log.Printf("Error: %s", err.Message)
    }
}
```

### 2. 错误聚合器

```go
// 创建错误聚合器
aggregator := errors.NewErrorAggregator()

// 按字段分组错误
aggregator.Add("username", usernameErr)
aggregator.Add("email", emailErr)
aggregator.Add("username", usernameLengthErr)

// 获取特定字段的错误
usernameErrors := aggregator.Get("username")
```

### 3. 错误上下文包装

```go
// 创建错误上下文
ctx := errors.NewErrorContext(
    userID,
    requestID,
    traceID,
    "user-service",
    "CreateUser"
)

// 包装错误
wrappedErr := ctx.Wrap(originalError)
```

### 4. 错误构建器模式

```go
// 使用构建器创建复杂错误
err := errors.NewErrorBuilder().
    WithCode("CUSTOM_ERROR").
    WithCategory(errors.CategoryBusiness).
    WithLevel(errors.LevelError).
    WithMessage("Custom business error").
    WithDetails("Detailed error description").
    WithService("user-service", "CreateUser").
    WithContext(userID, requestID, traceID).
    WithHTTPStatus(422).
    WithMetadata("field", "username").
    WithMetadata("value", "").
    Build()
```

## 最佳实践

### 1. 错误分类原则

- **验证错误** (`validation`): 输入参数验证失败
- **业务错误** (`business`): 业务规则违反
- **系统错误** (`system`): 内部系统错误
- **外部错误** (`external`): 外部服务调用失败
- **网络错误** (`network`): 网络相关错误
- **认证错误** (`auth`): 认证授权失败
- **数据库错误** (`database`): 数据库操作失败
- **缓存错误** (`cache`): 缓存操作失败

### 2. 错误代码规范

- 使用大写字母和下划线：`VALIDATION_ERROR`、`USER_NOT_FOUND`
- 具有唯一性，不同服务可以使用相同代码
- 简洁明了，能够清楚表达错误含义

### 3. 错误消息规范

- **用户友好**：错误消息应该对最终用户友好
- **信息充分**：提供足够的信息帮助解决问题
- **安全考虑**：不暴露敏感的系统信息
- **本地化支持**：考虑多语言支持

### 4. 日志记录策略

- **开发环境**：记录详细错误信息，包括堆栈跟踪
- **生产环境**：记录关键错误信息，避免敏感数据泄露
- **错误追踪**：使用结构化日志，便于分析和监控

### 5. 性能考虑

- **错误ID生成**：使用时间戳和计数器，确保唯一性
- **内存管理**：及时清理错误对象，避免内存泄露
- **异步处理**：对于不紧急的错误日志，可以考虑异步处理

## 扩展机制

### 自定义错误类型

```go
// 自定义错误类型
type CustomError struct {
    *errors.UnifiedError
    CustomField string `json:"custom_field"`
}

// 创建自定义错误
func NewCustomError(field string) *CustomError {
    return &CustomError{
        UnifiedError: errors.NewErrorBuilder().
            WithCode("CUSTOM_ERROR").
            WithCategory(errors.CategoryBusiness).
            WithMessage("Custom error occurred").
            Build(),
        CustomField: field,
    }
}
```

### 自定义错误处理器

```go
type CustomErrorHandler struct {
    *errors.ErrorHandler
}

// 覆盖默认的错误处理逻辑
func (h *CustomErrorHandler) HandleError(c *gin.Context, err error, service, operation string) {
    // 自定义处理逻辑
    // ...
}
```

## 监控和告警

### 错误指标收集

```go
// 错误计数器
var (
    errorCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "app_errors_total",
            Help: "Total number of errors",
        },
        []string{"service", "category", "level", "code"},
    )
)

// 在错误处理器中记录指标
func (h *ErrorHandler) HandleError(c *gin.Context, err error, service, operation string) {
    unifiedErr := h.converter.ConvertGenericError(err, service, operation)

    // 记录指标
    errorCounter.WithLabelValues(
        unifiedErr.Service,
        string(unifiedErr.Category),
        string(unifiedErr.Level),
        unifiedErr.Code,
    ).Inc()

    // 其他处理逻辑...
}
```

### 错误告警规则

- **严重错误**：立即告警（`critical` 级别）
- **系统错误**：监控告警（`error` 级别）
- **业务错误**：趋势告警（`warning` 级别）
- **外部服务错误**：服务依赖告警

## 测试策略

### 单元测试

```go
func TestErrorFactory_ValidationError(t *testing.T) {
    err := UserServiceFactory.ValidationError(
        "INVALID_USERNAME",
        "Username is required",
    )

    assert.Equal(t, "VALIDATION_ERROR", err.Code)
    assert.Equal(t, errors.CategoryValidation, err.Category)
    assert.Equal(t, 400, err.HTTPStatus)
}
```

### 集成测试

```go
func TestErrorMiddleware(t *testing.T) {
    // 测试中间件是否正确处理错误
    router := gin.New()
    router.Use(middleware.ErrorMiddleware("test-service"))

    router.GET("/error", func(c *gin.Context) {
        c.Error(errors.NewValidationError("TEST_ERROR", "Test error"))
    })

    // 发送请求并验证响应
    // ...
}
```

## 总结

统一错误处理中间件为青羽后端项目提供了一套完整的错误处理解决方案，具有以下特点：

1. **统一性**：所有错误都遵循相同的结构和格式
2. **可追溯性**：支持完整的错误追踪和上下文信息
3. **可扩展性**：支持自定义错误类型和处理逻辑
4. **性能优化**：高效的错误处理和响应构建
5. **开发友好**：提供简单易用的错误处理API
6. **监控友好**：支持指标收集和告警规则

通过这套统一错误处理机制，项目能够更好地处理各种异常情况，提高系统的稳定性和可维护性。
