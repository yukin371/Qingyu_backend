# 响应处理中间件设计

> **文档版本**: v1.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ✅ 设计完成

---

## 1. 需求概述

### 1.1 功能描述

响应处理中间件为青羽后端提供统一的HTTP响应处理能力，包括响应格式化、敏感字段过滤、响应时间统计、缓存控制等，确保API响应的一致性、安全性和可观测性。

### 1.2 业务价值

- **一致性**：统一的响应格式，简化前端处理
- **安全性**：自动过滤敏感信息，防止数据泄露
- **性能监控**：响应时间统计，识别性能瓶颈
- **缓存优化**：合理的缓存控制，提升用户体验

### 1.3 应用场景

- **API响应标准化**：统一返回格式
- **敏感数据保护**：过滤密码、Token等敏感字段
- **性能分析**：记录响应时间
- **HTTP缓存控制**：设置Cache-Control头
- **内容协商**：支持多种响应格式（JSON、XML等）

---

## 2. 架构设计

### 2.1 响应处理流程

```
┌─────────────────────────────────────────┐
│         响应处理流程                      │
├─────────────────────────────────────────┤
│  业务Handler                             │
│  └─> 返回数据对象                        │
│              ↓                           │
│  ResponseFormatter Middleware            │
│  └─> 包装为统一格式                      │
│              ↓                           │
│  SensitiveFieldFilter Middleware         │
│  └─> 过滤敏感字段                        │
│              ↓                           │
│  ResponseTiming Middleware               │
│  └─> 添加响应时间                        │
│              ↓                           │
│  CacheControl Middleware                 │
│  └─> 设置缓存头                          │
│              ↓                           │
│  HTTP响应返回给客户端                     │
└─────────────────────────────────────────┘
```

### 2.2 响应格式标准化

```json
// 成功响应格式
{
  "code": 200,
  "message": "Success",
  "data": { ... },
  "timestamp": 1698765432,
  "request_id": "uuid",
  "elapsed_ms": 123
}

// 错误响应格式
{
  "code": 40001,
  "message": "Validation failed",
  "error": "Email is required",
  "timestamp": 1698765432,
  "request_id": "uuid",
  "elapsed_ms": 45
}

// 分页响应格式
{
  "code": 200,
  "message": "Success",
  "data": {
    "items": [ ... ],
    "pagination": {
      "page": 1,
      "page_size": 20,
      "total": 100,
      "total_pages": 5
    }
  },
  "timestamp": 1698765432
}
```

---

## 3. 详细设计

### 3.1 响应格式化中间件

#### 3.1.1 标准响应结构

```go
// 实现文件：response.go

// 标准响应结构
type Response struct {
    Code      int         `json:"code"`               // 状态码
    Message   string      `json:"message"`            // 消息
    Data      interface{} `json:"data,omitempty"`     // 数据
    Error     string      `json:"error,omitempty"`    // 错误详情
    Timestamp int64       `json:"timestamp"`          // 时间戳
    RequestID string      `json:"request_id,omitempty"` // 请求ID
    ElapsedMs int64       `json:"elapsed_ms,omitempty"` // 响应时间（毫秒）
}

// 分页响应
type PagedResponse struct {
    Items      interface{}       `json:"items"`
    Pagination PaginationInfo    `json:"pagination"`
}

type PaginationInfo struct {
    Page       int   `json:"page"`
    PageSize   int   `json:"page_size"`
    Total      int64 `json:"total"`
    TotalPages int   `json:"total_pages"`
}
```

#### 3.1.2 响应格式化实现

```go
// 实现文件：response.go

func ResponseFormatterMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 记录请求开始时间
        startTime := time.Now()
        
        // 生成请求ID
        requestID := generateRequestID()
        c.Set("request_id", requestID)
        
        // 执行业务逻辑
        c.Next()
        
        // 如果已经写入响应，直接返回
        if c.Writer.Written() {
            return
        }
        
        // 如果有错误，格式化错误响应
        if len(c.Errors) > 0 {
            formatErrorResponse(c, startTime, requestID)
            return
        }
        
        // 格式化成功响应
        formatSuccessResponse(c, startTime, requestID)
    }
}

// 格式化成功响应
func formatSuccessResponse(c *gin.Context, startTime time.Time, requestID string) {
    // 获取业务数据
    data, exists := c.Get("response_data")
    if !exists {
        data = nil
    }
    
    // 获取消息
    message, _ := c.Get("response_message")
    if message == nil {
        message = "Success"
    }
    
    // 计算响应时间
    elapsed := time.Since(startTime).Milliseconds()
    
    // 构建响应
    response := Response{
        Code:      c.Writer.Status(),
        Message:   message.(string),
        Data:      data,
        Timestamp: time.Now().Unix(),
        RequestID: requestID,
        ElapsedMs: elapsed,
    }
    
    c.JSON(c.Writer.Status(), response)
}

// 格式化错误响应
func formatErrorResponse(c *gin.Context, startTime time.Time, requestID string) {
    err := c.Errors.Last()
    
    elapsed := time.Since(startTime).Milliseconds()
    
    response := Response{
        Code:      c.Writer.Status(),
        Message:   err.Error(),
        Error:     err.Meta.(string),
        Timestamp: time.Now().Unix(),
        RequestID: requestID,
        ElapsedMs: elapsed,
    }
    
    c.JSON(c.Writer.Status(), response)
}

// 生成请求ID
func generateRequestID() string {
    return uuid.New().String()
}
```

---

### 3.2 敏感字段过滤中间件

#### 3.2.1 敏感字段定义

```go
// 默认敏感字段列表
var defaultSensitiveFields = []string{
    "password",
    "passwd",
    "secret",
    "token",
    "api_key",
    "apikey",
    "access_token",
    "refresh_token",
    "private_key",
    "privatekey",
    "auth",
    "authorization",
    "credential",
    "ssn",              // 社会保险号
    "credit_card",      // 信用卡号
    "cvv",              // CVV码
}
```

#### 3.2.2 过滤中间件实现

```go
// 实现文件：response.go

func SensitiveFieldFilterMiddleware() gin.HandlerFunc {
    return SensitiveFieldFilterWithFields(defaultSensitiveFields)
}

func SensitiveFieldFilterWithFields(sensitiveFields []string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 创建自定义ResponseWriter
        blw := &bodyLogWriter{
            ResponseWriter: c.Writer,
            body:           &bytes.Buffer{},
        }
        c.Writer = blw
        
        c.Next()
        
        // 如果是JSON响应，过滤敏感字段
        if isJSONResponse(c) {
            filtered := filterSensitiveData(blw.body.Bytes(), sensitiveFields)
            c.Writer.Write(filtered)
        } else {
            c.Writer.Write(blw.body.Bytes())
        }
    }
}

// 自定义ResponseWriter，用于缓存响应体
type bodyLogWriter struct {
    gin.ResponseWriter
    body *bytes.Buffer
}

func (w *bodyLogWriter) Write(b []byte) (int, error) {
    return w.body.Write(b)
}

// 判断是否为JSON响应
func isJSONResponse(c *gin.Context) bool {
    contentType := c.Writer.Header().Get("Content-Type")
    return strings.Contains(contentType, "application/json")
}

// 过滤敏感数据
func filterSensitiveData(data []byte, sensitiveFields []string) []byte {
    var jsonData interface{}
    
    if err := json.Unmarshal(data, &jsonData); err != nil {
        return data // 解析失败，返回原数据
    }
    
    // 递归过滤
    filtered := filterSensitiveFields(jsonData, sensitiveFields)
    
    // 重新序列化
    result, err := json.Marshal(filtered)
    if err != nil {
        return data
    }
    
    return result
}

// 递归过滤敏感字段
func filterSensitiveFields(data interface{}, sensitiveFields []string) interface{} {
    switch v := data.(type) {
    case map[string]interface{}:
        filtered := make(map[string]interface{})
        for key, value := range v {
            if isSensitiveField(key, sensitiveFields) {
                // 替换为***
                filtered[key] = "***FILTERED***"
            } else {
                // 递归处理
                filtered[key] = filterSensitiveFields(value, sensitiveFields)
            }
        }
        return filtered
        
    case []interface{}:
        filtered := make([]interface{}, len(v))
        for i, item := range v {
            filtered[i] = filterSensitiveFields(item, sensitiveFields)
        }
        return filtered
        
    default:
        return v
    }
}

// 判断是否为敏感字段
func isSensitiveField(fieldName string, sensitiveFields []string) bool {
    lowerName := strings.ToLower(fieldName)
    for _, sensitive := range sensitiveFields {
        if strings.Contains(lowerName, strings.ToLower(sensitive)) {
            return true
        }
    }
    return false
}
```

---

### 3.3 响应时间统计中间件

```go
// 实现文件：response.go

func ResponseTimingMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        startTime := time.Now()
        
        c.Next()
        
        // 计算响应时间
        elapsed := time.Since(startTime)
        
        // 添加到响应头
        c.Header("X-Response-Time", fmt.Sprintf("%dms", elapsed.Milliseconds()))
        
        // 记录慢请求
        if elapsed > 1*time.Second {
            logger.Warn("Slow request detected",
                zap.String("path", c.Request.URL.Path),
                zap.String("method", c.Request.Method),
                zap.Duration("elapsed", elapsed),
            )
        }
        
        // 记录Prometheus指标
        recordResponseTime(c.Request.URL.Path, elapsed)
    }
}

// 记录响应时间指标
func recordResponseTime(path string, duration time.Duration) {
    responseTimeHistogram.WithLabelValues(path).Observe(duration.Seconds())
}

var responseTimeHistogram = prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    "http_response_time_seconds",
        Help:    "HTTP response time in seconds",
        Buckets: prometheus.DefBuckets,
    },
    []string{"path"},
)
```

---

### 3.4 缓存控制中间件

#### 3.4.1 缓存策略

```go
// 缓存策略枚举
type CacheStrategy string

const (
    CacheStrategyNoCache    CacheStrategy = "no-cache"     // 不缓存
    CacheStrategyPrivate    CacheStrategy = "private"      // 浏览器缓存
    CacheStrategyPublic     CacheStrategy = "public"       // CDN缓存
    CacheStrategyImmutable  CacheStrategy = "immutable"    // 永久缓存
)

// 缓存配置
type CacheConfig struct {
    Strategy  CacheStrategy
    MaxAge    int           // 最大缓存时间（秒）
    SMaxAge   int           // 共享缓存最大时间（秒）
    MustRevalidate bool     // 必须重新验证
    NoTransform    bool     // 禁止转换
}
```

#### 3.4.2 缓存控制实现

```go
// 实现文件：response.go

func CacheControlMiddleware(maxAge int) gin.HandlerFunc {
    config := CacheConfig{
        Strategy: CacheStrategyPrivate,
        MaxAge:   maxAge,
    }
    return CacheControlWithConfig(config)
}

func CacheControlWithConfig(config CacheConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()
        
        // 构建Cache-Control头
        cacheControl := buildCacheControlHeader(config)
        c.Header("Cache-Control", cacheControl)
        
        // 添加Expires头
        if config.MaxAge > 0 {
            expires := time.Now().Add(time.Duration(config.MaxAge) * time.Second)
            c.Header("Expires", expires.Format(http.TimeFormat))
        }
        
        // 添加Vary头（告诉缓存根据哪些请求头来区分缓存）
        c.Header("Vary", "Accept-Encoding, Accept-Language")
    }
}

// 构建Cache-Control头
func buildCacheControlHeader(config CacheConfig) string {
    var parts []string
    
    // 策略
    parts = append(parts, string(config.Strategy))
    
    // max-age
    if config.MaxAge > 0 {
        parts = append(parts, fmt.Sprintf("max-age=%d", config.MaxAge))
    }
    
    // s-maxage (shared cache)
    if config.SMaxAge > 0 {
        parts = append(parts, fmt.Sprintf("s-maxage=%d", config.SMaxAge))
    }
    
    // must-revalidate
    if config.MustRevalidate {
        parts = append(parts, "must-revalidate")
    }
    
    // no-transform
    if config.NoTransform {
        parts = append(parts, "no-transform")
    }
    
    return strings.Join(parts, ", ")
}

// 常用缓存配置

// 不缓存（动态内容）
func NoCacheMiddleware() gin.HandlerFunc {
    return CacheControlWithConfig(CacheConfig{
        Strategy: CacheStrategyNoCache,
    })
}

// 短时缓存（1分钟）
func ShortCacheMiddleware() gin.HandlerFunc {
    return CacheControlWithConfig(CacheConfig{
        Strategy: CacheStrategyPrivate,
        MaxAge:   60,
    })
}

// 长时缓存（1天）
func LongCacheMiddleware() gin.HandlerFunc {
    return CacheControlWithConfig(CacheConfig{
        Strategy: CacheStrategyPublic,
        MaxAge:   86400,
        SMaxAge:  86400,
    })
}

// 永久缓存（静态资源）
func ImmutableCacheMiddleware() gin.HandlerFunc {
    return CacheControlWithConfig(CacheConfig{
        Strategy: CacheStrategyPublic,
        MaxAge:   31536000, // 1年
    })
}
```

---

## 4. 高级特性

### 4.1 条件响应（ETag）

```go
// ETag中间件
func ETagMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 创建自定义Writer
        blw := &bodyLogWriter{
            ResponseWriter: c.Writer,
            body:           &bytes.Buffer{},
        }
        c.Writer = blw
        
        c.Next()
        
        // 计算ETag
        etag := calculateETag(blw.body.Bytes())
        c.Header("ETag", etag)
        
        // 检查If-None-Match
        ifNoneMatch := c.Request.Header.Get("If-None-Match")
        if ifNoneMatch == etag {
            c.Status(http.StatusNotModified)
            return
        }
        
        // 写入响应
        c.Writer.Write(blw.body.Bytes())
    }
}

func calculateETag(data []byte) string {
    hash := sha256.Sum256(data)
    return fmt.Sprintf(`"%x"`, hash)
}
```

### 4.2 响应压缩

```go
// Gzip压缩中间件
func GzipMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 检查客户端是否支持gzip
        if !strings.Contains(c.Request.Header.Get("Accept-Encoding"), "gzip") {
            c.Next()
            return
        }
        
        // 创建gzip writer
        gz := gzip.NewWriter(c.Writer)
        defer gz.Close()
        
        // 设置响应头
        c.Header("Content-Encoding", "gzip")
        c.Header("Vary", "Accept-Encoding")
        
        // 替换Writer
        c.Writer = &gzipWriter{
            ResponseWriter: c.Writer,
            writer:         gz,
        }
        
        c.Next()
    }
}

type gzipWriter struct {
    gin.ResponseWriter
    writer *gzip.Writer
}

func (w *gzipWriter) Write(data []byte) (int, error) {
    return w.writer.Write(data)
}
```

### 4.3 内容协商

```go
// 内容协商中间件
func ContentNegotiationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        accept := c.Request.Header.Get("Accept")
        
        // 根据Accept头设置响应格式
        switch {
        case strings.Contains(accept, "application/xml"):
            c.Set("response_format", "xml")
        case strings.Contains(accept, "application/json"):
            c.Set("response_format", "json")
        default:
            c.Set("response_format", "json") // 默认JSON
        }
        
        c.Next()
    }
}
```

---

## 5. 配置管理

### 5.1 配置文件

```yaml
# config/response.yaml
response:
  # 响应格式化
  formatter:
    enabled: true
    include_request_id: true
    include_elapsed_time: true
    include_timestamp: true
  
  # 敏感字段过滤
  sensitive_filter:
    enabled: true
    fields:
      - "password"
      - "secret"
      - "token"
      - "api_key"
      - "private_key"
      - "ssn"
      - "credit_card"
  
  # 响应时间统计
  timing:
    enabled: true
    slow_threshold: 1s
    include_in_header: true
  
  # 缓存控制
  cache:
    default_strategy: "private"
    paths:
      # 静态资源：长时缓存
      /api/v1/static/*:
        strategy: "public"
        max_age: 86400
        immutable: true
      
      # 用户数据：不缓存
      /api/v1/user/*:
        strategy: "no-cache"
      
      # 列表数据：短时缓存
      /api/v1/books:
        strategy: "public"
        max_age: 300
        s_maxage: 600
```

---

## 6. 监控与日志

### 6.1 Prometheus指标

```go
var (
    responseTimeHistogram = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_response_time_seconds",
            Help:    "HTTP response time in seconds",
            Buckets: []float64{0.001, 0.01, 0.1, 0.5, 1, 2, 5, 10},
        },
        []string{"path", "method", "status"},
    )
    
    responseSizeHistogram = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_response_size_bytes",
            Help:    "HTTP response size in bytes",
            Buckets: prometheus.ExponentialBuckets(100, 10, 8),
        },
        []string{"path"},
    )
)
```

---

## 7. 测试设计

### 7.1 响应格式化测试

```go
func TestResponseFormatter(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    router := gin.New()
    router.Use(ResponseFormatterMiddleware())
    router.GET("/test", func(c *gin.Context) {
        c.Set("response_data", gin.H{"name": "test"})
        c.Status(200)
    })
    
    w := httptest.NewRecorder()
    req, _ := http.NewRequest("GET", "/test", nil)
    router.ServeHTTP(w, req)
    
    var response Response
    json.Unmarshal(w.Body.Bytes(), &response)
    
    assert.Equal(t, 200, response.Code)
    assert.Equal(t, "Success", response.Message)
    assert.NotNil(t, response.Data)
}
```

---

## 8. 使用示例

### 8.1 基本使用

```go
// router/enter.go
func InitRoutes(r *gin.Engine) {
    // 全局中间件
    r.Use(middleware.ResponseTimingMiddleware())
    r.Use(middleware.SensitiveFieldFilterMiddleware())
    r.Use(middleware.ResponseFormatterMiddleware())
    
    // API路由
    api := r.Group("/api/v1")
    {
        // 用户数据：不缓存
        api.GET("/user/profile", 
            middleware.NoCacheMiddleware(),
            userApi.GetProfile)
        
        // 列表数据：短时缓存
        api.GET("/books", 
            middleware.ShortCacheMiddleware(),
            bookApi.List)
        
        // 静态资源：长时缓存
        api.GET("/static/*filepath", 
            middleware.LongCacheMiddleware(),
            staticApi.Serve)
    }
}
```

---

## 9. 最佳实践

### 9.1 响应格式建议

- ✅ 使用统一的响应格式
- ✅ 包含请求ID便于追踪
- ✅ 包含时间戳便于调试
- ✅ 区分data和error字段

### 9.2 缓存策略建议

- ✅ 动态内容使用no-cache
- ✅ 静态资源使用长时缓存
- ✅ 列表数据使用短时缓存
- ✅ 设置合理的Vary头

### 9.3 安全建议

- ✅ 必须过滤敏感字段
- ✅ 生产环境隐藏错误详情
- ✅ 设置安全的缓存策略

---

## 10. 关联文件

### 实现文件

- `middleware/response.go` - 响应处理中间件 (~110行)

### 相关设计

- [中间件总体设计](./中间件总体设计.md) - 中间件架构
- [安全中间件设计](./安全中间件设计.md) - 敏感信息过滤
- [日志中间件设计](./日志中间件设计.md) - 日志记录

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21  
**作者**: 青羽架构组

