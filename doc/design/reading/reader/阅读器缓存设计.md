# 阅读器缓存设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ⚠️ 待完善实现

---

## 1. 设计概述

### 1.1 缓存目标

- 提升章节加载速度
- 减少数据库查询
- 优化阅读进度同步

---

## 2. 核心缓存策略

### 2.1 章节内容缓存

**缓存Key**：`chapter:content:{chapterId}`

**TTL**: 30分钟

**缓存内容**：
```go
type CachedChapterContent struct {
    ChapterID   string
    Title       string
    Content     string
    WordCount   int
    PrevChapter string  // 上一章ID
    NextChapter string  // 下一章ID
    CachedAt    time.Time
}
```

### 2.2 阅读进度缓存

**缓存Key**：`progress:{userId}:{bookId}`

**TTL**: 5分钟（频繁更新）

**更新策略**：
- 读取时从缓存获取
- 更新时先写缓存，异步写数据库

```go
func UpdateProgress(userID, bookID string, progress *ReadingProgress) {
    // 1. 立即更新缓存
    cache.Set("progress:"+userID+":"+bookID, progress, 5*time.Minute)
    
    // 2. 异步更新数据库
    go db.Update(progress)
}
```

### 2.3 阅读设置缓存

**缓存Key**：`settings:{userId}`

**TTL**: 1小时（不常变化）

---

## 3. 预加载策略（独特设计）

### 3.1 相邻章节预加载

**问题**：用户翻页时需要等待下一章加载

**解决方案**：预加载前后3章

```go
func LoadChapter(chapterID string) (*Chapter, error) {
    // 1. 加载当前章节
    current := getChapterFromCache(chapterID)
    
    // 2. 后台预加载相邻章节
    go preloadAdjacentChapters(chapterID, 3)
    
    return current, nil
}

func preloadAdjacentChapters(chapterID string, count int) {
    // 获取章节序列
    chapter := getChapter(chapterID)
    
    // 预加载后续章节
    nextChapters := getNextChapters(chapter, count)
    for _, ch := range nextChapters {
        if !cache.Exists("chapter:content:" + ch.ID) {
            content := loadChapterContent(ch.ID)
            cache.Set("chapter:content:"+ch.ID, content, 30*time.Minute)
        }
    }
    
    // 预加载前面章节
    prevChapters := getPrevChapters(chapter, count)
    for _, ch := range prevChapters {
        if !cache.Exists("chapter:content:" + ch.ID) {
            content := loadChapterContent(ch.ID)
            cache.Set("chapter:content:"+ch.ID, content, 30*time.Minute)
        }
    }
}
```

### 3.2 智能预测

**根据阅读速度预加载**：
```go
// 根据用户阅读速度动态调整预加载数量
func calculatePreloadCount(readingSpeed int) int {
    // readingSpeed: 字/分钟
    if readingSpeed > 500 {
        return 5  // 快速阅读，预加载更多
    } else if readingSpeed > 300 {
        return 3  // 正常阅读
    } else {
        return 2  // 慢速阅读
    }
}
```

---

## 4. 标注数据缓存

**缓存Key**：`annotations:{userId}:{chapterId}`

**TTL**: 10分钟

**缓存内容**：用户在该章节的所有标注

```go
type CachedAnnotations struct {
    ChapterID   string
    Annotations []Annotation
    CachedAt    time.Time
}
```

**更新策略**：
- 读取章节时加载标注
- 新增/删除标注时清除缓存

---

## 5. 离线阅读支持

### 5.1 章节打包下载

```go
type OfflinePackage struct {
    BookID    string
    Chapters  []CachedChapterContent
    Settings  ReadingSettings
    CreatedAt time.Time
}

func GenerateOfflinePackage(bookID string, startChapter, endChapter int) (*OfflinePackage, error) {
    // 打包指定范围的章节
    chapters := loadChapters(bookID, startChapter, endChapter)
    
    return &OfflinePackage{
        BookID:   bookID,
        Chapters: chapters,
    }, nil
}
```

---

## 6. 实现参考

**代码文件**：
- `service/reading/reader_cache_service.go`（待创建）
- `service/reading/reading_progress_service.go`（已有）

---

**文档状态**: ✅ 已完成  
**优先级**: P0

