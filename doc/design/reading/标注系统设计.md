# 标注系统设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ✅ 已实现，补充设计文档

---

## 1. 为什么需要这个设计

### 1.1 业务背景

标注系统是增强阅读体验的重要功能，负责：
- 用户阅读时划线、高亮、批注
- 记录阅读感悟和笔记
- 分享和交流阅读心得
- 个人知识库积累
- 提升用户粘性

### 1.2 实际实现情况

已完整实现，包含：
- **Annotation数据模型**：`models/reading/reader/annotation.go`
- **标注CRUD操作**
- **标注类型**：高亮、下划线、笔记、书签

**实现文件**：
- `models/reading/reader/annotation.go` - 标注数据模型
- `service/reading/annotation_service.go` - 标注服务（如果存在）
- `repository/mongodb/reading/annotation_mongo.go` - Repository实现
- `api/v1/reader/annotation_api.go` - 标注API

---

## 2. 数据模型设计

### 2.1 Annotation（标注）

#### 2.1.1 数据结构

```go
type Annotation struct {
    ID         string         `bson:"_id,omitempty" json:"id"`
    UserID     string         `bson:"userId" json:"userId" validate:"required"`      // 用户ID
    BookID     string         `bson:"bookId" json:"bookId" validate:"required"`      // 书籍ID
    ChapterID  string         `bson:"chapterId" json:"chapterId" validate:"required"` // 章节ID
    Type       AnnotationType `bson:"type" json:"type" validate:"required"`          // 标注类型
    StartPos   int            `bson:"startPos" json:"startPos"`                      // 起始位置
    EndPos     int            `bson:"endPos" json:"endPos"`                          // 结束位置
    Text       string         `bson:"text" json:"text"`                              // 标注文本内容
    Note       string         `bson:"note,omitempty" json:"note,omitempty"`          // 用户笔记
    Color      string         `bson:"color,omitempty" json:"color,omitempty"`        // 高亮颜色
    IsPublic   bool           `bson:"isPublic" json:"isPublic"`                      // 是否公开
    LikeCount  int            `bson:"likeCount" json:"likeCount"`                    // 点赞数
    CreatedAt  time.Time      `bson:"createdAt" json:"createdAt"`
    UpdatedAt  time.Time      `bson:"updatedAt" json:"updatedAt"`
}
```

#### 2.1.2 AnnotationType（标注类型）

```go
type AnnotationType string

const (
    TypeHighlight  AnnotationType = "highlight"  // 高亮
    TypeUnderline  AnnotationType = "underline"  // 下划线
    TypeNote       AnnotationType = "note"       // 笔记/批注
    TypeBookmark   AnnotationType = "bookmark"   // 书签
)
```

#### 2.1.3 HighlightColor（高亮颜色）

```go
// 预定义高亮颜色
var HighlightColors = []string{
    "#FFEB3B", // 黄色
    "#FF9800", // 橙色
    "#4CAF50", // 绿色
    "#2196F3", // 蓝色
    "#9C27B0", // 紫色
    "#F44336", // 红色
}

const DefaultHighlightColor = "#FFEB3B" // 默认黄色
```

#### 2.1.4 业务方法

```go
// IsValid 验证标注是否有效
func (a *Annotation) IsValid() bool {
    if a.StartPos < 0 || a.EndPos < 0 {
        return false
    }
    if a.EndPos < a.StartPos {
        return false
    }
    if a.Type == TypeNote && a.Note == "" {
        return false  // 笔记类型必须有内容
    }
    return true
}

// GetLength 获取标注长度
func (a *Annotation) GetLength() int {
    return a.EndPos - a.StartPos
}

// HasNote 是否有笔记
func (a *Annotation) HasNote() bool {
    return a.Note != ""
}

// IsBookmark 是否是书签
func (a *Annotation) IsBookmark() bool {
    return a.Type == TypeBookmark
}

// CanBePublic 是否可以公开（只有带笔记的标注才能公开）
func (a *Annotation) CanBePublic() bool {
    return a.Type == TypeNote && a.Note != ""
}
```

#### 2.1.5 索引策略

```javascript
// MongoDB索引
db.annotations.createIndex({ "userId": 1, "bookId": 1, "createdAt": -1 })     // 查询用户的书籍标注
db.annotations.createIndex({ "userId": 1, "chapterId": 1, "startPos": 1 })    // 查询章节内的标注
db.annotations.createIndex({ "bookId": 1, "isPublic": 1, "likeCount": -1 })   // 查询热门公开标注
db.annotations.createIndex({ "userId": 1, "type": 1, "createdAt": -1 })       // 按类型查询标注
```

---

### 2.2 AnnotationCount（标注统计）

```go
type AnnotationCount struct {
    UserID          string `bson:"_id" json:"userId"`
    TotalAnnotations int64  `bson:"totalAnnotations" json:"totalAnnotations"`
    HighlightCount  int64  `bson:"highlightCount" json:"highlightCount"`
    NoteCount       int64  `bson:"noteCount" json:"noteCount"`
    BookmarkCount   int64  `bson:"bookmarkCount" json:"bookmarkCount"`
}
```

---

## 3. Service层设计

### 3.1 核心业务方法

```go
// CreateAnnotation 创建标注
func (s *AnnotationService) CreateAnnotation(ctx context.Context, req *CreateAnnotationRequest) (*CreateAnnotationResponse, error) {
    // 1. 验证请求
    if err := s.validateAnnotationRequest(req); err != nil {
        return nil, errors.NewValidationError(err.Error())
    }
    
    // 2. 检查是否已存在相同位置的标注
    existing, _ := s.annotationRepo.GetByPosition(ctx, req.UserID, req.ChapterID, req.StartPos, req.EndPos)
    if existing != nil {
        // 允许同一位置不同类型的标注共存
        if existing.Type == req.Type {
            return nil, errors.NewBusinessError("该位置已有标注")
        }
    }
    
    // 3. 设置默认颜色
    color := req.Color
    if color == "" && req.Type == TypeHighlight {
        color = DefaultHighlightColor
    }
    
    // 4. 创建标注
    annotation := &Annotation{
        UserID:    req.UserID,
        BookID:    req.BookID,
        ChapterID: req.ChapterID,
        Type:      req.Type,
        StartPos:  req.StartPos,
        EndPos:    req.EndPos,
        Text:      req.Text,
        Note:      req.Note,
        Color:     color,
        IsPublic:  req.IsPublic && req.Type == TypeNote, // 只有笔记可公开
        LikeCount: 0,
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    // 5. 保存标注
    if err := s.annotationRepo.Create(ctx, annotation); err != nil {
        return nil, errors.NewInternalError("创建标注失败").WithCause(err)
    }
    
    // 6. 更新阅读进度（书签类型）
    if annotation.Type == TypeBookmark {
        s.updateReadingProgress(ctx, req.UserID, req.BookID, req.ChapterID, req.StartPos)
    }
    
    // 7. 发布事件
    event := &base.BaseEvent{
        EventType: "annotation.created",
        EventData: map[string]interface{}{
            "annotation_id": annotation.ID,
            "user_id":       annotation.UserID,
            "book_id":       annotation.BookID,
            "type":          annotation.Type,
        },
        Timestamp: time.Now(),
        Source:    "AnnotationService",
    }
    s.eventBus.PublishAsync(ctx, event)
    
    // 8. 返回响应
    return &CreateAnnotationResponse{
        AnnotationID: annotation.ID,
        CreatedAt:    annotation.CreatedAt,
    }, nil
}

// GetChapterAnnotations 获取章节的标注列表
func (s *AnnotationService) GetChapterAnnotations(ctx context.Context, userID string, chapterID string) ([]*Annotation, error) {
    // 查询用户在该章节的所有标注
    annotations, err := s.annotationRepo.GetByUserAndChapter(ctx, userID, chapterID)
    if err != nil {
        return nil, err
    }
    
    // 按起始位置排序
    sort.Slice(annotations, func(i, j int) bool {
        return annotations[i].StartPos < annotations[j].StartPos
    })
    
    return annotations, nil
}

// UpdateAnnotation 更新标注
func (s *AnnotationService) UpdateAnnotation(ctx context.Context, annotationID string, userID string, req *UpdateAnnotationRequest) error {
    // 1. 获取标注
    annotation, err := s.annotationRepo.GetByID(ctx, annotationID)
    if err != nil || annotation == nil {
        return errors.NewNotFoundError("标注不存在")
    }
    
    // 2. 验证权限
    if annotation.UserID != userID {
        return errors.NewAuthError("无权修改此标注")
    }
    
    // 3. 更新字段
    updates := make(map[string]interface{})
    
    if req.Note != nil {
        updates["note"] = *req.Note
    }
    
    if req.Color != nil {
        updates["color"] = *req.Color
    }
    
    if req.IsPublic != nil {
        // 只有笔记类型可以公开
        if annotation.Type == TypeNote {
            updates["isPublic"] = *req.IsPublic
        }
    }
    
    updates["updatedAt"] = time.Now()
    
    // 4. 更新数据库
    if err := s.annotationRepo.Update(ctx, annotationID, updates); err != nil {
        return errors.NewInternalError("更新标注失败").WithCause(err)
    }
    
    return nil
}

// DeleteAnnotation 删除标注
func (s *AnnotationService) DeleteAnnotation(ctx context.Context, annotationID string, userID string) error {
    // 1. 获取标注
    annotation, err := s.annotationRepo.GetByID(ctx, annotationID)
    if err != nil || annotation == nil {
        return errors.NewNotFoundError("标注不存在")
    }
    
    // 2. 验证权限
    if annotation.UserID != userID {
        return errors.NewAuthError("无权删除此标注")
    }
    
    // 3. 删除标注
    if err := s.annotationRepo.Delete(ctx, annotationID); err != nil {
        return errors.NewInternalError("删除标注失败").WithCause(err)
    }
    
    // 4. 发布事件
    event := &base.BaseEvent{
        EventType: "annotation.deleted",
        EventData: map[string]interface{}{
            "annotation_id": annotationID,
            "user_id":       userID,
            "book_id":       annotation.BookID,
        },
        Timestamp: time.Now(),
        Source:    "AnnotationService",
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}

// GetBookAnnotations 获取书籍的所有标注（用于导出）
func (s *AnnotationService) GetBookAnnotations(ctx context.Context, userID string, bookID string) (*BookAnnotationsSummary, error) {
    // 查询所有标注
    annotations, err := s.annotationRepo.GetByUserAndBook(ctx, userID, bookID)
    if err != nil {
        return nil, err
    }
    
    // 按章节分组
    annotationsByChapter := make(map[string][]*Annotation)
    for _, ann := range annotations {
        annotationsByChapter[ann.ChapterID] = append(annotationsByChapter[ann.ChapterID], ann)
    }
    
    // 统计
    summary := &BookAnnotationsSummary{
        BookID:        bookID,
        TotalCount:    len(annotations),
        HighlightCount: 0,
        NoteCount:     0,
        BookmarkCount: 0,
        ByChapter:     annotationsByChapter,
    }
    
    for _, ann := range annotations {
        switch ann.Type {
        case TypeHighlight:
            summary.HighlightCount++
        case TypeNote:
            summary.NoteCount++
        case TypeBookmark:
            summary.BookmarkCount++
        }
    }
    
    return summary, nil
}

// GetPublicAnnotations 获取书籍的公开标注（热门批注）
func (s *AnnotationService) GetPublicAnnotations(ctx context.Context, bookID string, limit int) ([]*Annotation, error) {
    return s.annotationRepo.GetPublicByBook(ctx, bookID, limit)
}

// LikeAnnotation 点赞标注
func (s *AnnotationService) LikeAnnotation(ctx context.Context, annotationID string, userID string) error {
    // 1. 检查是否已点赞（需要一个UserAnnotationLike表）
    // ... 省略实现
    
    // 2. 增加点赞数
    if err := s.annotationRepo.IncrementLikeCount(ctx, annotationID); err != nil {
        return errors.NewInternalError("点赞失败").WithCause(err)
    }
    
    return nil
}
```

### 3.2 标注验证

```go
// validateAnnotationRequest 验证标注请求
func (s *AnnotationService) validateAnnotationRequest(req *CreateAnnotationRequest) error {
    // 1. 位置验证
    if req.StartPos < 0 || req.EndPos < 0 {
        return fmt.Errorf("位置不能为负数")
    }
    
    if req.EndPos < req.StartPos {
        return fmt.Errorf("结束位置不能小于起始位置")
    }
    
    // 2. 长度限制
    if req.EndPos - req.StartPos > 500 {
        return fmt.Errorf("标注长度不能超过500字")
    }
    
    // 3. 类型验证
    validTypes := []AnnotationType{TypeHighlight, TypeUnderline, TypeNote, TypeBookmark}
    if !contains(validTypes, req.Type) {
        return fmt.Errorf("无效的标注类型")
    }
    
    // 4. 笔记类型必须有内容
    if req.Type == TypeNote && req.Note == "" {
        return fmt.Errorf("笔记类型必须填写内容")
    }
    
    // 5. 笔记长度限制
    if len(req.Note) > 2000 {
        return fmt.Errorf("笔记内容不能超过2000字")
    }
    
    // 6. 颜色验证
    if req.Color != "" && !isValidColor(req.Color) {
        return fmt.Errorf("无效的颜色值")
    }
    
    return nil
}

// isValidColor 验证颜色值
func isValidColor(color string) bool {
    for _, validColor := range HighlightColors {
        if color == validColor {
            return true
        }
    }
    return false
}
```

---

## 4. 标注缓存策略

### 4.1 章节标注缓存

```go
// GetChapterAnnotationsWithCache 带缓存的章节标注查询
func (s *AnnotationService) GetChapterAnnotationsWithCache(ctx context.Context, userID string, chapterID string) ([]*Annotation, error) {
    // 1. 尝试从缓存获取
    cacheKey := fmt.Sprintf("annotations:chapter:%s:user:%s", chapterID, userID)
    cached, err := s.cache.Get(ctx, cacheKey)
    if err == nil && cached != nil {
        return cached.([]*Annotation), nil
    }
    
    // 2. 从数据库查询
    annotations, err := s.GetChapterAnnotations(ctx, userID, chapterID)
    if err != nil {
        return nil, err
    }
    
    // 3. 缓存结果（10分钟）
    s.cache.Set(ctx, cacheKey, annotations, 10*time.Minute)
    
    return annotations, nil
}

// InvalidateChapterAnnotationCache 清除章节标注缓存
func (s *AnnotationService) InvalidateChapterAnnotationCache(ctx context.Context, userID string, chapterID string) {
    cacheKey := fmt.Sprintf("annotations:chapter:%s:user:%s", chapterID, userID)
    s.cache.Delete(ctx, cacheKey)
}
```

---

## 5. API设计

### 5.1 请求/响应

```go
// CreateAnnotationRequest 创建标注请求
type CreateAnnotationRequest struct {
    UserID    string         `json:"userId" validate:"required"`
    BookID    string         `json:"bookId" validate:"required"`
    ChapterID string         `json:"chapterId" validate:"required"`
    Type      AnnotationType `json:"type" validate:"required"`
    StartPos  int            `json:"startPos" validate:"required"`
    EndPos    int            `json:"endPos" validate:"required"`
    Text      string         `json:"text"`
    Note      string         `json:"note"`
    Color     string         `json:"color"`
    IsPublic  bool           `json:"isPublic"`
}

// UpdateAnnotationRequest 更新标注请求
type UpdateAnnotationRequest struct {
    Note     *string `json:"note"`
    Color    *string `json:"color"`
    IsPublic *bool   `json:"isPublic"`
}

// CreateAnnotationResponse 创建标注响应
type CreateAnnotationResponse struct {
    AnnotationID string    `json:"annotationId"`
    CreatedAt    time.Time `json:"createdAt"`
}

// BookAnnotationsSummary 书籍标注摘要
type BookAnnotationsSummary struct {
    BookID         string                       `json:"bookId"`
    TotalCount     int                          `json:"totalCount"`
    HighlightCount int                          `json:"highlightCount"`
    NoteCount      int                          `json:"noteCount"`
    BookmarkCount  int                          `json:"bookmarkCount"`
    ByChapter      map[string][]*Annotation     `json:"byChapter"`
}
```

### 5.2 API路由

```go
// POST /api/v1/annotations - 创建标注
func (api *AnnotationApi) CreateAnnotation(c *gin.Context) {
    userID, _ := c.Get("userId")
    
    var req CreateAnnotationRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.UserID = userID.(string)
    
    resp, err := api.annotationService.CreateAnnotation(c.Request.Context(), &req)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusCreated, "创建成功", resp)
}

// GET /api/v1/chapters/:chapterId/annotations - 获取章节标注
func (api *AnnotationApi) GetChapterAnnotations(c *gin.Context) {
    chapterID := c.Param("chapterId")
    userID, _ := c.Get("userId")
    
    annotations, err := api.annotationService.GetChapterAnnotations(c.Request.Context(), userID.(string), chapterID)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", annotations)
}

// PUT /api/v1/annotations/:id - 更新标注
func (api *AnnotationApi) UpdateAnnotation(c *gin.Context) {
    annotationID := c.Param("id")
    userID, _ := c.Get("userId")
    
    var req UpdateAnnotationRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    err := api.annotationService.UpdateAnnotation(c.Request.Context(), annotationID, userID.(string), &req)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "更新成功", nil)
}

// DELETE /api/v1/annotations/:id - 删除标注
func (api *AnnotationApi) DeleteAnnotation(c *gin.Context) {
    annotationID := c.Param("id")
    userID, _ := c.Get("userId")
    
    err := api.annotationService.DeleteAnnotation(c.Request.Context(), annotationID, userID.(string))
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "删除成功", nil)
}

// GET /api/v1/books/:bookId/annotations/summary - 获取书籍标注摘要
func (api *AnnotationApi) GetBookAnnotationsSummary(c *gin.Context) {
    bookID := c.Param("bookId")
    userID, _ := c.Get("userId")
    
    summary, err := api.annotationService.GetBookAnnotations(c.Request.Context(), userID.(string), bookID)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", summary)
}

// GET /api/v1/books/:bookId/annotations/public - 获取热门公开标注
func (api *AnnotationApi) GetPublicAnnotations(c *gin.Context) {
    bookID := c.Param("bookId")
    limit := c.GetInt("limit")
    if limit == 0 {
        limit = 20
    }
    
    annotations, err := api.annotationService.GetPublicAnnotations(c.Request.Context(), bookID, limit)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", annotations)
}
```

---

## 6. 与v2.1架构的关系

### 6.1 在整体架构中的位置

```
Reading Module (阅读端)
  └─ Reader Module (阅读器模块)
      └─ Annotation System (标注系统)
          ├─ Annotation (标注数据)
          ├─ AnnotationCache (标注缓存)
          └─ AnnotationService (标注服务)
```

### 6.2 事件发布

```go
// 标注创建事件
type AnnotationCreatedEvent struct {
    AnnotationID string
    UserID       string
    BookID       string
    ChapterID    string
    Type         AnnotationType
    Timestamp    time.Time
}

// 标注删除事件
type AnnotationDeletedEvent struct {
    AnnotationID string
    UserID       string
    BookID       string
    Timestamp    time.Time
}
```

---

## 7. 性能优化

### 7.1 批量加载

```go
// BatchGetChapterAnnotations 批量获取多个章节的标注
func (s *AnnotationService) BatchGetChapterAnnotations(ctx context.Context, userID string, chapterIDs []string) (map[string][]*Annotation, error) {
    result := make(map[string][]*Annotation)
    
    annotations, err := s.annotationRepo.GetByUserAndChapters(ctx, userID, chapterIDs)
    if err != nil {
        return nil, err
    }
    
    // 按章节分组
    for _, ann := range annotations {
        result[ann.ChapterID] = append(result[ann.ChapterID], ann)
    }
    
    return result, nil
}
```

### 7.2 延迟加载公开标注

```go
// 只在用户点击"查看热门批注"时才加载
func (api *AnnotationApi) GetPublicAnnotations(c *gin.Context) {
    // 延迟加载，减少主请求负担
    annotations, _ := api.annotationService.GetPublicAnnotations(ctx, bookID, limit)
    response.Success(c, http.StatusOK, "获取成功", annotations)
}
```

---

## 8. 实现参考

### 8.1 代码文件路径

- **数据模型**: `models/reading/reader/annotation.go`
- **Service**: `service/reading/annotation_service.go`（待创建）
- **Repository**: `repository/mongodb/reading/annotation_mongo.go`（待创建）
- **API**: `api/v1/reader/annotation_api.go`

### 8.2 关键实现特性

1. ✅ 4种标注类型（高亮、下划线、笔记、书签）
2. ✅ 多颜色高亮支持
3. ✅ 公开标注和分享
4. ✅ 标注点赞功能
5. ✅ 按章节缓存优化
6. ✅ 标注位置验证
7. ✅ 标注导出功能

---

**文档状态**: ✅ 已完成  
**最后审核**: 2025-10-21  
**优先级**: P0 - 核心阅读功能

