# 书城缓存策略设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ✅ 已实现，补充设计文档

---

## 1. 设计概述

### 1.1 缓存目标

- 减少数据库查询，提升响应速度
- 降低服务器负载
- 支持高并发访问

### 1.2 实现情况

**已实现**：
- Redis缓存榜单数据
- 书籍详情缓存
- 热门推荐缓存

**文件位置**：`service/bookstore/bookstore_service.go`

---

## 2. 缓存架构

### 2.1 多级缓存策略

```
L1: 本地内存缓存（热点数据，1-5分钟）
  ↓ Miss
L2: Redis缓存（常用数据，5-60分钟）
  ↓ Miss
L3: MongoDB（持久化存储）
```

---

## 3. 核心缓存设计

### 3.1 榜单缓存

**缓存Key设计**：
```go
// 格式：ranking:{type}:{dimension}:{category}:{period}
"ranking:realtime:popularity:all:2025-10-21"
"ranking:weekly:reads:fantasy:2025-W43"
"ranking:monthly:favorites:all:2025-10"
```

**TTL策略**：
| 榜单类型 | TTL | 说明 |
|---------|-----|------|
| 实时榜 | 5分钟 | 高频更新 |
| 日榜 | 30分钟 | 中频更新 |
| 周榜 | 2小时 | 低频更新 |
| 月榜 | 6小时 | 低频更新 |

### 3.2 书籍详情缓存

**缓存Key**：`book:detail:{bookId}`

**缓存内容**：
```go
type CachedBookDetail struct {
    BookID      string
    Title       string
    Author      string
    Summary     string
    CoverURL    string
    Tags        []string
    Stats       BookStatistics  // 统计数据
    CachedAt    time.Time
    TTL         int  // 30分钟
}
```

**独特设计**：
- 书籍基本信息和统计数据分离缓存
- 统计数据TTL更短（5分钟），基本信息TTL更长（30分钟）

### 3.3 热门推荐缓存

**缓存Key**：`hot:recommendations:{category}:{limit}`

**更新策略**：
- 每30分钟定时更新
- 点击量触发异步更新（超过阈值时）

---

## 4. 缓存更新策略

### 4.1 Cache Aside Pattern（旁路缓存）

```go
// 读取数据
func GetBookDetail(bookID string) (*BookDetail, error) {
    // 1. 尝试从缓存读取
    cached := cache.Get("book:detail:" + bookID)
    if cached != nil {
        return cached, nil
    }
    
    // 2. 缓存未命中，从数据库读取
    book := db.Find(bookID)
    
    // 3. 写入缓存
    cache.Set("book:detail:" + bookID, book, 30*time.Minute)
    
    return book, nil
}

// 更新数据
func UpdateBook(bookID string, updates map[string]interface{}) error {
    // 1. 更新数据库
    db.Update(bookID, updates)
    
    // 2. 删除缓存（而不是更新缓存）
    cache.Delete("book:detail:" + bookID)
    
    // 3. 下次读取时会重新加载最新数据
    return nil
}
```

**优势**：避免缓存与数据库不一致

### 4.2 Write Through（写穿透）

```go
// 用于榜单等关键数据
func UpdateRanking(ranking *Ranking) error {
    // 1. 同时更新数据库和缓存
    db.Update(ranking)
    cache.Set(ranking.GetCacheKey(), ranking, getTTL(ranking.Type))
    
    return nil
}
```

---

## 5. 缓存预热

### 5.1 应用启动时预热

```go
func WarmupCache() {
    // 预加载热门榜单
    for _, rankingType := range []string{"realtime", "daily", "weekly"} {
        ranking := loadRanking(rankingType)
        cache.Set(getRankingKey(rankingType), ranking, 30*time.Minute)
    }
    
    // 预加载热门书籍
    hotBooks := loadHotBooks(100)
    for _, book := range hotBooks {
        cache.Set("book:detail:"+book.ID, book, 30*time.Minute)
    }
}
```

### 5.2 定时预热

```go
// 每小时预热一次热门数据
cron.Every(1*time.Hour).Do(WarmupCache)
```

---

## 6. 缓存雪崩防护

### 6.1 随机TTL

```go
// 避免大量缓存同时失效
func SetCacheWithRandomTTL(key string, value interface{}, baseTTL time.Duration) {
    randomOffset := time.Duration(rand.Intn(300)) * time.Second  // 0-5分钟随机
    actualTTL := baseTTL + randomOffset
    cache.Set(key, value, actualTTL)
}
```

### 6.2 互斥锁（防止缓存击穿）

```go
var locks sync.Map

func GetWithMutex(key string) (interface{}, error) {
    // 尝试从缓存获取
    cached := cache.Get(key)
    if cached != nil {
        return cached, nil
    }
    
    // 获取互斥锁
    lock, _ := locks.LoadOrStore(key, &sync.Mutex{})
    lock.(*sync.Mutex).Lock()
    defer lock.(*sync.Mutex).Unlock()
    
    // 双重检查
    cached = cache.Get(key)
    if cached != nil {
        return cached, nil
    }
    
    // 从数据库加载
    data := loadFromDB(key)
    cache.Set(key, data, 30*time.Minute)
    
    return data, nil
}
```

---

## 7. 监控指标

### 7.1 关键指标

- **缓存命中率**：目标 > 85%
- **平均响应时间**：缓存命中 < 10ms，缓存未命中 < 100ms
- **缓存大小**：监控Redis内存使用

### 7.2 监控方法

```go
type CacheStats struct {
    Hits        int64
    Misses      int64
    HitRate     float64
    TotalKeys   int64
    MemoryUsage int64
}

func GetCacheStats() *CacheStats {
    hits := cache.GetHits()
    misses := cache.GetMisses()
    
    return &CacheStats{
        Hits:    hits,
        Misses:  misses,
        HitRate: float64(hits) / float64(hits+misses) * 100,
    }
}
```

---

## 8. 实现参考

**代码文件**：
- `service/bookstore/bookstore_service.go` - 缓存实现
- `service/bookstore/cache_service.go`（待创建） - 缓存服务抽象

**缓存配置**：
```yaml
cache:
  redis:
    host: localhost:6379
    db: 0
    pool_size: 100
  ttl:
    ranking: 300s      # 5分钟
    book_detail: 1800s # 30分钟
    hot_list: 1800s    # 30分钟
```

---

**文档状态**: ✅ 已完成  
**优先级**: P0

