# 榜单系统详细设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ✅ 已实现，补充设计文档

---

## 1. 为什么需要这个设计

### 1.1 业务背景

榜单系统是阅读平台的核心功能之一，负责：
- 提供多维度的书籍排行榜
- 帮助读者发现优质内容
- 激励作者创作
- 提升平台活跃度
- 支持运营推广

### 1.2 实际实现情况

已完整实现，包含：
- **Ranking数据模型**：`models/reading/bookstore/ranking.go`
- **BookstoreService**：`service/bookstore/bookstore_service.go` - 榜单计算逻辑
- **RankingScheduler**：`service/bookstore/ranking_scheduler.go` - 定时更新
- **缓存策略**：基于Redis的榜单缓存

**实现文件**：
- `models/reading/bookstore/ranking.go` - 榜单数据模型
- `service/bookstore/bookstore_service.go` - 榜单服务
- `service/bookstore/ranking_scheduler.go` - 榜单调度器
- `repository/mongodb/bookstore/ranking_mongo.go` - Repository实现

---

## 2. 榜单类型设计

### 2.1 榜单类型

```go
type RankingType string

const (
    RankingTypeRealtime  RankingType = "realtime"   // 实时榜（每10分钟更新）
    RankingTypeDaily     RankingType = "daily"      // 日榜
    RankingTypeWeekly    RankingType = "weekly"     // 周榜
    RankingTypeMonthly   RankingType = "monthly"    // 月榜
    RankingTypeAll       RankingType = "all"        // 总榜
    RankingTypeNewbie    RankingType = "newbie"     // 新书榜（最近30天发布）
    RankingTypeRising    RankingType = "rising"     // 飙升榜（增长最快）
    RankingTypeFinished  RankingType = "finished"   // 完结榜
    RankingTypeCategory  RankingType = "category"   // 分类榜
)
```

### 2.2 榜单维度

```go
type RankingDimension string

const (
    DimensionReads      RankingDimension = "reads"       // 阅读量
    DimensionFavorites  RankingDimension = "favorites"   // 收藏量
    DimensionComments   RankingDimension = "comments"    // 评论量
    DimensionRating     RankingDimension = "rating"      // 评分
    DimensionRevenue    RankingDimension = "revenue"     // 收入（VIP章节）
    DimensionGrowth     RankingDimension = "growth"      // 增长速度
    DimensionPopularity RankingDimension = "popularity"  // 综合人气
)
```

### 2.3 榜单分类

```go
type RankingCategory string

const (
    CategoryAll      RankingCategory = "all"        // 全部
    CategoryFantasy  RankingCategory = "fantasy"    // 玄幻
    CategoryUrban    RankingCategory = "urban"      // 都市
    CategoryRomance  RankingCategory = "romance"    // 言情
    CategoryHistory  RankingCategory = "history"    // 历史
    CategorySciF RankingCategory = "scifi"      // 科幻
    CategoryGame     RankingCategory = "game"       // 游戏
)
```

---

## 3. 数据模型设计

### 3.1 Ranking（榜单）

#### 3.1.1 数据结构

```go
type Ranking struct {
    ID          string           `bson:"_id,omitempty" json:"id"`
    Type        RankingType      `bson:"type" json:"type" validate:"required"`             // 榜单类型
    Dimension   RankingDimension `bson:"dimension" json:"dimension" validate:"required"`   // 榜单维度
    Category    RankingCategory  `bson:"category" json:"category"`                         // 分类（可选）
    Period      string           `bson:"period" json:"period"`                             // 统计周期
    StartTime   time.Time        `bson:"startTime" json:"startTime"`                       // 开始时间
    EndTime     time.Time        `bson:"endTime" json:"endTime"`                           // 结束时间
    Books       []RankingItem    `bson:"books" json:"books"`                               // 书籍列表
    UpdatedAt   time.Time        `bson:"updatedAt" json:"updatedAt"`                       // 更新时间
    ExpiresAt   time.Time        `bson:"expiresAt" json:"expiresAt"`                       // 过期时间
    Version     int              `bson:"version" json:"version"`                           // 版本号
}
```

#### 3.1.2 RankingItem（榜单项）

```go
type RankingItem struct {
    Rank       int                    `bson:"rank" json:"rank"`                 // 排名
    BookID     string                 `bson:"bookId" json:"bookId"`             // 书籍ID
    Title      string                 `bson:"title" json:"title"`               // 书名
    Author     string                 `bson:"author" json:"author"`             // 作者
    CoverURL   string                 `bson:"coverUrl" json:"coverUrl"`         // 封面
    Category   string                 `bson:"category" json:"category"`         // 分类
    Score      float64                `bson:"score" json:"score"`               // 排序分数
    Stats      map[string]interface{} `bson:"stats" json:"stats"`               // 统计数据
    Change     int                    `bson:"change" json:"change"`             // 排名变化（+5表示上升5名）
    IsNew      bool                   `bson:"isNew" json:"isNew"`               // 是否新上榜
}
```

#### 3.1.3 业务方法

```go
// GetRankingKey 获取榜单缓存键
func (r *Ranking) GetRankingKey() string {
    if r.Category == CategoryAll {
        return fmt.Sprintf("ranking:%s:%s:%s", r.Type, r.Dimension, r.Period)
    }
    return fmt.Sprintf("ranking:%s:%s:%s:%s", r.Type, r.Dimension, r.Category, r.Period)
}

// IsExpired 是否已过期
func (r *Ranking) IsExpired() bool {
    return time.Now().After(r.ExpiresAt)
}

// GetTopN 获取前N名
func (r *Ranking) GetTopN(n int) []RankingItem {
    if n > len(r.Books) {
        n = len(r.Books)
    }
    return r.Books[:n]
}
```

#### 3.1.4 索引策略

```javascript
// MongoDB索引
db.rankings.createIndex({ "type": 1, "dimension": 1, "category": 1, "period": 1 }, { unique: true })
db.rankings.createIndex({ "updatedAt": -1 })
db.rankings.createIndex({ "expiresAt": 1 })  // 用于清理过期榜单
```

---

## 4. 榜单计算逻辑

### 4.1 综合人气分数计算

```go
// CalculatePopularityScore 计算综合人气分数
func CalculatePopularityScore(stats *BookStatistics) float64 {
    // 权重配置
    const (
        readsWeight     = 0.3   // 阅读量权重
        favoritesWeight = 0.25  // 收藏量权重
        commentsWeight  = 0.15  // 评论量权重
        ratingWeight    = 0.2   // 评分权重
        revenueWeight   = 0.1   // 收入权重
    )
    
    // 归一化函数（对数归一化，避免数值差异过大）
    normalize := func(value float64) float64 {
        if value == 0 {
            return 0
        }
        return math.Log10(1 + value)
    }
    
    // 计算各维度得分
    readsScore := normalize(float64(stats.Reads)) * readsWeight
    favoritesScore := normalize(float64(stats.Favorites)) * favoritesWeight
    commentsScore := normalize(float64(stats.Comments)) * commentsWeight
    ratingScore := (stats.Rating / 5.0) * ratingWeight  // 评分已经是0-5，直接归一化
    revenueScore := normalize(stats.Revenue) * revenueWeight
    
    // 综合得分
    totalScore := readsScore + favoritesScore + commentsScore + ratingScore + revenueScore
    
    // 放大到100分制
    return totalScore * 100
}
```

### 4.2 飙升榜计算

```go
// CalculateGrowthScore 计算增长分数
func CalculateGrowthScore(current, previous *BookStatistics, hours int) float64 {
    if previous == nil || hours == 0 {
        return 0
    }
    
    // 计算各维度的增长率
    readGrowth := float64(current.Reads-previous.Reads) / float64(hours)
    favoriteGrowth := float64(current.Favorites-previous.Favorites) / float64(hours)
    commentGrowth := float64(current.Comments-previous.Comments) / float64(hours)
    
    // 加权增长分数
    growthScore := readGrowth*0.4 + favoriteGrowth*0.4 + commentGrowth*0.2
    
    return growthScore
}
```

### 4.3 新书榜过滤

```go
// IsNewBook 是否新书（最近30天发布）
func IsNewBook(publishedAt time.Time) bool {
    return time.Since(publishedAt) <= 30*24*time.Hour
}
```

---

## 5. 榜单更新策略

### 5.1 更新频率

| 榜单类型 | 更新频率 | 触发方式 | 说明 |
|---------|---------|---------|------|
| 实时榜 | 10分钟 | Cron定时 | 高频更新，展示最新热度 |
| 日榜 | 1小时 | Cron定时 | 每日00:00生成前一天数据 |
| 周榜 | 6小时 | Cron定时 | 每周一00:00生成上周数据 |
| 月榜 | 12小时 | Cron定时 | 每月1日00:00生成上月数据 |
| 新书榜 | 1小时 | Cron定时 | 动态过滤30天内新书 |
| 飙升榜 | 30分钟 | Cron定时 | 对比24小时内增长 |

### 5.2 定时调度器实现

```go
// service/bookstore/ranking_scheduler.go
type RankingScheduler struct {
    service BookstoreService
    cron    *cron.Cron
    logger  *log.Logger
}

func NewRankingScheduler(service BookstoreService, logger *log.Logger) *RankingScheduler {
    return &RankingScheduler{
        service: service,
        cron:    cron.New(cron.WithSeconds()),
        logger:  logger,
    }
}

// Start 启动调度器
func (s *RankingScheduler) Start() error {
    // 实时榜：每10分钟更新
    s.cron.AddFunc("0 */10 * * * *", func() {
        s.updateRanking(RankingTypeRealtime, DimensionPopularity, CategoryAll)
    })
    
    // 日榜：每小时更新
    s.cron.AddFunc("0 0 * * * *", func() {
        s.updateRanking(RankingTypeDaily, DimensionReads, CategoryAll)
        s.updateRanking(RankingTypeDaily, DimensionFavorites, CategoryAll)
    })
    
    // 周榜：每6小时更新
    s.cron.AddFunc("0 0 */6 * * *", func() {
        s.updateRanking(RankingTypeWeekly, DimensionPopularity, CategoryAll)
    })
    
    // 月榜：每12小时更新
    s.cron.AddFunc("0 0 */12 * * *", func() {
        s.updateRanking(RankingTypeMonthly, DimensionPopularity, CategoryAll)
    })
    
    // 新书榜：每小时更新
    s.cron.AddFunc("0 0 * * * *", func() {
        s.updateRanking(RankingTypeNewbie, DimensionPopularity, CategoryAll)
    })
    
    // 飙升榜：每30分钟更新
    s.cron.AddFunc("0 */30 * * * *", func() {
        s.updateRanking(RankingTypeRising, DimensionGrowth, CategoryAll)
    })
    
    // 清理过期榜单：每天凌晨3点
    s.cron.AddFunc("0 0 3 * * *", func() {
        s.cleanupExpiredRankings()
    })
    
    s.cron.Start()
    s.logger.Println("榜单调度器已启动")
    return nil
}

// updateRanking 更新榜单
func (s *RankingScheduler) updateRanking(rankingType RankingType, dimension RankingDimension, category RankingCategory) {
    ctx := context.Background()
    
    s.logger.Printf("开始更新榜单: %s-%s-%s", rankingType, dimension, category)
    
    if err := s.service.UpdateRanking(ctx, rankingType, dimension, category); err != nil {
        s.logger.Printf("更新榜单失败: %v", err)
        return
    }
    
    s.logger.Printf("榜单更新成功: %s-%s-%s", rankingType, dimension, category)
}
```

---

## 6. Service层设计

### 6.1 BookstoreService榜单方法

```go
// UpdateRanking 更新榜单
func (s *BookstoreService) UpdateRanking(ctx context.Context, rankingType RankingType, dimension RankingDimension, category RankingCategory) error {
    // 1. 确定统计时间范围
    startTime, endTime := s.getRankingTimeRange(rankingType)
    
    // 2. 查询书籍统计数据
    books, err := s.getBookStatistics(ctx, startTime, endTime, category)
    if err != nil {
        return err
    }
    
    // 3. 计算排名
    rankedBooks := s.calculateRanking(books, dimension, rankingType)
    
    // 4. 对比上一期榜单，计算排名变化
    previousRanking, _ := s.rankingRepo.GetLatest(ctx, rankingType, dimension, category)
    s.calculateRankingChanges(rankedBooks, previousRanking)
    
    // 5. 创建新榜单
    period := s.getRankingPeriod(rankingType, startTime)
    ranking := &Ranking{
        Type:      rankingType,
        Dimension: dimension,
        Category:  category,
        Period:    period,
        StartTime: startTime,
        EndTime:   endTime,
        Books:     rankedBooks,
        UpdatedAt: time.Now(),
        ExpiresAt: s.getRankingExpireTime(rankingType),
        Version:   1,
    }
    
    // 6. 保存到数据库
    if err := s.rankingRepo.Upsert(ctx, ranking); err != nil {
        return err
    }
    
    // 7. 更新缓存
    cacheKey := ranking.GetRankingKey()
    s.cache.Set(ctx, cacheKey, ranking, s.getRankingCacheTTL(rankingType))
    
    // 8. 发布事件
    event := &base.BaseEvent{
        EventType: "ranking.updated",
        EventData: map[string]interface{}{
            "type":      rankingType,
            "dimension": dimension,
            "category":  category,
            "count":     len(rankedBooks),
        },
        Timestamp: time.Now(),
        Source:    "BookstoreService",
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}

// GetRanking 获取榜单
func (s *BookstoreService) GetRanking(ctx context.Context, rankingType RankingType, dimension RankingDimension, category RankingCategory, limit int) (*Ranking, error) {
    // 1. 尝试从缓存获取
    cacheKey := fmt.Sprintf("ranking:%s:%s:%s", rankingType, dimension, category)
    cached, err := s.cache.Get(ctx, cacheKey)
    if err == nil && cached != nil {
        ranking := cached.(*Ranking)
        if !ranking.IsExpired() {
            return ranking, nil
        }
    }
    
    // 2. 从数据库查询
    ranking, err := s.rankingRepo.GetLatest(ctx, rankingType, dimension, category)
    if err != nil || ranking == nil {
        return nil, errors.NewNotFoundError("榜单不存在")
    }
    
    // 3. 检查是否过期
    if ranking.IsExpired() {
        // 触发异步更新
        go s.UpdateRanking(context.Background(), rankingType, dimension, category)
        
        // 返回过期榜单（优于无数据）
    }
    
    // 4. 限制返回数量
    if limit > 0 && len(ranking.Books) > limit {
        ranking.Books = ranking.Books[:limit]
    }
    
    // 5. 更新缓存
    s.cache.Set(ctx, cacheKey, ranking, s.getRankingCacheTTL(rankingType))
    
    return ranking, nil
}

// calculateRanking 计算排名
func (s *BookstoreService) calculateRanking(books []*BookWithStats, dimension RankingDimension, rankingType RankingType) []RankingItem {
    // 1. 根据维度排序
    sort.Slice(books, func(i, j int) bool {
        scoreI := s.getScoreByDimension(books[i], dimension)
        scoreJ := s.getScoreByDimension(books[j], dimension)
        return scoreI > scoreJ
    })
    
    // 2. 构建榜单项
    items := make([]RankingItem, len(books))
    for i, book := range books {
        items[i] = RankingItem{
            Rank:     i + 1,
            BookID:   book.ID,
            Title:    book.Title,
            Author:   book.Author,
            CoverURL: book.CoverURL,
            Category: book.Category,
            Score:    s.getScoreByDimension(book, dimension),
            Stats: map[string]interface{}{
                "reads":     book.Stats.Reads,
                "favorites": book.Stats.Favorites,
                "comments":  book.Stats.Comments,
                "rating":    book.Stats.Rating,
            },
        }
    }
    
    return items
}

// getScoreByDimension 根据维度获取分数
func (s *BookstoreService) getScoreByDimension(book *BookWithStats, dimension RankingDimension) float64 {
    switch dimension {
    case DimensionReads:
        return float64(book.Stats.Reads)
    case DimensionFavorites:
        return float64(book.Stats.Favorites)
    case DimensionComments:
        return float64(book.Stats.Comments)
    case DimensionRating:
        return book.Stats.Rating
    case DimensionRevenue:
        return book.Stats.Revenue
    case DimensionGrowth:
        return s.calculateGrowthScore(book)
    case DimensionPopularity:
        return CalculatePopularityScore(book.Stats)
    default:
        return 0
    }
}
```

---

## 7. 缓存策略

### 7.1 缓存层级

```
L1: Redis缓存（热数据，5-30分钟）
  ↓ 未命中
L2: MongoDB（持久化，所有历史榜单）
  ↓ 未命中
L3: 实时计算（触发异步更新）
```

### 7.2 缓存TTL

| 榜单类型 | 缓存TTL | 说明 |
|---------|---------|------|
| 实时榜 | 5分钟 | 高频更新，短缓存 |
| 日榜 | 30分钟 | 中频更新，中等缓存 |
| 周榜 | 2小时 | 低频更新，长缓存 |
| 月榜 | 6小时 | 低频更新，长缓存 |
| 新书榜 | 30分钟 | 动态榜单，中等缓存 |
| 飙升榜 | 15分钟 | 高频更新，短缓存 |

### 7.3 缓存更新策略

```go
// 缓存更新策略：先更新数据库，再删除缓存（Cache Aside Pattern）
func (s *BookstoreService) UpdateRanking(ctx context.Context, rankingType RankingType, dimension RankingDimension, category RankingCategory) error {
    // 1. 计算新榜单
    ranking := s.calculateNewRanking(ctx, rankingType, dimension, category)
    
    // 2. 更新数据库
    if err := s.rankingRepo.Upsert(ctx, ranking); err != nil {
        return err
    }
    
    // 3. 删除旧缓存（而不是更新缓存，避免缓存与数据库不一致）
    cacheKey := ranking.GetRankingKey()
    s.cache.Delete(ctx, cacheKey)
    
    // 4. 下次查询时会重新加载到缓存
    return nil
}
```

---

## 8. API设计

### 8.1 请求/响应

```go
// GetRankingRequest 获取榜单请求
type GetRankingRequest struct {
    Type      RankingType      `json:"type" validate:"required"`      // 榜单类型
    Dimension RankingDimension `json:"dimension" validate:"required"` // 维度
    Category  RankingCategory  `json:"category"`                      // 分类（可选）
    Limit     int              `json:"limit"`                         // 返回数量（默认100）
}

// GetRankingResponse 获取榜单响应
type GetRankingResponse struct {
    Type      RankingType      `json:"type"`
    Dimension RankingDimension `json:"dimension"`
    Category  RankingCategory  `json:"category"`
    Period    string           `json:"period"`      // 统计周期（如：2025-01-20）
    Books     []RankingItem    `json:"books"`
    UpdatedAt time.Time        `json:"updatedAt"`
}
```

### 8.2 API路由

```go
// GET /api/v1/rankings/:type/:dimension
// GET /api/v1/rankings/:type/:dimension/:category
func (api *BookstoreApi) GetRanking(c *gin.Context) {
    rankingType := RankingType(c.Param("type"))
    dimension := RankingDimension(c.Param("dimension"))
    category := RankingCategory(c.Param("category"))
    if category == "" {
        category = CategoryAll
    }
    
    limit := 100
    if limitStr := c.Query("limit"); limitStr != "" {
        limit, _ = strconv.Atoi(limitStr)
    }
    
    ranking, err := api.bookstoreService.GetRanking(c.Request.Context(), rankingType, dimension, category, limit)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", ranking)
}
```

---

## 9. 与v2.1架构的关系

### 9.1 在整体架构中的位置

```
Reading Module (阅读端)
  └─ Bookstore Module (书城模块)
      ├─ BookstoreService (书城服务)
      │   └─ 榜单计算逻辑
      ├─ RankingScheduler (榜单调度器)
      │   └─ 定时更新任务
      └─ CacheService (缓存服务)
          └─ 榜单缓存
```

### 9.2 事件发布

```go
// 榜单更新事件
type RankingUpdatedEvent struct {
    Type      RankingType
    Dimension RankingDimension
    Category  RankingCategory
    Count     int
    Timestamp time.Time
}
```

---

## 10. 性能优化

### 10.1 分页加载

```go
// 前端只展示前20名，支持下拉加载更多
func (api *BookstoreApi) GetRankingPaged(c *gin.Context) {
    page := c.GetInt("page")      // 默认1
    pageSize := c.GetInt("pageSize")  // 默认20
    
    // 从缓存获取完整榜单
    ranking, _ := api.bookstoreService.GetRanking(ctx, ...)
    
    // 分页切片
    start := (page - 1) * pageSize
    end := start + pageSize
    if end > len(ranking.Books) {
        end = len(ranking.Books)
    }
    
    pagedBooks := ranking.Books[start:end]
    
    response.Success(c, http.StatusOK, "获取成功", gin.H{
        "books": pagedBooks,
        "total": len(ranking.Books),
        "page":  page,
    })
}
```

### 10.2 增量更新

```go
// 对于实时榜，只更新变化的书籍，而不是全量重新计算
func (s *BookstoreService) IncrementalUpdateRanking(ctx context.Context, bookID string) error {
    // 1. 获取书籍最新统计
    bookStats := s.getLatestBookStats(ctx, bookID)
    
    // 2. 获取当前榜单
    ranking := s.getCurrentRealTimeRanking(ctx)
    
    // 3. 更新或插入书籍
    updated := false
    for i, item := range ranking.Books {
        if item.BookID == bookID {
            ranking.Books[i].Score = CalculatePopularityScore(bookStats)
            ranking.Books[i].Stats = bookStats
            updated = true
            break
        }
    }
    
    if !updated {
        // 新书插入榜单
        ranking.Books = append(ranking.Books, RankingItem{...})
    }
    
    // 4. 重新排序
    sort.Slice(ranking.Books, func(i, j int) bool {
        return ranking.Books[i].Score > ranking.Books[j].Score
    })
    
    // 5. 更新排名
    for i := range ranking.Books {
        ranking.Books[i].Rank = i + 1
    }
    
    // 6. 保存
    return s.rankingRepo.Update(ctx, ranking.ID, ranking)
}
```

---

## 11. 实现参考

### 11.1 代码文件路径

- **数据模型**: `models/reading/bookstore/ranking.go`
- **Service**: `service/bookstore/bookstore_service.go`
- **调度器**: `service/bookstore/ranking_scheduler.go`
- **Repository**: `repository/mongodb/bookstore/ranking_mongo.go`

### 11.2 关键实现特性

1. ✅ 多维度榜单（阅读、收藏、评分、综合等）
2. ✅ 定时调度更新（Cron）
3. ✅ 分类榜单支持
4. ✅ 排名变化追踪
5. ✅ Redis缓存优化
6. ✅ 事件驱动更新

---

**文档状态**: ✅ 已完成  
**最后审核**: 2025-10-21  
**优先级**: P0 - 核心业务功能

