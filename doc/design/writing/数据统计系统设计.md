# 写作端数据统计系统设计

> **版本**: v1.0  
> **创建日期**: 2025-10-17  
> **最后更新**: 2025-10-17  
> **维护者**: 青羽写作团队  
> **优先级**: 🔥 MVP高优先级

## 1. 需求概述

### 1.1 功能描述

数据统计系统为作者提供全方位的作品数据分析能力，包括阅读数据、读者行为分析、章节质量评估等，帮助作者了解作品表现，优化创作策略。系统支持实时统计、历史趋势分析、多维度对比、可视化报表等功能。

### 1.2 业务价值

- **数据驱动创作**：通过数据分析指导创作方向，提升作品质量
- **读者洞察**：深入了解读者行为和偏好，精准定位目标读者
- **收入分析**：清晰展示订阅、打赏等收入数据，帮助作者规划
- **作品优化**：识别高质量和低质量章节，针对性改进

### 1.3 用户场景

**作者端场景**：
1. **查看作品概览**：快速了解作品的总体数据（总阅读量、收藏数、订阅数）
2. **分析章节表现**：查看每章的完读率、跳章率、停留时间等
3. **追踪读者行为**：了解读者从哪里来、在哪里流失、喜欢哪些章节
4. **收入统计**：查看订阅收入、打赏收入、广告收入的详细数据
5. **趋势分析**：查看阅读量、收藏数等指标的历史趋势
6. **对比分析**：对比不同作品或不同时期的数据表现

**管理员场景**：
1. **平台数据总览**：查看平台整体的阅读数据、活跃作者数等
2. **作品排行**：查看阅读量、收入等维度的作品排行
3. **数据报表**：生成平台运营报表，支持导出

### 1.4 功能边界

**包含功能**：
- ✅ 作品数据概览（阅读量、收藏、订阅、评论）
- ✅ 章节数据分析（完读率、跳章率、停留时间、跳出点）
- ✅ 读者行为分析（来源渠道、阅读轨迹、流失分析）
- ✅ 收入统计（订阅、打赏、广告分成）
- ✅ 趋势分析（日/周/月趋势图）
- ✅ 数据对比（作品对比、时期对比）
- ✅ 数据导出（Excel、CSV、PDF）
- ✅ 实时数据更新

**不包含功能**：
- ❌ 读者画像（后期版本，需要更详细的用户数据）
- ❌ 智能预测（后期版本，AI预测阅读趋势）
- ❌ 竞品分析（后期版本）
- ❌ A/B测试（后期版本）

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    前端数据可视化 (Vue + ECharts)              │
│          折线图 | 柱状图 | 饼图 | 热力图 | 数据表格             │
├─────────────────────────────────────────────────────────────┤
│                  Router Layer (路由层)                        │
│               /api/v1/statistics/*                           │
├─────────────────────────────────────────────────────────────┤
│                   API Layer (接口层)                          │
│    WorkStatisticsApi / ChapterStatisticsApi / RevenueApi    │
├─────────────────────────────────────────────────────────────┤
│                Service Layer (业务逻辑层)                      │
│  StatisticsService / ChapterAnalysisService / RevenueService│
├─────────────────────────────────────────────────────────────┤
│            Repository Layer (数据访问层)                       │
│  ReadingLogRepo / ChapterStatsRepo / RevenueRepo            │
├─────────────────────────────────────────────────────────────┤
│               Model Layer (数据模型层)                         │
│  ReadingLog / ChapterStats / RevenueRecord                  │
├─────────────────────────────────────────────────────────────┤
│        数据采集与计算层 (Kafka + Flink + Redis)                │
│     埋点数据 → Kafka → Flink实时计算 → MongoDB/Redis          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 数据流设计

#### 数据采集流程
```
用户阅读行为 → 前端埋点 → Kafka消息队列 
→ Flink实时计算 → 聚合统计数据 
→ MongoDB存储 + Redis缓存 → API查询
```

#### 数据查询流程
```
用户请求 → API层 → Service层 → Redis缓存查询
→ (缓存未命中) → MongoDB查询 → 写入Redis → 返回结果
```

#### 数据导出流程
```
导出请求 → 后台异步任务 → 查询数据 → 格式转换 
→ 生成文件 → OSS存储 → 通知用户 → 下载链接
```

### 2.3 模块划分

**核心模块**：
- **StatisticsService**：统计数据核心服务
- **ChapterAnalysisService**：章节分析服务
- **RevenueService**：收入统计服务
- **TrendAnalysisService**：趋势分析服务
- **ComparisonService**：数据对比服务

**数据采集模块**：
- **EventCollector**：埋点数据收集器
- **RealtimeProcessor**：Flink实时处理器
- **AggregationCalculator**：聚合计算器

**辅助模块**：
- **ExportService**：数据导出服务
- **CacheManager**：统计数据缓存管理
- **ReportGenerator**：报表生成器

---

## 3. 详细设计

### 3.1 Router层设计

**路由分组**：`/api/v1/statistics`

**路由定义**：
```go
// 作品统计路由
statsGroup := v1.Group("/statistics")
statsGroup.Use(middleware.JWTAuth())
{
    // 作品概览
    statsGroup.GET("/works/:workId/overview", workStatsApi.GetOverview)
    
    // 章节统计
    statsGroup.GET("/works/:workId/chapters", chapterStatsApi.GetChapterStats)
    statsGroup.GET("/works/:workId/chapters/:chapterId", chapterStatsApi.GetChapterDetail)
    
    // 读者行为分析
    statsGroup.GET("/works/:workId/readers/behavior", readerAnalysisApi.GetReaderBehavior)
    statsGroup.GET("/works/:workId/readers/source", readerAnalysisApi.GetReaderSource)
    statsGroup.GET("/works/:workId/readers/retention", readerAnalysisApi.GetRetention)
    
    // 收入统计
    statsGroup.GET("/works/:workId/revenue", revenueApi.GetRevenue)
    statsGroup.GET("/works/:workId/revenue/trend", revenueApi.GetRevenueTrend)
    
    // 趋势分析
    statsGroup.GET("/works/:workId/trends", trendApi.GetTrends)
    
    // 数据对比
    statsGroup.POST("/comparison", comparisonApi.CompareWorks)
    
    // 数据导出
    statsGroup.POST("/export", exportApi.ExportData)
    statsGroup.GET("/export/:taskId", exportApi.GetExportTask)
}

// 我的统计（作者自己的所有作品）
myStatsGroup := v1.Group("/my-statistics")
myStatsGroup.Use(middleware.JWTAuth())
{
    // 我的作品列表统计
    myStatsGroup.GET("/works", myStatsApi.GetMyWorksStats)
    
    // 总收入统计
    myStatsGroup.GET("/revenue/total", myStatsApi.GetTotalRevenue)
}
```

### 3.2 API层设计

#### 3.2.1 作品概览接口

**请求**：
```
GET /api/v1/statistics/works/:workId/overview?period=30d
```

**查询参数**：
- `period`: 统计周期（7d, 30d, 90d, all）

**响应**：
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "workId": "work123",
    "workTitle": "我的小说",
    "period": "30d",
    "overview": {
      "totalReadCount": 120000,
      "totalReaders": 5000,
      "avgReadTime": 180, // 秒
      "completionRate": 0.65, // 完读率
      "favoriteCount": 1200,
      "subscriptionCount": 800,
      "commentCount": 3500,
      "shareCount": 450
    },
    "trends": {
      "readCountChange": "+15%", // 相比上个周期
      "readerCountChange": "+8%",
      "favoriteCountChange": "+12%"
    },
    "updatedAt": "2025-10-17T10:30:00Z"
  }
}
```

#### 3.2.2 章节统计接口

**请求**：
```
GET /api/v1/statistics/works/:workId/chapters?sort=completion_rate&order=asc&limit=10
```

**查询参数**：
- `sort`: 排序字段（read_count, completion_rate, jump_rate, stay_time）
- `order`: 排序方向（asc, desc）
- `limit`: 返回数量

**响应**：
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "totalChapters": 50,
    "chapters": [
      {
        "chapterId": "chapter1",
        "chapterTitle": "第一章：开端",
        "chapterNumber": 1,
        "wordCount": 2500,
        "readCount": 5000,
        "uniqueReaders": 4200,
        "completionRate": 0.85, // 完读率
        "jumpRate": 0.05, // 跳过率
        "avgStayTime": 300, // 平均停留时间（秒）
        "jumpOutRate": 0.10, // 跳出率（读完后不继续）
        "jumpOutPosition": [0.3, 0.6, 0.9], // 跳出热点位置（归一化）
        "qualityScore": 8.5, // 质量评分（基于多指标计算）
        "ranking": 5 // 在所有章节中的排名
      }
    ]
  }
}
```

#### 3.2.3 章节详细数据接口

**请求**：
```
GET /api/v1/statistics/works/:workId/chapters/:chapterId?period=7d
```

**响应**：
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "chapterId": "chapter1",
    "chapterInfo": {
      "title": "第一章：开端",
      "number": 1,
      "wordCount": 2500,
      "publishedAt": "2025-10-01T10:00:00Z"
    },
    "statistics": {
      "readCount": 5000,
      "uniqueReaders": 4200,
      "completionRate": 0.85,
      "jumpRate": 0.05,
      "avgStayTime": 300,
      "jumpOutRate": 0.10
    },
    "trends": {
      "daily": [
        {
          "date": "2025-10-10",
          "readCount": 120,
          "uniqueReaders": 100,
          "completionRate": 0.83
        }
      ]
    },
    "heatmap": {
      "description": "章节内容热力图，显示读者停留时长分布",
      "data": [
        {
          "position": 0.1, // 位置（归一化，0-1）
          "heatValue": 0.8, // 热度值（归一化，0-1）
          "readCount": 4500, // 读到此处的人数
          "avgStayTime": 15 // 该位置平均停留时间（秒）
        },
        {
          "position": 0.3,
          "heatValue": 0.6,
          "readCount": 4000,
          "avgStayTime": 20
        }
      ]
    },
    "jumpOutPoints": {
      "description": "读者跳出热点，显示读者在哪些位置离开",
      "data": [
        {
          "position": 0.3,
          "jumpOutCount": 500,
          "jumpOutRate": 0.12,
          "reason": "可能原因：情节拖沓"
        }
      ]
    },
    "comments": {
      "totalCount": 150,
      "topComments": [
        {
          "content": "这一章写得真好！",
          "likes": 50,
          "position": 0.8
        }
      ]
    }
  }
}
```

#### 3.2.4 读者行为分析接口

**请求**：
```
GET /api/v1/statistics/works/:workId/readers/behavior?period=30d
```

**响应**：
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "readerSource": {
      "search": 2000, // 搜索引擎
      "recommendation": 1500, // 推荐系统
      "ranking": 800, // 榜单
      "social": 500, // 社交分享
      "direct": 200 // 直接访问
    },
    "readingPath": {
      "description": "读者阅读路径分析",
      "sequentialReading": 0.70, // 顺序阅读比例
      "jumpReading": 0.20, // 跳跃阅读比例
      "randomReading": 0.10, // 随机阅读比例
      "avgChaptersPerSession": 3.5 // 每次阅读平均章节数
    },
    "retention": {
      "day1": 0.60, // 次日留存率
      "day7": 0.35, // 7日留存率
      "day30": 0.20 // 30日留存率
    },
    "churn": {
      "totalChurn": 1500, // 流失读者数
      "churnRate": 0.30, // 流失率
      "churnReasons": {
        "updateTooSlow": 500,
        "qualityDecline": 300,
        "plotBoring": 400,
        "other": 300
      }
    }
  }
}
```

#### 3.2.5 收入统计接口

**请求**：
```
GET /api/v1/statistics/works/:workId/revenue?period=30d
```

**响应**：
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "workId": "work123",
    "period": "30d",
    "revenue": {
      "total": 15000.00, // 总收入（元）
      "subscription": 10000.00, // 订阅收入
      "reward": 3000.00, // 打赏收入
      "advertising": 2000.00 // 广告分成
    },
    "breakdown": {
      "subscriptionCount": 800, // 订阅人数
      "avgSubscriptionPrice": 12.50, // 平均订阅价格
      "rewardCount": 150, // 打赏人次
      "avgRewardAmount": 20.00, // 平均打赏金额
      "adImpressions": 100000, // 广告展示次数
      "adCPM": 20.00 // 千次展示收益
    },
    "trends": {
      "daily": [
        {
          "date": "2025-10-10",
          "total": 500.00,
          "subscription": 350.00,
          "reward": 100.00,
          "advertising": 50.00
        }
      ]
    },
    "topRewardChapters": [
      {
        "chapterId": "chapter10",
        "chapterTitle": "第十章：高潮",
        "rewardAmount": 800.00,
        "rewardCount": 40
      }
    ]
  }
}
```

### 3.3 Service层设计

#### StatisticsService 核心方法

```go
type StatisticsService struct {
    readingLogRepo    repository.ReadingLogRepository
    chapterStatsRepo  repository.ChapterStatsRepository
    revenueRepo       repository.RevenueRepository
    cacheManager      *StatsCacheManager
    flinkClient       *FlinkClient
    eventBus          base.EventBus
}

// GetWorkOverview 获取作品概览统计
func (s *StatisticsService) GetWorkOverview(ctx context.Context, workId string, period string) (*WorkOverviewResponse, error) {
    // 1. 参数验证
    if workId == "" {
        return nil, errors.NewValidationError("作品ID不能为空")
    }
    
    // 2. 尝试从缓存获取
    cacheKey := fmt.Sprintf("stats:overview:%s:%s", workId, period)
    if cached, err := s.cacheManager.Get(ctx, cacheKey); err == nil {
        var overview WorkOverviewResponse
        if json.Unmarshal([]byte(cached), &overview) == nil {
            return &overview, nil
        }
    }
    
    // 3. 计算时间范围
    startTime, endTime := s.calculateTimeRange(period)
    
    // 4. 并行查询各项指标
    var (
        totalReadCount     int64
        totalReaders       int64
        avgReadTime        float64
        completionRate     float64
        favoriteCount      int64
        subscriptionCount  int64
        commentCount       int64
        shareCount         int64
        wg                 sync.WaitGroup
        mu                 sync.Mutex
    )
    
    // 4.1 查询阅读数据
    wg.Add(1)
    go func() {
        defer wg.Done()
        stats, _ := s.readingLogRepo.GetWorkStats(ctx, workId, startTime, endTime)
        mu.Lock()
        totalReadCount = stats.TotalReadCount
        totalReaders = stats.UniqueReaders
        avgReadTime = stats.AvgReadTime
        completionRate = stats.CompletionRate
        mu.Unlock()
    }()
    
    // 4.2 查询互动数据
    wg.Add(1)
    go func() {
        defer wg.Done()
        interactions, _ := s.readingLogRepo.GetInteractionStats(ctx, workId, startTime, endTime)
        mu.Lock()
        favoriteCount = interactions.FavoriteCount
        commentCount = interactions.CommentCount
        shareCount = interactions.ShareCount
        mu.Unlock()
    }()
    
    // 4.3 查询订阅数据
    wg.Add(1)
    go func() {
        defer wg.Done()
        subCount, _ := s.revenueRepo.GetSubscriptionCount(ctx, workId, startTime, endTime)
        mu.Lock()
        subscriptionCount = subCount
        mu.Unlock()
    }()
    
    wg.Wait()
    
    // 5. 计算趋势变化
    trends := s.calculateTrends(ctx, workId, period)
    
    // 6. 构建响应
    overview := &WorkOverviewResponse{
        WorkId: workId,
        Period: period,
        Overview: OverviewData{
            TotalReadCount:    totalReadCount,
            TotalReaders:      totalReaders,
            AvgReadTime:       int(avgReadTime),
            CompletionRate:    completionRate,
            FavoriteCount:     favoriteCount,
            SubscriptionCount: subscriptionCount,
            CommentCount:      commentCount,
            ShareCount:        shareCount,
        },
        Trends:    trends,
        UpdatedAt: time.Now(),
    }
    
    // 7. 写入缓存（5分钟TTL）
    if data, err := json.Marshal(overview); err == nil {
        s.cacheManager.Set(ctx, cacheKey, string(data), 5*time.Minute)
    }
    
    return overview, nil
}

// AnalyzeChapter 分析章节数据
func (s *StatisticsService) AnalyzeChapter(ctx context.Context, workId, chapterId string, period string) (*ChapterAnalysisResponse, error) {
    // 1. 查询章节基础信息
    chapterInfo, err := s.chapterStatsRepo.GetChapterInfo(ctx, chapterId)
    if err != nil {
        return nil, errors.NewInternalError("查询章节信息失败").WithCause(err)
    }
    
    // 2. 计算时间范围
    startTime, endTime := s.calculateTimeRange(period)
    
    // 3. 查询章节统计数据
    stats, err := s.chapterStatsRepo.GetChapterStats(ctx, chapterId, startTime, endTime)
    if err != nil {
        return nil, errors.NewInternalError("查询章节统计失败").WithCause(err)
    }
    
    // 4. 查询趋势数据
    trends, _ := s.chapterStatsRepo.GetChapterTrends(ctx, chapterId, startTime, endTime)
    
    // 5. 生成热力图数据
    heatmap := s.generateHeatmap(ctx, chapterId, startTime, endTime)
    
    // 6. 分析跳出点
    jumpOutPoints := s.analyzeJumpOutPoints(ctx, chapterId, startTime, endTime)
    
    // 7. 查询评论数据
    comments, _ := s.readingLogRepo.GetChapterComments(ctx, chapterId, 10)
    
    // 8. 构建响应
    return &ChapterAnalysisResponse{
        ChapterId:     chapterId,
        ChapterInfo:   chapterInfo,
        Statistics:    stats,
        Trends:        trends,
        Heatmap:       heatmap,
        JumpOutPoints: jumpOutPoints,
        Comments:      comments,
    }, nil
}

// generateHeatmap 生成章节热力图
func (s *StatisticsService) generateHeatmap(ctx context.Context, chapterId string, startTime, endTime time.Time) HeatmapData {
    // 从阅读日志中提取读者停留数据
    logs, _ := s.readingLogRepo.GetReadingLogs(ctx, chapterId, startTime, endTime)
    
    // 将章节分成100段，统计每段的停留时长
    segments := 100
    heatValues := make([]float64, segments)
    readCounts := make([]int64, segments)
    stayTimes := make([]float64, segments)
    
    for _, log := range logs {
        // log.ReadProgress: 阅读进度（0-1）
        // log.StayTime: 停留时间（秒）
        segment := int(log.ReadProgress * float64(segments))
        if segment >= segments {
            segment = segments - 1
        }
        
        readCounts[segment]++
        stayTimes[segment] += float64(log.StayTime)
    }
    
    // 计算热度值（归一化）
    maxStayTime := 0.0
    for i := 0; i < segments; i++ {
        if readCounts[i] > 0 {
            stayTimes[i] /= float64(readCounts[i]) // 平均停留时间
            if stayTimes[i] > maxStayTime {
                maxStayTime = stayTimes[i]
            }
        }
    }
    
    // 归一化热度值
    for i := 0; i < segments; i++ {
        if maxStayTime > 0 {
            heatValues[i] = stayTimes[i] / maxStayTime
        }
    }
    
    // 构建热力图数据（采样，返回20个点）
    var data []HeatmapPoint
    step := segments / 20
    for i := 0; i < segments; i += step {
        data = append(data, HeatmapPoint{
            Position:    float64(i) / float64(segments),
            HeatValue:   heatValues[i],
            ReadCount:   readCounts[i],
            AvgStayTime: int(stayTimes[i]),
        })
    }
    
    return HeatmapData{
        Description: "章节内容热力图，显示读者停留时长分布",
        Data:        data,
    }
}

// analyzeJumpOutPoints 分析章节跳出点
func (s *StatisticsService) analyzeJumpOutPoints(ctx context.Context, chapterId string, startTime, endTime time.Time) JumpOutPointsData {
    // 查询跳出记录
    jumpOuts, _ := s.readingLogRepo.GetJumpOutRecords(ctx, chapterId, startTime, endTime)
    
    // 统计跳出点分布
    segments := 100
    jumpOutCounts := make([]int64, segments)
    
    for _, record := range jumpOuts {
        segment := int(record.JumpOutPosition * float64(segments))
        if segment >= segments {
            segment = segments - 1
        }
        jumpOutCounts[segment]++
    }
    
    // 找出跳出热点（前5个）
    type PointCount struct {
        Position float64
        Count    int64
    }
    var points []PointCount
    for i, count := range jumpOutCounts {
        if count > 0 {
            points = append(points, PointCount{
                Position: float64(i) / float64(segments),
                Count:    count,
            })
        }
    }
    
    // 按数量排序
    sort.Slice(points, func(i, j int) bool {
        return points[i].Count > points[j].Count
    })
    
    // 取前5个
    var data []JumpOutPoint
    for i := 0; i < len(points) && i < 5; i++ {
        totalReaders, _ := s.readingLogRepo.GetReaderCountAtPosition(ctx, chapterId, points[i].Position)
        jumpOutRate := float64(points[i].Count) / float64(totalReaders)
        
        data = append(data, JumpOutPoint{
            Position:      points[i].Position,
            JumpOutCount:  points[i].Count,
            JumpOutRate:   jumpOutRate,
            Reason:        s.inferJumpOutReason(jumpOutRate),
        })
    }
    
    return JumpOutPointsData{
        Description: "读者跳出热点，显示读者在哪些位置离开",
        Data:        data,
    }
}

// inferJumpOutReason 推断跳出原因
func (s *StatisticsService) inferJumpOutReason(jumpOutRate float64) string {
    if jumpOutRate > 0.3 {
        return "可能原因：情节拖沓或内容质量较差"
    } else if jumpOutRate > 0.15 {
        return "可能原因：节奏把握不佳"
    } else if jumpOutRate > 0.05 {
        return "可能原因：部分读者阅读习惯"
    }
    return "正常范围"
}
```

### 3.4 Repository层设计

#### ReadingLogRepository 接口定义

```go
type ReadingLogRepository interface {
    // 阅读日志基础操作
    Create(ctx context.Context, log *models.ReadingLog) error
    BatchCreate(ctx context.Context, logs []*models.ReadingLog) error
    
    // 统计查询
    GetWorkStats(ctx context.Context, workId string, startTime, endTime time.Time) (*WorkStats, error)
    GetChapterStats(ctx context.Context, chapterId string, startTime, endTime time.Time) (*ChapterStats, error)
    GetInteractionStats(ctx context.Context, workId string, startTime, endTime time.Time) (*InteractionStats, error)
    
    // 读者行为分析
    GetReaderSource(ctx context.Context, workId string, startTime, endTime time.Time) (map[string]int64, error)
    GetReadingPath(ctx context.Context, workId string, startTime, endTime time.Time) (*ReadingPathStats, error)
    GetRetentionRate(ctx context.Context, workId string, startTime, endTime time.Time) (*RetentionStats, error)
    
    // 章节详细分析
    GetReadingLogs(ctx context.Context, chapterId string, startTime, endTime time.Time) ([]*models.ReadingLog, error)
    GetJumpOutRecords(ctx context.Context, chapterId string, startTime, endTime time.Time) ([]*models.JumpOutRecord, error)
    GetReaderCountAtPosition(ctx context.Context, chapterId string, position float64) (int64, error)
    
    // 评论查询
    GetChapterComments(ctx context.Context, chapterId string, limit int) ([]*models.Comment, error)
}
```

#### ChapterStatsRepository 接口定义

```go
type ChapterStatsRepository interface {
    // 章节信息
    GetChapterInfo(ctx context.Context, chapterId string) (*ChapterInfo, error)
    
    // 章节统计
    GetChapterStats(ctx context.Context, chapterId string, startTime, endTime time.Time) (*ChapterStats, error)
    GetAllChaptersStats(ctx context.Context, workId string, startTime, endTime time.Time) ([]*ChapterStats, error)
    
    // 趋势数据
    GetChapterTrends(ctx context.Context, chapterId string, startTime, endTime time.Time) (*TrendData, error)
    
    // 更新统计数据
    UpdateChapterStats(ctx context.Context, chapterId string, stats *ChapterStats) error
    BatchUpdateStats(ctx context.Context, statsMap map[string]*ChapterStats) error
}
```

#### RevenueRepository 接口定义

```go
type RevenueRepository interface {
    // 收入记录
    Create(ctx context.Context, record *models.RevenueRecord) error
    GetByWorkId(ctx context.Context, workId string, startTime, endTime time.Time) ([]*models.RevenueRecord, error)
    
    // 收入统计
    GetTotalRevenue(ctx context.Context, workId string, startTime, endTime time.Time) (*RevenueStats, error)
    GetRevenueByType(ctx context.Context, workId string, revenueType string, startTime, endTime time.Time) (float64, error)
    GetSubscriptionCount(ctx context.Context, workId string, startTime, endTime time.Time) (int64, error)
    
    // 收入趋势
    GetRevenueTrend(ctx context.Context, workId string, startTime, endTime time.Time, granularity string) ([]*RevenuePoint, error)
    
    // 排行榜
    GetTopRewardChapters(ctx context.Context, workId string, limit int, startTime, endTime time.Time) ([]*ChapterRevenue, error)
}
```

### 3.5 Model层设计

#### ReadingLog 阅读日志模型

```go
type ReadingLog struct {
    ID            string    `bson:"_id,omitempty" json:"id"`
    UserID        string    `bson:"user_id" json:"userId"`
    WorkID        string    `bson:"work_id" json:"workId"`
    ChapterID     string    `bson:"chapter_id" json:"chapterId"`
    SessionID     string    `bson:"session_id" json:"sessionId"` // 阅读会话ID
    ReadProgress  float64   `bson:"read_progress" json:"readProgress"` // 阅读进度（0-1）
    StayTime      int       `bson:"stay_time" json:"stayTime"` // 停留时间（秒）
    IsCompleted   bool      `bson:"is_completed" json:"isCompleted"` // 是否读完
    IsJumpOut     bool      `bson:"is_jump_out" json:"isJumpOut"` // 是否跳出
    JumpOutPos    float64   `bson:"jump_out_position" json:"jumpOutPosition"` // 跳出位置
    Source        string    `bson:"source" json:"source"` // 来源（search, recommendation, ranking, etc.）
    Device        string    `bson:"device" json:"device"` // 设备类型（mobile, desktop, tablet）
    CreatedAt     time.Time `bson:"created_at" json:"createdAt"`
}
```

#### ChapterStats 章节统计模型

```go
type ChapterStats struct {
    ID             string    `bson:"_id,omitempty" json:"id"`
    WorkID         string    `bson:"work_id" json:"workId"`
    ChapterID      string    `bson:"chapter_id" json:"chapterId"`
    ChapterNumber  int       `bson:"chapter_number" json:"chapterNumber"`
    Date           string    `bson:"date" json:"date"` // 统计日期（YYYY-MM-DD）
    ReadCount      int64     `bson:"read_count" json:"readCount"`
    UniqueReaders  int64     `bson:"unique_readers" json:"uniqueReaders"`
    CompletionRate float64   `bson:"completion_rate" json:"completionRate"`
    JumpRate       float64   `bson:"jump_rate" json:"jumpRate"`
    AvgStayTime    float64   `bson:"avg_stay_time" json:"avgStayTime"`
    JumpOutRate    float64   `bson:"jump_out_rate" json:"jumpOutRate"`
    QualityScore   float64   `bson:"quality_score" json:"qualityScore"` // 质量评分
    UpdatedAt      time.Time `bson:"updated_at" json:"updatedAt"`
}
```

#### RevenueRecord 收入记录模型

```go
type RevenueRecord struct {
    ID           string    `bson:"_id,omitempty" json:"id"`
    WorkID       string    `bson:"work_id" json:"workId"`
    ChapterID    string    `bson:"chapter_id" json:"chapterId"` // 可选，针对章节的收入
    UserID       string    `bson:"user_id" json:"userId"` // 付费用户ID
    Type         string    `bson:"type" json:"type"` // subscription, reward, advertising
    Amount       float64   `bson:"amount" json:"amount"` // 金额（元）
    Currency     string    `bson:"currency" json:"currency"` // 货币类型（CNY）
    OrderID      string    `bson:"order_id" json:"orderId"` // 订单ID
    Status       string    `bson:"status" json:"status"` // pending, completed, refunded
    SettledAt    time.Time `bson:"settled_at" json:"settledAt"` // 结算时间
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
}
```

---

## 4. 数据采集与实时计算

### 4.1 埋点设计

**前端埋点事件**：
```javascript
// 进入章节
sendEvent({
  event: 'chapter_enter',
  workId: 'work123',
  chapterId: 'chapter1',
  userId: 'user456',
  sessionId: 'session789',
  source: 'recommendation',
  device: 'mobile',
  timestamp: Date.now()
});

// 阅读进度
sendEvent({
  event: 'reading_progress',
  workId: 'work123',
  chapterId: 'chapter1',
  userId: 'user456',
  sessionId: 'session789',
  progress: 0.5, // 已读50%
  stayTime: 60, // 停留60秒
  timestamp: Date.now()
});

// 离开章节
sendEvent({
  event: 'chapter_leave',
  workId: 'work123',
  chapterId: 'chapter1',
  userId: 'user456',
  sessionId: 'session789',
  progress: 0.8,
  stayTime: 180,
  isCompleted: false,
  timestamp: Date.now()
});

// 收藏作品
sendEvent({
  event: 'work_favorite',
  workId: 'work123',
  userId: 'user456',
  timestamp: Date.now()
});
```

### 4.2 Kafka Topic设计

**Topic命名规范**：
- `reading-events`: 阅读行为事件
- `interaction-events`: 互动事件（收藏、评论、分享）
- `revenue-events`: 收入事件（订阅、打赏）

**消息格式**：
```json
{
  "eventType": "chapter_enter",
  "eventData": {
    "workId": "work123",
    "chapterId": "chapter1",
    "userId": "user456",
    "sessionId": "session789",
    "source": "recommendation",
    "device": "mobile"
  },
  "timestamp": 1697538600000
}
```

### 4.3 Flink实时计算

**计算逻辑**：
```java
// 伪代码示例
DataStream<ReadingEvent> events = env
    .addSource(new FlinkKafkaConsumer<>("reading-events", ...))
    .map(new EventParser());

// 计算章节阅读量（5分钟窗口）
DataStream<ChapterStats> readCounts = events
    .keyBy(event -> event.getChapterId())
    .window(TumblingEventTimeWindows.of(Time.minutes(5)))
    .aggregate(new ReadCountAggregator());

// 计算完读率
DataStream<CompletionRate> completionRates = events
    .filter(event -> event.getEventType().equals("chapter_leave"))
    .keyBy(event -> event.getChapterId())
    .window(TumblingEventTimeWindows.of(Time.minutes(5)))
    .aggregate(new CompletionRateAggregator());

// 写入MongoDB
readCounts.addSink(new MongoDBSink(...));
completionRates.addSink(new MongoDBSink(...));

// 写入Redis缓存
readCounts.addSink(new RedisSink(...));
```

---

## 5. 数据导出

### 5.1 导出格式

**Excel格式**：
- 作品概览数据
- 章节统计列表
- 收入明细

**CSV格式**：
- 原始阅读日志
- 读者行为数据

**PDF格式**：
- 数据分析报告（含图表）

### 5.2 导出流程

```go
// ExportService
func (s *ExportService) ExportData(ctx context.Context, req *ExportRequest) (*ExportTaskResponse, error) {
    // 1. 创建导出任务
    task := &models.ExportTask{
        ID:        primitive.NewObjectID().Hex(),
        UserID:    req.UserID,
        WorkID:    req.WorkID,
        Type:      req.ExportType, // excel, csv, pdf
        Status:    "pending",
        CreatedAt: time.Now(),
    }
    
    // 2. 保存任务记录
    if err := s.exportTaskRepo.Create(ctx, task); err != nil {
        return nil, err
    }
    
    // 3. 异步执行导出
    go s.executeExport(context.Background(), task)
    
    // 4. 返回任务ID
    return &ExportTaskResponse{
        TaskID:            task.ID,
        Status:            task.Status,
        EstimatedDuration: "3-5分钟",
    }, nil
}

// executeExport 执行导出（后台任务）
func (s *ExportService) executeExport(ctx context.Context, task *models.ExportTask) {
    // 1. 更新任务状态
    task.Status = "processing"
    s.exportTaskRepo.Update(ctx, task.ID, task)
    
    // 2. 查询数据
    data, err := s.queryExportData(ctx, task.WorkID, task.Type)
    if err != nil {
        task.Status = "failed"
        task.ErrorMsg = err.Error()
        s.exportTaskRepo.Update(ctx, task.ID, task)
        return
    }
    
    // 3. 生成文件
    var fileBytes []byte
    var fileName string
    
    switch task.Type {
    case "excel":
        fileBytes, fileName = s.generateExcel(data)
    case "csv":
        fileBytes, fileName = s.generateCSV(data)
    case "pdf":
        fileBytes, fileName = s.generatePDF(data)
    }
    
    // 4. 上传到OSS
    fileURL, err := s.ossService.Upload(ctx, fileName, fileBytes)
    if err != nil {
        task.Status = "failed"
        task.ErrorMsg = "文件上传失败"
        s.exportTaskRepo.Update(ctx, task.ID, task)
        return
    }
    
    // 5. 更新任务状态
    task.Status = "completed"
    task.FileURL = fileURL
    task.CompletedAt = time.Now()
    s.exportTaskRepo.Update(ctx, task.ID, task)
    
    // 6. 发送通知
    s.notifyUser(ctx, task.UserID, task.ID, fileURL)
}
```

---

## 6. 缓存策略

### 6.1 Redis缓存设计

**缓存Key设计**：
- `stats:overview:{workId}:{period}`: 作品概览统计（TTL: 5分钟）
- `stats:chapter:{chapterId}`: 章节统计（TTL: 5分钟）
- `stats:revenue:{workId}:{period}`: 收入统计（TTL: 10分钟）
- `stats:realtime:{workId}`: 实时阅读数（TTL: 1分钟）

**缓存更新策略**：
- **被动更新**：缓存过期后，下次查询时更新
- **主动更新**：Flink计算完成后，主动刷新缓存
- **缓存预热**：定时任务预热热门作品的统计数据

### 6.2 多级缓存

```
用户请求 → 应用内存缓存（1分钟） 
→ Redis缓存（5分钟） 
→ MongoDB查询 
→ 回写缓存
```

---

## 7. 性能优化

### 7.1 查询优化

- **索引优化**：在MongoDB中建立合适的索引
- **分页查询**：大数据量使用分页
- **聚合查询**：使用MongoDB聚合管道
- **预计算**：通过Flink预计算统计数据

### 7.2 性能指标

- **查询响应时间**：< 500ms (P95)
- **数据延迟**：< 5分钟（实时统计）
- **并发支持**：200 QPS
- **数据保留**：原始日志保留30天，聚合数据永久保留

---

## 8. 实施计划

### 8.1 开发阶段 (8天)

**Phase 1: 数据采集 (2天)**
- [ ] 前端埋点实现
- [ ] Kafka消息队列配置
- [ ] 数据模型设计

**Phase 2: 实时计算 (2天)**
- [ ] Flink实时计算任务
- [ ] 数据聚合逻辑
- [ ] MongoDB存储

**Phase 3: 统计API (3天)**
- [ ] 作品概览API
- [ ] 章节统计API
- [ ] 收入统计API
- [ ] 趋势分析API

**Phase 4: 数据导出 (1天)**
- [ ] 导出功能实现
- [ ] 报表生成

---

## 9. 相关文档

- [写作端模块设计](./README_写作端模块设计文档总览.md)
- [数据分析系统](../platform/数据分析系统.md)
- [消息队列设计](../shared/消息队列设计.md)
- [MongoDB应用层优化设计](../database/MongoDB应用层优化设计.md)

---

**文档状态**: ✅ 设计完成  
**最后更新**: 2025-10-17  
**下一步**: 进入开发阶段

