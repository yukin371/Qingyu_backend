# 文档管理系统设计文档

> **版本**: v1.0  
> **创建日期**: 2025-10-16  
> **最后更新**: 2025-10-16  
> **维护者**: 青羽写作团队

## 1. 概述

### 1.1 功能描述

文档管理系统负责管理写作项目的文档结构，支持树形层级管理、拖拽排序、文档移动等功能。系统采用灵活的树形结构，支持卷、章、节等多层级组织方式，满足不同类型创作的需求。

### 1.2 业务价值

- **结构化管理**：提供清晰的文档层级结构
- **灵活组织**：支持拖拽排序和文档移动
- **关联管理**：文档与角色、地点、时间线等设定关联
- **批量操作**：支持批量移动、删除等操作

### 1.3 用户场景

1. **创建文档结构**：新建卷、章、节等层级文档
2. **调整结构**：拖拽调整文档顺序和层级
3. **查看文档树**：以树形结构查看整体架构
4. **移动文档**：将文档移动到其他位置
5. **删除文档**：删除不需要的文档节点

### 1.4 功能边界

**包含功能**：
- 文档树形结构管理
- 文档CRUD操作
- 文档拖拽排序
- 文档移动和复制
- 文档层级管理（最多3层）
- 文档类型管理（卷、章、节、场景）

**不包含功能**：
- 文档内容编辑（由编辑器模块负责）
- 版本控制（由版本控制模块负责）
- 权限管理（由项目管理模块负责）

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────┐
│         Router Layer (路由层)            │
│    /api/v1/projects/:id/documents/*    │
├─────────────────────────────────────────┤
│         API Layer (接口层)               │
│          DocumentApi                    │
├─────────────────────────────────────────┤
│        Service Layer (业务逻辑层)         │
│      DocumentService                    │
├─────────────────────────────────────────┤
│      Repository Layer (数据访问层)        │
│     DocumentRepository                  │
├─────────────────────────────────────────┤
│        Model Layer (数据模型层)           │
│           Document                      │
├─────────────────────────────────────────┤
│         MongoDB (存储层)                 │
└─────────────────────────────────────────┘
```

### 2.2 模块划分

- **DocumentService**：文档管理核心服务
- **DocumentTreeService**：文档树形结构服务
- **DocumentOrderService**：文档排序服务
- **DocumentMoveService**：文档移动服务

### 2.3 数据流设计

```
用户操作 → 权限验证 → 树形结构处理 → 数据持久化 → 统计更新 → 响应返回
```

### 2.4 技术选型

- **Go**: 1.21+
- **Gin**: Web框架
- **MongoDB**: 数据存储
- **Redis**: 缓存

## 3. 详细设计

### 3.1 数据模型设计

#### 3.1.1 Document模型

```go
// models/document/document.go
package document

import "time"

// Document 文档模型
type Document struct {
    ID         string        `bson:"_id,omitempty" json:"id"`
    ProjectID  string        `bson:"project_id" json:"projectId" validate:"required"`
    ParentID   string        `bson:"parent_id,omitempty" json:"parentId,omitempty"` // 父文档ID，空表示根文档
    Title      string        `bson:"title" json:"title" validate:"required,min=1,max=200"`
    Type       DocumentType  `bson:"type" json:"type" validate:"required"`
    Level      int           `bson:"level" json:"level"`                // 层级深度（0-2）
    Order      int           `bson:"order" json:"order"`                // 同级排序
    Status     string        `bson:"status" json:"status"`              // planned | writing | completed
    
    // 内容引用
    ContentID  string        `bson:"content_id,omitempty" json:"contentId,omitempty"` // 关联DocumentContent
    
    // 统计信息
    WordCount  int           `bson:"word_count" json:"wordCount"`       // 字数统计
    
    // 关联信息
    CharacterIDs []string    `bson:"character_ids,omitempty" json:"characterIds,omitempty"` // 关联角色
    LocationIDs  []string    `bson:"location_ids,omitempty" json:"locationIds,omitempty"`   // 关联地点
    TimelineIDs  []string    `bson:"timeline_ids,omitempty" json:"timelineIds,omitempty"`   // 关联时间线
    
    // 标签和备注
    Tags       []string      `bson:"tags,omitempty" json:"tags,omitempty"`
    Notes      string        `bson:"notes,omitempty" json:"notes,omitempty"`
    
    // 时间戳
    CreatedAt  time.Time     `bson:"created_at" json:"createdAt"`
    UpdatedAt  time.Time     `bson:"updated_at" json:"updatedAt"`
    DeletedAt  *time.Time    `bson:"deleted_at,omitempty" json:"deletedAt,omitempty"`
}

// DocumentType 文档类型
type DocumentType string

const (
    TypeVolume  DocumentType = "volume"  // 卷
    TypeChapter DocumentType = "chapter" // 章
    TypeSection DocumentType = "section" // 节
    TypeScene   DocumentType = "scene"   // 场景
)

// 业务方法
func (d *Document) IsRoot() bool {
    return d.ParentID == ""
}

func (d *Document) CanHaveChildren() bool {
    return d.Level < 2 // 最多3层，0-2
}

func (d *Document) GetNextLevel() int {
    return d.Level + 1
}

func (d *Document) UpdateWordCount(count int) {
    d.WordCount = count
    d.UpdatedAt = time.Now()
}
```

### 3.2 Repository层设计

#### 3.2.1 DocumentRepository接口

```go
// repository/interfaces/writing/document_repository.go
package writing

import (
    "context"
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces/infrastructure"
)

type DocumentRepository interface {
    // 基础CRUD操作
    Create(ctx context.Context, doc *document.Document) error
    GetByID(ctx context.Context, id string) (*document.Document, error)
    Update(ctx context.Context, id string, updates map[string]interface{}) error
    Delete(ctx context.Context, id string) error
    
    // 树形结构查询
    GetByProjectID(ctx context.Context, projectID string) ([]*document.Document, error)
    GetChildren(ctx context.Context, parentID string) ([]*document.Document, error)
    GetByParentID(ctx context.Context, parentID string) ([]*document.Document, error)
    GetRootDocuments(ctx context.Context, projectID string) ([]*document.Document, error)
    GetDocumentTree(ctx context.Context, projectID string) ([]*document.Document, error)
    
    // 排序操作
    UpdateOrder(ctx context.Context, id string, order int) error
    GetMaxOrder(ctx context.Context, parentID string) (int, error)
    ReorderSiblings(ctx context.Context, parentID string, orders map[string]int) error
    
    // 移动操作
    Move(ctx context.Context, id, newParentID string, order int) error
    UpdateParent(ctx context.Context, id, newParentID string) error
    
    // 批量操作
    BatchDelete(ctx context.Context, ids []string) error
    GetDescendants(ctx context.Context, id string) ([]*document.Document, error)
    
    // 统计操作
    UpdateWordCount(ctx context.Context, id string, wordCount int) error
    GetWordCountSum(ctx context.Context, parentID string) (int, error)
    
    // 软删除
    SoftDelete(ctx context.Context, id string) error
    SoftDeleteWithChildren(ctx context.Context, id string) error
    
    // 健康检查
    Health(ctx context.Context) error
}
```

#### 3.2.2 MongoDB实现

```go
// repository/mongodb/writing/document_repository_mongo.go
package writing

import (
    "context"
    "fmt"
    "time"
    
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    
    "qingyu_backend/models/document"
)

type MongoDocumentRepository struct {
    collection *mongo.Collection
}

func NewMongoDocumentRepository(db *mongo.Database) *MongoDocumentRepository {
    return &MongoDocumentRepository{
        collection: db.Collection("documents"),
    }
}

// Create 创建文档
func (r *MongoDocumentRepository) Create(ctx context.Context, doc *document.Document) error {
    doc.ID = primitive.NewObjectID().Hex()
    doc.CreatedAt = time.Now()
    doc.UpdatedAt = time.Now()
    
    // 如果没有指定order，设置为最大值+1
    if doc.Order == 0 {
        maxOrder, err := r.GetMaxOrder(ctx, doc.ParentID)
        if err != nil {
            return err
        }
        doc.Order = maxOrder + 1
    }
    
    _, err := r.collection.InsertOne(ctx, doc)
    if err != nil {
        return fmt.Errorf("创建文档失败: %w", err)
    }
    
    return nil
}

// GetDocumentTree 获取文档树
func (r *MongoDocumentRepository) GetDocumentTree(ctx context.Context, projectID string) ([]*document.Document, error) {
    filter := bson.M{
        "project_id": projectID,
        "deleted_at": nil,
    }
    
    opts := options.Find().SetSort(bson.D{
        {Key: "level", Value: 1},
        {Key: "order", Value: 1},
    })
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("查询文档树失败: %w", err)
    }
    defer cursor.Close(ctx)
    
    var documents []*document.Document
    if err = cursor.All(ctx, &documents); err != nil {
        return nil, fmt.Errorf("解析文档数据失败: %w", err)
    }
    
    return documents, nil
}

// GetChildren 获取子文档
func (r *MongoDocumentRepository) GetChildren(ctx context.Context, parentID string) ([]*document.Document, error) {
    filter := bson.M{
        "parent_id":  parentID,
        "deleted_at": nil,
    }
    
    opts := options.Find().SetSort(bson.D{{Key: "order", Value: 1}})
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("查询子文档失败: %w", err)
    }
    defer cursor.Close(ctx)
    
    var documents []*document.Document
    if err = cursor.All(ctx, &documents); err != nil {
        return nil, fmt.Errorf("解析文档数据失败: %w", err)
    }
    
    return documents, nil
}

// GetMaxOrder 获取同级最大order
func (r *MongoDocumentRepository) GetMaxOrder(ctx context.Context, parentID string) (int, error) {
    filter := bson.M{
        "parent_id":  parentID,
        "deleted_at": nil,
    }
    
    opts := options.FindOne().SetSort(bson.D{{Key: "order", Value: -1}})
    
    var doc document.Document
    err := r.collection.FindOne(ctx, filter, opts).Decode(&doc)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return 0, nil
        }
        return 0, fmt.Errorf("查询最大order失败: %w", err)
    }
    
    return doc.Order, nil
}

// Move 移动文档
func (r *MongoDocumentRepository) Move(ctx context.Context, id, newParentID string, order int) error {
    updates := map[string]interface{}{
        "parent_id":  newParentID,
        "order":      order,
        "updated_at": time.Now(),
    }
    
    objID, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return fmt.Errorf("无效的文档ID: %w", err)
    }
    
    filter := bson.M{"_id": objID}
    update := bson.M{"$set": updates}
    
    _, err = r.collection.UpdateOne(ctx, filter, update)
    if err != nil {
        return fmt.Errorf("移动文档失败: %w", err)
    }
    
    return nil
}

// ReorderSiblings 重新排序兄弟节点
func (r *MongoDocumentRepository) ReorderSiblings(ctx context.Context, parentID string, orders map[string]int) error {
    // 使用事务批量更新
    session, err := r.collection.Database().Client().StartSession()
    if err != nil {
        return fmt.Errorf("启动事务失败: %w", err)
    }
    defer session.EndSession(ctx)
    
    _, err = session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) {
        for id, order := range orders {
            objID, err := primitive.ObjectIDFromHex(id)
            if err != nil {
                return nil, fmt.Errorf("无效的文档ID: %w", err)
            }
            
            filter := bson.M{"_id": objID}
            update := bson.M{
                "$set": bson.M{
                    "order":      order,
                    "updated_at": time.Now(),
                },
            }
            
            _, err = r.collection.UpdateOne(sessCtx, filter, update)
            if err != nil {
                return nil, err
            }
        }
        return nil, nil
    })
    
    if err != nil {
        return fmt.Errorf("重新排序失败: %w", err)
    }
    
    return nil
}

// SoftDeleteWithChildren 软删除文档及其子文档
func (r *MongoDocumentRepository) SoftDeleteWithChildren(ctx context.Context, id string) error {
    // 1. 获取所有子孙文档
    descendants, err := r.GetDescendants(ctx, id)
    if err != nil {
        return err
    }
    
    // 2. 收集所有需要删除的ID
    ids := []string{id}
    for _, desc := range descendants {
        ids = append(ids, desc.ID)
    }
    
    // 3. 批量软删除
    return r.BatchDelete(ctx, ids)
}

// GetDescendants 获取所有子孙文档
func (r *MongoDocumentRepository) GetDescendants(ctx context.Context, id string) ([]*document.Document, error) {
    // 递归查询所有子孙节点
    var descendants []*document.Document
    
    children, err := r.GetChildren(ctx, id)
    if err != nil {
        return nil, err
    }
    
    for _, child := range children {
        descendants = append(descendants, child)
        
        // 递归获取子文档的子文档
        childDescendants, err := r.GetDescendants(ctx, child.ID)
        if err != nil {
            return nil, err
        }
        descendants = append(descendants, childDescendants...)
    }
    
    return descendants, nil
}

// Health 健康检查
func (r *MongoDocumentRepository) Health(ctx context.Context) error {
    return r.collection.Database().Client().Ping(ctx, nil)
}
```

### 3.3 Service层设计

```go
// service/document/document_service.go
package document

import (
    "context"
    "fmt"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
    "qingyu_backend/service/base"
)

type DocumentService struct {
    documentRepo interfaces.DocumentRepository
    projectRepo  interfaces.ProjectRepository
    eventBus     base.EventBus
}

func NewDocumentService(
    documentRepo interfaces.DocumentRepository,
    projectRepo interfaces.ProjectRepository,
    eventBus base.EventBus,
) *DocumentService {
    return &DocumentService{
        documentRepo: documentRepo,
        projectRepo:  projectRepo,
        eventBus:     eventBus,
    }
}

// CreateDocument 创建文档
func (s *DocumentService) CreateDocument(ctx context.Context, req *CreateDocumentRequest) (*CreateDocumentResponse, error) {
    // 1. 参数验证
    if err := s.validateCreateDocumentRequest(req); err != nil {
        return nil, errors.NewValidationError("参数验证失败").WithDetails(err.Error())
    }
    
    // 2. 验证项目权限
    project, err := s.projectRepo.GetByID(ctx, req.ProjectID)
    if err != nil {
        return nil, errors.NewInternalError("查询项目失败").WithCause(err)
    }
    
    if project == nil {
        return nil, errors.NewNotFoundError("项目不存在")
    }
    
    userID := ctx.Value("userID").(string)
    if !project.CanEdit(userID) {
        return nil, errors.NewAuthError("无权限编辑该项目")
    }
    
    // 3. 验证父文档
    var level int
    if req.ParentID != "" {
        parent, err := s.documentRepo.GetByID(ctx, req.ParentID)
        if err != nil {
            return nil, errors.NewInternalError("查询父文档失败").WithCause(err)
        }
        
        if parent == nil {
            return nil, errors.NewNotFoundError("父文档不存在")
        }
        
        if !parent.CanHaveChildren() {
            return nil, errors.NewBusinessError("该文档不能添加子文档（最多3层）")
        }
        
        level = parent.GetNextLevel()
    }
    
    // 4. 创建文档对象
    doc := &document.Document{
        ProjectID:    req.ProjectID,
        ParentID:     req.ParentID,
        Title:        req.Title,
        Type:         req.Type,
        Level:        level,
        Order:        req.Order,
        Status:       "planned",
        WordCount:    0,
        CharacterIDs: req.CharacterIDs,
        LocationIDs:  req.LocationIDs,
        TimelineIDs:  req.TimelineIDs,
        Tags:         req.Tags,
        Notes:        req.Notes,
    }
    
    // 5. 保存文档
    if err := s.documentRepo.Create(ctx, doc); err != nil {
        return nil, errors.NewInternalError("创建文档失败").WithCause(err)
    }
    
    // 6. 更新项目统计
    go s.updateProjectStatistics(context.Background(), req.ProjectID)
    
    // 7. 发布事件
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.created",
        EventData: map[string]interface{}{
            "document_id": doc.ID,
            "project_id":  doc.ProjectID,
            "title":       doc.Title,
        },
        Timestamp: time.Now(),
        Source:    "DocumentService",
    })
    
    return &CreateDocumentResponse{
        DocumentID: doc.ID,
        Title:      doc.Title,
        Type:       string(doc.Type),
        CreatedAt:  doc.CreatedAt,
    }, nil
}

// GetDocumentTree 获取文档树
func (s *DocumentService) GetDocumentTree(ctx context.Context, projectID string) (*DocumentTreeResponse, error) {
    // 1. 验证项目权限
    project, err := s.projectRepo.GetByID(ctx, projectID)
    if err != nil {
        return nil, errors.NewInternalError("查询项目失败").WithCause(err)
    }
    
    if project == nil {
        return nil, errors.NewNotFoundError("项目不存在")
    }
    
    userID := ctx.Value("userID").(string)
    if !project.CanView(userID) {
        return nil, errors.NewAuthError("无权限查看该项目")
    }
    
    // 2. 获取所有文档
    documents, err := s.documentRepo.GetDocumentTree(ctx, projectID)
    if err != nil {
        return nil, errors.NewInternalError("查询文档树失败").WithCause(err)
    }
    
    // 3. 构建树形结构
    tree := s.buildDocumentTree(documents)
    
    return &DocumentTreeResponse{
        ProjectID: projectID,
        Documents: tree,
    }, nil
}

// MoveDocument 移动文档
func (s *DocumentService) MoveDocument(ctx context.Context, req *MoveDocumentRequest) error {
    // 1. 获取文档
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return errors.NewInternalError("查询文档失败").WithCause(err)
    }
    
    if doc == nil {
        return errors.NewNotFoundError("文档不存在")
    }
    
    // 2. 验证项目权限
    project, err := s.projectRepo.GetByID(ctx, doc.ProjectID)
    if err != nil {
        return errors.NewInternalError("查询项目失败").WithCause(err)
    }
    
    userID := ctx.Value("userID").(string)
    if !project.CanEdit(userID) {
        return errors.NewAuthError("无权限编辑该项目")
    }
    
    // 3. 验证新父文档
    if req.NewParentID != "" && req.NewParentID != doc.ParentID {
        newParent, err := s.documentRepo.GetByID(ctx, req.NewParentID)
        if err != nil {
            return errors.NewInternalError("查询新父文档失败").WithCause(err)
        }
        
        if newParent == nil {
            return errors.NewNotFoundError("新父文档不存在")
        }
        
        if !newParent.CanHaveChildren() {
            return errors.NewBusinessError("目标文档不能添加子文档")
        }
        
        // 检查是否移动到自己的子文档下（避免循环）
        if s.isDescendant(ctx, newParent.ID, doc.ID) {
            return errors.NewBusinessError("不能移动到自己的子文档下")
        }
    }
    
    // 4. 执行移动
    if err := s.documentRepo.Move(ctx, req.DocumentID, req.NewParentID, req.Order); err != nil {
        return errors.NewInternalError("移动文档失败").WithCause(err)
    }
    
    // 5. 发布事件
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.moved",
        EventData: map[string]interface{}{
            "document_id":    req.DocumentID,
            "old_parent_id":  doc.ParentID,
            "new_parent_id":  req.NewParentID,
        },
        Timestamp: time.Now(),
        Source:    "DocumentService",
    })
    
    return nil
}

// ReorderDocuments 重新排序文档
func (s *DocumentService) ReorderDocuments(ctx context.Context, req *ReorderDocumentsRequest) error {
    // 1. 验证项目权限
    project, err := s.projectRepo.GetByID(ctx, req.ProjectID)
    if err != nil {
        return errors.NewInternalError("查询项目失败").WithCause(err)
    }
    
    if project == nil {
        return errors.NewNotFoundError("项目不存在")
    }
    
    userID := ctx.Value("userID").(string)
    if !project.CanEdit(userID) {
        return errors.NewAuthError("无权限编辑该项目")
    }
    
    // 2. 执行重新排序
    if err := s.documentRepo.ReorderSiblings(ctx, req.ParentID, req.Orders); err != nil {
        return errors.NewInternalError("重新排序失败").WithCause(err)
    }
    
    return nil
}

// DeleteDocument 删除文档
func (s *DocumentService) DeleteDocument(ctx context.Context, documentID string) error {
    // 1. 获取文档
    doc, err := s.documentRepo.GetByID(ctx, documentID)
    if err != nil {
        return errors.NewInternalError("查询文档失败").WithCause(err)
    }
    
    if doc == nil {
        return errors.NewNotFoundError("文档不存在")
    }
    
    // 2. 验证项目权限
    project, err := s.projectRepo.GetByID(ctx, doc.ProjectID)
    if err != nil {
        return errors.NewInternalError("查询项目失败").WithCause(err)
    }
    
    userID := ctx.Value("userID").(string)
    if !project.CanEdit(userID) {
        return errors.NewAuthError("无权限编辑该项目")
    }
    
    // 3. 软删除文档及其子文档
    if err := s.documentRepo.SoftDeleteWithChildren(ctx, documentID); err != nil {
        return errors.NewInternalError("删除文档失败").WithCause(err)
    }
    
    // 4. 更新项目统计
    go s.updateProjectStatistics(context.Background(), doc.ProjectID)
    
    // 5. 发布事件
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.deleted",
        EventData: map[string]interface{}{
            "document_id": documentID,
            "project_id":  doc.ProjectID,
        },
        Timestamp: time.Now(),
        Source:    "DocumentService",
    })
    
    return nil
}

// 私有方法
func (s *DocumentService) buildDocumentTree(documents []*document.Document) []*DocumentTreeNode {
    // 构建树形结构
    nodeMap := make(map[string]*DocumentTreeNode)
    var rootNodes []*DocumentTreeNode
    
    // 第一遍遍历：创建所有节点
    for _, doc := range documents {
        node := &DocumentTreeNode{
            Document: doc,
            Children: []*DocumentTreeNode{},
        }
        nodeMap[doc.ID] = node
    }
    
    // 第二遍遍历：建立父子关系
    for _, doc := range documents {
        node := nodeMap[doc.ID]
        if doc.ParentID == "" {
            rootNodes = append(rootNodes, node)
        } else {
            if parent, exists := nodeMap[doc.ParentID]; exists {
                parent.Children = append(parent.Children, node)
            }
        }
    }
    
    return rootNodes
}

func (s *DocumentService) isDescendant(ctx context.Context, ancestorID, documentID string) bool {
    descendants, err := s.documentRepo.GetDescendants(ctx, ancestorID)
    if err != nil {
        return false
    }
    
    for _, desc := range descendants {
        if desc.ID == documentID {
            return true
        }
    }
    
    return false
}

func (s *DocumentService) updateProjectStatistics(ctx context.Context, projectID string) {
    // TODO: 实现项目统计更新
}

func (s *DocumentService) validateCreateDocumentRequest(req *CreateDocumentRequest) error {
    if req.ProjectID == "" {
        return fmt.Errorf("项目ID不能为空")
    }
    if req.Title == "" {
        return fmt.Errorf("文档标题不能为空")
    }
    if len(req.Title) > 200 {
        return fmt.Errorf("文档标题不能超过200字符")
    }
    return nil
}
```

### 3.4 API层设计

```go
// api/v1/writer/document_api.go
package writer

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
    "qingyu_backend/service/document"
    "qingyu_backend/pkg/response"
)

type DocumentApi struct {
    documentService *document.DocumentService
}

func NewDocumentApi(documentService *document.DocumentService) *DocumentApi {
    return &DocumentApi{
        documentService: documentService,
    }
}

// CreateDocument 创建文档
func (api *DocumentApi) CreateDocument(c *gin.Context) {
    projectID := c.Param("projectId")
    
    var req document.CreateDocumentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.ProjectID = projectID
    
    resp, err := api.documentService.CreateDocument(c.Request.Context(), &req)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusCreated, "创建成功", resp)
}

// GetDocumentTree 获取文档树
func (api *DocumentApi) GetDocumentTree(c *gin.Context) {
    projectID := c.Param("projectId")
    
    resp, err := api.documentService.GetDocumentTree(c.Request.Context(), projectID)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", resp)
}

// MoveDocument 移动文档
func (api *DocumentApi) MoveDocument(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.MoveDocumentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    if err := api.documentService.MoveDocument(c.Request.Context(), &req); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "移动成功", nil)
}

// ReorderDocuments 重新排序
func (api *DocumentApi) ReorderDocuments(c *gin.Context) {
    projectID := c.Param("projectId")
    
    var req document.ReorderDocumentsRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.ProjectID = projectID
    
    if err := api.documentService.ReorderDocuments(c.Request.Context(), &req); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "排序成功", nil)
}

// DeleteDocument 删除文档
func (api *DocumentApi) DeleteDocument(c *gin.Context) {
    documentID := c.Param("id")
    
    if err := api.documentService.DeleteDocument(c.Request.Context(), documentID); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "删除成功", nil)
}
```

### 3.5 Router层设计

```go
// router/writer/document.go
package writer

import (
    "github.com/gin-gonic/gin"
    "qingyu_backend/api/v1/writer"
    "qingyu_backend/middleware"
)

func InitDocumentRouter(r *gin.RouterGroup, documentApi *writer.DocumentApi) {
    docGroup := r.Group("/projects/:projectId/documents")
    docGroup.Use(middleware.JWTAuth())
    {
        // 文档管理
        docGroup.POST("", documentApi.CreateDocument)
        docGroup.GET("/tree", documentApi.GetDocumentTree)
        docGroup.POST("/:id/move", documentApi.MoveDocument)
        docGroup.POST("/reorder", documentApi.ReorderDocuments)
        docGroup.DELETE("/:id", documentApi.DeleteDocument)
    }
}
```

## 4. API接口设计

### 4.1 创建文档

```http
POST /api/v1/projects/{projectId}/documents
Authorization: Bearer {token}
Content-Type: application/json

{
  "parentId": "parent123",
  "title": "第一章",
  "type": "chapter",
  "characterIds": ["char1", "char2"],
  "tags": ["重要"]
}

Response:
{
  "code": 200,
  "message": "创建成功",
  "data": {
    "documentId": "doc123",
    "title": "第一章",
    "type": "chapter",
    "createdAt": "2025-10-16T10:00:00Z"
  }
}
```

### 4.2 获取文档树

```http
GET /api/v1/projects/{projectId}/documents/tree
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "projectId": "project123",
    "documents": [
      {
        "id": "doc1",
        "title": "第一卷",
        "type": "volume",
        "level": 0,
        "children": [
          {
            "id": "doc2",
            "title": "第一章",
            "type": "chapter",
            "level": 1,
            "children": []
          }
        ]
      }
    ]
  }
}
```

### 4.3 移动文档

```http
POST /api/v1/projects/{projectId}/documents/{id}/move
Authorization: Bearer {token}
Content-Type: application/json

{
  "newParentId": "newParent123",
  "order": 5
}

Response:
{
  "code": 200,
  "message": "移动成功"
}
```

### 4.4 重新排序

```http
POST /api/v1/projects/{projectId}/documents/reorder
Authorization: Bearer {token}
Content-Type: application/json

{
  "parentId": "parent123",
  "orders": {
    "doc1": 1,
    "doc2": 2,
    "doc3": 3
  }
}

Response:
{
  "code": 200,
  "message": "排序成功"
}
```

## 5. 前端集成示例

```vue
<template>
  <el-tree
    :data="treeData"
    :props="defaultProps"
    draggable
    @node-drop="handleNodeDrop"
  >
    <template #default="{ node, data }">
      <span class="custom-tree-node">
        <span>{{ data.title }}</span>
        <span>
          <el-button size="small" @click="editDocument(data)">
            编辑
          </el-button>
          <el-button size="small" type="danger" @click="deleteDocument(data)">
            删除
          </el-button>
        </span>
      </span>
    </template>
  </el-tree>
</template>

<script>
export default {
  data() {
    return {
      treeData: [],
      defaultProps: {
        children: 'children',
        label: 'title'
      }
    }
  },
  
  mounted() {
    this.loadDocumentTree()
  },
  
  methods: {
    async loadDocumentTree() {
      const res = await this.$api.getDocumentTree(this.projectId)
      this.treeData = res.data.documents
    },
    
    async handleNodeDrop(draggingNode, dropNode, dropType) {
      // 拖拽后重新排序
      const newParentId = dropType === 'inner' ? dropNode.data.id : dropNode.data.parentId
      
      await this.$api.moveDocument(draggingNode.data.id, {
        newParentId: newParentId,
        order: draggingNode.data.order
      })
      
      this.$message.success('移动成功')
    },
    
    async deleteDocument(data) {
      try {
        await this.$confirm('确定删除该文档吗？')
        await this.$api.deleteDocument(data.id)
        this.$message.success('删除成功')
        this.loadDocumentTree()
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('删除失败')
        }
      }
    }
  }
}
</script>
```

## 6. 性能优化

- **索引优化**：在project_id、parent_id、order等字段建立复合索引
- **缓存策略**：文档树缓存5分钟
- **懒加载**：大型文档树支持按需加载子节点

## 7. 安全设计

- **权限控制**：基于项目权限控制文档操作
- **层级限制**：最多3层防止无限嵌套
- **循环检测**：移动时检测是否形成循环

## 8. 相关文档

- [项目管理系统设计](./项目管理系统设计.md)
- [编辑器系统设计](./编辑器系统设计.md)
- [实施文档](../../implementation/04写作端模块/README_写作端实施文档.md)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-16  
**最后更新**: 2025-10-16  
**维护者**: 青羽写作团队

