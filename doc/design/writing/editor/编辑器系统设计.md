# ç¼–è¾‘å™¨ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

> **ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-16  
> **æœ€åæ›´æ–°**: 2025-10-16  
> **ç»´æŠ¤è€…**: é’ç¾½å†™ä½œå›¢é˜Ÿ

## 1. æ¦‚è¿°

### 1.1 åŠŸèƒ½æè¿°

ç¼–è¾‘å™¨ç³»ç»Ÿæ˜¯é’ç¾½å†™ä½œå¹³å°çš„æ ¸å¿ƒåŠŸèƒ½æ¨¡å—ï¼Œä¸ºä½œè€…æä¾›ä¸“ä¸šçš„æ–‡æ¡£ç¼–è¾‘ç¯å¢ƒã€‚ç³»ç»Ÿæ”¯æŒMarkdownå’Œå¯Œæ–‡æœ¬ä¸¤ç§ç¼–è¾‘æ¨¡å¼ï¼Œæä¾›è‡ªåŠ¨ä¿å­˜ã€ç‰ˆæœ¬æ§åˆ¶ã€æ ¼å¼è½¬æ¢ç­‰åŠŸèƒ½ï¼Œæ»¡è¶³ä¸åŒåˆ›ä½œåœºæ™¯çš„éœ€æ±‚ã€‚

### 1.2 ä¸šåŠ¡ä»·å€¼

- **æå‡åˆ›ä½œä½“éªŒ**ï¼šæä¾›æµç•…ã€ä¸“ä¸šçš„ç¼–è¾‘ç¯å¢ƒ
- **ä¿éšœå†…å®¹å®‰å…¨**ï¼šè‡ªåŠ¨ä¿å­˜å’Œç‰ˆæœ¬æ§åˆ¶é˜²æ­¢å†…å®¹ä¸¢å¤±
- **æ”¯æŒå¤šç§æ ¼å¼**ï¼šMarkdownå’Œå¯Œæ–‡æœ¬åŒæ¨¡å¼æ»¡è¶³ä¸åŒéœ€æ±‚
- **å¢å¼ºåˆ›ä½œæ•ˆç‡**ï¼šå¿«æ·é”®ã€å·¥å…·æ ã€å®æ—¶é¢„è§ˆç­‰åŠŸèƒ½æå‡æ•ˆç‡

### 1.3 ç”¨æˆ·åœºæ™¯

1. **å°è¯´åˆ›ä½œ**ï¼šä½¿ç”¨Markdownç¼–è¾‘å™¨å¿«é€Ÿå†™ä½œï¼Œæ”¯æŒç« èŠ‚ç®¡ç†
2. **å¯Œæ–‡æœ¬ç¼–è¾‘**ï¼šéœ€è¦å¤æ‚æ ¼å¼çš„åˆ›ä½œåœºæ™¯
3. **å¤šè®¾å¤‡åˆ›ä½œ**ï¼šæ”¯æŒä¸åŒè®¾å¤‡é—´çš„å†…å®¹åŒæ­¥
4. **ç‰ˆæœ¬ç®¡ç†**ï¼šæŸ¥çœ‹å†å²ç‰ˆæœ¬ã€å¯¹æ¯”å·®å¼‚ã€æ¢å¤å†…å®¹

### 1.4 åŠŸèƒ½è¾¹ç•Œ

**åŒ…å«åŠŸèƒ½**ï¼š
- Markdownç¼–è¾‘å™¨å’Œå¯Œæ–‡æœ¬ç¼–è¾‘å™¨
- è‡ªåŠ¨ä¿å­˜å’Œæ‰‹åŠ¨ä¿å­˜
- ç‰ˆæœ¬å†å²å’Œç‰ˆæœ¬å¯¹æ¯”
- æ ¼å¼è½¬æ¢ï¼ˆMarkdown â†” å¯Œæ–‡æœ¬ï¼‰
- å·¥å…·æ å’Œå¿«æ·é”®æ”¯æŒ
- å›¾ç‰‡ä¸Šä¼ å’Œé“¾æ¥æ’å…¥

**ä¸åŒ…å«åŠŸèƒ½**ï¼š
- å®æ—¶åä½œç¼–è¾‘ï¼ˆåæœŸç‰ˆæœ¬ï¼‰
- ç¦»çº¿ç¼–è¾‘ï¼ˆåæœŸç‰ˆæœ¬ï¼‰
- è¯­éŸ³è¾“å…¥ï¼ˆåæœŸç‰ˆæœ¬ï¼‰

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å‰ç«¯ç¼–è¾‘å™¨ç»„ä»¶                     â”‚
â”‚   (v-md-editor / Quill)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Router Layer (è·¯ç”±å±‚)            â”‚
â”‚       /api/v1/documents/*               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         API Layer (æ¥å£å±‚)               â”‚
â”‚    DocumentContentApi / VersionApi      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        Service Layer (ä¸šåŠ¡é€»è¾‘å±‚)         â”‚
â”‚   DocumentContentService / VersionServiceâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Repository Layer (æ•°æ®è®¿é—®å±‚)        â”‚
â”‚  DocumentContentRepo / VersionRepo      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        Model Layer (æ•°æ®æ¨¡å‹å±‚)           â”‚
â”‚    DocumentContent / Version            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      MongoDB / GridFS (å­˜å‚¨å±‚)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ¨¡å—åˆ’åˆ†

- **DocumentContentService**ï¼šæ–‡æ¡£å†…å®¹ç®¡ç†æœåŠ¡
- **VersionService**ï¼šç‰ˆæœ¬æ§åˆ¶æœåŠ¡
- **AutoSaveService**ï¼šè‡ªåŠ¨ä¿å­˜æœåŠ¡
- **FormatConverterService**ï¼šæ ¼å¼è½¬æ¢æœåŠ¡

### 2.3 æ•°æ®æµè®¾è®¡

```
ç¼–è¾‘æ“ä½œ â†’ è‡ªåŠ¨ä¿å­˜ â†’ å†…å®¹éªŒè¯ â†’ æ•°æ®æŒä¹…åŒ– â†’ ç‰ˆæœ¬åˆ›å»º â†’ ç¼“å­˜æ›´æ–°
```

### 2.4 æŠ€æœ¯é€‰å‹

**åç«¯æŠ€æœ¯**ï¼š
- **Go**: 1.21+
- **Gin**: Webæ¡†æ¶
- **MongoDB**: å†…å®¹å­˜å‚¨ï¼ˆ<16MBæ–‡æ¡£ï¼‰
- **GridFS**: å¤§æ–‡æ¡£å­˜å‚¨ï¼ˆâ‰¥16MBï¼‰
- **Redis**: è‡ªåŠ¨ä¿å­˜ç¼“å­˜

**å‰ç«¯æŠ€æœ¯**ï¼š
- **v-md-editor**: Markdownç¼–è¾‘å™¨
- **Quill**: å¯Œæ–‡æœ¬ç¼–è¾‘å™¨
- **diff-match-patch**: æ–‡æœ¬å·®å¼‚å¯¹æ¯”
- **marked**: Markdownè§£æ

## 3. è¯¦ç»†è®¾è®¡

### 3.1 æ•°æ®æ¨¡å‹è®¾è®¡

#### 3.1.1 DocumentContentæ¨¡å‹

```go
// models/document/document_content.go
package document

import "time"

// DocumentContent æ–‡æ¡£å†…å®¹
type DocumentContent struct {
    ID           string    `bson:"_id,omitempty" json:"id"`
    DocumentID   string    `bson:"document_id" json:"documentId" validate:"required"`
    Content      string    `bson:"content" json:"content"`                    // æ–‡æ¡£å†…å®¹
    ContentType  string    `bson:"content_type" json:"contentType"`           // markdown | richtext
    WordCount    int       `bson:"word_count" json:"wordCount"`               // å­—æ•°ç»Ÿè®¡
    CharCount    int       `bson:"char_count" json:"charCount"`               // å­—ç¬¦ç»Ÿè®¡
    GridFSID     string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"` // å¤§æ–‡ä»¶GridFS ID
    Version      int       `bson:"version" json:"version"`                    // ç‰ˆæœ¬å·
    LastSavedAt  time.Time `bson:"last_saved_at" json:"lastSavedAt"`         // æœ€åä¿å­˜æ—¶é—´
    LastEditedBy string    `bson:"last_edited_by" json:"lastEditedBy"`       // æœ€åç¼–è¾‘äºº
    UpdatedAt    time.Time `bson:"updated_at" json:"updatedAt"`
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
}

// IsLargeDocument åˆ¤æ–­æ˜¯å¦ä¸ºå¤§æ–‡æ¡£ï¼ˆ>1MBï¼‰
func (d *DocumentContent) IsLargeDocument() bool {
    return len(d.Content) > 1024*1024
}

// GetDisplayWordCount è·å–æ˜¾ç¤ºç”¨çš„å­—æ•°
func (d *DocumentContent) GetDisplayWordCount() int {
    if d.WordCount > 0 {
        return d.WordCount
    }
    return len([]rune(d.Content))
}
```

#### 3.1.2 Versionæ¨¡å‹

```go
// models/document/version.go
package document

import "time"

// Version æ–‡æ¡£ç‰ˆæœ¬
type Version struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    DocumentID  string    `bson:"document_id" json:"documentId" validate:"required"`
    VersionNum  int       `bson:"version_num" json:"versionNum"`           // ç‰ˆæœ¬å·
    Content     string    `bson:"content" json:"content"`                  // ç‰ˆæœ¬å†…å®¹
    GridFSID    string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"`
    ContentType string    `bson:"content_type" json:"contentType"`         // å†…å®¹ç±»å‹
    WordCount   int       `bson:"word_count" json:"wordCount"`             // å­—æ•°
    Comment     string    `bson:"comment,omitempty" json:"comment,omitempty"` // ç‰ˆæœ¬è¯´æ˜
    CreatedBy   string    `bson:"created_by" json:"createdBy"`             // åˆ›å»ºäºº
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`             // åˆ›å»ºæ—¶é—´
    IsAutoSave  bool      `bson:"is_auto_save" json:"isAutoSave"`          // æ˜¯å¦è‡ªåŠ¨ä¿å­˜
}

// GetVersionLabel è·å–ç‰ˆæœ¬æ ‡ç­¾
func (v *Version) GetVersionLabel() string {
    if v.IsAutoSave {
        return fmt.Sprintf("v%d (è‡ªåŠ¨ä¿å­˜)", v.VersionNum)
    }
    return fmt.Sprintf("v%d", v.VersionNum)
}
```

### 3.2 Repositoryå±‚è®¾è®¡

#### 3.2.1 DocumentContentRepositoryæ¥å£

```go
// repository/interfaces/document/document_content_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces/infrastructure"
)

type DocumentContentRepository interface {
    // åŸºç¡€CRUDæ“ä½œ
    Create(ctx context.Context, content *document.DocumentContent) error
    GetByDocumentID(ctx context.Context, documentID string) (*document.DocumentContent, error)
    Update(ctx context.Context, documentID string, updates map[string]interface{}) error
    Delete(ctx context.Context, documentID string) error
    
    // å†…å®¹æ“ä½œ
    SaveContent(ctx context.Context, documentID, content, contentType string) error
    GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error)
    
    // GridFSæ“ä½œ
    SaveToGridFS(ctx context.Context, documentID, content string) (string, error)
    LoadFromGridFS(ctx context.Context, gridfsID string) (string, error)
    DeleteFromGridFS(ctx context.Context, gridfsID string) error
    
    // ç»Ÿè®¡æ“ä½œ
    UpdateWordCount(ctx context.Context, documentID string, wordCount int) error
    
    // å¥åº·æ£€æŸ¥
    Health(ctx context.Context) error
}
```

#### 3.2.2 VersionRepositoryæ¥å£

```go
// repository/interfaces/document/version_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
)

type VersionRepository interface {
    // ç‰ˆæœ¬ç®¡ç†
    Create(ctx context.Context, version *document.Version) error
    GetByID(ctx context.Context, id string) (*document.Version, error)
    GetByDocumentID(ctx context.Context, documentID string, limit int) ([]*document.Version, error)
    GetByVersionNum(ctx context.Context, documentID string, versionNum int) (*document.Version, error)
    Delete(ctx context.Context, id string) error
    
    // ç‰ˆæœ¬æ¸…ç†
    DeleteOldVersions(ctx context.Context, documentID string, keepDays int) error
    GetVersionCount(ctx context.Context, documentID string) (int64, error)
    
    // å¥åº·æ£€æŸ¥
    Health(ctx context.Context) error
}
```

### 3.3 Serviceå±‚è®¾è®¡

#### 3.3.1 DocumentContentService

```go
// service/document/document_content_service.go
package document

import (
    "context"
    "fmt"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type DocumentContentService struct {
    contentRepo  interfaces.DocumentContentRepository
    versionRepo  interfaces.VersionRepository
    documentRepo interfaces.DocumentRepository
    eventBus     base.EventBus
}

func NewDocumentContentService(
    contentRepo interfaces.DocumentContentRepository,
    versionRepo interfaces.VersionRepository,
    documentRepo interfaces.DocumentRepository,
    eventBus base.EventBus,
) *DocumentContentService {
    return &DocumentContentService{
        contentRepo:  contentRepo,
        versionRepo:  versionRepo,
        documentRepo: documentRepo,
        eventBus:     eventBus,
    }
}

// SaveContent ä¿å­˜æ–‡æ¡£å†…å®¹
func (s *DocumentContentService) SaveContent(ctx context.Context, req *SaveContentRequest) (*SaveContentResponse, error) {
    // 1. éªŒè¯æ–‡æ¡£æƒé™
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewNotFoundError("æ–‡æ¡£ä¸å­˜åœ¨")
    }
    
    userID := ctx.Value("userID").(string)
    if !s.checkPermission(doc, userID) {
        return nil, errors.NewAuthError("æ— æƒé™ç¼–è¾‘è¯¥æ–‡æ¡£")
    }
    
    // 2. è·å–å½“å‰å†…å®¹
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, req.DocumentID)
    if err != nil && !errors.IsNotFound(err) {
        return nil, errors.NewInternalError("è·å–å½“å‰å†…å®¹å¤±è´¥").WithCause(err)
    }
    
    // 3. æ£€æŸ¥å¹¶å‘å†²çªï¼ˆä¹è§‚é”ï¼‰
    if currentContent != nil && req.Version > 0 && currentContent.Version != req.Version {
        return nil, errors.NewBusinessError("å†…å®¹å·²è¢«å…¶ä»–ç”¨æˆ·ä¿®æ”¹ï¼Œè¯·åˆ·æ–°åé‡è¯•")
    }
    
    // 4. è®¡ç®—å­—æ•°
    wordCount := s.calculateWordCount(req.Content)
    charCount := len([]rune(req.Content))
    
    // 5. åˆ¤æ–­æ˜¯å¦ä½¿ç”¨GridFS
    var gridfsID string
    var content string
    
    if len(req.Content) > 1024*1024 { // å¤§äº1MBä½¿ç”¨GridFS
        gridfsID, err = s.contentRepo.SaveToGridFS(ctx, req.DocumentID, req.Content)
        if err != nil {
            return nil, errors.NewInternalError("ä¿å­˜å¤§æ–‡ä»¶å¤±è´¥").WithCause(err)
        }
        content = "" // å†…å®¹å­˜å‚¨åœ¨GridFSï¼Œä¸»æ–‡æ¡£ä¸å­˜å‚¨
    } else {
        content = req.Content
    }
    
    // 6. ä¿å­˜æˆ–æ›´æ–°å†…å®¹
    newVersion := 1
    if currentContent != nil {
        newVersion = currentContent.Version + 1
    }
    
    updates := map[string]interface{}{
        "content":        content,
        "content_type":   req.ContentType,
        "word_count":     wordCount,
        "char_count":     charCount,
        "gridfs_id":      gridfsID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "last_edited_by": userID,
        "updated_at":     time.Now(),
    }
    
    if currentContent == nil {
        // åˆ›å»ºæ–°å†…å®¹
        newContent := &document.DocumentContent{
            DocumentID:   req.DocumentID,
            Content:      content,
            ContentType:  req.ContentType,
            WordCount:    wordCount,
            CharCount:    charCount,
            GridFSID:     gridfsID,
            Version:      newVersion,
            LastSavedAt:  time.Now(),
            LastEditedBy: userID,
            CreatedAt:    time.Now(),
            UpdatedAt:    time.Now(),
        }
        if err := s.contentRepo.Create(ctx, newContent); err != nil {
            return nil, errors.NewInternalError("åˆ›å»ºå†…å®¹å¤±è´¥").WithCause(err)
        }
    } else {
        // æ›´æ–°å†…å®¹
        if err := s.contentRepo.Update(ctx, req.DocumentID, updates); err != nil {
            return nil, errors.NewInternalError("æ›´æ–°å†…å®¹å¤±è´¥").WithCause(err)
        }
    }
    
    // 7. åˆ›å»ºç‰ˆæœ¬ï¼ˆéè‡ªåŠ¨ä¿å­˜æ‰åˆ›å»ºç‰ˆæœ¬ï¼‰
    if !req.IsAutoSave {
        version := &document.Version{
            DocumentID:  req.DocumentID,
            VersionNum:  newVersion,
            Content:     content,
            GridFSID:    gridfsID,
            ContentType: req.ContentType,
            WordCount:   wordCount,
            Comment:     req.Comment,
            CreatedBy:   userID,
            CreatedAt:   time.Now(),
            IsAutoSave:  false,
        }
        if err := s.versionRepo.Create(ctx, version); err != nil {
            // ç‰ˆæœ¬åˆ›å»ºå¤±è´¥ä¸å½±å“ä¸»æµç¨‹
            fmt.Printf("åˆ›å»ºç‰ˆæœ¬å¤±è´¥: %v\n", err)
        }
    }
    
    // 8. æ›´æ–°æ–‡æ¡£ç»Ÿè®¡
    docUpdates := map[string]interface{}{
        "word_count": wordCount,
        "updated_at": time.Now(),
    }
    s.documentRepo.Update(ctx, req.DocumentID, docUpdates)
    
    // 9. å‘å¸ƒäº‹ä»¶
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.content_saved",
        EventData: map[string]interface{}{
            "document_id": req.DocumentID,
            "word_count":  wordCount,
            "version":     newVersion,
        },
        Timestamp: time.Now(),
        Source:    "DocumentContentService",
    })
    
    return &SaveContentResponse{
        DocumentID: req.DocumentID,
        Version:    newVersion,
        WordCount:  wordCount,
        SavedAt:    time.Now(),
    }, nil
}

// GetContent è·å–æ–‡æ¡£å†…å®¹
func (s *DocumentContentService) GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error) {
    // 1. è·å–å†…å®¹è®°å½•
    content, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return nil, errors.NewNotFoundError("æ–‡æ¡£å†…å®¹ä¸å­˜åœ¨")
    }
    
    // 2. å¦‚æœä½¿ç”¨GridFSï¼ŒåŠ è½½å†…å®¹
    if content.GridFSID != "" {
        fullContent, err := s.contentRepo.LoadFromGridFS(ctx, content.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("åŠ è½½æ–‡æ¡£å†…å®¹å¤±è´¥").WithCause(err)
        }
        content.Content = fullContent
    }
    
    return content, nil
}

// AutoSave è‡ªåŠ¨ä¿å­˜
func (s *DocumentContentService) AutoSave(ctx context.Context, req *AutoSaveRequest) error {
    // è‡ªåŠ¨ä¿å­˜ä½¿ç”¨ç®€åŒ–é€»è¾‘ï¼Œä¸åˆ›å»ºç‰ˆæœ¬
    saveReq := &SaveContentRequest{
        DocumentID:  req.DocumentID,
        Content:     req.Content,
        ContentType: req.ContentType,
        Version:     req.Version,
        IsAutoSave:  true,
    }
    
    _, err := s.SaveContent(ctx, saveReq)
    return err
}

// ç§æœ‰æ–¹æ³•
func (s *DocumentContentService) calculateWordCount(content string) int {
    // ç®€åŒ–çš„å­—æ•°ç»Ÿè®¡ï¼Œå®é™…åº”è¯¥æ›´å¤æ‚
    return len([]rune(content))
}

func (s *DocumentContentService) checkPermission(doc *document.Document, userID string) bool {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™ç¼–è¾‘æ–‡æ¡£
    // TODO: å®ç°å®Œæ•´çš„æƒé™æ£€æŸ¥
    return true
}
```

#### 3.3.2 VersionService

```go
// service/document/version_service.go
package document

import (
    "context"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type VersionService struct {
    versionRepo interfaces.VersionRepository
    contentRepo interfaces.DocumentContentRepository
}

func NewVersionService(
    versionRepo interfaces.VersionRepository,
    contentRepo interfaces.DocumentContentRepository,
) *VersionService {
    return &VersionService{
        versionRepo: versionRepo,
        contentRepo: contentRepo,
    }
}

// ListVersions è·å–ç‰ˆæœ¬å†å²
func (s *VersionService) ListVersions(ctx context.Context, documentID string, limit int) ([]*document.Version, error) {
    versions, err := s.versionRepo.GetByDocumentID(ctx, documentID, limit)
    if err != nil {
        return nil, errors.NewInternalError("è·å–ç‰ˆæœ¬å†å²å¤±è´¥").WithCause(err)
    }
    
    // åŠ è½½GridFSå†…å®¹
    for _, version := range versions {
        if version.GridFSID != "" {
            content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
            if err != nil {
                continue // è·³è¿‡åŠ è½½å¤±è´¥çš„ç‰ˆæœ¬
            }
            version.Content = content
        }
    }
    
    return versions, nil
}

// GetVersion è·å–æŒ‡å®šç‰ˆæœ¬
func (s *VersionService) GetVersion(ctx context.Context, documentID string, versionNum int) (*document.Version, error) {
    version, err := s.versionRepo.GetByVersionNum(ctx, documentID, versionNum)
    if err != nil {
        return nil, errors.NewNotFoundError("ç‰ˆæœ¬ä¸å­˜åœ¨")
    }
    
    // åŠ è½½GridFSå†…å®¹
    if version.GridFSID != "" {
        content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("åŠ è½½ç‰ˆæœ¬å†…å®¹å¤±è´¥").WithCause(err)
        }
        version.Content = content
    }
    
    return version, nil
}

// CompareVersions å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬
func (s *VersionService) CompareVersions(ctx context.Context, documentID string, version1, version2 int) (*VersionCompareResponse, error) {
    // è·å–ä¸¤ä¸ªç‰ˆæœ¬
    v1, err := s.GetVersion(ctx, documentID, version1)
    if err != nil {
        return nil, err
    }
    
    v2, err := s.GetVersion(ctx, documentID, version2)
    if err != nil {
        return nil, err
    }
    
    // è¿”å›å¯¹æ¯”ç»“æœï¼ˆå®é™…diffè®¡ç®—åœ¨å‰ç«¯è¿›è¡Œï¼‰
    return &VersionCompareResponse{
        Version1:     v1,
        Version2:     v2,
        WordCountDiff: v2.WordCount - v1.WordCount,
    }, nil
}

// RestoreVersion æ¢å¤åˆ°æŒ‡å®šç‰ˆæœ¬
func (s *VersionService) RestoreVersion(ctx context.Context, documentID string, versionNum int) error {
    // 1. è·å–æŒ‡å®šç‰ˆæœ¬
    version, err := s.GetVersion(ctx, documentID, versionNum)
    if err != nil {
        return err
    }
    
    // 2. è·å–å½“å‰å†…å®¹
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return errors.NewInternalError("è·å–å½“å‰å†…å®¹å¤±è´¥").WithCause(err)
    }
    
    // 3. ä¿å­˜æ¢å¤æ“ä½œä¸ºæ–°ç‰ˆæœ¬
    newVersion := currentContent.Version + 1
    
    updates := map[string]interface{}{
        "content":        version.Content,
        "content_type":   version.ContentType,
        "gridfs_id":      version.GridFSID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "updated_at":     time.Now(),
    }
    
    if err := s.contentRepo.Update(ctx, documentID, updates); err != nil {
        return errors.NewInternalError("æ¢å¤ç‰ˆæœ¬å¤±è´¥").WithCause(err)
    }
    
    // 4. åˆ›å»ºæ¢å¤è®°å½•ç‰ˆæœ¬
    restoreVersion := &document.Version{
        DocumentID:  documentID,
        VersionNum:  newVersion,
        Content:     version.Content,
        GridFSID:    version.GridFSID,
        ContentType: version.ContentType,
        WordCount:   version.WordCount,
        Comment:     fmt.Sprintf("æ¢å¤åˆ°ç‰ˆæœ¬ v%d", versionNum),
        CreatedBy:   ctx.Value("userID").(string),
        CreatedAt:   time.Now(),
        IsAutoSave:  false,
    }
    
    return s.versionRepo.Create(ctx, restoreVersion)
}

// CleanOldVersions æ¸…ç†æ—§ç‰ˆæœ¬
func (s *VersionService) CleanOldVersions(ctx context.Context, documentID string, keepDays int) error {
    return s.versionRepo.DeleteOldVersions(ctx, documentID, keepDays)
}
```

### 3.4 APIå±‚è®¾è®¡

```go
// api/v1/writer/document_content_api.go
package writer

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
    "qingyu_backend/service/document"
    "qingyu_backend/pkg/response"
)

type DocumentContentApi struct {
    contentService *document.DocumentContentService
    versionService *document.VersionService
}

func NewDocumentContentApi(
    contentService *document.DocumentContentService,
    versionService *document.VersionService,
) *DocumentContentApi {
    return &DocumentContentApi{
        contentService: contentService,
        versionService: versionService,
    }
}

// GetContent è·å–æ–‡æ¡£å†…å®¹
func (api *DocumentContentApi) GetContent(c *gin.Context) {
    documentID := c.Param("id")
    
    content, err := api.contentService.GetContent(c.Request.Context(), documentID)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "è·å–æˆåŠŸ", content)
}

// SaveContent ä¿å­˜æ–‡æ¡£å†…å®¹
func (api *DocumentContentApi) SaveContent(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.SaveContentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "å‚æ•°é”™è¯¯", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    resp, err := api.contentService.SaveContent(c.Request.Context(), &req)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "ä¿å­˜æˆåŠŸ", resp)
}

// AutoSave è‡ªåŠ¨ä¿å­˜
func (api *DocumentContentApi) AutoSave(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.AutoSaveRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "å‚æ•°é”™è¯¯", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    if err := api.contentService.AutoSave(c.Request.Context(), &req); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "è‡ªåŠ¨ä¿å­˜æˆåŠŸ", nil)
}

// GetVersions è·å–ç‰ˆæœ¬å†å²
func (api *DocumentContentApi) GetVersions(c *gin.Context) {
    documentID := c.Param("id")
    limit := 30 // é»˜è®¤æ˜¾ç¤ºæœ€è¿‘30ä¸ªç‰ˆæœ¬
    
    versions, err := api.versionService.ListVersions(c.Request.Context(), documentID, limit)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "è·å–æˆåŠŸ", versions)
}

// GetVersion è·å–æŒ‡å®šç‰ˆæœ¬
func (api *DocumentContentApi) GetVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    version, err := api.versionService.GetVersion(c.Request.Context(), documentID, versionNum)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "è·å–æˆåŠŸ", version)
}

// RestoreVersion æ¢å¤ç‰ˆæœ¬
func (api *DocumentContentApi) RestoreVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    if err := api.versionService.RestoreVersion(c.Request.Context(), documentID, versionNum); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "æ¢å¤æˆåŠŸ", nil)
}
```

### 3.5 Routerå±‚è®¾è®¡

```go
// router/writer/document_content.go
package writer

import (
    "github.com/gin-gonic/gin"
    "qingyu_backend/api/v1/writer"
    "qingyu_backend/middleware"
)

func InitDocumentContentRouter(r *gin.RouterGroup, contentApi *writer.DocumentContentApi) {
    docGroup := r.Group("/documents")
    docGroup.Use(middleware.JWTAuth())
    {
        // å†…å®¹ç®¡ç†
        docGroup.GET("/:id/content", contentApi.GetContent)
        docGroup.PUT("/:id/content", contentApi.SaveContent)
        docGroup.POST("/:id/autosave", contentApi.AutoSave)
        
        // ç‰ˆæœ¬ç®¡ç†
        docGroup.GET("/:id/versions", contentApi.GetVersions)
        docGroup.GET("/:id/versions/:version", contentApi.GetVersion)
        docGroup.POST("/:id/restore/:version", contentApi.RestoreVersion)
    }
}
```

## 4. APIæ¥å£è®¾è®¡

### 4.1 å†…å®¹ç®¡ç†æ¥å£

#### 4.1.1 è·å–æ–‡æ¡£å†…å®¹

```http
GET /api/v1/documents/{id}/content
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "è·å–æˆåŠŸ",
  "data": {
    "id": "string",
    "documentId": "string",
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "charCount": 3000,
    "version": 5,
    "lastSavedAt": "2025-10-16T10:00:00Z"
  }
}
```

#### 4.1.2 ä¿å­˜æ–‡æ¡£å†…å®¹

```http
PUT /api/v1/documents/{id}/content
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5,
  "comment": "ä¿®æ”¹äº†ç¬¬ä¸‰ç« "
}

Response:
{
  "code": 200,
  "message": "ä¿å­˜æˆåŠŸ",
  "data": {
    "documentId": "string",
    "version": 6,
    "wordCount": 1050,
    "savedAt": "2025-10-16T10:05:00Z"
  }
}
```

#### 4.1.3 è‡ªåŠ¨ä¿å­˜

```http
POST /api/v1/documents/{id}/autosave
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5
}

Response:
{
  "code": 200,
  "message": "è‡ªåŠ¨ä¿å­˜æˆåŠŸ",
  "data": null
}
```

### 4.2 ç‰ˆæœ¬ç®¡ç†æ¥å£

#### 4.2.1 è·å–ç‰ˆæœ¬å†å²

```http
GET /api/v1/documents/{id}/versions
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "è·å–æˆåŠŸ",
  "data": [
    {
      "id": "string",
      "versionNum": 6,
      "wordCount": 1050,
      "comment": "ä¿®æ”¹äº†ç¬¬ä¸‰ç« ",
      "createdBy": "user123",
      "createdAt": "2025-10-16T10:05:00Z",
      "isAutoSave": false
    }
  ]
}
```

#### 4.2.2 è·å–æŒ‡å®šç‰ˆæœ¬

```http
GET /api/v1/documents/{id}/versions/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "è·å–æˆåŠŸ",
  "data": {
    "id": "string",
    "versionNum": 5,
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "createdAt": "2025-10-16T09:00:00Z"
  }
}
```

#### 4.2.3 æ¢å¤ç‰ˆæœ¬

```http
POST /api/v1/documents/{id}/restore/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "æ¢å¤æˆåŠŸ",
  "data": null
}
```

## 5. å‰ç«¯é›†æˆè®¾è®¡

### 5.1 Markdownç¼–è¾‘å™¨

```vue
<template>
  <div class="editor-container">
    <v-md-editor
      v-model="content"
      height="600px"
      :disabled-menus="[]"
      @save="handleSave"
      @change="handleChange"
    >
    </v-md-editor>
    
    <div class="editor-status">
      <span>å­—æ•°: {{ wordCount }}</span>
      <span>{{ saveStatus }}</span>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      content: '',
      wordCount: 0,
      saveStatus: 'å·²ä¿å­˜',
      autoSaveTimer: null,
      version: 0
    }
  },
  
  mounted() {
    this.loadContent()
    this.startAutoSave()
  },
  
  methods: {
    async loadContent() {
      const res = await this.$api.getDocumentContent(this.documentId)
      this.content = res.data.content
      this.version = res.data.version
      this.wordCount = res.data.wordCount
    },
    
    async handleSave() {
      try {
        const res = await this.$api.saveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.version = res.data.version
        this.saveStatus = 'å·²ä¿å­˜'
        this.$message.success('ä¿å­˜æˆåŠŸ')
      } catch (error) {
        this.$message.error('ä¿å­˜å¤±è´¥')
      }
    },
    
    handleChange() {
      this.saveStatus = 'æœªä¿å­˜'
      this.wordCount = this.content.length
    },
    
    startAutoSave() {
      this.autoSaveTimer = setInterval(() => {
        if (this.saveStatus === 'æœªä¿å­˜') {
          this.autoSave()
        }
      }, 30000) // 30ç§’è‡ªåŠ¨ä¿å­˜
    },
    
    async autoSave() {
      try {
        await this.$api.autoSaveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.saveStatus = 'è‡ªåŠ¨ä¿å­˜äº ' + new Date().toLocaleTimeString()
      } catch (error) {
        console.error('è‡ªåŠ¨ä¿å­˜å¤±è´¥', error)
      }
    }
  },
  
  beforeUnmount() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer)
    }
  }
}
</script>
```

### 5.2 ç‰ˆæœ¬å†å²ç»„ä»¶

```vue
<template>
  <div class="version-history">
    <el-timeline>
      <el-timeline-item
        v-for="version in versions"
        :key="version.id"
        :timestamp="formatTime(version.createdAt)"
      >
        <div class="version-item">
          <div class="version-info">
            <span class="version-num">v{{ version.versionNum }}</span>
            <span class="version-comment">{{ version.comment }}</span>
            <span class="word-count">{{ version.wordCount }}å­—</span>
          </div>
          <div class="version-actions">
            <el-button size="small" @click="previewVersion(version)">
              é¢„è§ˆ
            </el-button>
            <el-button size="small" @click="compareVersion(version)">
              å¯¹æ¯”
            </el-button>
            <el-button size="small" type="primary" @click="restoreVersion(version)">
              æ¢å¤
            </el-button>
          </div>
        </div>
      </el-timeline-item>
    </el-timeline>
  </div>
</template>

<script>
export default {
  data() {
    return {
      versions: []
    }
  },
  
  mounted() {
    this.loadVersions()
  },
  
  methods: {
    async loadVersions() {
      const res = await this.$api.getVersionHistory(this.documentId)
      this.versions = res.data
    },
    
    async previewVersion(version) {
      const res = await this.$api.getVersion(this.documentId, version.versionNum)
      this.$emit('preview', res.data)
    },
    
    async compareVersion(version) {
      this.$emit('compare', version)
    },
    
    async restoreVersion(version) {
      try {
        await this.$confirm('ç¡®å®šè¦æ¢å¤åˆ°æ­¤ç‰ˆæœ¬å—ï¼Ÿ')
        await this.$api.restoreVersion(this.documentId, version.versionNum)
        this.$message.success('æ¢å¤æˆåŠŸ')
        this.$emit('restored')
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('æ¢å¤å¤±è´¥')
        }
      }
    },
    
    formatTime(time) {
      return new Date(time).toLocaleString()
    }
  }
}
</script>
```

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 å¤§æ–‡æ¡£å¤„ç†

- **åˆ†å—åŠ è½½**ï¼šæ–‡æ¡£è¶…è¿‡1MBæ—¶ä½¿ç”¨GridFSå­˜å‚¨
- **æ‡’åŠ è½½**ï¼šç‰ˆæœ¬å†å²å†…å®¹æŒ‰éœ€åŠ è½½
- **å‹ç¼©ä¼ è¾“**ï¼šä½¿ç”¨gzipå‹ç¼©ä¼ è¾“å†…å®¹

### 6.2 è‡ªåŠ¨ä¿å­˜ä¼˜åŒ–

- **é˜²æŠ–åŠ¨**ï¼šé¿å…é¢‘ç¹ä¿å­˜
- **å¢é‡ä¿å­˜**ï¼šåªä¿å­˜å˜æ›´çš„å†…å®¹ï¼ˆåæœŸä¼˜åŒ–ï¼‰
- **æœ¬åœ°ç¼“å­˜**ï¼šå‰ç«¯LocalStorageç¼“å­˜ï¼Œç½‘ç»œæ¢å¤ååŒæ­¥

### 6.3 ç‰ˆæœ¬æ§åˆ¶ä¼˜åŒ–

- **ç‰ˆæœ¬é™åˆ¶**ï¼šæ¯ä¸ªæ–‡æ¡£æœ€å¤šä¿ç•™100ä¸ªç‰ˆæœ¬
- **å®šæœŸæ¸…ç†**ï¼šè‡ªåŠ¨æ¸…ç†30å¤©å‰çš„è‡ªåŠ¨ä¿å­˜ç‰ˆæœ¬
- **ç‰ˆæœ¬åˆå¹¶**ï¼šåˆå¹¶è¿ç»­çš„å°æ”¹åŠ¨ï¼ˆåæœŸä¼˜åŒ–ï¼‰

## 7. å®‰å…¨è®¾è®¡

### 7.1 æƒé™æ§åˆ¶

- **æ–‡æ¡£æƒé™**ï¼šåªæœ‰æ–‡æ¡£æ‰€æœ‰è€…å’Œåä½œè€…å¯ä»¥ç¼–è¾‘
- **ç‰ˆæœ¬æƒé™**ï¼šåªèƒ½æŸ¥çœ‹å’Œæ¢å¤è‡ªå·±çš„ç‰ˆæœ¬
- **APIé‰´æƒ**ï¼šæ‰€æœ‰æ¥å£éœ€è¦JWTè®¤è¯

### 7.2 æ•°æ®å®‰å…¨

- **ä¹è§‚é”**ï¼šä½¿ç”¨ç‰ˆæœ¬å·é˜²æ­¢å¹¶å‘å†²çª
- **å†…å®¹åŠ å¯†**ï¼šæ•æ„Ÿå†…å®¹å¯é€‰æ‹©åŠ å¯†å­˜å‚¨
- **å¤‡ä»½æœºåˆ¶**ï¼šå®šæœŸå¤‡ä»½é‡è¦æ–‡æ¡£

### 7.3 è¾“å…¥éªŒè¯

- **å†…å®¹é•¿åº¦é™åˆ¶**ï¼šå•ä¸ªæ–‡æ¡£ä¸è¶…è¿‡10MB
- **XSSé˜²æŠ¤**ï¼šè¿‡æ»¤æ¶æ„è„šæœ¬
- **SQLæ³¨å…¥é˜²æŠ¤**ï¼šå‚æ•°åŒ–æŸ¥è¯¢

## 8. æµ‹è¯•è®¾è®¡

### 8.1 å•å…ƒæµ‹è¯•

```go
func TestDocumentContentService_SaveContent(t *testing.T) {
    // æµ‹è¯•æ­£å¸¸ä¿å­˜
    // æµ‹è¯•å¤§æ–‡æ¡£ä¿å­˜
    // æµ‹è¯•å¹¶å‘å†²çª
    // æµ‹è¯•æƒé™éªŒè¯
}

func TestVersionService_RestoreVersion(t *testing.T) {
    // æµ‹è¯•ç‰ˆæœ¬æ¢å¤
    // æµ‹è¯•ä¸å­˜åœ¨çš„ç‰ˆæœ¬
    // æµ‹è¯•æƒé™éªŒè¯
}
```

### 8.2 é›†æˆæµ‹è¯•

- APIæ¥å£æµ‹è¯•
- æ•°æ®åº“æ“ä½œæµ‹è¯•
- GridFSå­˜å‚¨æµ‹è¯•

### 8.3 æ€§èƒ½æµ‹è¯•

- å¤§æ–‡æ¡£åŠ è½½æ€§èƒ½
- è‡ªåŠ¨ä¿å­˜å“åº”æ—¶é—´
- ç‰ˆæœ¬å†å²æŸ¥è¯¢æ€§èƒ½
- å¹¶å‘ç¼–è¾‘æµ‹è¯•

## 9. ç›‘æ§å’Œæ—¥å¿—

### 9.1 ç›‘æ§æŒ‡æ ‡

- ä¿å­˜æˆåŠŸç‡
- è‡ªåŠ¨ä¿å­˜é¢‘ç‡
- æ–‡æ¡£åŠ è½½æ—¶é—´
- GridFSä½¿ç”¨ç‡

### 9.2 æ—¥å¿—è®°å½•

- å†…å®¹ä¿å­˜æ—¥å¿—
- ç‰ˆæœ¬åˆ›å»ºæ—¥å¿—
- é”™è¯¯æ—¥å¿—
- æ€§èƒ½æ—¥å¿—

## 10. é£é™©ä¸åº”å¯¹

### 10.1 æ•°æ®ä¸¢å¤±é£é™©

**é£é™©**ï¼šè‡ªåŠ¨ä¿å­˜å¤±è´¥å¯¼è‡´å†…å®¹ä¸¢å¤±

**åº”å¯¹**ï¼š
- å‰ç«¯LocalStorageç¼“å­˜
- ä¿å­˜å¤±è´¥é‡è¯•æœºåˆ¶
- å®šæœŸå…¨é‡å¤‡ä»½

### 10.2 å¹¶å‘å†²çªé£é™©

**é£é™©**ï¼šå¤šè®¾å¤‡åŒæ—¶ç¼–è¾‘å¯¼è‡´å†…å®¹è¦†ç›–

**åº”å¯¹**ï¼š
- ä¹è§‚é”ç‰ˆæœ¬æ§åˆ¶
- å†²çªæç¤ºå’Œåˆå¹¶
- æœ€åç¼–è¾‘æ—¶é—´æ˜¾ç¤º

### 10.3 æ€§èƒ½é£é™©

**é£é™©**ï¼šå¤§æ–‡æ¡£å¯¼è‡´åŠ è½½ç¼“æ…¢

**åº”å¯¹**ï¼š
- GridFSåˆ†å—å­˜å‚¨
- å†…å®¹å‹ç¼©
- CDNåŠ é€Ÿ

## 11. å®æ–½è®¡åˆ’

### 11.1 ç¬¬ä¸€é˜¶æ®µï¼ˆ2å‘¨ï¼‰

- [ ] DocumentContentå’ŒVersionæ¨¡å‹è®¾è®¡
- [ ] Repositoryå±‚å®ç°
- [ ] Serviceå±‚åŸºç¡€åŠŸèƒ½

### 11.2 ç¬¬äºŒé˜¶æ®µï¼ˆ2å‘¨ï¼‰

- [ ] APIæ¥å£å¼€å‘
- [ ] å‰ç«¯Markdownç¼–è¾‘å™¨é›†æˆ
- [ ] è‡ªåŠ¨ä¿å­˜åŠŸèƒ½

### 11.3 ç¬¬ä¸‰é˜¶æ®µï¼ˆ1å‘¨ï¼‰

- [ ] ç‰ˆæœ¬æ§åˆ¶åŠŸèƒ½
- [ ] GridFSå¤§æ–‡æ¡£æ”¯æŒ
- [ ] å¯Œæ–‡æœ¬ç¼–è¾‘å™¨é›†æˆ

### 11.4 ç¬¬å››é˜¶æ®µï¼ˆ1å‘¨ï¼‰

- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] æµ‹è¯•å’ŒBUGä¿®å¤
- [ ] æ–‡æ¡£å’Œéƒ¨ç½²

## 12. MVPåŠŸèƒ½å¢å¼ºè®¾è®¡

> **æ›´æ–°æ—¥æœŸ**: 2025-10-17  
> **ä¼˜å…ˆçº§**: ğŸ”¥ MVPé«˜ä¼˜å…ˆçº§

### 12.1 è‡ªåŠ¨ä¿å­˜æœºåˆ¶è¯¦ç»†è®¾è®¡

#### 12.1.1 è®¾è®¡ç›®æ ‡

- **æ•°æ®å®‰å…¨**ï¼šé˜²æ­¢å› æµè§ˆå™¨å´©æºƒã€æ–­ç½‘ç­‰å¯¼è‡´çš„æ•°æ®ä¸¢å¤±
- **æ— æ„Ÿä¿å­˜**ï¼šåå°è‡ªåŠ¨ä¿å­˜ï¼Œä¸æ‰“æ–­ç”¨æˆ·åˆ›ä½œæµç¨‹
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘ä¸å¿…è¦çš„ä¿å­˜è¯·æ±‚ï¼Œé™ä½æœåŠ¡å™¨å‹åŠ›
- **å†²çªå¤„ç†**ï¼šå¤„ç†å¤šè®¾å¤‡ç¼–è¾‘å¯èƒ½å¯¼è‡´çš„æ•°æ®å†²çª

#### 12.1.2 è§¦å‘ç­–ç•¥

**æ—¶é—´è§¦å‘**ï¼š
```javascript
// 30ç§’æ— æ“ä½œåè‡ªåŠ¨ä¿å­˜
let autoSaveTimer = null;
const AUTO_SAVE_DELAY = 30000; // 30ç§’

function scheduleAutoSave() {
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => {
        if (isDirty()) {
            autoSave();
        }
    }, AUTO_SAVE_DELAY);
}

// ç›‘å¬ç¼–è¾‘å™¨å˜åŒ–
editor.on('change', () => {
    markDirty();
    scheduleAutoSave();
});
```

**äº‹ä»¶è§¦å‘**ï¼š
- **å¤±ç„¦è§¦å‘**ï¼šç”¨æˆ·åˆ‡æ¢æ ‡ç­¾é¡µæˆ–çª—å£æ—¶è§¦å‘ä¿å­˜
- **å…³é—­å‰ä¿å­˜**ï¼šç”¨æˆ·å…³é—­æµè§ˆå™¨å‰è§¦å‘ä¿å­˜
- **å®šæ—¶è½®è¯¢**ï¼šæ¯5åˆ†é’Ÿå¼ºåˆ¶æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦ä¿å­˜

```javascript
// å¤±ç„¦ä¿å­˜
window.addEventListener('blur', () => {
    if (isDirty()) {
        autoSave();
    }
});

// å…³é—­å‰ä¿å­˜
window.addEventListener('beforeunload', (e) => {
    if (isDirty()) {
        // åŒæ­¥ä¿å­˜
        syncSave();
        e.preventDefault();
        e.returnValue = 'æ‚¨æœ‰æœªä¿å­˜çš„æ›´æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
    }
});

// å®šæ—¶è½®è¯¢
setInterval(() => {
    if (isDirty()) {
        autoSave();
    }
}, 5 * 60 * 1000); // 5åˆ†é’Ÿ
```

#### 12.1.3 ä¿å­˜æµç¨‹

```
ç”¨æˆ·ç¼–è¾‘ â†’ æ ‡è®°ä¸ºè„æ•°æ® â†’ é˜²æŠ–å»¶è¿Ÿ â†’ æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ– 
â†’ ç”Ÿæˆå†…å®¹Hash â†’ å¯¹æ¯”ä¸Šæ¬¡Hash â†’ (æœ‰å˜åŒ–) â†’ è°ƒç”¨ä¿å­˜API 
â†’ ä¹è§‚æ›´æ–°UI â†’ åå°ä¿å­˜ â†’ ä¿å­˜æˆåŠŸ â†’ æ›´æ–°Hashå’Œæ—¶é—´æˆ³ 
â†’ æ¸…é™¤è„æ ‡è®° â†’ æ˜¾ç¤ºä¿å­˜çŠ¶æ€
```

#### 12.1.4 Serviceå±‚å®ç°

```go
// AutoSaveService
type AutoSaveService struct {
    documentRepo repository.DocumentRepository
    versionRepo  repository.VersionRepository
    redis        *redis.Client
}

// AutoSave è‡ªåŠ¨ä¿å­˜
func (s *AutoSaveService) AutoSave(ctx context.Context, req *AutoSaveRequest) (*AutoSaveResponse, error) {
    // 1. è·å–åˆ†å¸ƒå¼é”ï¼Œé˜²æ­¢å¹¶å‘ä¿å­˜
    lockKey := fmt.Sprintf("lock:autosave:%s", req.DocumentID)
    lock, err := s.redis.SetNX(ctx, lockKey, "1", 10*time.Second).Result()
    if err != nil || !lock {
        return nil, errors.NewConflictError("æ­£åœ¨ä¿å­˜ä¸­ï¼Œè¯·ç¨å")
    }
    defer s.redis.Del(ctx, lockKey)
    
    // 2. æŸ¥è¯¢å½“å‰æ–‡æ¡£ç‰ˆæœ¬
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewNotFoundError("æ–‡æ¡£ä¸å­˜åœ¨")
    }
    
    // 3. æ£€æŸ¥ç‰ˆæœ¬å·ï¼Œé˜²æ­¢è¦†ç›–æ›´æ–°
    if req.Version != "" && req.Version != doc.Version {
        return nil, errors.NewConflictError("æ–‡æ¡£å·²è¢«ä»–äººæ›´æ–°ï¼Œè¯·åˆ·æ–°åé‡è¯•")
    }
    
    // 4. è®¡ç®—å†…å®¹Hash
    contentHash := s.calculateHash(req.Content)
    
    // 5. å¯¹æ¯”Hashï¼Œå¦‚æœç›¸åŒåˆ™è·³è¿‡ä¿å­˜
    if contentHash == doc.ContentHash {
        return &AutoSaveResponse{
            Saved:     false,
            Message:   "å†…å®¹æœªå˜åŒ–",
            Version:   doc.Version,
            UpdatedAt: doc.UpdatedAt,
        }, nil
    }
    
    // 6. æ›´æ–°æ–‡æ¡£å†…å®¹
    updates := map[string]interface{}{
        "content":      req.Content,
        "content_hash": contentHash,
        "word_count":   s.calculateWordCount(req.Content),
        "updated_at":   time.Now(),
        "version":      s.generateVersion(), // ç”Ÿæˆæ–°ç‰ˆæœ¬å·
    }
    
    if err := s.documentRepo.Update(ctx, req.DocumentID, updates); err != nil {
        return nil, errors.NewInternalError("ä¿å­˜å¤±è´¥").WithCause(err)
    }
    
    // 7. åˆ›å»ºè‡ªåŠ¨ä¿å­˜ç‰ˆæœ¬ï¼ˆè½»é‡çº§ç‰ˆæœ¬ï¼Œä¸è®¡å…¥æ­£å¼ç‰ˆæœ¬ï¼‰
    s.createAutoSaveVersion(ctx, doc, req.Content)
    
    // 8. è¿”å›å“åº”
    return &AutoSaveResponse{
        Saved:     true,
        Message:   "è‡ªåŠ¨ä¿å­˜æˆåŠŸ",
        Version:   updates["version"].(string),
        UpdatedAt: updates["updated_at"].(time.Time),
    }, nil
}

// calculateHash è®¡ç®—å†…å®¹Hash
func (s *AutoSaveService) calculateHash(content string) string {
    hash := md5.Sum([]byte(content))
    return hex.EncodeToString(hash[:])
}

// calculateWordCount è®¡ç®—å­—æ•°
func (s *AutoSaveService) calculateWordCount(content string) int {
    // å»é™¤Markdownæ ‡è®°
    content = s.stripMarkdown(content)
    // ç»Ÿè®¡ä¸­æ–‡å­—ç¬¦å’Œè‹±æ–‡å•è¯
    return s.countChineseChars(content) + s.countEnglishWords(content)
}
```

#### 12.1.5 å†²çªå¤„ç†

**åœºæ™¯1ï¼šåŒä¸€ç”¨æˆ·å¤šè®¾å¤‡ç¼–è¾‘**
- **æ£€æµ‹**ï¼šé€šè¿‡ç‰ˆæœ¬å·æ£€æµ‹å†²çª
- **å¤„ç†**ï¼šæç¤ºç”¨æˆ·é€‰æ‹©ä¿ç•™å“ªä¸ªç‰ˆæœ¬ï¼Œæˆ–åˆå¹¶å†…å®¹
- **UI**ï¼šæ˜¾ç¤ºå†²çªå¯¹æ¯”ç•Œé¢ï¼Œé«˜äº®å·®å¼‚éƒ¨åˆ†

**åœºæ™¯2ï¼šä¿å­˜å¤±è´¥**
- **æ£€æµ‹**ï¼šä¿å­˜APIè¿”å›é”™è¯¯
- **å¤„ç†**ï¼šå°†å†…å®¹ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆLocalStorageï¼‰ï¼Œæç¤ºç”¨æˆ·
- **æ¢å¤**ï¼šä¸‹æ¬¡æ‰“å¼€æ—¶æ£€æŸ¥æœ¬åœ°å­˜å‚¨ï¼Œè¯¢é—®æ˜¯å¦æ¢å¤

```javascript
// ä¿å­˜å¤±è´¥æ—¶çš„æœ¬åœ°å­˜å‚¨
function saveToLocal(documentId, content) {
    const key = `autosave:${documentId}`;
    localStorage.setItem(key, JSON.stringify({
        content: content,
        timestamp: Date.now(),
        version: currentVersion
    }));
}

// é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æœ¬åœ°å­˜å‚¨
function checkLocalAutosave(documentId) {
    const key = `autosave:${documentId}`;
    const saved = localStorage.getItem(key);
    if (saved) {
        const data = JSON.parse(saved);
        // æ˜¾ç¤ºæ¢å¤æç¤º
        showRecoveryPrompt(data);
    }
}
```

#### 12.1.6 æ€§èƒ½ä¼˜åŒ–

**é˜²æŠ–å’ŒèŠ‚æµ**ï¼š
```javascript
// ä½¿ç”¨Lodashçš„é˜²æŠ–å‡½æ•°
const debouncedAutoSave = _.debounce(autoSave, 30000, {
    leading: false,
    trailing: true
});

// é™æµï¼šæœ€å¤šæ¯10ç§’ä¿å­˜ä¸€æ¬¡
const throttledAutoSave = _.throttle(autoSave, 10000, {
    leading: true,
    trailing: true
});
```

**å¢é‡ä¿å­˜**ï¼ˆæœªæ¥ä¼˜åŒ–ï¼‰ï¼š
- ä»…ä¿å­˜å˜åŒ–çš„éƒ¨åˆ†ï¼Œè€Œéæ•´ä¸ªæ–‡æ¡£
- ä½¿ç”¨diffç®—æ³•è®¡ç®—å·®å¼‚
- å‡å°‘ç½‘ç»œä¼ è¾“é‡

---

### 12.2 å¿«æ·é”®ç³»ç»Ÿè¯¦ç»†è®¾è®¡

#### 12.2.1 è®¾è®¡ç›®æ ‡

- **æå‡æ•ˆç‡**ï¼šå¸¸ç”¨æ“ä½œé€šè¿‡å¿«æ·é”®å¿«é€Ÿæ‰§è¡Œ
- **ç¬¦åˆä¹ æƒ¯**ï¼šéµå¾ªé€šç”¨ç¼–è¾‘å™¨å¿«æ·é”®çº¦å®š
- **å¯å®šåˆ¶**ï¼šæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰å¿«æ·é”®
- **å†²çªæ£€æµ‹**ï¼šé˜²æ­¢å¿«æ·é”®å†²çª

#### 12.2.2 å¿«æ·é”®åˆ—è¡¨

**ç¼–è¾‘æ“ä½œ**ï¼š
| å¿«æ·é”® | åŠŸèƒ½ | æè¿° |
|-------|-----|------|
| `Ctrl + S` / `Cmd + S` | æ‰‹åŠ¨ä¿å­˜ | ç«‹å³ä¿å­˜æ–‡æ¡£ |
| `Ctrl + Z` / `Cmd + Z` | æ’¤é”€ | æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ |
| `Ctrl + Y` / `Cmd + Shift + Z` | é‡åš | é‡åšä¸Šä¸€æ­¥æ’¤é”€çš„æ“ä½œ |
| `Ctrl + X` / `Cmd + X` | å‰ªåˆ‡ | å‰ªåˆ‡é€‰ä¸­æ–‡æœ¬ |
| `Ctrl + C` / `Cmd + C` | å¤åˆ¶ | å¤åˆ¶é€‰ä¸­æ–‡æœ¬ |
| `Ctrl + V` / `Cmd + V` | ç²˜è´´ | ç²˜è´´æ–‡æœ¬ |
| `Ctrl + A` / `Cmd + A` | å…¨é€‰ | é€‰ä¸­å…¨éƒ¨æ–‡æœ¬ |
| `Ctrl + F` / `Cmd + F` | æŸ¥æ‰¾ | æ‰“å¼€æŸ¥æ‰¾é¢æ¿ |
| `Ctrl + H` / `Cmd + H` | æ›¿æ¢ | æ‰“å¼€æŸ¥æ‰¾æ›¿æ¢é¢æ¿ |

**æ ¼å¼åŒ–æ“ä½œ**ï¼š
| å¿«æ·é”® | åŠŸèƒ½ | æè¿° |
|-------|-----|------|
| `Ctrl + B` / `Cmd + B` | åŠ ç²— | åŠ ç²—é€‰ä¸­æ–‡æœ¬ |
| `Ctrl + I` / `Cmd + I` | æ–œä½“ | æ–œä½“é€‰ä¸­æ–‡æœ¬ |
| `Ctrl + U` / `Cmd + U` | ä¸‹åˆ’çº¿ | ä¸‹åˆ’çº¿é€‰ä¸­æ–‡æœ¬ |
| `Ctrl + K` / `Cmd + K` | æ’å…¥é“¾æ¥ | æ’å…¥è¶…é“¾æ¥ |
| `Ctrl + Shift + C` | æ’å…¥ä»£ç  | æ’å…¥è¡Œå†…ä»£ç  |
| `Ctrl + Shift + K` | æ’å…¥ä»£ç å— | æ’å…¥ä»£ç å— |

**æ ‡é¢˜å’Œåˆ—è¡¨**ï¼š
| å¿«æ·é”® | åŠŸèƒ½ | æè¿° |
|-------|-----|------|
| `Ctrl + Alt + 1-6` | æ ‡é¢˜ | æ’å…¥H1-H6æ ‡é¢˜ |
| `Ctrl + Shift + O` | æœ‰åºåˆ—è¡¨ | æ’å…¥æœ‰åºåˆ—è¡¨ |
| `Ctrl + Shift + U` | æ— åºåˆ—è¡¨ | æ’å…¥æ— åºåˆ—è¡¨ |
| `Ctrl + Shift + Q` | å¼•ç”¨ | æ’å…¥å¼•ç”¨å— |

**å¯¼èˆªå’Œè§†å›¾**ï¼š
| å¿«æ·é”® | åŠŸèƒ½ | æè¿° |
|-------|-----|------|
| `Ctrl + P` / `Cmd + P` | é¢„è§ˆ | åˆ‡æ¢é¢„è§ˆæ¨¡å¼ |
| `Ctrl + \\` / `Cmd + \\` | ä¾§è¾¹æ  | æ˜¾ç¤º/éšè—ä¾§è¾¹æ  |
| `Ctrl + E` / `Cmd + E` | èšç„¦ç¼–è¾‘å™¨ | èšç„¦åˆ°ç¼–è¾‘å™¨ |
| `ESC` | é€€å‡º | é€€å‡ºå½“å‰æ¨¡å¼ |

**è‡ªå®šä¹‰æ“ä½œ**ï¼š
| å¿«æ·é”® | åŠŸèƒ½ | æè¿° |
|-------|-----|------|
| `Ctrl + /` / `Cmd + /` | å¿«æ·é”®å¸®åŠ© | æ˜¾ç¤ºå¿«æ·é”®åˆ—è¡¨ |
| `Ctrl + ,` / `Cmd + ,` | è®¾ç½® | æ‰“å¼€è®¾ç½®é¢æ¿ |

#### 12.2.3 å¿«æ·é”®ç®¡ç†å™¨å®ç°

```javascript
class ShortcutManager {
    constructor() {
        this.shortcuts = new Map();
        this.customShortcuts = this.loadCustomShortcuts();
        this.registerDefaultShortcuts();
    }
    
    // æ³¨å†Œå¿«æ·é”®
    register(key, handler, options = {}) {
        const normalizedKey = this.normalizeKey(key);
        
        // æ£€æŸ¥å†²çª
        if (this.shortcuts.has(normalizedKey) && !options.override) {
            console.warn(`å¿«æ·é”® ${key} å·²å­˜åœ¨`);
            return false;
        }
        
        this.shortcuts.set(normalizedKey, {
            handler: handler,
            description: options.description || '',
            category: options.category || 'å…¶ä»–',
            customizable: options.customizable !== false
        });
        
        return true;
    }
    
    // å¤„ç†é”®ç›˜äº‹ä»¶
    handleKeyDown(event) {
        const key = this.getKeyFromEvent(event);
        const shortcut = this.shortcuts.get(key);
        
        if (shortcut) {
            // é˜»æ­¢é»˜è®¤è¡Œä¸º
            event.preventDefault();
            event.stopPropagation();
            
            // æ‰§è¡Œå¤„ç†å‡½æ•°
            shortcut.handler(event);
            
            // è®°å½•ä½¿ç”¨ç»Ÿè®¡
            this.recordUsage(key);
        }
    }
    
    // å°†äº‹ä»¶è½¬æ¢ä¸ºå¿«æ·é”®å­—ç¬¦ä¸²
    getKeyFromEvent(event) {
        const parts = [];
        
        if (event.ctrlKey || event.metaKey) parts.push('Ctrl');
        if (event.altKey) parts.push('Alt');
        if (event.shiftKey) parts.push('Shift');
        
        // ç‰¹æ®Šé”®
        const specialKeys = {
            13: 'Enter',
            27: 'Escape',
            32: 'Space',
            // ... å…¶ä»–ç‰¹æ®Šé”®
        };
        
        const keyName = specialKeys[event.keyCode] || event.key.toUpperCase();
        parts.push(keyName);
        
        return parts.join('+');
    }
    
    // å½’ä¸€åŒ–å¿«æ·é”®ï¼ˆå…¼å®¹Macå’ŒWindowsï¼‰
    normalizeKey(key) {
        // å°† Cmd è½¬æ¢ä¸º Ctrlï¼ˆåœ¨Windowsä¸Šï¼‰
        if (!this.isMac()) {
            key = key.replace(/Cmd/g, 'Ctrl');
        }
        return key.toUpperCase();
    }
    
    // æ³¨å†Œé»˜è®¤å¿«æ·é”®
    registerDefaultShortcuts() {
        // ä¿å­˜
        this.register('Ctrl+S', (e) => {
            this.saveDocument();
        }, { description: 'æ‰‹åŠ¨ä¿å­˜', category: 'ç¼–è¾‘' });
        
        // æ’¤é”€/é‡åš
        this.register('Ctrl+Z', (e) => {
            this.undo();
        }, { description: 'æ’¤é”€', category: 'ç¼–è¾‘' });
        
        this.register('Ctrl+Y', (e) => {
            this.redo();
        }, { description: 'é‡åš', category: 'ç¼–è¾‘' });
        
        // åŠ ç²—
        this.register('Ctrl+B', (e) => {
            this.toggleBold();
        }, { description: 'åŠ ç²—', category: 'æ ¼å¼åŒ–' });
        
        // ... æ³¨å†Œå…¶ä»–å¿«æ·é”®
    }
    
    // è·å–æ‰€æœ‰å¿«æ·é”®åˆ—è¡¨ï¼ˆç”¨äºå¸®åŠ©é¢æ¿ï¼‰
    getAllShortcuts() {
        const shortcuts = [];
        for (const [key, config] of this.shortcuts.entries()) {
            shortcuts.push({
                key: key,
                description: config.description,
                category: config.category,
                customizable: config.customizable
            });
        }
        return shortcuts;
    }
    
    // è‡ªå®šä¹‰å¿«æ·é”®
    customize(oldKey, newKey) {
        const shortcut = this.shortcuts.get(oldKey);
        if (!shortcut || !shortcut.customizable) {
            return false;
        }
        
        // æ£€æŸ¥æ–°å¿«æ·é”®æ˜¯å¦å·²è¢«å ç”¨
        if (this.shortcuts.has(newKey)) {
            throw new Error('å¿«æ·é”®å·²è¢«å ç”¨');
        }
        
        // æ›´æ–°å¿«æ·é”®
        this.shortcuts.delete(oldKey);
        this.shortcuts.set(newKey, shortcut);
        
        // ä¿å­˜è‡ªå®šä¹‰é…ç½®
        this.saveCustomShortcuts();
        
        return true;
    }
    
    // æ£€æµ‹æ“ä½œç³»ç»Ÿ
    isMac() {
        return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    }
}

// åˆå§‹åŒ–å¿«æ·é”®ç®¡ç†å™¨
const shortcutManager = new ShortcutManager();

// ç›‘å¬é”®ç›˜äº‹ä»¶
document.addEventListener('keydown', (e) => {
    shortcutManager.handleKeyDown(e);
});
```

#### 12.2.4 å¿«æ·é”®å¸®åŠ©é¢æ¿

```vue
<template>
  <el-dialog title="å¿«æ·é”®å¸®åŠ©" :visible.sync="visible" width="600px">
    <el-tabs v-model="activeCategory">
      <el-tab-pane 
        v-for="category in categories" 
        :key="category" 
        :label="category" 
        :name="category"
      >
        <el-table :data="getShortcutsByCategory(category)" stripe>
          <el-table-column label="å¿«æ·é”®" width="150">
            <template slot-scope="scope">
              <el-tag type="info">{{ scope.row.key }}</el-tag>
            </template>
          </el-table-column>
          <el-table-column label="åŠŸèƒ½è¯´æ˜" prop="description" />
        </el-table>
      </el-tab-pane>
    </el-tabs>
    
    <div slot="footer">
      <el-button @click="visible = false">å…³é—­</el-button>
      <el-button type="primary" @click="openCustomize">è‡ªå®šä¹‰å¿«æ·é”®</el-button>
    </div>
  </el-dialog>
</template>
```

---

### 12.3 å­—æ•°ç»Ÿè®¡è¯¦ç»†è®¾è®¡

#### 12.3.1 è®¾è®¡ç›®æ ‡

- **å®æ—¶æ›´æ–°**ï¼šç¼–è¾‘æ—¶å®æ—¶æ˜¾ç¤ºå­—æ•°
- **å¤šç»´ç»Ÿè®¡**ï¼šå­—æ•°ã€å­—ç¬¦æ•°ã€æ®µè½æ•°ã€é˜…è¯»æ—¶é•¿
- **ç›®æ ‡è®¾ç½®**ï¼šæ”¯æŒè®¾ç½®æ¯æ—¥å­—æ•°ç›®æ ‡
- **è¿›åº¦å±•ç¤º**ï¼šå¯è§†åŒ–å±•ç¤ºå†™ä½œè¿›åº¦

#### 12.3.2 ç»Ÿè®¡ç»´åº¦

**åŸºç¡€ç»Ÿè®¡**ï¼š
- æ€»å­—æ•°ï¼ˆå»é™¤Markdownæ ‡è®°ï¼‰
- ä¸­æ–‡å­—æ•°
- è‹±æ–‡å•è¯æ•°
- å­—ç¬¦æ•°ï¼ˆå«æ ‡ç‚¹å’Œç©ºæ ¼ï¼‰
- æ®µè½æ•°
- è¡Œæ•°

**é«˜çº§ç»Ÿè®¡**ï¼š
- é¢„è®¡é˜…è¯»æ—¶é•¿ï¼ˆæŒ‰300å­—/åˆ†é’Ÿè®¡ç®—ï¼‰
- ä»Šæ—¥æ–°å¢å­—æ•°
- æœ¬å‘¨æ–°å¢å­—æ•°
- æœ¬æœˆæ–°å¢å­—æ•°

#### 12.3.3 ç»Ÿè®¡ç®—æ³•

```go
// WordCountService
type WordCountService struct{}

// CountWords ç»Ÿè®¡å­—æ•°
func (s *WordCountService) CountWords(content string) *WordCountResult {
    // 1. å»é™¤Markdownæ ‡è®°
    plainText := s.stripMarkdown(content)
    
    // 2. ç»Ÿè®¡ä¸­æ–‡å­—æ•°
    chineseCount := s.countChinese(plainText)
    
    // 3. ç»Ÿè®¡è‹±æ–‡å•è¯æ•°
    englishCount := s.countEnglish(plainText)
    
    // 4. ç»Ÿè®¡å­—ç¬¦æ•°
    charCount := len([]rune(content))
    
    // 5. ç»Ÿè®¡æ®µè½æ•°
    paragraphCount := s.countParagraphs(content)
    
    // 6. ç»Ÿè®¡è¡Œæ•°
    lineCount := strings.Count(content, "\n") + 1
    
    // 7. è®¡ç®—é˜…è¯»æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    readingTime := float64(chineseCount+englishCount) / 300.0
    
    return &WordCountResult{
        TotalWords:     chineseCount + englishCount,
        ChineseWords:   chineseCount,
        EnglishWords:   englishCount,
        Characters:     charCount,
        Paragraphs:     paragraphCount,
        Lines:          lineCount,
        ReadingTime:    readingTime,
    }
}

// stripMarkdown å»é™¤Markdownæ ‡è®°
func (s *WordCountService) stripMarkdown(content string) string {
    // å»é™¤æ ‡é¢˜æ ‡è®°
    content = regexp.MustCompile(`#{1,6}\s`).ReplaceAllString(content, "")
    
    // å»é™¤åŠ ç²—æ ‡è®°
    content = regexp.MustCompile(`\*\*(.+?)\*\*`).ReplaceAllString(content, "$1")
    
    // å»é™¤æ–œä½“æ ‡è®°
    content = regexp.MustCompile(`\*(.+?)\*`).ReplaceAllString(content, "$1")
    
    // å»é™¤é“¾æ¥æ ‡è®° [text](url)
    content = regexp.MustCompile(`\[(.+?)\]\(.+?\)`).ReplaceAllString(content, "$1")
    
    // å»é™¤å›¾ç‰‡æ ‡è®° ![alt](url)
    content = regexp.MustCompile(`!\[.+?\]\(.+?\)`).ReplaceAllString(content, "")
    
    // å»é™¤ä»£ç å—æ ‡è®°
    content = regexp.MustCompile("```[\\s\\S]*?```").ReplaceAllString(content, "")
    
    // å»é™¤è¡Œå†…ä»£ç æ ‡è®°
    content = regexp.MustCompile("`(.+?)`").ReplaceAllString(content, "$1")
    
    return content
}

// countChinese ç»Ÿè®¡ä¸­æ–‡å­—æ•°
func (s *WordCountService) countChinese(text string) int {
    count := 0
    for _, r := range text {
        // æ±‰å­—UnicodeèŒƒå›´ï¼š\u4e00-\u9fa5
        if r >= 0x4e00 && r <= 0x9fa5 {
            count++
        }
    }
    return count
}

// countEnglish ç»Ÿè®¡è‹±æ–‡å•è¯æ•°
func (s *WordCountService) countEnglish(text string) int {
    // ä½¿ç”¨æ­£åˆ™åŒ¹é…è‹±æ–‡å•è¯
    re := regexp.MustCompile(`[a-zA-Z]+`)
    matches := re.FindAllString(text, -1)
    return len(matches)
}

// countParagraphs ç»Ÿè®¡æ®µè½æ•°
func (s *WordCountService) countParagraphs(content string) int {
    // æ®µè½ä»¥åŒæ¢è¡Œåˆ†éš”
    paragraphs := strings.Split(content, "\n\n")
    count := 0
    for _, p := range paragraphs {
        if strings.TrimSpace(p) != "" {
            count++
        }
    }
    return count
}
```

#### 12.3.4 å‰ç«¯å®æ—¶ç»Ÿè®¡

```vue
<template>
  <div class="word-count-panel">
    <!-- åŸºç¡€ç»Ÿè®¡ -->
    <div class="stats-row">
      <div class="stat-item">
        <span class="label">å­—æ•°</span>
        <span class="value">{{ wordCount.totalWords }}</span>
      </div>
      <div class="stat-item">
        <span class="label">å­—ç¬¦</span>
        <span class="value">{{ wordCount.characters }}</span>
      </div>
      <div class="stat-item">
        <span class="label">æ®µè½</span>
        <span class="value">{{ wordCount.paragraphs }}</span>
      </div>
      <div class="stat-item">
        <span class="label">é¢„è®¡é˜…è¯»</span>
        <span class="value">{{ readingTime }} åˆ†é’Ÿ</span>
      </div>
    </div>
    
    <!-- ä»Šæ—¥ç›®æ ‡ -->
    <div class="daily-goal" v-if="dailyGoal > 0">
      <div class="goal-header">
        <span>ä»Šæ—¥ç›®æ ‡ï¼š{{ todayWords }} / {{ dailyGoal }} å­—</span>
        <span class="percentage">{{ goalPercentage }}%</span>
      </div>
      <el-progress 
        :percentage="goalPercentage" 
        :color="progressColor"
        :stroke-width="8"
      />
    </div>
    
    <!-- è¯¦ç»†ç»Ÿè®¡ï¼ˆå¯æŠ˜å ï¼‰ -->
    <el-collapse v-model="activeNames">
      <el-collapse-item title="è¯¦ç»†ç»Ÿè®¡" name="detail">
        <div class="detail-stats">
          <div class="stat-line">
            <span>ä¸­æ–‡å­—æ•°ï¼š</span>
            <span>{{ wordCount.chineseWords }}</span>
          </div>
          <div class="stat-line">
            <span>è‹±æ–‡å•è¯ï¼š</span>
            <span>{{ wordCount.englishWords }}</span>
          </div>
          <div class="stat-line">
            <span>ä»Šæ—¥æ–°å¢ï¼š</span>
            <span class="highlight">+{{ todayNewWords }}</span>
          </div>
          <div class="stat-line">
            <span>æœ¬å‘¨æ–°å¢ï¼š</span>
            <span>{{ weekNewWords }}</span>
          </div>
          <div class="stat-line">
            <span>æœ¬æœˆæ–°å¢ï¼š</span>
            <span>{{ monthNewWords }}</span>
          </div>
        </div>
      </el-collapse-item>
    </el-collapse>
  </div>
</template>

<script>
export default {
  data() {
    return {
      wordCount: {
        totalWords: 0,
        chineseWords: 0,
        englishWords: 0,
        characters: 0,
        paragraphs: 0,
        lines: 0
      },
      dailyGoal: 2000, // æ¯æ—¥ç›®æ ‡å­—æ•°
      todayWords: 0,
      todayNewWords: 0,
      weekNewWords: 0,
      monthNewWords: 0,
      activeNames: []
    };
  },
  
  computed: {
    readingTime() {
      return Math.ceil(this.wordCount.totalWords / 300);
    },
    
    goalPercentage() {
      if (this.dailyGoal === 0) return 0;
      return Math.min(100, Math.floor((this.todayWords / this.dailyGoal) * 100));
    },
    
    progressColor() {
      if (this.goalPercentage >= 100) return '#67c23a';
      if (this.goalPercentage >= 50) return '#409eff';
      return '#e6a23c';
    }
  },
  
  methods: {
    // æ›´æ–°å­—æ•°ç»Ÿè®¡
    updateWordCount(content) {
      // ä½¿ç”¨é˜²æŠ–ï¼Œé¿å…é¢‘ç¹è®¡ç®—
      clearTimeout(this.countTimer);
      this.countTimer = setTimeout(() => {
        this.wordCount = this.calculateWordCount(content);
      }, 500);
    },
    
    // è®¡ç®—å­—æ•°ï¼ˆå‰ç«¯ç®€åŒ–ç‰ˆï¼‰
    calculateWordCount(content) {
      const plainText = this.stripMarkdown(content);
      
      return {
        totalWords: this.countTotal(plainText),
        chineseWords: this.countChinese(plainText),
        englishWords: this.countEnglish(plainText),
        characters: content.length,
        paragraphs: this.countParagraphs(content),
        lines: content.split('\n').length
      };
    },
    
    // å»é™¤Markdownæ ‡è®°ï¼ˆç®€åŒ–ç‰ˆï¼‰
    stripMarkdown(content) {
      return content
        .replace(/#{1,6}\s/g, '')
        .replace(/\*\*(.+?)\*\*/g, '$1')
        .replace(/\*(.+?)\*/g, '$1')
        .replace(/\[(.+?)\]\(.+?\)/g, '$1')
        .replace(/!\[.+?\]\(.+?\)/g, '')
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`(.+?)`/g, '$1');
    },
    
    // ç»Ÿè®¡ä¸­æ–‡å­—æ•°
    countChinese(text) {
      const matches = text.match(/[\u4e00-\u9fa5]/g);
      return matches ? matches.length : 0;
    },
    
    // ç»Ÿè®¡è‹±æ–‡å•è¯æ•°
    countEnglish(text) {
      const matches = text.match(/[a-zA-Z]+/g);
      return matches ? matches.length : 0;
    },
    
    // ç»Ÿè®¡æ€»å­—æ•°
    countTotal(text) {
      return this.countChinese(text) + this.countEnglish(text);
    },
    
    // ç»Ÿè®¡æ®µè½æ•°
    countParagraphs(content) {
      return content.split(/\n\n+/).filter(p => p.trim()).length;
    }
  }
};
</script>
```

#### 12.3.5 æ¯æ—¥ç›®æ ‡è®¾ç½®

```vue
<template>
  <el-dialog title="è®¾ç½®æ¯æ—¥ç›®æ ‡" :visible.sync="visible" width="400px">
    <el-form :model="form" label-width="100px">
      <el-form-item label="ç›®æ ‡å­—æ•°">
        <el-input-number 
          v-model="form.dailyGoal" 
          :min="0" 
          :step="500"
        />
        <span class="unit">å­—/å¤©</span>
      </el-form-item>
      
      <el-form-item label="æé†’æ—¶é—´">
        <el-time-select
          v-model="form.reminderTime"
          placeholder="é€‰æ‹©æ—¶é—´"
          :picker-options="{
            start: '08:00',
            step: '00:30',
            end: '23:00'
          }"
        />
      </el-form-item>
      
      <el-form-item label="å¯ç”¨æé†’">
        <el-switch v-model="form.enableReminder" />
      </el-form-item>
    </el-form>
    
    <div slot="footer">
      <el-button @click="visible = false">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="saveGoal">ä¿å­˜</el-button>
    </div>
  </el-dialog>
</template>
```

---

## 13. ç›¸å…³æ–‡æ¡£

- [é¡¹ç›®ç®¡ç†ç³»ç»Ÿè®¾è®¡](./é¡¹ç›®ç®¡ç†ç³»ç»Ÿè®¾è®¡.md)
- [æ–‡æ¡£ç®¡ç†ç³»ç»Ÿè®¾è®¡](./æ–‡æ¡£ç®¡ç†ç³»ç»Ÿè®¾è®¡.md)
- [ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿè®¾è®¡](./ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿè®¾è®¡.md)
- [å†…å®¹å®¡æ ¸ç³»ç»Ÿè®¾è®¡](./å†…å®¹å®¡æ ¸ç³»ç»Ÿè®¾è®¡.md) â† æ–°å¢
- [æ•°æ®ç»Ÿè®¡ç³»ç»Ÿè®¾è®¡](./æ•°æ®ç»Ÿè®¡ç³»ç»Ÿè®¾è®¡.md) â† æ–°å¢
- [å®æ–½æ–‡æ¡£](../../implementation/04å†™ä½œç«¯æ¨¡å—/README_å†™ä½œç«¯å®æ–½æ–‡æ¡£.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1 (MVPå¢å¼ºç‰ˆ)  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-16  
**æœ€åæ›´æ–°**: 2025-10-17  
**ç»´æŠ¤è€…**: é’ç¾½å†™ä½œå›¢é˜Ÿ

