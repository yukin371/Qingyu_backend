# 编辑器系统设计文档

> **版本**: v1.0  
> **创建日期**: 2025-10-16  
> **最后更新**: 2025-10-16  
> **维护者**: 青羽写作团队

## 1. 概述

### 1.1 功能描述

编辑器系统是青羽写作平台的核心功能模块，为作者提供专业的文档编辑环境。系统支持Markdown和富文本两种编辑模式，提供自动保存、版本控制、格式转换等功能，满足不同创作场景的需求。

### 1.2 业务价值

- **提升创作体验**：提供流畅、专业的编辑环境
- **保障内容安全**：自动保存和版本控制防止内容丢失
- **支持多种格式**：Markdown和富文本双模式满足不同需求
- **增强创作效率**：快捷键、工具栏、实时预览等功能提升效率

### 1.3 用户场景

1. **小说创作**：使用Markdown编辑器快速写作，支持章节管理
2. **富文本编辑**：需要复杂格式的创作场景
3. **多设备创作**：支持不同设备间的内容同步
4. **版本管理**：查看历史版本、对比差异、恢复内容

### 1.4 功能边界

**包含功能**：
- Markdown编辑器和富文本编辑器
- 自动保存和手动保存
- 版本历史和版本对比
- 格式转换（Markdown ↔ 富文本）
- 工具栏和快捷键支持
- 图片上传和链接插入

**不包含功能**：
- 实时协作编辑（后期版本）
- 离线编辑（后期版本）
- 语音输入（后期版本）

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────┐
│         前端编辑器组件                     │
│   (v-md-editor / Quill)                 │
├─────────────────────────────────────────┤
│         Router Layer (路由层)            │
│       /api/v1/documents/*               │
├─────────────────────────────────────────┤
│         API Layer (接口层)               │
│    DocumentContentApi / VersionApi      │
├─────────────────────────────────────────┤
│        Service Layer (业务逻辑层)         │
│   DocumentContentService / VersionService│
├─────────────────────────────────────────┤
│      Repository Layer (数据访问层)        │
│  DocumentContentRepo / VersionRepo      │
├─────────────────────────────────────────┤
│        Model Layer (数据模型层)           │
│    DocumentContent / Version            │
├─────────────────────────────────────────┤
│      MongoDB / GridFS (存储层)          │
└─────────────────────────────────────────┘
```

### 2.2 模块划分

- **DocumentContentService**：文档内容管理服务
- **VersionService**：版本控制服务
- **AutoSaveService**：自动保存服务
- **FormatConverterService**：格式转换服务

### 2.3 数据流设计

```
编辑操作 → 自动保存 → 内容验证 → 数据持久化 → 版本创建 → 缓存更新
```

### 2.4 技术选型

**后端技术**：
- **Go**: 1.21+
- **Gin**: Web框架
- **MongoDB**: 内容存储（<16MB文档）
- **GridFS**: 大文档存储（≥16MB）
- **Redis**: 自动保存缓存

**前端技术**：
- **v-md-editor**: Markdown编辑器
- **Quill**: 富文本编辑器
- **diff-match-patch**: 文本差异对比
- **marked**: Markdown解析

## 3. 详细设计

### 3.1 数据模型设计

#### 3.1.1 DocumentContent模型

```go
// models/document/document_content.go
package document

import "time"

// DocumentContent 文档内容
type DocumentContent struct {
    ID           string    `bson:"_id,omitempty" json:"id"`
    DocumentID   string    `bson:"document_id" json:"documentId" validate:"required"`
    Content      string    `bson:"content" json:"content"`                    // 文档内容
    ContentType  string    `bson:"content_type" json:"contentType"`           // markdown | richtext
    WordCount    int       `bson:"word_count" json:"wordCount"`               // 字数统计
    CharCount    int       `bson:"char_count" json:"charCount"`               // 字符统计
    GridFSID     string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"` // 大文件GridFS ID
    Version      int       `bson:"version" json:"version"`                    // 版本号
    LastSavedAt  time.Time `bson:"last_saved_at" json:"lastSavedAt"`         // 最后保存时间
    LastEditedBy string    `bson:"last_edited_by" json:"lastEditedBy"`       // 最后编辑人
    UpdatedAt    time.Time `bson:"updated_at" json:"updatedAt"`
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
}

// IsLargeDocument 判断是否为大文档（>1MB）
func (d *DocumentContent) IsLargeDocument() bool {
    return len(d.Content) > 1024*1024
}

// GetDisplayWordCount 获取显示用的字数
func (d *DocumentContent) GetDisplayWordCount() int {
    if d.WordCount > 0 {
        return d.WordCount
    }
    return len([]rune(d.Content))
}
```

#### 3.1.2 Version模型

```go
// models/document/version.go
package document

import "time"

// Version 文档版本
type Version struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    DocumentID  string    `bson:"document_id" json:"documentId" validate:"required"`
    VersionNum  int       `bson:"version_num" json:"versionNum"`           // 版本号
    Content     string    `bson:"content" json:"content"`                  // 版本内容
    GridFSID    string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"`
    ContentType string    `bson:"content_type" json:"contentType"`         // 内容类型
    WordCount   int       `bson:"word_count" json:"wordCount"`             // 字数
    Comment     string    `bson:"comment,omitempty" json:"comment,omitempty"` // 版本说明
    CreatedBy   string    `bson:"created_by" json:"createdBy"`             // 创建人
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`             // 创建时间
    IsAutoSave  bool      `bson:"is_auto_save" json:"isAutoSave"`          // 是否自动保存
}

// GetVersionLabel 获取版本标签
func (v *Version) GetVersionLabel() string {
    if v.IsAutoSave {
        return fmt.Sprintf("v%d (自动保存)", v.VersionNum)
    }
    return fmt.Sprintf("v%d", v.VersionNum)
}
```

### 3.2 Repository层设计

#### 3.2.1 DocumentContentRepository接口

```go
// repository/interfaces/document/document_content_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces/infrastructure"
)

type DocumentContentRepository interface {
    // 基础CRUD操作
    Create(ctx context.Context, content *document.DocumentContent) error
    GetByDocumentID(ctx context.Context, documentID string) (*document.DocumentContent, error)
    Update(ctx context.Context, documentID string, updates map[string]interface{}) error
    Delete(ctx context.Context, documentID string) error
    
    // 内容操作
    SaveContent(ctx context.Context, documentID, content, contentType string) error
    GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error)
    
    // GridFS操作
    SaveToGridFS(ctx context.Context, documentID, content string) (string, error)
    LoadFromGridFS(ctx context.Context, gridfsID string) (string, error)
    DeleteFromGridFS(ctx context.Context, gridfsID string) error
    
    // 统计操作
    UpdateWordCount(ctx context.Context, documentID string, wordCount int) error
    
    // 健康检查
    Health(ctx context.Context) error
}
```

#### 3.2.2 VersionRepository接口

```go
// repository/interfaces/document/version_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
)

type VersionRepository interface {
    // 版本管理
    Create(ctx context.Context, version *document.Version) error
    GetByID(ctx context.Context, id string) (*document.Version, error)
    GetByDocumentID(ctx context.Context, documentID string, limit int) ([]*document.Version, error)
    GetByVersionNum(ctx context.Context, documentID string, versionNum int) (*document.Version, error)
    Delete(ctx context.Context, id string) error
    
    // 版本清理
    DeleteOldVersions(ctx context.Context, documentID string, keepDays int) error
    GetVersionCount(ctx context.Context, documentID string) (int64, error)
    
    // 健康检查
    Health(ctx context.Context) error
}
```

### 3.3 Service层设计

#### 3.3.1 DocumentContentService

```go
// service/document/document_content_service.go
package document

import (
    "context"
    "fmt"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type DocumentContentService struct {
    contentRepo  interfaces.DocumentContentRepository
    versionRepo  interfaces.VersionRepository
    documentRepo interfaces.DocumentRepository
    eventBus     base.EventBus
}

func NewDocumentContentService(
    contentRepo interfaces.DocumentContentRepository,
    versionRepo interfaces.VersionRepository,
    documentRepo interfaces.DocumentRepository,
    eventBus base.EventBus,
) *DocumentContentService {
    return &DocumentContentService{
        contentRepo:  contentRepo,
        versionRepo:  versionRepo,
        documentRepo: documentRepo,
        eventBus:     eventBus,
    }
}

// SaveContent 保存文档内容
func (s *DocumentContentService) SaveContent(ctx context.Context, req *SaveContentRequest) (*SaveContentResponse, error) {
    // 1. 验证文档权限
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewNotFoundError("文档不存在")
    }
    
    userID := ctx.Value("userID").(string)
    if !s.checkPermission(doc, userID) {
        return nil, errors.NewAuthError("无权限编辑该文档")
    }
    
    // 2. 获取当前内容
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, req.DocumentID)
    if err != nil && !errors.IsNotFound(err) {
        return nil, errors.NewInternalError("获取当前内容失败").WithCause(err)
    }
    
    // 3. 检查并发冲突（乐观锁）
    if currentContent != nil && req.Version > 0 && currentContent.Version != req.Version {
        return nil, errors.NewBusinessError("内容已被其他用户修改，请刷新后重试")
    }
    
    // 4. 计算字数
    wordCount := s.calculateWordCount(req.Content)
    charCount := len([]rune(req.Content))
    
    // 5. 判断是否使用GridFS
    var gridfsID string
    var content string
    
    if len(req.Content) > 1024*1024 { // 大于1MB使用GridFS
        gridfsID, err = s.contentRepo.SaveToGridFS(ctx, req.DocumentID, req.Content)
        if err != nil {
            return nil, errors.NewInternalError("保存大文件失败").WithCause(err)
        }
        content = "" // 内容存储在GridFS，主文档不存储
    } else {
        content = req.Content
    }
    
    // 6. 保存或更新内容
    newVersion := 1
    if currentContent != nil {
        newVersion = currentContent.Version + 1
    }
    
    updates := map[string]interface{}{
        "content":        content,
        "content_type":   req.ContentType,
        "word_count":     wordCount,
        "char_count":     charCount,
        "gridfs_id":      gridfsID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "last_edited_by": userID,
        "updated_at":     time.Now(),
    }
    
    if currentContent == nil {
        // 创建新内容
        newContent := &document.DocumentContent{
            DocumentID:   req.DocumentID,
            Content:      content,
            ContentType:  req.ContentType,
            WordCount:    wordCount,
            CharCount:    charCount,
            GridFSID:     gridfsID,
            Version:      newVersion,
            LastSavedAt:  time.Now(),
            LastEditedBy: userID,
            CreatedAt:    time.Now(),
            UpdatedAt:    time.Now(),
        }
        if err := s.contentRepo.Create(ctx, newContent); err != nil {
            return nil, errors.NewInternalError("创建内容失败").WithCause(err)
        }
    } else {
        // 更新内容
        if err := s.contentRepo.Update(ctx, req.DocumentID, updates); err != nil {
            return nil, errors.NewInternalError("更新内容失败").WithCause(err)
        }
    }
    
    // 7. 创建版本（非自动保存才创建版本）
    if !req.IsAutoSave {
        version := &document.Version{
            DocumentID:  req.DocumentID,
            VersionNum:  newVersion,
            Content:     content,
            GridFSID:    gridfsID,
            ContentType: req.ContentType,
            WordCount:   wordCount,
            Comment:     req.Comment,
            CreatedBy:   userID,
            CreatedAt:   time.Now(),
            IsAutoSave:  false,
        }
        if err := s.versionRepo.Create(ctx, version); err != nil {
            // 版本创建失败不影响主流程
            fmt.Printf("创建版本失败: %v\n", err)
        }
    }
    
    // 8. 更新文档统计
    docUpdates := map[string]interface{}{
        "word_count": wordCount,
        "updated_at": time.Now(),
    }
    s.documentRepo.Update(ctx, req.DocumentID, docUpdates)
    
    // 9. 发布事件
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.content_saved",
        EventData: map[string]interface{}{
            "document_id": req.DocumentID,
            "word_count":  wordCount,
            "version":     newVersion,
        },
        Timestamp: time.Now(),
        Source:    "DocumentContentService",
    })
    
    return &SaveContentResponse{
        DocumentID: req.DocumentID,
        Version:    newVersion,
        WordCount:  wordCount,
        SavedAt:    time.Now(),
    }, nil
}

// GetContent 获取文档内容
func (s *DocumentContentService) GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error) {
    // 1. 获取内容记录
    content, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return nil, errors.NewNotFoundError("文档内容不存在")
    }
    
    // 2. 如果使用GridFS，加载内容
    if content.GridFSID != "" {
        fullContent, err := s.contentRepo.LoadFromGridFS(ctx, content.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("加载文档内容失败").WithCause(err)
        }
        content.Content = fullContent
    }
    
    return content, nil
}

// AutoSave 自动保存
func (s *DocumentContentService) AutoSave(ctx context.Context, req *AutoSaveRequest) error {
    // 自动保存使用简化逻辑，不创建版本
    saveReq := &SaveContentRequest{
        DocumentID:  req.DocumentID,
        Content:     req.Content,
        ContentType: req.ContentType,
        Version:     req.Version,
        IsAutoSave:  true,
    }
    
    _, err := s.SaveContent(ctx, saveReq)
    return err
}

// 私有方法
func (s *DocumentContentService) calculateWordCount(content string) int {
    // 简化的字数统计，实际应该更复杂
    return len([]rune(content))
}

func (s *DocumentContentService) checkPermission(doc *document.Document, userID string) bool {
    // 检查用户是否有权限编辑文档
    // TODO: 实现完整的权限检查
    return true
}
```

#### 3.3.2 VersionService

```go
// service/document/version_service.go
package document

import (
    "context"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type VersionService struct {
    versionRepo interfaces.VersionRepository
    contentRepo interfaces.DocumentContentRepository
}

func NewVersionService(
    versionRepo interfaces.VersionRepository,
    contentRepo interfaces.DocumentContentRepository,
) *VersionService {
    return &VersionService{
        versionRepo: versionRepo,
        contentRepo: contentRepo,
    }
}

// ListVersions 获取版本历史
func (s *VersionService) ListVersions(ctx context.Context, documentID string, limit int) ([]*document.Version, error) {
    versions, err := s.versionRepo.GetByDocumentID(ctx, documentID, limit)
    if err != nil {
        return nil, errors.NewInternalError("获取版本历史失败").WithCause(err)
    }
    
    // 加载GridFS内容
    for _, version := range versions {
        if version.GridFSID != "" {
            content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
            if err != nil {
                continue // 跳过加载失败的版本
            }
            version.Content = content
        }
    }
    
    return versions, nil
}

// GetVersion 获取指定版本
func (s *VersionService) GetVersion(ctx context.Context, documentID string, versionNum int) (*document.Version, error) {
    version, err := s.versionRepo.GetByVersionNum(ctx, documentID, versionNum)
    if err != nil {
        return nil, errors.NewNotFoundError("版本不存在")
    }
    
    // 加载GridFS内容
    if version.GridFSID != "" {
        content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("加载版本内容失败").WithCause(err)
        }
        version.Content = content
    }
    
    return version, nil
}

// CompareVersions 对比两个版本
func (s *VersionService) CompareVersions(ctx context.Context, documentID string, version1, version2 int) (*VersionCompareResponse, error) {
    // 获取两个版本
    v1, err := s.GetVersion(ctx, documentID, version1)
    if err != nil {
        return nil, err
    }
    
    v2, err := s.GetVersion(ctx, documentID, version2)
    if err != nil {
        return nil, err
    }
    
    // 返回对比结果（实际diff计算在前端进行）
    return &VersionCompareResponse{
        Version1:     v1,
        Version2:     v2,
        WordCountDiff: v2.WordCount - v1.WordCount,
    }, nil
}

// RestoreVersion 恢复到指定版本
func (s *VersionService) RestoreVersion(ctx context.Context, documentID string, versionNum int) error {
    // 1. 获取指定版本
    version, err := s.GetVersion(ctx, documentID, versionNum)
    if err != nil {
        return err
    }
    
    // 2. 获取当前内容
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return errors.NewInternalError("获取当前内容失败").WithCause(err)
    }
    
    // 3. 保存恢复操作为新版本
    newVersion := currentContent.Version + 1
    
    updates := map[string]interface{}{
        "content":        version.Content,
        "content_type":   version.ContentType,
        "gridfs_id":      version.GridFSID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "updated_at":     time.Now(),
    }
    
    if err := s.contentRepo.Update(ctx, documentID, updates); err != nil {
        return errors.NewInternalError("恢复版本失败").WithCause(err)
    }
    
    // 4. 创建恢复记录版本
    restoreVersion := &document.Version{
        DocumentID:  documentID,
        VersionNum:  newVersion,
        Content:     version.Content,
        GridFSID:    version.GridFSID,
        ContentType: version.ContentType,
        WordCount:   version.WordCount,
        Comment:     fmt.Sprintf("恢复到版本 v%d", versionNum),
        CreatedBy:   ctx.Value("userID").(string),
        CreatedAt:   time.Now(),
        IsAutoSave:  false,
    }
    
    return s.versionRepo.Create(ctx, restoreVersion)
}

// CleanOldVersions 清理旧版本
func (s *VersionService) CleanOldVersions(ctx context.Context, documentID string, keepDays int) error {
    return s.versionRepo.DeleteOldVersions(ctx, documentID, keepDays)
}
```

### 3.4 API层设计

```go
// api/v1/writer/document_content_api.go
package writer

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
    "qingyu_backend/service/document"
    "qingyu_backend/pkg/response"
)

type DocumentContentApi struct {
    contentService *document.DocumentContentService
    versionService *document.VersionService
}

func NewDocumentContentApi(
    contentService *document.DocumentContentService,
    versionService *document.VersionService,
) *DocumentContentApi {
    return &DocumentContentApi{
        contentService: contentService,
        versionService: versionService,
    }
}

// GetContent 获取文档内容
func (api *DocumentContentApi) GetContent(c *gin.Context) {
    documentID := c.Param("id")
    
    content, err := api.contentService.GetContent(c.Request.Context(), documentID)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", content)
}

// SaveContent 保存文档内容
func (api *DocumentContentApi) SaveContent(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.SaveContentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    resp, err := api.contentService.SaveContent(c.Request.Context(), &req)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "保存成功", resp)
}

// AutoSave 自动保存
func (api *DocumentContentApi) AutoSave(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.AutoSaveRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    if err := api.contentService.AutoSave(c.Request.Context(), &req); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "自动保存成功", nil)
}

// GetVersions 获取版本历史
func (api *DocumentContentApi) GetVersions(c *gin.Context) {
    documentID := c.Param("id")
    limit := 30 // 默认显示最近30个版本
    
    versions, err := api.versionService.ListVersions(c.Request.Context(), documentID, limit)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", versions)
}

// GetVersion 获取指定版本
func (api *DocumentContentApi) GetVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    version, err := api.versionService.GetVersion(c.Request.Context(), documentID, versionNum)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", version)
}

// RestoreVersion 恢复版本
func (api *DocumentContentApi) RestoreVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    if err := api.versionService.RestoreVersion(c.Request.Context(), documentID, versionNum); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "恢复成功", nil)
}
```

### 3.5 Router层设计

```go
// router/writer/document_content.go
package writer

import (
    "github.com/gin-gonic/gin"
    "qingyu_backend/api/v1/writer"
    "qingyu_backend/middleware"
)

func InitDocumentContentRouter(r *gin.RouterGroup, contentApi *writer.DocumentContentApi) {
    docGroup := r.Group("/documents")
    docGroup.Use(middleware.JWTAuth())
    {
        // 内容管理
        docGroup.GET("/:id/content", contentApi.GetContent)
        docGroup.PUT("/:id/content", contentApi.SaveContent)
        docGroup.POST("/:id/autosave", contentApi.AutoSave)
        
        // 版本管理
        docGroup.GET("/:id/versions", contentApi.GetVersions)
        docGroup.GET("/:id/versions/:version", contentApi.GetVersion)
        docGroup.POST("/:id/restore/:version", contentApi.RestoreVersion)
    }
}
```

## 4. API接口设计

### 4.1 内容管理接口

#### 4.1.1 获取文档内容

```http
GET /api/v1/documents/{id}/content
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "id": "string",
    "documentId": "string",
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "charCount": 3000,
    "version": 5,
    "lastSavedAt": "2025-10-16T10:00:00Z"
  }
}
```

#### 4.1.2 保存文档内容

```http
PUT /api/v1/documents/{id}/content
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5,
  "comment": "修改了第三章"
}

Response:
{
  "code": 200,
  "message": "保存成功",
  "data": {
    "documentId": "string",
    "version": 6,
    "wordCount": 1050,
    "savedAt": "2025-10-16T10:05:00Z"
  }
}
```

#### 4.1.3 自动保存

```http
POST /api/v1/documents/{id}/autosave
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5
}

Response:
{
  "code": 200,
  "message": "自动保存成功",
  "data": null
}
```

### 4.2 版本管理接口

#### 4.2.1 获取版本历史

```http
GET /api/v1/documents/{id}/versions
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": [
    {
      "id": "string",
      "versionNum": 6,
      "wordCount": 1050,
      "comment": "修改了第三章",
      "createdBy": "user123",
      "createdAt": "2025-10-16T10:05:00Z",
      "isAutoSave": false
    }
  ]
}
```

#### 4.2.2 获取指定版本

```http
GET /api/v1/documents/{id}/versions/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "id": "string",
    "versionNum": 5,
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "createdAt": "2025-10-16T09:00:00Z"
  }
}
```

#### 4.2.3 恢复版本

```http
POST /api/v1/documents/{id}/restore/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "恢复成功",
  "data": null
}
```

## 5. 前端集成设计

### 5.1 Markdown编辑器

```vue
<template>
  <div class="editor-container">
    <v-md-editor
      v-model="content"
      height="600px"
      :disabled-menus="[]"
      @save="handleSave"
      @change="handleChange"
    >
    </v-md-editor>
    
    <div class="editor-status">
      <span>字数: {{ wordCount }}</span>
      <span>{{ saveStatus }}</span>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      content: '',
      wordCount: 0,
      saveStatus: '已保存',
      autoSaveTimer: null,
      version: 0
    }
  },
  
  mounted() {
    this.loadContent()
    this.startAutoSave()
  },
  
  methods: {
    async loadContent() {
      const res = await this.$api.getDocumentContent(this.documentId)
      this.content = res.data.content
      this.version = res.data.version
      this.wordCount = res.data.wordCount
    },
    
    async handleSave() {
      try {
        const res = await this.$api.saveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.version = res.data.version
        this.saveStatus = '已保存'
        this.$message.success('保存成功')
      } catch (error) {
        this.$message.error('保存失败')
      }
    },
    
    handleChange() {
      this.saveStatus = '未保存'
      this.wordCount = this.content.length
    },
    
    startAutoSave() {
      this.autoSaveTimer = setInterval(() => {
        if (this.saveStatus === '未保存') {
          this.autoSave()
        }
      }, 30000) // 30秒自动保存
    },
    
    async autoSave() {
      try {
        await this.$api.autoSaveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.saveStatus = '自动保存于 ' + new Date().toLocaleTimeString()
      } catch (error) {
        console.error('自动保存失败', error)
      }
    }
  },
  
  beforeUnmount() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer)
    }
  }
}
</script>
```

### 5.2 版本历史组件

```vue
<template>
  <div class="version-history">
    <el-timeline>
      <el-timeline-item
        v-for="version in versions"
        :key="version.id"
        :timestamp="formatTime(version.createdAt)"
      >
        <div class="version-item">
          <div class="version-info">
            <span class="version-num">v{{ version.versionNum }}</span>
            <span class="version-comment">{{ version.comment }}</span>
            <span class="word-count">{{ version.wordCount }}字</span>
          </div>
          <div class="version-actions">
            <el-button size="small" @click="previewVersion(version)">
              预览
            </el-button>
            <el-button size="small" @click="compareVersion(version)">
              对比
            </el-button>
            <el-button size="small" type="primary" @click="restoreVersion(version)">
              恢复
            </el-button>
          </div>
        </div>
      </el-timeline-item>
    </el-timeline>
  </div>
</template>

<script>
export default {
  data() {
    return {
      versions: []
    }
  },
  
  mounted() {
    this.loadVersions()
  },
  
  methods: {
    async loadVersions() {
      const res = await this.$api.getVersionHistory(this.documentId)
      this.versions = res.data
    },
    
    async previewVersion(version) {
      const res = await this.$api.getVersion(this.documentId, version.versionNum)
      this.$emit('preview', res.data)
    },
    
    async compareVersion(version) {
      this.$emit('compare', version)
    },
    
    async restoreVersion(version) {
      try {
        await this.$confirm('确定要恢复到此版本吗？')
        await this.$api.restoreVersion(this.documentId, version.versionNum)
        this.$message.success('恢复成功')
        this.$emit('restored')
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('恢复失败')
        }
      }
    },
    
    formatTime(time) {
      return new Date(time).toLocaleString()
    }
  }
}
</script>
```

## 6. 性能优化

### 6.1 大文档处理

- **分块加载**：文档超过1MB时使用GridFS存储
- **懒加载**：版本历史内容按需加载
- **压缩传输**：使用gzip压缩传输内容

### 6.2 自动保存优化

- **防抖动**：避免频繁保存
- **增量保存**：只保存变更的内容（后期优化）
- **本地缓存**：前端LocalStorage缓存，网络恢复后同步

### 6.3 版本控制优化

- **版本限制**：每个文档最多保留100个版本
- **定期清理**：自动清理30天前的自动保存版本
- **版本合并**：合并连续的小改动（后期优化）

## 7. 安全设计

### 7.1 权限控制

- **文档权限**：只有文档所有者和协作者可以编辑
- **版本权限**：只能查看和恢复自己的版本
- **API鉴权**：所有接口需要JWT认证

### 7.2 数据安全

- **乐观锁**：使用版本号防止并发冲突
- **内容加密**：敏感内容可选择加密存储
- **备份机制**：定期备份重要文档

### 7.3 输入验证

- **内容长度限制**：单个文档不超过10MB
- **XSS防护**：过滤恶意脚本
- **SQL注入防护**：参数化查询

## 8. 测试设计

### 8.1 单元测试

```go
func TestDocumentContentService_SaveContent(t *testing.T) {
    // 测试正常保存
    // 测试大文档保存
    // 测试并发冲突
    // 测试权限验证
}

func TestVersionService_RestoreVersion(t *testing.T) {
    // 测试版本恢复
    // 测试不存在的版本
    // 测试权限验证
}
```

### 8.2 集成测试

- API接口测试
- 数据库操作测试
- GridFS存储测试

### 8.3 性能测试

- 大文档加载性能
- 自动保存响应时间
- 版本历史查询性能
- 并发编辑测试

## 9. 监控和日志

### 9.1 监控指标

- 保存成功率
- 自动保存频率
- 文档加载时间
- GridFS使用率

### 9.2 日志记录

- 内容保存日志
- 版本创建日志
- 错误日志
- 性能日志

## 10. 风险与应对

### 10.1 数据丢失风险

**风险**：自动保存失败导致内容丢失

**应对**：
- 前端LocalStorage缓存
- 保存失败重试机制
- 定期全量备份

### 10.2 并发冲突风险

**风险**：多设备同时编辑导致内容覆盖

**应对**：
- 乐观锁版本控制
- 冲突提示和合并
- 最后编辑时间显示

### 10.3 性能风险

**风险**：大文档导致加载缓慢

**应对**：
- GridFS分块存储
- 内容压缩
- CDN加速

## 11. 实施计划

### 11.1 第一阶段（2周）

- [ ] DocumentContent和Version模型设计
- [ ] Repository层实现
- [ ] Service层基础功能

### 11.2 第二阶段（2周）

- [ ] API接口开发
- [ ] 前端Markdown编辑器集成
- [ ] 自动保存功能

### 11.3 第三阶段（1周）

- [ ] 版本控制功能
- [ ] GridFS大文档支持
- [ ] 富文本编辑器集成

### 11.4 第四阶段（1周）

- [ ] 性能优化
- [ ] 测试和BUG修复
- [ ] 文档和部署

## 12. MVP功能增强设计

> **更新日期**: 2025-10-17  
> **优先级**: 🔥 MVP高优先级

### 12.1 自动保存机制详细设计

#### 12.1.1 设计目标

- **数据安全**：防止因浏览器崩溃、断网等导致的数据丢失
- **无感保存**：后台自动保存，不打断用户创作流程
- **性能优化**：减少不必要的保存请求，降低服务器压力
- **冲突处理**：处理多设备编辑可能导致的数据冲突

#### 12.1.2 触发策略

**时间触发**：
```javascript
// 30秒无操作后自动保存
let autoSaveTimer = null;
const AUTO_SAVE_DELAY = 30000; // 30秒

function scheduleAutoSave() {
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => {
        if (isDirty()) {
            autoSave();
        }
    }, AUTO_SAVE_DELAY);
}

// 监听编辑器变化
editor.on('change', () => {
    markDirty();
    scheduleAutoSave();
});
```

**事件触发**：
- **失焦触发**：用户切换标签页或窗口时触发保存
- **关闭前保存**：用户关闭浏览器前触发保存
- **定时轮询**：每5分钟强制检查一次是否需要保存

```javascript
// 失焦保存
window.addEventListener('blur', () => {
    if (isDirty()) {
        autoSave();
    }
});

// 关闭前保存
window.addEventListener('beforeunload', (e) => {
    if (isDirty()) {
        // 同步保存
        syncSave();
        e.preventDefault();
        e.returnValue = '您有未保存的更改，确定要离开吗？';
    }
});

// 定时轮询
setInterval(() => {
    if (isDirty()) {
        autoSave();
    }
}, 5 * 60 * 1000); // 5分钟
```

#### 12.1.3 保存流程

```
用户编辑 → 标记为脏数据 → 防抖延迟 → 检查是否有变化 
→ 生成内容Hash → 对比上次Hash → (有变化) → 调用保存API 
→ 乐观更新UI → 后台保存 → 保存成功 → 更新Hash和时间戳 
→ 清除脏标记 → 显示保存状态
```

#### 12.1.4 Service层实现

```go
// AutoSaveService
type AutoSaveService struct {
    documentRepo repository.DocumentRepository
    versionRepo  repository.VersionRepository
    redis        *redis.Client
}

// AutoSave 自动保存
func (s *AutoSaveService) AutoSave(ctx context.Context, req *AutoSaveRequest) (*AutoSaveResponse, error) {
    // 1. 获取分布式锁，防止并发保存
    lockKey := fmt.Sprintf("lock:autosave:%s", req.DocumentID)
    lock, err := s.redis.SetNX(ctx, lockKey, "1", 10*time.Second).Result()
    if err != nil || !lock {
        return nil, errors.NewConflictError("正在保存中，请稍后")
    }
    defer s.redis.Del(ctx, lockKey)
    
    // 2. 查询当前文档版本
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewNotFoundError("文档不存在")
    }
    
    // 3. 检查版本号，防止覆盖更新
    if req.Version != "" && req.Version != doc.Version {
        return nil, errors.NewConflictError("文档已被他人更新，请刷新后重试")
    }
    
    // 4. 计算内容Hash
    contentHash := s.calculateHash(req.Content)
    
    // 5. 对比Hash，如果相同则跳过保存
    if contentHash == doc.ContentHash {
        return &AutoSaveResponse{
            Saved:     false,
            Message:   "内容未变化",
            Version:   doc.Version,
            UpdatedAt: doc.UpdatedAt,
        }, nil
    }
    
    // 6. 更新文档内容
    updates := map[string]interface{}{
        "content":      req.Content,
        "content_hash": contentHash,
        "word_count":   s.calculateWordCount(req.Content),
        "updated_at":   time.Now(),
        "version":      s.generateVersion(), // 生成新版本号
    }
    
    if err := s.documentRepo.Update(ctx, req.DocumentID, updates); err != nil {
        return nil, errors.NewInternalError("保存失败").WithCause(err)
    }
    
    // 7. 创建自动保存版本（轻量级版本，不计入正式版本）
    s.createAutoSaveVersion(ctx, doc, req.Content)
    
    // 8. 返回响应
    return &AutoSaveResponse{
        Saved:     true,
        Message:   "自动保存成功",
        Version:   updates["version"].(string),
        UpdatedAt: updates["updated_at"].(time.Time),
    }, nil
}

// calculateHash 计算内容Hash
func (s *AutoSaveService) calculateHash(content string) string {
    hash := md5.Sum([]byte(content))
    return hex.EncodeToString(hash[:])
}

// calculateWordCount 计算字数
func (s *AutoSaveService) calculateWordCount(content string) int {
    // 去除Markdown标记
    content = s.stripMarkdown(content)
    // 统计中文字符和英文单词
    return s.countChineseChars(content) + s.countEnglishWords(content)
}
```

#### 12.1.5 冲突处理

**场景1：同一用户多设备编辑**
- **检测**：通过版本号检测冲突
- **处理**：提示用户选择保留哪个版本，或合并内容
- **UI**：显示冲突对比界面，高亮差异部分

**场景2：保存失败**
- **检测**：保存API返回错误
- **处理**：将内容保存到本地存储（LocalStorage），提示用户
- **恢复**：下次打开时检查本地存储，询问是否恢复

```javascript
// 保存失败时的本地存储
function saveToLocal(documentId, content) {
    const key = `autosave:${documentId}`;
    localStorage.setItem(key, JSON.stringify({
        content: content,
        timestamp: Date.now(),
        version: currentVersion
    }));
}

// 页面加载时检查本地存储
function checkLocalAutosave(documentId) {
    const key = `autosave:${documentId}`;
    const saved = localStorage.getItem(key);
    if (saved) {
        const data = JSON.parse(saved);
        // 显示恢复提示
        showRecoveryPrompt(data);
    }
}
```

#### 12.1.6 性能优化

**防抖和节流**：
```javascript
// 使用Lodash的防抖函数
const debouncedAutoSave = _.debounce(autoSave, 30000, {
    leading: false,
    trailing: true
});

// 限流：最多每10秒保存一次
const throttledAutoSave = _.throttle(autoSave, 10000, {
    leading: true,
    trailing: true
});
```

**增量保存**（未来优化）：
- 仅保存变化的部分，而非整个文档
- 使用diff算法计算差异
- 减少网络传输量

---

### 12.2 快捷键系统详细设计

#### 12.2.1 设计目标

- **提升效率**：常用操作通过快捷键快速执行
- **符合习惯**：遵循通用编辑器快捷键约定
- **可定制**：支持用户自定义快捷键
- **冲突检测**：防止快捷键冲突

#### 12.2.2 快捷键列表

**编辑操作**：
| 快捷键 | 功能 | 描述 |
|-------|-----|------|
| `Ctrl + S` / `Cmd + S` | 手动保存 | 立即保存文档 |
| `Ctrl + Z` / `Cmd + Z` | 撤销 | 撤销上一步操作 |
| `Ctrl + Y` / `Cmd + Shift + Z` | 重做 | 重做上一步撤销的操作 |
| `Ctrl + X` / `Cmd + X` | 剪切 | 剪切选中文本 |
| `Ctrl + C` / `Cmd + C` | 复制 | 复制选中文本 |
| `Ctrl + V` / `Cmd + V` | 粘贴 | 粘贴文本 |
| `Ctrl + A` / `Cmd + A` | 全选 | 选中全部文本 |
| `Ctrl + F` / `Cmd + F` | 查找 | 打开查找面板 |
| `Ctrl + H` / `Cmd + H` | 替换 | 打开查找替换面板 |

**格式化操作**：
| 快捷键 | 功能 | 描述 |
|-------|-----|------|
| `Ctrl + B` / `Cmd + B` | 加粗 | 加粗选中文本 |
| `Ctrl + I` / `Cmd + I` | 斜体 | 斜体选中文本 |
| `Ctrl + U` / `Cmd + U` | 下划线 | 下划线选中文本 |
| `Ctrl + K` / `Cmd + K` | 插入链接 | 插入超链接 |
| `Ctrl + Shift + C` | 插入代码 | 插入行内代码 |
| `Ctrl + Shift + K` | 插入代码块 | 插入代码块 |

**标题和列表**：
| 快捷键 | 功能 | 描述 |
|-------|-----|------|
| `Ctrl + Alt + 1-6` | 标题 | 插入H1-H6标题 |
| `Ctrl + Shift + O` | 有序列表 | 插入有序列表 |
| `Ctrl + Shift + U` | 无序列表 | 插入无序列表 |
| `Ctrl + Shift + Q` | 引用 | 插入引用块 |

**导航和视图**：
| 快捷键 | 功能 | 描述 |
|-------|-----|------|
| `Ctrl + P` / `Cmd + P` | 预览 | 切换预览模式 |
| `Ctrl + \\` / `Cmd + \\` | 侧边栏 | 显示/隐藏侧边栏 |
| `Ctrl + E` / `Cmd + E` | 聚焦编辑器 | 聚焦到编辑器 |
| `ESC` | 退出 | 退出当前模式 |

**自定义操作**：
| 快捷键 | 功能 | 描述 |
|-------|-----|------|
| `Ctrl + /` / `Cmd + /` | 快捷键帮助 | 显示快捷键列表 |
| `Ctrl + ,` / `Cmd + ,` | 设置 | 打开设置面板 |

#### 12.2.3 快捷键管理器实现

```javascript
class ShortcutManager {
    constructor() {
        this.shortcuts = new Map();
        this.customShortcuts = this.loadCustomShortcuts();
        this.registerDefaultShortcuts();
    }
    
    // 注册快捷键
    register(key, handler, options = {}) {
        const normalizedKey = this.normalizeKey(key);
        
        // 检查冲突
        if (this.shortcuts.has(normalizedKey) && !options.override) {
            console.warn(`快捷键 ${key} 已存在`);
            return false;
        }
        
        this.shortcuts.set(normalizedKey, {
            handler: handler,
            description: options.description || '',
            category: options.category || '其他',
            customizable: options.customizable !== false
        });
        
        return true;
    }
    
    // 处理键盘事件
    handleKeyDown(event) {
        const key = this.getKeyFromEvent(event);
        const shortcut = this.shortcuts.get(key);
        
        if (shortcut) {
            // 阻止默认行为
            event.preventDefault();
            event.stopPropagation();
            
            // 执行处理函数
            shortcut.handler(event);
            
            // 记录使用统计
            this.recordUsage(key);
        }
    }
    
    // 将事件转换为快捷键字符串
    getKeyFromEvent(event) {
        const parts = [];
        
        if (event.ctrlKey || event.metaKey) parts.push('Ctrl');
        if (event.altKey) parts.push('Alt');
        if (event.shiftKey) parts.push('Shift');
        
        // 特殊键
        const specialKeys = {
            13: 'Enter',
            27: 'Escape',
            32: 'Space',
            // ... 其他特殊键
        };
        
        const keyName = specialKeys[event.keyCode] || event.key.toUpperCase();
        parts.push(keyName);
        
        return parts.join('+');
    }
    
    // 归一化快捷键（兼容Mac和Windows）
    normalizeKey(key) {
        // 将 Cmd 转换为 Ctrl（在Windows上）
        if (!this.isMac()) {
            key = key.replace(/Cmd/g, 'Ctrl');
        }
        return key.toUpperCase();
    }
    
    // 注册默认快捷键
    registerDefaultShortcuts() {
        // 保存
        this.register('Ctrl+S', (e) => {
            this.saveDocument();
        }, { description: '手动保存', category: '编辑' });
        
        // 撤销/重做
        this.register('Ctrl+Z', (e) => {
            this.undo();
        }, { description: '撤销', category: '编辑' });
        
        this.register('Ctrl+Y', (e) => {
            this.redo();
        }, { description: '重做', category: '编辑' });
        
        // 加粗
        this.register('Ctrl+B', (e) => {
            this.toggleBold();
        }, { description: '加粗', category: '格式化' });
        
        // ... 注册其他快捷键
    }
    
    // 获取所有快捷键列表（用于帮助面板）
    getAllShortcuts() {
        const shortcuts = [];
        for (const [key, config] of this.shortcuts.entries()) {
            shortcuts.push({
                key: key,
                description: config.description,
                category: config.category,
                customizable: config.customizable
            });
        }
        return shortcuts;
    }
    
    // 自定义快捷键
    customize(oldKey, newKey) {
        const shortcut = this.shortcuts.get(oldKey);
        if (!shortcut || !shortcut.customizable) {
            return false;
        }
        
        // 检查新快捷键是否已被占用
        if (this.shortcuts.has(newKey)) {
            throw new Error('快捷键已被占用');
        }
        
        // 更新快捷键
        this.shortcuts.delete(oldKey);
        this.shortcuts.set(newKey, shortcut);
        
        // 保存自定义配置
        this.saveCustomShortcuts();
        
        return true;
    }
    
    // 检测操作系统
    isMac() {
        return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    }
}

// 初始化快捷键管理器
const shortcutManager = new ShortcutManager();

// 监听键盘事件
document.addEventListener('keydown', (e) => {
    shortcutManager.handleKeyDown(e);
});
```

#### 12.2.4 快捷键帮助面板

```vue
<template>
  <el-dialog title="快捷键帮助" :visible.sync="visible" width="600px">
    <el-tabs v-model="activeCategory">
      <el-tab-pane 
        v-for="category in categories" 
        :key="category" 
        :label="category" 
        :name="category"
      >
        <el-table :data="getShortcutsByCategory(category)" stripe>
          <el-table-column label="快捷键" width="150">
            <template slot-scope="scope">
              <el-tag type="info">{{ scope.row.key }}</el-tag>
            </template>
          </el-table-column>
          <el-table-column label="功能说明" prop="description" />
        </el-table>
      </el-tab-pane>
    </el-tabs>
    
    <div slot="footer">
      <el-button @click="visible = false">关闭</el-button>
      <el-button type="primary" @click="openCustomize">自定义快捷键</el-button>
    </div>
  </el-dialog>
</template>
```

---

### 12.3 字数统计详细设计

#### 12.3.1 设计目标

- **实时更新**：编辑时实时显示字数
- **多维统计**：字数、字符数、段落数、阅读时长
- **目标设置**：支持设置每日字数目标
- **进度展示**：可视化展示写作进度

#### 12.3.2 统计维度

**基础统计**：
- 总字数（去除Markdown标记）
- 中文字数
- 英文单词数
- 字符数（含标点和空格）
- 段落数
- 行数

**高级统计**：
- 预计阅读时长（按300字/分钟计算）
- 今日新增字数
- 本周新增字数
- 本月新增字数

#### 12.3.3 统计算法

```go
// WordCountService
type WordCountService struct{}

// CountWords 统计字数
func (s *WordCountService) CountWords(content string) *WordCountResult {
    // 1. 去除Markdown标记
    plainText := s.stripMarkdown(content)
    
    // 2. 统计中文字数
    chineseCount := s.countChinese(plainText)
    
    // 3. 统计英文单词数
    englishCount := s.countEnglish(plainText)
    
    // 4. 统计字符数
    charCount := len([]rune(content))
    
    // 5. 统计段落数
    paragraphCount := s.countParagraphs(content)
    
    // 6. 统计行数
    lineCount := strings.Count(content, "\n") + 1
    
    // 7. 计算阅读时长（分钟）
    readingTime := float64(chineseCount+englishCount) / 300.0
    
    return &WordCountResult{
        TotalWords:     chineseCount + englishCount,
        ChineseWords:   chineseCount,
        EnglishWords:   englishCount,
        Characters:     charCount,
        Paragraphs:     paragraphCount,
        Lines:          lineCount,
        ReadingTime:    readingTime,
    }
}

// stripMarkdown 去除Markdown标记
func (s *WordCountService) stripMarkdown(content string) string {
    // 去除标题标记
    content = regexp.MustCompile(`#{1,6}\s`).ReplaceAllString(content, "")
    
    // 去除加粗标记
    content = regexp.MustCompile(`\*\*(.+?)\*\*`).ReplaceAllString(content, "$1")
    
    // 去除斜体标记
    content = regexp.MustCompile(`\*(.+?)\*`).ReplaceAllString(content, "$1")
    
    // 去除链接标记 [text](url)
    content = regexp.MustCompile(`\[(.+?)\]\(.+?\)`).ReplaceAllString(content, "$1")
    
    // 去除图片标记 ![alt](url)
    content = regexp.MustCompile(`!\[.+?\]\(.+?\)`).ReplaceAllString(content, "")
    
    // 去除代码块标记
    content = regexp.MustCompile("```[\\s\\S]*?```").ReplaceAllString(content, "")
    
    // 去除行内代码标记
    content = regexp.MustCompile("`(.+?)`").ReplaceAllString(content, "$1")
    
    return content
}

// countChinese 统计中文字数
func (s *WordCountService) countChinese(text string) int {
    count := 0
    for _, r := range text {
        // 汉字Unicode范围：\u4e00-\u9fa5
        if r >= 0x4e00 && r <= 0x9fa5 {
            count++
        }
    }
    return count
}

// countEnglish 统计英文单词数
func (s *WordCountService) countEnglish(text string) int {
    // 使用正则匹配英文单词
    re := regexp.MustCompile(`[a-zA-Z]+`)
    matches := re.FindAllString(text, -1)
    return len(matches)
}

// countParagraphs 统计段落数
func (s *WordCountService) countParagraphs(content string) int {
    // 段落以双换行分隔
    paragraphs := strings.Split(content, "\n\n")
    count := 0
    for _, p := range paragraphs {
        if strings.TrimSpace(p) != "" {
            count++
        }
    }
    return count
}
```

#### 12.3.4 前端实时统计

```vue
<template>
  <div class="word-count-panel">
    <!-- 基础统计 -->
    <div class="stats-row">
      <div class="stat-item">
        <span class="label">字数</span>
        <span class="value">{{ wordCount.totalWords }}</span>
      </div>
      <div class="stat-item">
        <span class="label">字符</span>
        <span class="value">{{ wordCount.characters }}</span>
      </div>
      <div class="stat-item">
        <span class="label">段落</span>
        <span class="value">{{ wordCount.paragraphs }}</span>
      </div>
      <div class="stat-item">
        <span class="label">预计阅读</span>
        <span class="value">{{ readingTime }} 分钟</span>
      </div>
    </div>
    
    <!-- 今日目标 -->
    <div class="daily-goal" v-if="dailyGoal > 0">
      <div class="goal-header">
        <span>今日目标：{{ todayWords }} / {{ dailyGoal }} 字</span>
        <span class="percentage">{{ goalPercentage }}%</span>
      </div>
      <el-progress 
        :percentage="goalPercentage" 
        :color="progressColor"
        :stroke-width="8"
      />
    </div>
    
    <!-- 详细统计（可折叠） -->
    <el-collapse v-model="activeNames">
      <el-collapse-item title="详细统计" name="detail">
        <div class="detail-stats">
          <div class="stat-line">
            <span>中文字数：</span>
            <span>{{ wordCount.chineseWords }}</span>
          </div>
          <div class="stat-line">
            <span>英文单词：</span>
            <span>{{ wordCount.englishWords }}</span>
          </div>
          <div class="stat-line">
            <span>今日新增：</span>
            <span class="highlight">+{{ todayNewWords }}</span>
          </div>
          <div class="stat-line">
            <span>本周新增：</span>
            <span>{{ weekNewWords }}</span>
          </div>
          <div class="stat-line">
            <span>本月新增：</span>
            <span>{{ monthNewWords }}</span>
          </div>
        </div>
      </el-collapse-item>
    </el-collapse>
  </div>
</template>

<script>
export default {
  data() {
    return {
      wordCount: {
        totalWords: 0,
        chineseWords: 0,
        englishWords: 0,
        characters: 0,
        paragraphs: 0,
        lines: 0
      },
      dailyGoal: 2000, // 每日目标字数
      todayWords: 0,
      todayNewWords: 0,
      weekNewWords: 0,
      monthNewWords: 0,
      activeNames: []
    };
  },
  
  computed: {
    readingTime() {
      return Math.ceil(this.wordCount.totalWords / 300);
    },
    
    goalPercentage() {
      if (this.dailyGoal === 0) return 0;
      return Math.min(100, Math.floor((this.todayWords / this.dailyGoal) * 100));
    },
    
    progressColor() {
      if (this.goalPercentage >= 100) return '#67c23a';
      if (this.goalPercentage >= 50) return '#409eff';
      return '#e6a23c';
    }
  },
  
  methods: {
    // 更新字数统计
    updateWordCount(content) {
      // 使用防抖，避免频繁计算
      clearTimeout(this.countTimer);
      this.countTimer = setTimeout(() => {
        this.wordCount = this.calculateWordCount(content);
      }, 500);
    },
    
    // 计算字数（前端简化版）
    calculateWordCount(content) {
      const plainText = this.stripMarkdown(content);
      
      return {
        totalWords: this.countTotal(plainText),
        chineseWords: this.countChinese(plainText),
        englishWords: this.countEnglish(plainText),
        characters: content.length,
        paragraphs: this.countParagraphs(content),
        lines: content.split('\n').length
      };
    },
    
    // 去除Markdown标记（简化版）
    stripMarkdown(content) {
      return content
        .replace(/#{1,6}\s/g, '')
        .replace(/\*\*(.+?)\*\*/g, '$1')
        .replace(/\*(.+?)\*/g, '$1')
        .replace(/\[(.+?)\]\(.+?\)/g, '$1')
        .replace(/!\[.+?\]\(.+?\)/g, '')
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`(.+?)`/g, '$1');
    },
    
    // 统计中文字数
    countChinese(text) {
      const matches = text.match(/[\u4e00-\u9fa5]/g);
      return matches ? matches.length : 0;
    },
    
    // 统计英文单词数
    countEnglish(text) {
      const matches = text.match(/[a-zA-Z]+/g);
      return matches ? matches.length : 0;
    },
    
    // 统计总字数
    countTotal(text) {
      return this.countChinese(text) + this.countEnglish(text);
    },
    
    // 统计段落数
    countParagraphs(content) {
      return content.split(/\n\n+/).filter(p => p.trim()).length;
    }
  }
};
</script>
```

#### 12.3.5 每日目标设置

```vue
<template>
  <el-dialog title="设置每日目标" :visible.sync="visible" width="400px">
    <el-form :model="form" label-width="100px">
      <el-form-item label="目标字数">
        <el-input-number 
          v-model="form.dailyGoal" 
          :min="0" 
          :step="500"
        />
        <span class="unit">字/天</span>
      </el-form-item>
      
      <el-form-item label="提醒时间">
        <el-time-select
          v-model="form.reminderTime"
          placeholder="选择时间"
          :picker-options="{
            start: '08:00',
            step: '00:30',
            end: '23:00'
          }"
        />
      </el-form-item>
      
      <el-form-item label="启用提醒">
        <el-switch v-model="form.enableReminder" />
      </el-form-item>
    </el-form>
    
    <div slot="footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="saveGoal">保存</el-button>
    </div>
  </el-dialog>
</template>
```

---

## 13. 相关文档

- [项目管理系统设计](./项目管理系统设计.md)
- [文档管理系统设计](./文档管理系统设计.md)
- [版本控制系统设计](./版本控制系统设计.md)
- [内容审核系统设计](./内容审核系统设计.md) ← 新增
- [数据统计系统设计](./数据统计系统设计.md) ← 新增
- [实施文档](../../implementation/04写作端模块/README_写作端实施文档.md)

---

**文档版本**: v1.1 (MVP增强版)  
**创建日期**: 2025-10-16  
**最后更新**: 2025-10-17  
**维护者**: 青羽写作团队

