# 编辑器系统设计文档

> **版本**: v1.0  
> **创建日期**: 2025-10-16  
> **最后更新**: 2025-10-16  
> **维护者**: 青羽写作团队

## 1. 概述

### 1.1 功能描述

编辑器系统是青羽写作平台的核心功能模块，为作者提供专业的文档编辑环境。系统支持Markdown和富文本两种编辑模式，提供自动保存、版本控制、格式转换等功能，满足不同创作场景的需求。

### 1.2 业务价值

- **提升创作体验**：提供流畅、专业的编辑环境
- **保障内容安全**：自动保存和版本控制防止内容丢失
- **支持多种格式**：Markdown和富文本双模式满足不同需求
- **增强创作效率**：快捷键、工具栏、实时预览等功能提升效率

### 1.3 用户场景

1. **小说创作**：使用Markdown编辑器快速写作，支持章节管理
2. **富文本编辑**：需要复杂格式的创作场景
3. **多设备创作**：支持不同设备间的内容同步
4. **版本管理**：查看历史版本、对比差异、恢复内容

### 1.4 功能边界

**包含功能**：
- Markdown编辑器和富文本编辑器
- 自动保存和手动保存
- 版本历史和版本对比
- 格式转换（Markdown ↔ 富文本）
- 工具栏和快捷键支持
- 图片上传和链接插入

**不包含功能**：
- 实时协作编辑（后期版本）
- 离线编辑（后期版本）
- 语音输入（后期版本）

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────┐
│         前端编辑器组件                     │
│   (v-md-editor / Quill)                 │
├─────────────────────────────────────────┤
│         Router Layer (路由层)            │
│       /api/v1/documents/*               │
├─────────────────────────────────────────┤
│         API Layer (接口层)               │
│    DocumentContentApi / VersionApi      │
├─────────────────────────────────────────┤
│        Service Layer (业务逻辑层)         │
│   DocumentContentService / VersionService│
├─────────────────────────────────────────┤
│      Repository Layer (数据访问层)        │
│  DocumentContentRepo / VersionRepo      │
├─────────────────────────────────────────┤
│        Model Layer (数据模型层)           │
│    DocumentContent / Version            │
├─────────────────────────────────────────┤
│      MongoDB / GridFS (存储层)          │
└─────────────────────────────────────────┘
```

### 2.2 模块划分

- **DocumentContentService**：文档内容管理服务
- **VersionService**：版本控制服务
- **AutoSaveService**：自动保存服务
- **FormatConverterService**：格式转换服务

### 2.3 数据流设计

```
编辑操作 → 自动保存 → 内容验证 → 数据持久化 → 版本创建 → 缓存更新
```

### 2.4 技术选型

**后端技术**：
- **Go**: 1.21+
- **Gin**: Web框架
- **MongoDB**: 内容存储（<16MB文档）
- **GridFS**: 大文档存储（≥16MB）
- **Redis**: 自动保存缓存

**前端技术**：
- **v-md-editor**: Markdown编辑器
- **Quill**: 富文本编辑器
- **diff-match-patch**: 文本差异对比
- **marked**: Markdown解析

## 3. 详细设计

### 3.1 数据模型设计

#### 3.1.1 DocumentContent模型

```go
// models/document/document_content.go
package document

import "time"

// DocumentContent 文档内容
type DocumentContent struct {
    ID           string    `bson:"_id,omitempty" json:"id"`
    DocumentID   string    `bson:"document_id" json:"documentId" validate:"required"`
    Content      string    `bson:"content" json:"content"`                    // 文档内容
    ContentType  string    `bson:"content_type" json:"contentType"`           // markdown | richtext
    WordCount    int       `bson:"word_count" json:"wordCount"`               // 字数统计
    CharCount    int       `bson:"char_count" json:"charCount"`               // 字符统计
    GridFSID     string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"` // 大文件GridFS ID
    Version      int       `bson:"version" json:"version"`                    // 版本号
    LastSavedAt  time.Time `bson:"last_saved_at" json:"lastSavedAt"`         // 最后保存时间
    LastEditedBy string    `bson:"last_edited_by" json:"lastEditedBy"`       // 最后编辑人
    UpdatedAt    time.Time `bson:"updated_at" json:"updatedAt"`
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
}

// IsLargeDocument 判断是否为大文档（>1MB）
func (d *DocumentContent) IsLargeDocument() bool {
    return len(d.Content) > 1024*1024
}

// GetDisplayWordCount 获取显示用的字数
func (d *DocumentContent) GetDisplayWordCount() int {
    if d.WordCount > 0 {
        return d.WordCount
    }
    return len([]rune(d.Content))
}
```

#### 3.1.2 Version模型

```go
// models/document/version.go
package document

import "time"

// Version 文档版本
type Version struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    DocumentID  string    `bson:"document_id" json:"documentId" validate:"required"`
    VersionNum  int       `bson:"version_num" json:"versionNum"`           // 版本号
    Content     string    `bson:"content" json:"content"`                  // 版本内容
    GridFSID    string    `bson:"gridfs_id,omitempty" json:"gridfsId,omitempty"`
    ContentType string    `bson:"content_type" json:"contentType"`         // 内容类型
    WordCount   int       `bson:"word_count" json:"wordCount"`             // 字数
    Comment     string    `bson:"comment,omitempty" json:"comment,omitempty"` // 版本说明
    CreatedBy   string    `bson:"created_by" json:"createdBy"`             // 创建人
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`             // 创建时间
    IsAutoSave  bool      `bson:"is_auto_save" json:"isAutoSave"`          // 是否自动保存
}

// GetVersionLabel 获取版本标签
func (v *Version) GetVersionLabel() string {
    if v.IsAutoSave {
        return fmt.Sprintf("v%d (自动保存)", v.VersionNum)
    }
    return fmt.Sprintf("v%d", v.VersionNum)
}
```

### 3.2 Repository层设计

#### 3.2.1 DocumentContentRepository接口

```go
// repository/interfaces/document/document_content_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces/infrastructure"
)

type DocumentContentRepository interface {
    // 基础CRUD操作
    Create(ctx context.Context, content *document.DocumentContent) error
    GetByDocumentID(ctx context.Context, documentID string) (*document.DocumentContent, error)
    Update(ctx context.Context, documentID string, updates map[string]interface{}) error
    Delete(ctx context.Context, documentID string) error
    
    // 内容操作
    SaveContent(ctx context.Context, documentID, content, contentType string) error
    GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error)
    
    // GridFS操作
    SaveToGridFS(ctx context.Context, documentID, content string) (string, error)
    LoadFromGridFS(ctx context.Context, gridfsID string) (string, error)
    DeleteFromGridFS(ctx context.Context, gridfsID string) error
    
    // 统计操作
    UpdateWordCount(ctx context.Context, documentID string, wordCount int) error
    
    // 健康检查
    Health(ctx context.Context) error
}
```

#### 3.2.2 VersionRepository接口

```go
// repository/interfaces/document/version_repository.go
package document

import (
    "context"
    "qingyu_backend/models/document"
)

type VersionRepository interface {
    // 版本管理
    Create(ctx context.Context, version *document.Version) error
    GetByID(ctx context.Context, id string) (*document.Version, error)
    GetByDocumentID(ctx context.Context, documentID string, limit int) ([]*document.Version, error)
    GetByVersionNum(ctx context.Context, documentID string, versionNum int) (*document.Version, error)
    Delete(ctx context.Context, id string) error
    
    // 版本清理
    DeleteOldVersions(ctx context.Context, documentID string, keepDays int) error
    GetVersionCount(ctx context.Context, documentID string) (int64, error)
    
    // 健康检查
    Health(ctx context.Context) error
}
```

### 3.3 Service层设计

#### 3.3.1 DocumentContentService

```go
// service/document/document_content_service.go
package document

import (
    "context"
    "fmt"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type DocumentContentService struct {
    contentRepo  interfaces.DocumentContentRepository
    versionRepo  interfaces.VersionRepository
    documentRepo interfaces.DocumentRepository
    eventBus     base.EventBus
}

func NewDocumentContentService(
    contentRepo interfaces.DocumentContentRepository,
    versionRepo interfaces.VersionRepository,
    documentRepo interfaces.DocumentRepository,
    eventBus base.EventBus,
) *DocumentContentService {
    return &DocumentContentService{
        contentRepo:  contentRepo,
        versionRepo:  versionRepo,
        documentRepo: documentRepo,
        eventBus:     eventBus,
    }
}

// SaveContent 保存文档内容
func (s *DocumentContentService) SaveContent(ctx context.Context, req *SaveContentRequest) (*SaveContentResponse, error) {
    // 1. 验证文档权限
    doc, err := s.documentRepo.GetByID(ctx, req.DocumentID)
    if err != nil {
        return nil, errors.NewNotFoundError("文档不存在")
    }
    
    userID := ctx.Value("userID").(string)
    if !s.checkPermission(doc, userID) {
        return nil, errors.NewAuthError("无权限编辑该文档")
    }
    
    // 2. 获取当前内容
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, req.DocumentID)
    if err != nil && !errors.IsNotFound(err) {
        return nil, errors.NewInternalError("获取当前内容失败").WithCause(err)
    }
    
    // 3. 检查并发冲突（乐观锁）
    if currentContent != nil && req.Version > 0 && currentContent.Version != req.Version {
        return nil, errors.NewBusinessError("内容已被其他用户修改，请刷新后重试")
    }
    
    // 4. 计算字数
    wordCount := s.calculateWordCount(req.Content)
    charCount := len([]rune(req.Content))
    
    // 5. 判断是否使用GridFS
    var gridfsID string
    var content string
    
    if len(req.Content) > 1024*1024 { // 大于1MB使用GridFS
        gridfsID, err = s.contentRepo.SaveToGridFS(ctx, req.DocumentID, req.Content)
        if err != nil {
            return nil, errors.NewInternalError("保存大文件失败").WithCause(err)
        }
        content = "" // 内容存储在GridFS，主文档不存储
    } else {
        content = req.Content
    }
    
    // 6. 保存或更新内容
    newVersion := 1
    if currentContent != nil {
        newVersion = currentContent.Version + 1
    }
    
    updates := map[string]interface{}{
        "content":        content,
        "content_type":   req.ContentType,
        "word_count":     wordCount,
        "char_count":     charCount,
        "gridfs_id":      gridfsID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "last_edited_by": userID,
        "updated_at":     time.Now(),
    }
    
    if currentContent == nil {
        // 创建新内容
        newContent := &document.DocumentContent{
            DocumentID:   req.DocumentID,
            Content:      content,
            ContentType:  req.ContentType,
            WordCount:    wordCount,
            CharCount:    charCount,
            GridFSID:     gridfsID,
            Version:      newVersion,
            LastSavedAt:  time.Now(),
            LastEditedBy: userID,
            CreatedAt:    time.Now(),
            UpdatedAt:    time.Now(),
        }
        if err := s.contentRepo.Create(ctx, newContent); err != nil {
            return nil, errors.NewInternalError("创建内容失败").WithCause(err)
        }
    } else {
        // 更新内容
        if err := s.contentRepo.Update(ctx, req.DocumentID, updates); err != nil {
            return nil, errors.NewInternalError("更新内容失败").WithCause(err)
        }
    }
    
    // 7. 创建版本（非自动保存才创建版本）
    if !req.IsAutoSave {
        version := &document.Version{
            DocumentID:  req.DocumentID,
            VersionNum:  newVersion,
            Content:     content,
            GridFSID:    gridfsID,
            ContentType: req.ContentType,
            WordCount:   wordCount,
            Comment:     req.Comment,
            CreatedBy:   userID,
            CreatedAt:   time.Now(),
            IsAutoSave:  false,
        }
        if err := s.versionRepo.Create(ctx, version); err != nil {
            // 版本创建失败不影响主流程
            fmt.Printf("创建版本失败: %v\n", err)
        }
    }
    
    // 8. 更新文档统计
    docUpdates := map[string]interface{}{
        "word_count": wordCount,
        "updated_at": time.Now(),
    }
    s.documentRepo.Update(ctx, req.DocumentID, docUpdates)
    
    // 9. 发布事件
    s.eventBus.PublishAsync(ctx, &base.BaseEvent{
        EventType: "document.content_saved",
        EventData: map[string]interface{}{
            "document_id": req.DocumentID,
            "word_count":  wordCount,
            "version":     newVersion,
        },
        Timestamp: time.Now(),
        Source:    "DocumentContentService",
    })
    
    return &SaveContentResponse{
        DocumentID: req.DocumentID,
        Version:    newVersion,
        WordCount:  wordCount,
        SavedAt:    time.Now(),
    }, nil
}

// GetContent 获取文档内容
func (s *DocumentContentService) GetContent(ctx context.Context, documentID string) (*document.DocumentContent, error) {
    // 1. 获取内容记录
    content, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return nil, errors.NewNotFoundError("文档内容不存在")
    }
    
    // 2. 如果使用GridFS，加载内容
    if content.GridFSID != "" {
        fullContent, err := s.contentRepo.LoadFromGridFS(ctx, content.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("加载文档内容失败").WithCause(err)
        }
        content.Content = fullContent
    }
    
    return content, nil
}

// AutoSave 自动保存
func (s *DocumentContentService) AutoSave(ctx context.Context, req *AutoSaveRequest) error {
    // 自动保存使用简化逻辑，不创建版本
    saveReq := &SaveContentRequest{
        DocumentID:  req.DocumentID,
        Content:     req.Content,
        ContentType: req.ContentType,
        Version:     req.Version,
        IsAutoSave:  true,
    }
    
    _, err := s.SaveContent(ctx, saveReq)
    return err
}

// 私有方法
func (s *DocumentContentService) calculateWordCount(content string) int {
    // 简化的字数统计，实际应该更复杂
    return len([]rune(content))
}

func (s *DocumentContentService) checkPermission(doc *document.Document, userID string) bool {
    // 检查用户是否有权限编辑文档
    // TODO: 实现完整的权限检查
    return true
}
```

#### 3.3.2 VersionService

```go
// service/document/version_service.go
package document

import (
    "context"
    "time"
    
    "qingyu_backend/models/document"
    "qingyu_backend/repository/interfaces"
    "qingyu_backend/pkg/errors"
)

type VersionService struct {
    versionRepo interfaces.VersionRepository
    contentRepo interfaces.DocumentContentRepository
}

func NewVersionService(
    versionRepo interfaces.VersionRepository,
    contentRepo interfaces.DocumentContentRepository,
) *VersionService {
    return &VersionService{
        versionRepo: versionRepo,
        contentRepo: contentRepo,
    }
}

// ListVersions 获取版本历史
func (s *VersionService) ListVersions(ctx context.Context, documentID string, limit int) ([]*document.Version, error) {
    versions, err := s.versionRepo.GetByDocumentID(ctx, documentID, limit)
    if err != nil {
        return nil, errors.NewInternalError("获取版本历史失败").WithCause(err)
    }
    
    // 加载GridFS内容
    for _, version := range versions {
        if version.GridFSID != "" {
            content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
            if err != nil {
                continue // 跳过加载失败的版本
            }
            version.Content = content
        }
    }
    
    return versions, nil
}

// GetVersion 获取指定版本
func (s *VersionService) GetVersion(ctx context.Context, documentID string, versionNum int) (*document.Version, error) {
    version, err := s.versionRepo.GetByVersionNum(ctx, documentID, versionNum)
    if err != nil {
        return nil, errors.NewNotFoundError("版本不存在")
    }
    
    // 加载GridFS内容
    if version.GridFSID != "" {
        content, err := s.contentRepo.LoadFromGridFS(ctx, version.GridFSID)
        if err != nil {
            return nil, errors.NewInternalError("加载版本内容失败").WithCause(err)
        }
        version.Content = content
    }
    
    return version, nil
}

// CompareVersions 对比两个版本
func (s *VersionService) CompareVersions(ctx context.Context, documentID string, version1, version2 int) (*VersionCompareResponse, error) {
    // 获取两个版本
    v1, err := s.GetVersion(ctx, documentID, version1)
    if err != nil {
        return nil, err
    }
    
    v2, err := s.GetVersion(ctx, documentID, version2)
    if err != nil {
        return nil, err
    }
    
    // 返回对比结果（实际diff计算在前端进行）
    return &VersionCompareResponse{
        Version1:     v1,
        Version2:     v2,
        WordCountDiff: v2.WordCount - v1.WordCount,
    }, nil
}

// RestoreVersion 恢复到指定版本
func (s *VersionService) RestoreVersion(ctx context.Context, documentID string, versionNum int) error {
    // 1. 获取指定版本
    version, err := s.GetVersion(ctx, documentID, versionNum)
    if err != nil {
        return err
    }
    
    // 2. 获取当前内容
    currentContent, err := s.contentRepo.GetByDocumentID(ctx, documentID)
    if err != nil {
        return errors.NewInternalError("获取当前内容失败").WithCause(err)
    }
    
    // 3. 保存恢复操作为新版本
    newVersion := currentContent.Version + 1
    
    updates := map[string]interface{}{
        "content":        version.Content,
        "content_type":   version.ContentType,
        "gridfs_id":      version.GridFSID,
        "version":        newVersion,
        "last_saved_at":  time.Now(),
        "updated_at":     time.Now(),
    }
    
    if err := s.contentRepo.Update(ctx, documentID, updates); err != nil {
        return errors.NewInternalError("恢复版本失败").WithCause(err)
    }
    
    // 4. 创建恢复记录版本
    restoreVersion := &document.Version{
        DocumentID:  documentID,
        VersionNum:  newVersion,
        Content:     version.Content,
        GridFSID:    version.GridFSID,
        ContentType: version.ContentType,
        WordCount:   version.WordCount,
        Comment:     fmt.Sprintf("恢复到版本 v%d", versionNum),
        CreatedBy:   ctx.Value("userID").(string),
        CreatedAt:   time.Now(),
        IsAutoSave:  false,
    }
    
    return s.versionRepo.Create(ctx, restoreVersion)
}

// CleanOldVersions 清理旧版本
func (s *VersionService) CleanOldVersions(ctx context.Context, documentID string, keepDays int) error {
    return s.versionRepo.DeleteOldVersions(ctx, documentID, keepDays)
}
```

### 3.4 API层设计

```go
// api/v1/writer/document_content_api.go
package writer

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
    "qingyu_backend/service/document"
    "qingyu_backend/pkg/response"
)

type DocumentContentApi struct {
    contentService *document.DocumentContentService
    versionService *document.VersionService
}

func NewDocumentContentApi(
    contentService *document.DocumentContentService,
    versionService *document.VersionService,
) *DocumentContentApi {
    return &DocumentContentApi{
        contentService: contentService,
        versionService: versionService,
    }
}

// GetContent 获取文档内容
func (api *DocumentContentApi) GetContent(c *gin.Context) {
    documentID := c.Param("id")
    
    content, err := api.contentService.GetContent(c.Request.Context(), documentID)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", content)
}

// SaveContent 保存文档内容
func (api *DocumentContentApi) SaveContent(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.SaveContentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    resp, err := api.contentService.SaveContent(c.Request.Context(), &req)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "保存成功", resp)
}

// AutoSave 自动保存
func (api *DocumentContentApi) AutoSave(c *gin.Context) {
    documentID := c.Param("id")
    
    var req document.AutoSaveRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "参数错误", err.Error())
        return
    }
    
    req.DocumentID = documentID
    
    if err := api.contentService.AutoSave(c.Request.Context(), &req); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "自动保存成功", nil)
}

// GetVersions 获取版本历史
func (api *DocumentContentApi) GetVersions(c *gin.Context) {
    documentID := c.Param("id")
    limit := 30 // 默认显示最近30个版本
    
    versions, err := api.versionService.ListVersions(c.Request.Context(), documentID, limit)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", versions)
}

// GetVersion 获取指定版本
func (api *DocumentContentApi) GetVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    version, err := api.versionService.GetVersion(c.Request.Context(), documentID, versionNum)
    if err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "获取成功", version)
}

// RestoreVersion 恢复版本
func (api *DocumentContentApi) RestoreVersion(c *gin.Context) {
    documentID := c.Param("id")
    versionNum, _ := strconv.Atoi(c.Param("version"))
    
    if err := api.versionService.RestoreVersion(c.Request.Context(), documentID, versionNum); err != nil {
        response.HandleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "恢复成功", nil)
}
```

### 3.5 Router层设计

```go
// router/writer/document_content.go
package writer

import (
    "github.com/gin-gonic/gin"
    "qingyu_backend/api/v1/writer"
    "qingyu_backend/middleware"
)

func InitDocumentContentRouter(r *gin.RouterGroup, contentApi *writer.DocumentContentApi) {
    docGroup := r.Group("/documents")
    docGroup.Use(middleware.JWTAuth())
    {
        // 内容管理
        docGroup.GET("/:id/content", contentApi.GetContent)
        docGroup.PUT("/:id/content", contentApi.SaveContent)
        docGroup.POST("/:id/autosave", contentApi.AutoSave)
        
        // 版本管理
        docGroup.GET("/:id/versions", contentApi.GetVersions)
        docGroup.GET("/:id/versions/:version", contentApi.GetVersion)
        docGroup.POST("/:id/restore/:version", contentApi.RestoreVersion)
    }
}
```

## 4. API接口设计

### 4.1 内容管理接口

#### 4.1.1 获取文档内容

```http
GET /api/v1/documents/{id}/content
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "id": "string",
    "documentId": "string",
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "charCount": 3000,
    "version": 5,
    "lastSavedAt": "2025-10-16T10:00:00Z"
  }
}
```

#### 4.1.2 保存文档内容

```http
PUT /api/v1/documents/{id}/content
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5,
  "comment": "修改了第三章"
}

Response:
{
  "code": 200,
  "message": "保存成功",
  "data": {
    "documentId": "string",
    "version": 6,
    "wordCount": 1050,
    "savedAt": "2025-10-16T10:05:00Z"
  }
}
```

#### 4.1.3 自动保存

```http
POST /api/v1/documents/{id}/autosave
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "string",
  "contentType": "markdown",
  "version": 5
}

Response:
{
  "code": 200,
  "message": "自动保存成功",
  "data": null
}
```

### 4.2 版本管理接口

#### 4.2.1 获取版本历史

```http
GET /api/v1/documents/{id}/versions
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": [
    {
      "id": "string",
      "versionNum": 6,
      "wordCount": 1050,
      "comment": "修改了第三章",
      "createdBy": "user123",
      "createdAt": "2025-10-16T10:05:00Z",
      "isAutoSave": false
    }
  ]
}
```

#### 4.2.2 获取指定版本

```http
GET /api/v1/documents/{id}/versions/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "id": "string",
    "versionNum": 5,
    "content": "string",
    "contentType": "markdown",
    "wordCount": 1000,
    "createdAt": "2025-10-16T09:00:00Z"
  }
}
```

#### 4.2.3 恢复版本

```http
POST /api/v1/documents/{id}/restore/{version}
Authorization: Bearer {token}

Response:
{
  "code": 200,
  "message": "恢复成功",
  "data": null
}
```

## 5. 前端集成设计

### 5.1 Markdown编辑器

```vue
<template>
  <div class="editor-container">
    <v-md-editor
      v-model="content"
      height="600px"
      :disabled-menus="[]"
      @save="handleSave"
      @change="handleChange"
    >
    </v-md-editor>
    
    <div class="editor-status">
      <span>字数: {{ wordCount }}</span>
      <span>{{ saveStatus }}</span>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      content: '',
      wordCount: 0,
      saveStatus: '已保存',
      autoSaveTimer: null,
      version: 0
    }
  },
  
  mounted() {
    this.loadContent()
    this.startAutoSave()
  },
  
  methods: {
    async loadContent() {
      const res = await this.$api.getDocumentContent(this.documentId)
      this.content = res.data.content
      this.version = res.data.version
      this.wordCount = res.data.wordCount
    },
    
    async handleSave() {
      try {
        const res = await this.$api.saveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.version = res.data.version
        this.saveStatus = '已保存'
        this.$message.success('保存成功')
      } catch (error) {
        this.$message.error('保存失败')
      }
    },
    
    handleChange() {
      this.saveStatus = '未保存'
      this.wordCount = this.content.length
    },
    
    startAutoSave() {
      this.autoSaveTimer = setInterval(() => {
        if (this.saveStatus === '未保存') {
          this.autoSave()
        }
      }, 30000) // 30秒自动保存
    },
    
    async autoSave() {
      try {
        await this.$api.autoSaveDocumentContent(this.documentId, {
          content: this.content,
          contentType: 'markdown',
          version: this.version
        })
        this.saveStatus = '自动保存于 ' + new Date().toLocaleTimeString()
      } catch (error) {
        console.error('自动保存失败', error)
      }
    }
  },
  
  beforeUnmount() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer)
    }
  }
}
</script>
```

### 5.2 版本历史组件

```vue
<template>
  <div class="version-history">
    <el-timeline>
      <el-timeline-item
        v-for="version in versions"
        :key="version.id"
        :timestamp="formatTime(version.createdAt)"
      >
        <div class="version-item">
          <div class="version-info">
            <span class="version-num">v{{ version.versionNum }}</span>
            <span class="version-comment">{{ version.comment }}</span>
            <span class="word-count">{{ version.wordCount }}字</span>
          </div>
          <div class="version-actions">
            <el-button size="small" @click="previewVersion(version)">
              预览
            </el-button>
            <el-button size="small" @click="compareVersion(version)">
              对比
            </el-button>
            <el-button size="small" type="primary" @click="restoreVersion(version)">
              恢复
            </el-button>
          </div>
        </div>
      </el-timeline-item>
    </el-timeline>
  </div>
</template>

<script>
export default {
  data() {
    return {
      versions: []
    }
  },
  
  mounted() {
    this.loadVersions()
  },
  
  methods: {
    async loadVersions() {
      const res = await this.$api.getVersionHistory(this.documentId)
      this.versions = res.data
    },
    
    async previewVersion(version) {
      const res = await this.$api.getVersion(this.documentId, version.versionNum)
      this.$emit('preview', res.data)
    },
    
    async compareVersion(version) {
      this.$emit('compare', version)
    },
    
    async restoreVersion(version) {
      try {
        await this.$confirm('确定要恢复到此版本吗？')
        await this.$api.restoreVersion(this.documentId, version.versionNum)
        this.$message.success('恢复成功')
        this.$emit('restored')
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('恢复失败')
        }
      }
    },
    
    formatTime(time) {
      return new Date(time).toLocaleString()
    }
  }
}
</script>
```

## 6. 性能优化

### 6.1 大文档处理

- **分块加载**：文档超过1MB时使用GridFS存储
- **懒加载**：版本历史内容按需加载
- **压缩传输**：使用gzip压缩传输内容

### 6.2 自动保存优化

- **防抖动**：避免频繁保存
- **增量保存**：只保存变更的内容（后期优化）
- **本地缓存**：前端LocalStorage缓存，网络恢复后同步

### 6.3 版本控制优化

- **版本限制**：每个文档最多保留100个版本
- **定期清理**：自动清理30天前的自动保存版本
- **版本合并**：合并连续的小改动（后期优化）

## 7. 安全设计

### 7.1 权限控制

- **文档权限**：只有文档所有者和协作者可以编辑
- **版本权限**：只能查看和恢复自己的版本
- **API鉴权**：所有接口需要JWT认证

### 7.2 数据安全

- **乐观锁**：使用版本号防止并发冲突
- **内容加密**：敏感内容可选择加密存储
- **备份机制**：定期备份重要文档

### 7.3 输入验证

- **内容长度限制**：单个文档不超过10MB
- **XSS防护**：过滤恶意脚本
- **SQL注入防护**：参数化查询

## 8. 测试设计

### 8.1 单元测试

```go
func TestDocumentContentService_SaveContent(t *testing.T) {
    // 测试正常保存
    // 测试大文档保存
    // 测试并发冲突
    // 测试权限验证
}

func TestVersionService_RestoreVersion(t *testing.T) {
    // 测试版本恢复
    // 测试不存在的版本
    // 测试权限验证
}
```

### 8.2 集成测试

- API接口测试
- 数据库操作测试
- GridFS存储测试

### 8.3 性能测试

- 大文档加载性能
- 自动保存响应时间
- 版本历史查询性能
- 并发编辑测试

## 9. 监控和日志

### 9.1 监控指标

- 保存成功率
- 自动保存频率
- 文档加载时间
- GridFS使用率

### 9.2 日志记录

- 内容保存日志
- 版本创建日志
- 错误日志
- 性能日志

## 10. 风险与应对

### 10.1 数据丢失风险

**风险**：自动保存失败导致内容丢失

**应对**：
- 前端LocalStorage缓存
- 保存失败重试机制
- 定期全量备份

### 10.2 并发冲突风险

**风险**：多设备同时编辑导致内容覆盖

**应对**：
- 乐观锁版本控制
- 冲突提示和合并
- 最后编辑时间显示

### 10.3 性能风险

**风险**：大文档导致加载缓慢

**应对**：
- GridFS分块存储
- 内容压缩
- CDN加速

## 11. 实施计划

### 11.1 第一阶段（2周）

- [ ] DocumentContent和Version模型设计
- [ ] Repository层实现
- [ ] Service层基础功能

### 11.2 第二阶段（2周）

- [ ] API接口开发
- [ ] 前端Markdown编辑器集成
- [ ] 自动保存功能

### 11.3 第三阶段（1周）

- [ ] 版本控制功能
- [ ] GridFS大文档支持
- [ ] 富文本编辑器集成

### 11.4 第四阶段（1周）

- [ ] 性能优化
- [ ] 测试和BUG修复
- [ ] 文档和部署

## 12. 相关文档

- [项目管理系统设计](./项目管理系统设计.md)
- [文档管理系统设计](./文档管理系统设计.md)
- [版本控制系统设计](./版本控制系统设计.md)
- [实施文档](../../implementation/04写作端模块/README_写作端实施文档.md)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-16  
**最后更新**: 2025-10-16  
**维护者**: 青羽写作团队

