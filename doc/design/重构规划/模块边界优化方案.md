# 模块边界优化方案

> **文档版本**: v1.0  
> **创建时间**: 2025-10-21  
> **实施状态**: 设计阶段

## 📋 文档概述

本文档详细阐述青羽平台架构重构中的模块边界优化方案，明确各模块的职责划分，实现单一数据源原则，避免职责不清和数据源分散的问题。

## 🎯 优化目标

1. **单一数据源**：每种核心数据只有一个模块负责维护
2. **职责明确**：每个模块的边界清晰，不存在职责重叠
3. **事件驱动**：跨模块通信优先使用事件，减少直接依赖
4. **数据一致性**：通过事件和Saga模式保证数据最终一致性

---

## 一、Reading Task vs User Level vs Wallet Service

### 1.1 现状问题分析

**问题描述**：
- Reading Task模块包含成就系统和代币奖励
- User Level模块管理用户等级和经验值
- Wallet Service管理代币余额
- 用户状态的"单一数据源"被分散到多个模块

**导致的问题**：
- ❌ 数据不一致风险（经验值和代币可能在多处被修改）
- ❌ 职责不清（奖励发放的责任主体不明确）
- ❌ 难以扩展（新增奖励类型需要修改多个模块）
- ❌ 测试困难（需要同时Mock多个模块）

### 1.2 优化方案设计

#### 模块职责划分

| 模块 | 职责 | 数据所有权 | 操作权限 |
|------|------|-----------|---------|
| **Reading Task** | • 任务定义与配置<br>• 任务进度追踪<br>• 任务完成判定<br>• **触发**奖励事件 | 任务状态、任务进度 | 只读用户等级/代币 |
| **User Level** | • 用户等级体系<br>• 经验值计算与维护<br>• 升级逻辑<br>• 成就解锁<br>• 勋章颁发 | 经验值（唯一）<br>等级、成就、勋章 | 增减经验值 |
| **Wallet Service** | • 代币余额管理<br>• 交易记录<br>• 提现处理<br>• 风控检查 | 代币余额（唯一）<br>交易记录 | 增减代币 |

#### 数据流转图

```
┌─────────────────────────────────────────────────────────────┐
│                  Reading Task Module                        │
│                                                               │
│  1. 检测任务完成                                              │
│  2. 计算奖励数量（经验值、代币）                              │
│  3. 发布TaskCompletedEvent                                   │
│     {                                                        │
│       taskID: "xxx",                                         │
│       userID: "yyy",                                         │
│       rewardExp: 100,        // 奖励经验值                    │
│       rewardTokens: 50       // 奖励代币                      │
│     }                                                        │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            │ TaskCompletedEvent
                            │
          ┌─────────────────┴─────────────────┐
          │                                   │
          ▼                                   ▼
┌─────────────────────┐           ┌─────────────────────┐
│  User Level Module  │           │  Wallet Service     │
│                     │           │                     │
│  订阅事件处理：      │           │  订阅事件处理：      │
│  1. 增加经验值      │           │  1. 增加代币        │
│  2. 检查升级        │           │  2. 记录交易        │
│  3. 检查成就解锁    │           │  3. 更新余额        │
│                     │           │                     │
│  发布事件：          │           │  发布事件：          │
│  - UserLevelUpEvent │           │  - TokenAddedEvent  │
│  - AchievementEvent │           │                     │
└─────────────────────┘           └─────────────────────┘
```

### 1.3 接口设计

#### Reading Task Service接口

```go
package reading

import (
    "context"
    "Qingyu_backend/service/base"
)

// ReadingTaskService 阅读任务服务接口
type ReadingTaskService interface {
    base.BaseService
    
    // 任务管理
    GetTask(ctx context.Context, taskID string) (*Task, error)
    ListUserTasks(ctx context.Context, userID string) ([]*Task, error)
    
    // 进度管理
    UpdateProgress(ctx context.Context, userID, taskID string, progress int) error
    GetTaskProgress(ctx context.Context, userID, taskID string) (*TaskProgress, error)
    
    // 完成判定
    CheckTaskCompletion(ctx context.Context, userID, taskID string) (bool, error)
    
    // 事件处理方法（强制定义）
    OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error
    OnUserBehavior(ctx context.Context, event *UserBehaviorEvent) error
}

// TaskCompletedEvent 任务完成事件
type TaskCompletedEvent struct {
    TaskID       string `json:"task_id"`
    UserID       string `json:"user_id"`
    TaskType     string `json:"task_type"` // daily, weekly, achievement
    RewardExp    int    `json:"reward_exp"`    // 奖励经验值
    RewardTokens int64  `json:"reward_tokens"` // 奖励代币
    CompletedAt  time.Time `json:"completed_at"`
}
```

#### User Level Service接口

```go
package platform

import (
    "context"
    "Qingyu_backend/service/base"
)

// UserLevelService 用户等级服务接口
type UserLevelService interface {
    base.BaseService
    
    // 等级管理
    GetUserLevel(ctx context.Context, userID string) (*UserLevel, error)
    GetLevelConfig(ctx context.Context, level int) (*LevelConfig, error)
    
    // 经验值管理（唯一数据源）
    AddExperience(ctx context.Context, userID string, exp int, reason string) error
    GetExperience(ctx context.Context, userID string) (int, error)
    
    // 升级检查
    CheckLevelUp(ctx context.Context, userID string) (bool, *UserLevel, error)
    
    // 成就管理
    UnlockAchievement(ctx context.Context, userID, achievementID string) error
    GetUserAchievements(ctx context.Context, userID string) ([]*Achievement, error)
    
    // 事件处理方法（强制定义）
    OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error
    OnUserBehavior(ctx context.Context, event *UserBehaviorEvent) error
}

// UserLevelUpEvent 用户升级事件
type UserLevelUpEvent struct {
    UserID      string `json:"user_id"`
    OldLevel    int    `json:"old_level"`
    NewLevel    int    `json:"new_level"`
    UnlockedAt  time.Time `json:"unlocked_at"`
}
```

#### Wallet Service接口（已存在，需要添加事件方法）

```go
package wallet

// WalletService 钱包服务接口
type WalletService interface {
    // ... 现有方法 ...
    
    // 事件处理方法（新增）
    OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error
    OnRevenueGenerated(ctx context.Context, event *RevenueEvent) error
}
```

### 1.4 事件处理实现示例

#### Reading Task实现

```go
func (s *ReadingTaskServiceImpl) CheckTaskCompletion(ctx context.Context, userID, taskID string) (bool, error) {
    // 1. 获取任务
    task, err := s.taskRepo.GetByID(ctx, taskID)
    if err != nil {
        return false, err
    }
    
    // 2. 获取进度
    progress, err := s.progressRepo.GetProgress(ctx, userID, taskID)
    if err != nil {
        return false, err
    }
    
    // 3. 判断完成
    if progress.Current >= task.Target {
        // 4. 发布任务完成事件（不直接修改经验值和代币）
        event := &TaskCompletedEvent{
            TaskID:       taskID,
            UserID:       userID,
            TaskType:     task.Type,
            RewardExp:    task.RewardExp,
            RewardTokens: task.RewardTokens,
            CompletedAt:  time.Now(),
        }
        
        if err := s.eventBus.PublishAsync(ctx, "task.completed", event); err != nil {
            log.Error("发布任务完成事件失败", err)
            // 不影响主流程，但记录日志
        }
        
        return true, nil
    }
    
    return false, nil
}
```

#### User Level实现

```go
func (s *UserLevelServiceImpl) OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error {
    // 1. 增加经验值（唯一数据源）
    if err := s.AddExperience(ctx, event.UserID, event.RewardExp, fmt.Sprintf("task_%s", event.TaskID)); err != nil {
        return fmt.Errorf("增加经验值失败: %w", err)
    }
    
    // 2. 检查升级
    levelUp, newLevel, err := s.CheckLevelUp(ctx, event.UserID)
    if err != nil {
        log.Error("检查升级失败", err)
        // 不阻塞主流程
    }
    
    if levelUp {
        // 3. 发布升级事件
        upgradeEvent := &UserLevelUpEvent{
            UserID:     event.UserID,
            OldLevel:   newLevel.Level - 1,
            NewLevel:   newLevel.Level,
            UnlockedAt: time.Now(),
        }
        s.eventBus.PublishAsync(ctx, "user.level_up", upgradeEvent)
    }
    
    // 4. 检查成就
    s.checkAchievements(ctx, event.UserID, event.TaskType)
    
    return nil
}
```

#### Wallet Service实现

```go
func (s *UnifiedWalletService) OnTaskCompleted(ctx context.Context, event *TaskCompletedEvent) error {
    // 增加代币（唯一数据源）
    _, err := s.Recharge(ctx, event.UserID, float64(event.RewardTokens), fmt.Sprintf("task_reward_%s", event.TaskID))
    if err != nil {
        return fmt.Errorf("增加代币失败: %w", err)
    }
    
    return nil
}
```

### 1.5 数据模型设计

#### Task数据模型

```go
package models

type Task struct {
    ID           string    `bson:"_id" json:"id"`
    Type         string    `bson:"type" json:"type"` // daily, weekly, achievement
    Title        string    `bson:"title" json:"title"`
    Description  string    `bson:"description" json:"description"`
    Target       int       `bson:"target" json:"target"`      // 目标值
    RewardExp    int       `bson:"reward_exp" json:"rewardExp"`       // 奖励经验值
    RewardTokens int64     `bson:"reward_tokens" json:"rewardTokens"` // 奖励代币
    Status       string    `bson:"status" json:"status"`
    CreatedAt    time.Time `bson:"created_at" json:"createdAt"`
}

type TaskProgress struct {
    ID        string    `bson:"_id" json:"id"`
    UserID    string    `bson:"user_id" json:"userId"`
    TaskID    string    `bson:"task_id" json:"taskId"`
    Current   int       `bson:"current" json:"current"`   // 当前进度
    Completed bool      `bson:"completed" json:"completed"`
    UpdatedAt time.Time `bson:"updated_at" json:"updatedAt"`
}
```

#### User Level数据模型

```go
package models

type UserLevel struct {
    ID            string    `bson:"_id" json:"id"`
    UserID        string    `bson:"user_id" json:"userId"`
    Level         int       `bson:"level" json:"level"`
    Experience    int       `bson:"experience" json:"experience"` // 当前经验值（唯一数据源）
    NextLevelExp  int       `bson:"next_level_exp" json:"nextLevelExp"` // 下一级所需经验
    Achievements  []string  `bson:"achievements" json:"achievements"` // 已解锁成就ID列表
    Badges        []string  `bson:"badges" json:"badges"` // 勋章ID列表
    UpdatedAt     time.Time `bson:"updated_at" json:"updatedAt"`
}

type Achievement struct {
    ID          string   `bson:"_id" json:"id"`
    Title       string   `bson:"title" json:"title"`
    Description string   `bson:"description" json:"description"`
    Icon        string   `bson:"icon" json:"icon"`
    Type        string   `bson:"type" json:"type"` // reading, writing, social
    Condition   string   `bson:"condition" json:"condition"` // 解锁条件
    Reward      int      `bson:"reward" json:"reward"` // 奖励经验值
}

type LevelConfig struct {
    Level        int      `bson:"level" json:"level"`
    RequiredExp  int      `bson:"required_exp" json:"requiredExp"`
    Privileges   []string `bson:"privileges" json:"privileges"` // 特权列表
    BadgeID      string   `bson:"badge_id" json:"badgeId"`
}
```

---

## 二、Monetization vs Wallet Service

### 2.1 现状问题分析

**问题描述**：
- Monetization模块包含收入管理、提现管理
- Wallet Service也包含提现管理、交易记录
- 财务逻辑和账本管理混在一起

**导致的问题**：
- ❌ 财务核心账本的安全性和隔离性不足
- ❌ 业务规则（分成比例、合约）与技术账本（余额、交易）耦合
- ❌ 难以进行财务审计和对账

### 2.2 优化方案设计

#### 模块职责划分

| 模块 | 层次 | 职责 | 数据所有权 |
|------|------|------|-----------|
| **Monetization Service** | 业务逻辑层 | • 收益计算（订阅、打赏、广告、版权）<br>• 分成比例管理<br>• 合约管理<br>• 财务报表生成<br>• 提现申请流程（业务审核）<br>• 税务处理 | 收益记录、合约、分成配置 |
| **Wallet Service** | 技术账本层 | • 代币/货币余额管理（唯一）<br>• 交易记录（唯一）<br>• 提现处理（技术操作）<br>• 风控检查<br>• 账本对账 | 余额（唯一）、交易记录（唯一） |

#### 协作流程图

```
┌────────────────────────────────────────────────────────────┐
│                  Monetization Service                      │
│                   (业务逻辑层)                              │
│                                                              │
│  职责：                                                      │
│  1. 计算作者收益（根据阅读量、打赏、广告等）                │
│  2. 应用分成比例（根据合约配置）                            │
│  3. 生成财务报表                                            │
│  4. 审核提现申请                                            │
│                                                              │
│  不负责：直接修改余额                                        │
└──────────────────────┬─────────────────────────────────────┘
                       │
                       │ 调用Wallet API
                       │
┌──────────────────────▼─────────────────────────────────────┐
│                  Wallet Service                             │
│                  (技术账本层)                                │
│                                                              │
│  职责：                                                      │
│  1. 增加/扣除余额（唯一入口）                               │
│  2. 记录所有交易（唯一数据源）                              │
│  3. 处理提现（技术操作：冻结、解冻、转账）                  │
│  4. 风控检查（异常交易检测）                                │
│  5. 生成对账报表                                            │
│                                                              │
│  数据源：                                                    │
│  - 用户余额（唯一）                                          │
│  - 交易记录（唯一）                                          │
└────────────────────────────────────────────────────────────┘
```

### 2.3 接口设计

#### Monetization Service接口

```go
package writing

import (
    "context"
    "Qingyu_backend/service/base"
    "Qingyu_backend/service/shared/wallet"
)

// MonetizationService 稿费结算服务接口
type MonetizationService interface {
    base.BaseService
    
    // 收益计算
    CalculateRevenue(ctx context.Context, authorID string, period Period) (*RevenueReport, error)
    CalculateChapterRevenue(ctx context.Context, chapterID string) (float64, error)
    
    // 分成管理
    GetShareConfig(ctx context.Context, authorID string) (*ShareConfig, error)
    UpdateShareConfig(ctx context.Context, authorID string, config *ShareConfig) error
    
    // 合约管理
    GetContract(ctx context.Context, authorID string) (*Contract, error)
    CreateContract(ctx context.Context, contract *Contract) error
    UpdateContract(ctx context.Context, authorID string, updates map[string]interface{}) error
    
    // 提现申请（业务层）
    RequestWithdrawal(ctx context.Context, req *WithdrawalRequest) (*WithdrawalOrder, error)
    ApproveWithdrawal(ctx context.Context, orderID, adminID string) error
    RejectWithdrawal(ctx context.Context, orderID, adminID, reason string) error
    
    // 财务报表
    GenerateFinancialReport(ctx context.Context, authorID string, period Period) (*FinancialReport, error)
    
    // 税务处理
    CalculateTax(ctx context.Context, amount float64, authorID string) (float64, error)
}

// RevenueReport 收益报表
type RevenueReport struct {
    AuthorID        string  `json:"authorId"`
    Period          Period  `json:"period"`
    SubscriptionRev float64 `json:"subscriptionRevenue"` // 订阅收入
    RewardRev       float64 `json:"rewardRevenue"`       // 打赏收入
    AdRev           float64 `json:"adRevenue"`           // 广告收入
    CopyrightRev    float64 `json:"copyrightRevenue"`    // 版权收入
    TotalRev        float64 `json:"totalRevenue"`
    ShareRatio      float64 `json:"shareRatio"`          // 分成比例
    AuthorShare     float64 `json:"authorShare"`         // 作者实际收入
}

// WithdrawalRequest 提现申请
type WithdrawalRequest struct {
    AuthorID string  `json:"authorId"`
    Amount   float64 `json:"amount"`
    Account  string  `json:"account"` // 提现账号
    Method   string  `json:"method"`  // 提现方式：alipay, wechat, bank
}

// WithdrawalOrder 提现订单
type WithdrawalOrder struct {
    ID         string    `json:"id"`
    AuthorID   string    `json:"authorId"`
    Amount     float64   `json:"amount"`
    Fee        float64   `json:"fee"`       // 手续费
    Tax        float64   `json:"tax"`       // 税费
    NetAmount  float64   `json:"netAmount"` // 实际到账
    Status     string    `json:"status"`    // pending, approved, rejected, completed
    Reason     string    `json:"reason,omitempty"`
    CreatedAt  time.Time `json:"createdAt"`
    UpdatedAt  time.Time `json:"updatedAt"`
}
```

#### Wallet Service接口（扩展）

```go
package wallet

// WalletService 钱包服务接口
type WalletService interface {
    // ... 现有方法 ...
    
    // 提现处理（技术操作）
    FreezeForWithdrawal(ctx context.Context, userID string, amount float64, orderID string) error
    ProcessWithdrawal(ctx context.Context, orderID string) error
    CancelWithdrawal(ctx context.Context, orderID string) error // 解冻资金
    
    // 风控检查
    CheckRiskControl(ctx context.Context, userID string, amount float64) (bool, error)
    
    // 对账
    ReconcileTransactions(ctx context.Context, startDate, endDate time.Time) (*ReconciliationReport, error)
}
```

### 2.4 业务流程示例：作者提现

```go
// Monetization Service实现
func (ms *MonetizationServiceImpl) RequestWithdrawal(ctx context.Context, req *WithdrawalRequest) (*WithdrawalOrder, error) {
    // 1. 业务规则检查
    contract, err := ms.GetContract(ctx, req.AuthorID)
    if err != nil {
        return nil, err
    }
    
    // 检查合约是否允许提现
    if !contract.AllowWithdrawal() {
        return nil, errors.New("合约不允许提现")
    }
    
    // 检查最小提现金额
    if req.Amount < contract.MinWithdrawalAmount {
        return nil, fmt.Errorf("提现金额不能低于%v", contract.MinWithdrawalAmount)
    }
    
    // 2. 调用Wallet Service检查余额
    balance, err := ms.walletService.GetBalance(ctx, req.AuthorID)
    if err != nil {
        return nil, err
    }
    
    if balance < req.Amount {
        return nil, errors.New("余额不足")
    }
    
    // 3. 风控检查（Wallet Service提供）
    passed, err := ms.walletService.CheckRiskControl(ctx, req.AuthorID, req.Amount)
    if err != nil || !passed {
        return nil, errors.New("风控检查未通过")
    }
    
    // 4. 计算税费
    tax, err := ms.CalculateTax(ctx, req.Amount, req.AuthorID)
    if err != nil {
        return nil, err
    }
    
    // 5. 创建提现订单（Monetization管理）
    order := &WithdrawalOrder{
        ID:        uuid.New().String(),
        AuthorID:  req.AuthorID,
        Amount:    req.Amount,
        Fee:       req.Amount * 0.01,  // 1%手续费
        Tax:       tax,
        NetAmount: req.Amount - req.Amount*0.01 - tax,
        Status:    "pending",
        CreatedAt: time.Now(),
    }
    
    if err := ms.orderRepo.Create(ctx, order); err != nil {
        return nil, err
    }
    
    // 6. 调用Wallet Service冻结资金
    if err := ms.walletService.FreezeForWithdrawal(ctx, req.AuthorID, req.Amount, order.ID); err != nil {
        // 回滚：删除订单
        ms.orderRepo.Delete(ctx, order.ID)
        return nil, err
    }
    
    // 7. 发布事件
    ms.eventBus.PublishAsync(ctx, "withdrawal.requested", &WithdrawalRequestedEvent{
        OrderID:  order.ID,
        AuthorID: req.AuthorID,
        Amount:   req.Amount,
    })
    
    return order, nil
}

func (ms *MonetizationServiceImpl) ApproveWithdrawal(ctx context.Context, orderID, adminID string) error {
    // 1. 获取订单
    order, err := ms.orderRepo.GetByID(ctx, orderID)
    if err != nil {
        return err
    }
    
    // 2. 更新订单状态
    order.Status = "approved"
    if err := ms.orderRepo.Update(ctx, order); err != nil {
        return err
    }
    
    // 3. 调用Wallet Service处理提现（技术操作）
    if err := ms.walletService.ProcessWithdrawal(ctx, orderID); err != nil {
        // 回滚状态
        order.Status = "pending"
        ms.orderRepo.Update(ctx, order)
        return err
    }
    
    // 4. 发布事件
    ms.eventBus.PublishAsync(ctx, "withdrawal.approved", &WithdrawalApprovedEvent{
        OrderID:  orderID,
        AuthorID: order.AuthorID,
        Amount:   order.NetAmount,
    })
    
    return nil
}
```

### 2.5 数据模型设计

#### Monetization数据模型

```go
package models

// Revenue 收益记录
type Revenue struct {
    ID          string    `bson:"_id" json:"id"`
    AuthorID    string    `bson:"author_id" json:"authorId"`
    BookID      string    `bson:"book_id" json:"bookId"`
    Source      string    `bson:"source" json:"source"` // subscription, reward, ad, copyright
    Amount      float64   `bson:"amount" json:"amount"`
    ShareRatio  float64   `bson:"share_ratio" json:"shareRatio"`
    AuthorShare float64   `bson:"author_share" json:"authorShare"`
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`
}

// Contract 合约
type Contract struct {
    ID                  string    `bson:"_id" json:"id"`
    AuthorID            string    `bson:"author_id" json:"authorId"`
    Type                string    `bson:"type" json:"type"` // standard, premium, exclusive
    ShareRatio          float64   `bson:"share_ratio" json:"shareRatio"` // 分成比例 0-1
    MinWithdrawalAmount float64   `bson:"min_withdrawal_amount" json:"minWithdrawalAmount"`
    StartDate           time.Time `bson:"start_date" json:"startDate"`
    EndDate             *time.Time `bson:"end_date,omitempty" json:"endDate,omitempty"`
    Status              string    `bson:"status" json:"status"` // active, expired, terminated
    CreatedAt           time.Time `bson:"created_at" json:"createdAt"`
}

// ShareConfig 分成配置
type ShareConfig struct {
    ID            string  `bson:"_id" json:"id"`
    ContractType  string  `bson:"contract_type" json:"contractType"`
    SubscriptionShare float64 `bson:"subscription_share" json:"subscriptionShare"` // 订阅分成比例
    RewardShare       float64 `bson:"reward_share" json:"rewardShare"`             // 打赏分成比例
    AdShare           float64 `bson:"ad_share" json:"adShare"`                     // 广告分成比例
    CopyrightShare    float64 `bson:"copyright_share" json:"copyrightShare"`       // 版权分成比例
}
```

---

## 三、AI Module Go/Python分层

### 3.1 现状问题分析

**问题描述**：
- 当前AI模块完全在Go中实现
- AI逻辑（Agent、RAG）与API处理混在一起
- 难以利用Python生态的AI工具和库

**导致的问题**：
- ❌ 复杂AI逻辑在Go中实现困难
- ❌ 无法利用Python丰富的AI生态（LangChain、向量数据库客户端等）
- ❌ Agent工具调用系统难以扩展
- ❌ RAG检索增强实现复杂

### 3.2 优化方案设计

#### 架构分层

```
┌──────────────────────────────────────────────────────────┐
│                   Go Backend Service                     │
│                                                            │
│  ┌──────────────────────────────────────────┐            │
│  │       Router Layer (Gin)                 │            │
│  │  - /api/v1/ai/chat                       │            │
│  │  - /api/v1/ai/generate                   │            │
│  │  - /api/v1/ai/rag/search                 │            │
│  └────────────────┬─────────────────────────┘            │
│                   │                                       │
│  ┌────────────────▼─────────────────────────┐            │
│  │       API Layer                          │            │
│  │  - 参数验证                              │            │
│  │  - 认证授权                              │            │
│  │  - SSE响应包装                           │            │
│  └────────────────┬─────────────────────────┘            │
│                   │                                       │
│  ┌────────────────▼─────────────────────────┐            │
│  │   AI Proxy Service (Go代理层)           │            │
│  │                                           │            │
│  │  职责：                                   │            │
│  │  1. gRPC Client（连接Python服务）        │            │
│  │  2. 流式响应代理（SSE转换）               │            │
│  │  3. 熔断器（Circuit Breaker）            │            │
│  │  4. 限流器（Rate Limiter）               │            │
│  │  5. 超时控制                              │            │
│  │  6. 错误转换（Python异常→Go错误）        │            │
│  │  7. 请求/响应日志                         │            │
│  │                                           │            │
│  │  不负责：                                 │            │
│  │  - AI核心逻辑                             │            │
│  │  - 工具调用执行                           │            │
│  └────────────────┬─────────────────────────┘            │
└───────────────────┼──────────────────────────────────────┘
                    │
                    │ gRPC (推荐) / HTTP
                    │
┌───────────────────▼──────────────────────────────────────┐
│            Python AI Agent Service (FastAPI)             │
│                                                            │
│  ┌──────────────────────────────────────────┐            │
│  │     gRPC Server / HTTP Server            │            │
│  └────────────────┬─────────────────────────┘            │
│                   │                                       │
│  ┌────────────────▼─────────────────────────┐            │
│  │       Agent Engine Layer                 │            │
│  │                                           │            │
│  │  职责：                                   │            │
│  │  1. Agent核心引擎（BaseAgent）           │            │
│  │  2. 任务理解与规划                        │            │
│  │  3. 步骤执行编排                          │            │
│  │  4. 多Agent协作                           │            │
│  │  5. 结果汇总                              │            │
│  └────────────────┬─────────────────────────┘            │
│                   │                                       │
│  ┌────────────────▼─────────────────────────┐            │
│  │       Tool Calling System                │            │
│  │                                           │            │
│  │  职责：                                   │            │
│  │  1. 工具注册与发现                        │            │
│  │  2. 参数验证                              │            │
│  │  3. 调用Go API（回调）                    │            │
│  │  4. 结果解析                              │            │
│  │  5. 错误处理                              │            │
│  └────────────────┬─────────────────────────┘            │
│                   │                                       │
│  ┌────────────────▼─────────────────────────┐            │
│  │       RAG Retrieval Engine               │            │
│  │                                           │            │
│  │  职责：                                   │            │
│  │  1. 向量化（Embedding）                   │            │
│  │  2. 向量检索（Milvus/Qdrant）            │            │
│  │  3. 混合检索（语义+关键词）               │            │
│  │  4. 重排序（Rerank）                      │            │
│  │  5. 上下文构建                            │            │
│  └───────────────────────────────────────────┘            │
│                                                            │
│  ┌───────────────────────────────────────────┐            │
│  │    External Services                      │            │
│  │  - OpenAI API                             │            │
│  │  - Claude API                             │            │
│  │  - 本地LLM                                 │            │
│  │  - 向量数据库（Milvus/Qdrant）            │            │
│  └───────────────────────────────────────────┘            │
└────────────────────────────────────────────────────────────┘
```

### 3.3 通信协议设计

#### gRPC Proto定义

```protobuf
syntax = "proto3";

package ai;

service AIAgentService {
  // 文本生成
  rpc GenerateText(GenerateRequest) returns (GenerateResponse);
  
  // 流式文本生成
  rpc GenerateTextStream(GenerateRequest) returns (stream StreamChunk);
  
  // 对话
  rpc Chat(ChatRequest) returns (ChatResponse);
  
  // 流式对话
  rpc ChatStream(ChatRequest) returns (stream StreamChunk);
  
  // RAG检索增强生成
  rpc RAGGenerate(RAGRequest) returns (RAGResponse);
  
  // Agent执行
  rpc ExecuteAgent(AgentRequest) returns (AgentResponse);
  
  // 健康检查
  rpc HealthCheck(HealthRequest) returns (HealthResponse);
}

message GenerateRequest {
  string prompt = 1;
  string model = 2;
  float temperature = 3;
  int32 max_tokens = 4;
  map<string, string> metadata = 5;
}

message GenerateResponse {
  string text = 1;
  int32 tokens_used = 2;
  string model = 3;
}

message StreamChunk {
  string delta = 1;
  bool is_final = 2;
  string error = 3;
}

message ChatRequest {
  string session_id = 1;
  repeated Message messages = 2;
  string model = 3;
  float temperature = 4;
}

message Message {
  string role = 1;
  string content = 2;
}

message RAGRequest {
  string query = 1;
  repeated string knowledge_bases = 2;
  int32 top_k = 3;
  bool include_citations = 4;
}

message RAGResponse {
  string answer = 1;
  repeated Source sources = 2;
  float confidence = 3;
}

message Source {
  string document_id = 1;
  string content = 2;
  float score = 3;
}

message AgentRequest {
  string agent_type = 1; // creative, analysis, review, assistant
  string task = 2;
  map<string, string> context = 3;
  repeated string tools = 4; // 可用工具列表
}

message AgentResponse {
  string result = 1;
  repeated ToolCall tool_calls = 2;
  string status = 3;
}

message ToolCall {
  string tool_name = 1;
  string parameters = 2; // JSON
  string result = 3;
}
```

### 3.4 Go AI Proxy Service实现框架

```go
package ai

import (
    "context"
    "io"
    "time"
    
    "google.golang.org/grpc"
    pb "Qingyu_backend/proto/ai" // 生成的gRPC代码
)

// AIProxyService Go AI代理服务
type AIProxyService struct {
    grpcClient    pb.AIAgentServiceClient
    conn          *grpc.ClientConn
    circuitBreaker *CircuitBreaker
    rateLimiter    *RateLimiter
    timeout        time.Duration
}

// NewAIProxyService 创建AI代理服务
func NewAIProxyService(pythonAddr string) (*AIProxyService, error) {
    // 1. 建立gRPC连接
    conn, err := grpc.Dial(pythonAddr, 
        grpc.WithInsecure(),
        grpc.WithTimeout(30*time.Second),
    )
    if err != nil {
        return nil, err
    }
    
    client := pb.NewAIAgentServiceClient(conn)
    
    return &AIProxyService{
        grpcClient:     client,
        conn:           conn,
        circuitBreaker: NewCircuitBreaker(5, 30*time.Second),
        rateLimiter:    NewRateLimiter(100, time.Second), // 100 QPS
        timeout:        30 * time.Second,
    }, nil
}

// GenerateText 文本生成（同步）
func (s *AIProxyService) GenerateText(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error) {
    // 1. 限流检查
    if !s.rateLimiter.Allow() {
        return nil, errors.New("请求过于频繁，请稍后再试")
    }
    
    // 2. 熔断检查
    if !s.circuitBreaker.Allow() {
        return nil, errors.New("AI服务暂时不可用")
    }
    
    // 3. 转发到Python服务
    ctx, cancel := context.WithTimeout(ctx, s.timeout)
    defer cancel()
    
    pbReq := &pb.GenerateRequest{
        Prompt:      req.Prompt,
        Model:       req.Model,
        Temperature: req.Temperature,
        MaxTokens:   int32(req.MaxTokens),
    }
    
    resp, err := s.grpcClient.GenerateText(ctx, pbReq)
    if err != nil {
        s.circuitBreaker.RecordFailure()
        return nil, s.convertError(err)
    }
    
    s.circuitBreaker.RecordSuccess()
    
    // 4. 响应转换
    return &GenerateResponse{
        Text:       resp.Text,
        TokensUsed: int(resp.TokensUsed),
        Model:      resp.Model,
    }, nil
}

// GenerateTextStream 流式文本生成
func (s *AIProxyService) GenerateTextStream(ctx context.Context, req *GenerateRequest) (<-chan *StreamChunk, error) {
    // 1. 限流和熔断检查
    if !s.rateLimiter.Allow() {
        return nil, errors.New("请求过于频繁")
    }
    if !s.circuitBreaker.Allow() {
        return nil, errors.New("AI服务暂时不可用")
    }
    
    // 2. 调用gRPC流式接口
    pbReq := &pb.GenerateRequest{
        Prompt:      req.Prompt,
        Model:       req.Model,
        Temperature: req.Temperature,
        MaxTokens:   int32(req.MaxTokens),
    }
    
    stream, err := s.grpcClient.GenerateTextStream(ctx, pbReq)
    if err != nil {
        s.circuitBreaker.RecordFailure()
        return nil, s.convertError(err)
    }
    
    // 3. 创建输出channel
    chunkChan := make(chan *StreamChunk, 100)
    
    // 4. 异步接收流式数据
    go func() {
        defer close(chunkChan)
        
        for {
            chunk, err := stream.Recv()
            if err == io.EOF {
                s.circuitBreaker.RecordSuccess()
                return
            }
            if err != nil {
                s.circuitBreaker.RecordFailure()
                chunkChan <- &StreamChunk{
                    Error: s.convertError(err).Error(),
                }
                return
            }
            
            chunkChan <- &StreamChunk{
                Delta:   chunk.Delta,
                IsFinal: chunk.IsFinal,
            }
        }
    }()
    
    return chunkChan, nil
}

// convertError 错误转换
func (s *AIProxyService) convertError(err error) error {
    // TODO: 将gRPC错误转换为统一的Go错误
    return err
}

// Close 关闭连接
func (s *AIProxyService) Close() error {
    return s.conn.Close()
}
```

### 3.5 Python AI Agent Service框架（伪代码）

```python
# main.py
from fastapi import FastAPI
from grpc import aio
import ai_agent_pb2
import ai_agent_pb2_grpc

class AIAgentServicer(ai_agent_pb2_grpc.AIAgentServiceServicer):
    def __init__(self):
        self.agent_engine = AgentEngine()
        self.tool_registry = ToolRegistry()
        self.rag_engine = RAGEngine()
        
    async def GenerateTextStream(self, request, context):
        """流式文本生成"""
        try:
            # 调用Agent引擎
            async for chunk in self.agent_engine.generate_stream(
                prompt=request.prompt,
                model=request.model,
                temperature=request.temperature
            ):
                yield ai_agent_pb2.StreamChunk(
                    delta=chunk.text,
                    is_final=chunk.is_final
                )
        except Exception as e:
            yield ai_agent_pb2.StreamChunk(
                error=str(e)
            )
    
    async def ExecuteAgent(self, request, context):
        """执行Agent任务"""
        agent = self.agent_engine.create_agent(request.agent_type)
        
        # 注册工具
        for tool_name in request.tools:
            tool = self.tool_registry.get_tool(tool_name)
            agent.register_tool(tool)
        
        # 执行任务
        result = await agent.execute(
            task=request.task,
            context=request.context
        )
        
        return ai_agent_pb2.AgentResponse(
            result=result.output,
            tool_calls=[
                ai_agent_pb2.ToolCall(
                    tool_name=call.tool_name,
                    parameters=call.parameters,
                    result=call.result
                )
                for call in result.tool_calls
            ],
            status="completed"
        )

# 启动gRPC服务器
async def serve():
    server = aio.server()
    ai_agent_pb2_grpc.add_AIAgentServiceServicer_to_server(
        AIAgentServicer(), server
    )
    server.add_insecure_port('[::]:50051')
    await server.start()
    await server.wait_for_termination()

if __name__ == '__main__':
    import asyncio
    asyncio.run(serve())
```

---

## 四、实施建议

### 4.1 实施优先级

| 优化项 | 优先级 | 预计工时 | 风险等级 |
|--------|--------|----------|---------|
| Reading Task vs User Level职责划分 | P0 | 3-5天 | 中 |
| Monetization vs Wallet分离 | P0 | 5-7天 | 高 |
| AI Module Go/Python分层 | P1 | 2-3周 | 高 |

### 4.2 实施步骤

#### 阶段1：接口定义（1周）
1. 定义所有新增接口
2. 定义事件结构
3. 评审与确认

#### 阶段2：数据模型设计（1周）
1. 设计MongoDB Schema
2. 设计数据迁移方案
3. 准备测试数据

#### 阶段3：分模块实施（2-4周）
1. Reading Task重构
2. User Level实现
3. Monetization实现
4. Python AI Service开发

#### 阶段4：集成测试（1周）
1. 单元测试
2. 集成测试
3. 性能测试

### 4.3 风险与挑战

| 风险 | 影响 | 应对措施 |
|------|------|---------|
| 数据迁移失败 | 高 | 充分测试，备份数据，灰度发布 |
| 事件丢失 | 高 | 事件持久化，补偿机制 |
| Python服务稳定性 | 中 | 熔断器，降级方案 |
| 性能下降 | 中 | 缓存优化，连接池 |

---

## 五、总结

本模块边界优化方案通过明确职责划分、实现单一数据源、引入事件驱动和Go/Python分层，显著提升了系统的：

1. **可维护性**：职责清晰，易于理解和修改
2. **可扩展性**：模块独立，易于添加新功能
3. **可测试性**：边界明确，便于单元测试
4. **数据一致性**：单一数据源，减少不一致风险
5. **性能优化**：Go处理高并发，Python处理AI复杂逻辑

**下一步行动**：
- [ ] 编写详细的接口设计文档
- [ ] 准备数据迁移方案
- [ ] 搭建Python AI服务框架
- [ ] 实施事件驱动架构改造

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21  
**负责人**: 架构组  
**审核状态**: 待评审

