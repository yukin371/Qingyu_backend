# Go-Python é€šä¿¡åè®®è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-27  
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ  
> **è´Ÿè´£äºº**: AIæ¶æ„ç»„

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡ Go åç«¯ä¸ Python AI æœåŠ¡ä¹‹é—´çš„é€šä¿¡åè®®ï¼ŒåŒ…æ‹¬ gRPC Proto å®šä¹‰ã€Go AI Proxy Service å®ç°ã€æµå¼å“åº”ä»£ç†ã€é”™è¯¯å¤„ç†ç­‰å…³é”®æœºåˆ¶ã€‚

**é€‚ç”¨èŒƒå›´**ï¼š
- gRPC åè®®å®šä¹‰
- Go AI Proxy Service å®ç°
- æµå¼å“åº”ä»£ç†æœºåˆ¶
- è®¤è¯æˆæƒä¼ é€’
- è¶…æ—¶æ§åˆ¶å’Œé‡è¯•ç­–ç•¥

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. **é«˜æ€§èƒ½é€šä¿¡**ï¼šåŸºäº gRPCï¼Œæ”¯æŒåŒå‘æµå¼ä¼ è¾“
2. **ç»Ÿä¸€åè®®**ï¼šæ ‡å‡†åŒ–çš„è¯·æ±‚/å“åº”æ ¼å¼
3. **æµå¼ä»£ç†**ï¼šæ”¯æŒ SSE/WebSocket æµå¼å“åº”
4. **å®Œæ•´é”™è¯¯å¤„ç†**ï¼šgRPC é”™è¯¯åˆ° Go é”™è¯¯çš„å®Œæ•´è½¬æ¢
5. **å®‰å…¨ä¼ é€’**ï¼šJWT Token å’Œç”¨æˆ·ä¸Šä¸‹æ–‡çš„å®‰å…¨ä¼ é€’

### éç›®æ ‡

- âŒ ä¸é‡æ–°å‘æ˜è½®å­ï¼ˆä½¿ç”¨ gRPC æ ‡å‡†åŠŸèƒ½ï¼‰
- âŒ ä¸å®ç°è‡ªå®šä¹‰åŠ å¯†ï¼ˆä¾èµ– TLSï¼‰

---

## ä¸€ã€gRPC Proto å®šä¹‰

### 1.1 Proto æ–‡ä»¶ç»“æ„

```
proto/
â”œâ”€â”€ common.proto          # é€šç”¨æ¶ˆæ¯å®šä¹‰
â”œâ”€â”€ ai_agent.proto        # Agent æœåŠ¡
â”œâ”€â”€ rag.proto             # RAG æœåŠ¡
â””â”€â”€ tool.proto            # å·¥å…·æœåŠ¡
```

### 1.2 common.proto

```protobuf
// proto/common.proto
syntax = "proto3";

package qingyu.ai.common;

option go_package = "Qingyu_backend/proto/ai/common";

// é€šç”¨å“åº”çŠ¶æ€
message Status {
  int32 code = 1;           // çŠ¶æ€ç 
  string message = 2;       // æ¶ˆæ¯
  string details = 3;       // è¯¦ç»†ä¿¡æ¯
}

// å…ƒæ•°æ®
message Metadata {
  string request_id = 1;    // è¯·æ±‚ ID
  string user_id = 2;       // ç”¨æˆ· ID
  string project_id = 3;    // é¡¹ç›® ID
  int64 timestamp = 4;      // æ—¶é—´æˆ³
  map<string, string> extra = 5;  // é¢å¤–ä¿¡æ¯
}

// å·¥å…·è°ƒç”¨è®°å½•
message ToolCall {
  string tool_name = 1;     // å·¥å…·åç§°
  string parameters = 2;    // å‚æ•°ï¼ˆJSON æ ¼å¼ï¼‰
  string result = 3;        // ç»“æœï¼ˆJSON æ ¼å¼ï¼‰
  int64 duration_ms = 4;    // æ‰§è¡Œæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
  Status status = 5;        // æ‰§è¡ŒçŠ¶æ€
}

// æ¶ˆæ¯ï¼ˆå¯¹è¯ï¼‰
message Message {
  string role = 1;          // è§’è‰²ï¼šsystem/user/assistant
  string content = 2;       // å†…å®¹
  map<string, string> metadata = 3;  // å…ƒæ•°æ®
}
```

### 1.3 ai_agent.proto

```protobuf
// proto/ai_agent.proto
syntax = "proto3";

package qingyu.ai.agent;

import "common.proto";

option go_package = "Qingyu_backend/proto/ai/agent";

// Agent æœåŠ¡
service AIAgentService {
  // æ‰§è¡Œ Agentï¼ˆåŒæ­¥ï¼‰
  rpc ExecuteAgent(AgentRequest) returns (AgentResponse);
  
  // æ‰§è¡Œ Agentï¼ˆæµå¼ï¼‰
  rpc ExecuteAgentStream(AgentRequest) returns (stream AgentStreamChunk);
  
  // å¯¹è¯ï¼ˆåŒæ­¥ï¼‰
  rpc Chat(ChatRequest) returns (ChatResponse);
  
  // å¯¹è¯ï¼ˆæµå¼ï¼‰
  rpc ChatStream(ChatRequest) returns (stream ChatStreamChunk);
  
  // å¥åº·æ£€æŸ¥
  rpc HealthCheck(HealthRequest) returns (HealthResponse);
}

// Agent æ‰§è¡Œè¯·æ±‚
message AgentRequest {
  string agent_type = 1;           // Agent ç±»å‹ï¼šcreative, outline, character, plot, review
  string task = 2;                 // ä»»åŠ¡æè¿°
  map<string, string> context = 3; // ä¸Šä¸‹æ–‡ä¿¡æ¯
  repeated string tools = 4;       // å¯ç”¨å·¥å…·åˆ—è¡¨
  string user_id = 5;              // ç”¨æˆ· ID
  string project_id = 6;           // é¡¹ç›® ID
  common.Metadata metadata = 7;    // å…ƒæ•°æ®
  
  // é«˜çº§é€‰é¡¹
  AgentOptions options = 8;
}

// Agent é€‰é¡¹
message AgentOptions {
  string model = 1;                // LLM æ¨¡å‹
  float temperature = 2;           // æ¸©åº¦å‚æ•°
  int32 max_tokens = 3;            // æœ€å¤§ Token æ•°
  int32 max_retries = 4;           // æœ€å¤§é‡è¯•æ¬¡æ•°
  int32 timeout_seconds = 5;       // è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
  bool enable_reasoning = 6;       // å¯ç”¨æ¨ç†è¿‡ç¨‹
}

// Agent æ‰§è¡Œå“åº”
message AgentResponse {
  string output = 1;                     // è¾“å‡ºç»“æœ
  repeated common.ToolCall tool_calls = 2;  // å·¥å…·è°ƒç”¨è®°å½•
  string status = 3;                     // çŠ¶æ€ï¼šcompleted, failed, timeout
  repeated string reasoning = 4;         // æ¨ç†è¿‡ç¨‹
  common.Status response_status = 5;     // å“åº”çŠ¶æ€
  common.Metadata metadata = 6;          // å…ƒæ•°æ®
  
  // ç»Ÿè®¡ä¿¡æ¯
  AgentStats stats = 7;
}

// Agent ç»Ÿè®¡ä¿¡æ¯
message AgentStats {
  int32 tokens_used = 1;           // Token ä½¿ç”¨é‡
  int64 duration_ms = 2;           // æ€»è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
  int32 tool_calls_count = 3;      // å·¥å…·è°ƒç”¨æ¬¡æ•°
  int32 retry_count = 4;           // é‡è¯•æ¬¡æ•°
}

// Agent æµå¼å“åº”å—
message AgentStreamChunk {
  string delta = 1;                // å¢é‡å†…å®¹
  string chunk_type = 2;           // ç±»å‹ï¼štext, tool_start, tool_end, reasoning
  map<string, string> metadata = 3;  // å…ƒæ•°æ®
  bool is_final = 4;               // æ˜¯å¦æœ€åä¸€å—
}

// å¯¹è¯è¯·æ±‚
message ChatRequest {
  string session_id = 1;                 // ä¼šè¯ ID
  repeated common.Message messages = 2;  // æ¶ˆæ¯å†å²
  string model = 3;                      // æ¨¡å‹
  float temperature = 4;                 // æ¸©åº¦
  int32 max_tokens = 5;                  // æœ€å¤§ Token æ•°
  map<string, string> context = 6;       // ä¸Šä¸‹æ–‡
  common.Metadata metadata = 7;          // å…ƒæ•°æ®
}

// å¯¹è¯å“åº”
message ChatResponse {
  common.Message message = 1;            // åŠ©æ‰‹æ¶ˆæ¯
  int32 tokens_used = 2;                 // Token ä½¿ç”¨é‡
  common.Status status = 3;              // çŠ¶æ€
}

// å¯¹è¯æµå¼å“åº”å—
message ChatStreamChunk {
  string delta = 1;                      // å¢é‡å†…å®¹
  bool is_final = 2;                     // æ˜¯å¦æœ€åä¸€å—
}

// å¥åº·æ£€æŸ¥è¯·æ±‚
message HealthRequest {}

// å¥åº·æ£€æŸ¥å“åº”
message HealthResponse {
  string status = 1;                     // çŠ¶æ€ï¼šhealthy, unhealthy
  map<string, string> details = 2;       // è¯¦ç»†ä¿¡æ¯
  int64 uptime_seconds = 3;              // è¿è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰
}
```

### 1.4 rag.proto

```protobuf
// proto/rag.proto
syntax = "proto3";

package qingyu.ai.rag;

import "common.proto";

option go_package = "Qingyu_backend/proto/ai/rag";

// RAG æœåŠ¡
service RAGService {
  // æœç´¢
  rpc Search(SearchRequest) returns (SearchResponse);
  
  // ç´¢å¼•æ–‡æ¡£
  rpc IndexDocument(IndexRequest) returns (IndexResponse);
  
  // åˆ é™¤æ–‡æ¡£
  rpc DeleteDocument(DeleteRequest) returns (DeleteResponse);
  
  // æ‰¹é‡ç´¢å¼•
  rpc BatchIndex(stream IndexRequest) returns (BatchIndexResponse);
}

// æœç´¢è¯·æ±‚
message SearchRequest {
  string query = 1;                    // æŸ¥è¯¢æ–‡æœ¬
  string user_id = 2;                  // ç”¨æˆ· ID
  string project_id = 3;               // é¡¹ç›® ID
  repeated string content_types = 4;   // å†…å®¹ç±»å‹è¿‡æ»¤
  int32 top_k = 5;                     // è¿”å›æ•°é‡
  SearchOptions options = 6;           // æœç´¢é€‰é¡¹
  common.Metadata metadata = 7;        // å…ƒæ•°æ®
}

// æœç´¢é€‰é¡¹
message SearchOptions {
  float min_score = 1;                 // æœ€å°ç›¸ä¼¼åº¦åˆ†æ•°
  bool enable_rerank = 2;              // å¯ç”¨é‡æ’åº
  bool enable_hybrid = 3;              // å¯ç”¨æ··åˆæ£€ç´¢
  map<string, string> filters = 4;     // é¢å¤–è¿‡æ»¤æ¡ä»¶
}

// æœç´¢å“åº”
message SearchResponse {
  repeated SearchResult results = 1;   // æœç´¢ç»“æœ
  int64 total_count = 2;               // æ€»æ•°
  int64 duration_ms = 3;               // è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
  common.Status status = 4;            // çŠ¶æ€
}

// æœç´¢ç»“æœ
message SearchResult {
  string document_id = 1;              // æ–‡æ¡£ ID
  string content = 2;                  // å†…å®¹
  float score = 3;                     // ç›¸ä¼¼åº¦åˆ†æ•°
  map<string, string> metadata = 4;    // å…ƒæ•°æ®
  string content_type = 5;             // å†…å®¹ç±»å‹
  repeated string highlights = 6;      // é«˜äº®ç‰‡æ®µ
}

// ç´¢å¼•è¯·æ±‚
message IndexRequest {
  string document_id = 1;              // æ–‡æ¡£ ID
  string content = 2;                  // å†…å®¹
  string content_type = 3;             // å†…å®¹ç±»å‹
  string user_id = 4;                  // ç”¨æˆ· ID
  string project_id = 5;               // é¡¹ç›® ID
  map<string, string> metadata = 6;    // å…ƒæ•°æ®
}

// ç´¢å¼•å“åº”
message IndexResponse {
  string document_id = 1;              // æ–‡æ¡£ ID
  bool success = 2;                    // æ˜¯å¦æˆåŠŸ
  string message = 3;                  // æ¶ˆæ¯
  int32 chunks_count = 4;              // åˆ†å—æ•°é‡
}

// æ‰¹é‡ç´¢å¼•å“åº”
message BatchIndexResponse {
  int32 total = 1;                     // æ€»æ•°
  int32 success_count = 2;             // æˆåŠŸæ•°
  int32 failed_count = 3;              // å¤±è´¥æ•°
  repeated string failed_ids = 4;      // å¤±è´¥çš„æ–‡æ¡£ ID
}

// åˆ é™¤è¯·æ±‚
message DeleteRequest {
  string document_id = 1;              // æ–‡æ¡£ ID
  string user_id = 2;                  // ç”¨æˆ· ID
}

// åˆ é™¤å“åº”
message DeleteResponse {
  bool success = 1;                    // æ˜¯å¦æˆåŠŸ
  string message = 2;                  // æ¶ˆæ¯
}
```

### 1.5 tool.proto

```protobuf
// proto/tool.proto
syntax = "proto3";

package qingyu.ai.tool;

import "common.proto";

option go_package = "Qingyu_backend/proto/ai/tool";

// å·¥å…·æœåŠ¡
service ToolService {
  // è°ƒç”¨å·¥å…·
  rpc CallTool(ToolRequest) returns (ToolResponse);
  
  // è·å–å·¥å…·åˆ—è¡¨
  rpc ListTools(ListToolsRequest) returns (ListToolsResponse);
  
  // è·å–å·¥å…·ä¿¡æ¯
  rpc GetToolInfo(GetToolInfoRequest) returns (ToolInfo);
}

// å·¥å…·è¯·æ±‚
message ToolRequest {
  string tool_name = 1;                // å·¥å…·åç§°
  string parameters = 2;               // å‚æ•°ï¼ˆJSON æ ¼å¼ï¼‰
  string user_id = 3;                  // ç”¨æˆ· ID
  string project_id = 4;               // é¡¹ç›® ID
  common.Metadata metadata = 5;        // å…ƒæ•°æ®
}

// å·¥å…·å“åº”
message ToolResponse {
  string result = 1;                   // ç»“æœï¼ˆJSON æ ¼å¼ï¼‰
  bool success = 2;                    // æ˜¯å¦æˆåŠŸ
  string error = 3;                    // é”™è¯¯ä¿¡æ¯
  int64 duration_ms = 4;               // è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
  common.Status status = 5;            // çŠ¶æ€
}

// å·¥å…·åˆ—è¡¨è¯·æ±‚
message ListToolsRequest {
  string category = 1;                 // åˆ†ç±»è¿‡æ»¤
}

// å·¥å…·åˆ—è¡¨å“åº”
message ListToolsResponse {
  repeated ToolInfo tools = 1;         // å·¥å…·åˆ—è¡¨
}

// è·å–å·¥å…·ä¿¡æ¯è¯·æ±‚
message GetToolInfoRequest {
  string tool_name = 1;                // å·¥å…·åç§°
}

// å·¥å…·ä¿¡æ¯
message ToolInfo {
  string name = 1;                     // å·¥å…·åç§°
  string description = 2;              // æè¿°
  string category = 3;                 // åˆ†ç±»
  repeated ToolParameter parameters = 4;  // å‚æ•°å®šä¹‰
  bool requires_auth = 5;              // æ˜¯å¦éœ€è¦è®¤è¯
}

// å·¥å…·å‚æ•°
message ToolParameter {
  string name = 1;                     // å‚æ•°å
  string type = 2;                     // ç±»å‹
  string description = 3;              // æè¿°
  bool required = 4;                   // æ˜¯å¦å¿…éœ€
  string default_value = 5;            // é»˜è®¤å€¼
}
```

---

## äºŒã€Go AI Proxy Service å®ç°

### 2.1 Service æ¥å£å®šä¹‰

```go
// service/ai/proxy_service.go
package ai

import (
	"context"
	"io"
	"time"
)

// AIProxyService AIä»£ç†æœåŠ¡æ¥å£
type AIProxyService interface {
	// Agent ç›¸å…³
	ExecuteAgent(ctx context.Context, req *AgentRequest) (*AgentResponse, error)
	ExecuteAgentStream(ctx context.Context, req *AgentRequest) (<-chan *StreamChunk, error)
	
	// å¯¹è¯ç›¸å…³
	Chat(ctx context.Context, req *ChatRequest) (*ChatResponse, error)
	ChatStream(ctx context.Context, req *ChatRequest) (<-chan *StreamChunk, error)
	
	// RAG ç›¸å…³
	RAGSearch(ctx context.Context, req *RAGSearchRequest) (*RAGSearchResponse, error)
	RAGIndex(ctx context.Context, req *RAGIndexRequest) error
	
	// å·¥å…·ç›¸å…³
	CallTool(ctx context.Context, req *ToolRequest) (*ToolResponse, error)
	ListTools(ctx context.Context, category string) ([]*ToolInfo, error)
	
	// å¥åº·æ£€æŸ¥
	Health(ctx context.Context) error
	
	// å…³é—­
	Close() error
}

// AgentRequest Agent æ‰§è¡Œè¯·æ±‚
type AgentRequest struct {
	AgentType   string            `json:"agentType" validate:"required,oneof=creative outline character plot review"`
	Task        string            `json:"task" validate:"required"`
	Context     map[string]string `json:"context"`
	Tools       []string          `json:"tools"`
	UserID      string            `json:"userId"`
	ProjectID   string            `json:"projectId"`
	Options     *AgentOptions     `json:"options"`
	Stream      bool              `json:"stream"`
}

// AgentOptions Agent é€‰é¡¹
type AgentOptions struct {
	Model           string  `json:"model"`
	Temperature     float32 `json:"temperature"`
	MaxTokens       int     `json:"maxTokens"`
	MaxRetries      int     `json:"maxRetries"`
	TimeoutSeconds  int     `json:"timeoutSeconds"`
	EnableReasoning bool    `json:"enableReasoning"`
}

// AgentResponse Agent æ‰§è¡Œå“åº”
type AgentResponse struct {
	Output    string              `json:"output"`
	ToolCalls []ToolCallRecord    `json:"toolCalls"`
	Status    string              `json:"status"`
	Reasoning []string            `json:"reasoning"`
	Stats     *AgentStats         `json:"stats"`
}

// AgentStats Agent ç»Ÿè®¡ä¿¡æ¯
type AgentStats struct {
	TokensUsed     int   `json:"tokensUsed"`
	DurationMs     int64 `json:"durationMs"`
	ToolCallsCount int   `json:"toolCallsCount"`
	RetryCount     int   `json:"retryCount"`
}

// StreamChunk æµå¼å“åº”å—
type StreamChunk struct {
	Delta     string            `json:"delta"`
	ChunkType string            `json:"chunkType"`
	Metadata  map[string]string `json:"metadata"`
	IsFinal   bool              `json:"isFinal"`
	Error     string            `json:"error,omitempty"`
}

// ToolCallRecord å·¥å…·è°ƒç”¨è®°å½•
type ToolCallRecord struct {
	ToolName   string                 `json:"toolName"`
	Parameters map[string]interface{} `json:"parameters"`
	Result     interface{}            `json:"result"`
	DurationMs int64                  `json:"durationMs"`
	Success    bool                   `json:"success"`
}
```

### 2.2 Service å®ç°

```go
// service/ai/proxy_service_impl.go
package ai

import (
	"context"
	"fmt"
	"io"
	"sync"
	"time"
	
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/keepalive"
	"google.golang.org/grpc/status"
	
	pb "Qingyu_backend/proto/ai/agent"
	ragpb "Qingyu_backend/proto/ai/rag"
	toolpb "Qingyu_backend/proto/ai/tool"
	"Qingyu_backend/pkg/errors"
	"Qingyu_backend/pkg/logger"
)

// AIProxyServiceImpl AIä»£ç†æœåŠ¡å®ç°
type AIProxyServiceImpl struct {
	// gRPC å®¢æˆ·ç«¯
	agentClient pb.AIAgentServiceClient
	ragClient   ragpb.RAGServiceClient
	toolClient  toolpb.ToolServiceClient
	conn        *grpc.ClientConn
	
	// æœåŠ¡ä¿æŠ¤
	circuitBreaker *CircuitBreaker
	rateLimiter    *RateLimiter
	
	// é…ç½®
	config *ProxyConfig
	
	// æ—¥å¿—
	logger logger.Logger
	
	// çŠ¶æ€
	mu      sync.RWMutex
	healthy bool
}

// ProxyConfig ä»£ç†é…ç½®
type ProxyConfig struct {
	PythonAddr       string        `mapstructure:"python_addr"`
	Timeout          time.Duration `mapstructure:"timeout"`
	MaxRetries       int           `mapstructure:"max_retries"`
	RateLimit        int           `mapstructure:"rate_limit"` // QPS
	CircuitMaxFails  int           `mapstructure:"circuit_max_fails"`
	CircuitResetTime time.Duration `mapstructure:"circuit_reset_time"`
	EnableMetrics    bool          `mapstructure:"enable_metrics"`
}

// NewAIProxyService åˆ›å»º AI ä»£ç†æœåŠ¡
func NewAIProxyService(config *ProxyConfig, logger logger.Logger) (*AIProxyServiceImpl, error) {
	// å»ºç«‹ gRPC è¿æ¥
	conn, err := grpc.Dial(
		config.PythonAddr,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
		grpc.WithTimeout(10*time.Second),
		grpc.WithKeepaliveParams(keepalive.ClientParameters{
			Time:                10 * time.Second,
			Timeout:             3 * time.Second,
			PermitWithoutStream: true,
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("è¿æ¥ Python AI æœåŠ¡å¤±è´¥: %w", err)
	}
	
	// åˆ›å»º gRPC å®¢æˆ·ç«¯
	agentClient := pb.NewAIAgentServiceClient(conn)
	ragClient := ragpb.NewRAGServiceClient(conn)
	toolClient := toolpb.NewToolServiceClient(conn)
	
	// åˆ›å»ºæœåŠ¡ä¿æŠ¤ç»„ä»¶
	circuitBreaker := NewCircuitBreaker(
		config.CircuitMaxFails,
		config.CircuitResetTime,
	)
	
	rateLimiter := NewRateLimiter(
		config.RateLimit,
		time.Second,
	)
	
	service := &AIProxyServiceImpl{
		agentClient:    agentClient,
		ragClient:      ragClient,
		toolClient:     toolClient,
		conn:           conn,
		circuitBreaker: circuitBreaker,
		rateLimiter:    rateLimiter,
		config:         config,
		logger:         logger,
		healthy:        true,
	}
	
	// å¯åŠ¨å¥åº·æ£€æŸ¥
	go service.healthCheckLoop()
	
	return service, nil
}

// ExecuteAgent æ‰§è¡Œ Agentï¼ˆåŒæ­¥ï¼‰
func (s *AIProxyServiceImpl) ExecuteAgent(ctx context.Context, req *AgentRequest) (*AgentResponse, error) {
	// 1. é™æµæ£€æŸ¥
	if !s.rateLimiter.Allow() {
		s.logger.Warn("è¯·æ±‚è¢«é™æµæ‹’ç»")
		return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
	}
	
	// 2. ç†”æ–­æ£€æŸ¥
	if !s.circuitBreaker.Allow() {
		s.logger.Warn("ç†”æ–­å™¨å¼€å¯ï¼Œæ‹’ç»è¯·æ±‚")
		return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•")
	}
	
	// 3. è®¾ç½®è¶…æ—¶
	timeout := s.config.Timeout
	if req.Options != nil && req.Options.TimeoutSeconds > 0 {
		timeout = time.Duration(req.Options.TimeoutSeconds) * time.Second
	}
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()
	
	// 4. è½¬æ¢è¯·æ±‚
	pbReq := &pb.AgentRequest{
		AgentType: req.AgentType,
		Task:      req.Task,
		Context:   req.Context,
		Tools:     req.Tools,
		UserId:    req.UserID,
		ProjectId: req.ProjectID,
		Metadata: &pb.Metadata{
			RequestId: generateRequestID(),
			UserId:    req.UserID,
			ProjectId: req.ProjectID,
			Timestamp: time.Now().Unix(),
		},
	}
	
	if req.Options != nil {
		pbReq.Options = &pb.AgentOptions{
			Model:           req.Options.Model,
			Temperature:     req.Options.Temperature,
			MaxTokens:       int32(req.Options.MaxTokens),
			MaxRetries:      int32(req.Options.MaxRetries),
			TimeoutSeconds:  int32(req.Options.TimeoutSeconds),
			EnableReasoning: req.Options.EnableReasoning,
		}
	}
	
	// 5. è°ƒç”¨ Python æœåŠ¡
	s.logger.Info("è°ƒç”¨ Python AI æœåŠ¡æ‰§è¡Œ Agent",
		"agent_type", req.AgentType,
		"task_len", len(req.Task),
		"tools", req.Tools,
	)
	
	start := time.Now()
	resp, err := s.agentClient.ExecuteAgent(ctx, pbReq)
	duration := time.Since(start)
	
	if err != nil {
		s.circuitBreaker.RecordFailure()
		s.logger.Error("è°ƒç”¨ Python AI æœåŠ¡å¤±è´¥",
			"error", err,
			"duration", duration,
		)
		return nil, s.convertError(err)
	}
	
	s.circuitBreaker.RecordSuccess()
	s.logger.Info("Python AI æœåŠ¡è°ƒç”¨æˆåŠŸ",
		"duration", duration,
		"tokens_used", resp.Stats.TokensUsed,
		"tool_calls", resp.Stats.ToolCallsCount,
	)
	
	// 6. è®°å½•æŒ‡æ ‡
	if s.config.EnableMetrics {
		recordAgentMetrics(req.AgentType, duration, resp.Status, resp.Stats)
	}
	
	// 7. è½¬æ¢å“åº”
	return s.convertAgentResponse(resp), nil
}

// ExecuteAgentStream æ‰§è¡Œ Agentï¼ˆæµå¼ï¼‰
func (s *AIProxyServiceImpl) ExecuteAgentStream(ctx context.Context, req *AgentRequest) (<-chan *StreamChunk, error) {
	// 1. é™æµå’Œç†”æ–­æ£€æŸ¥
	if !s.rateLimiter.Allow() {
		return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹")
	}
	if !s.circuitBreaker.Allow() {
		return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
	}
	
	// 2. è½¬æ¢è¯·æ±‚
	pbReq := &pb.AgentRequest{
		AgentType: req.AgentType,
		Task:      req.Task,
		Context:   req.Context,
		Tools:     req.Tools,
		UserId:    req.UserID,
		ProjectId: req.ProjectID,
	}
	
	// 3. è°ƒç”¨ gRPC æµå¼æ¥å£
	s.logger.Info("è°ƒç”¨ Python AI æœåŠ¡æµå¼æ‰§è¡Œ Agent", "agent_type", req.AgentType)
	
	stream, err := s.agentClient.ExecuteAgentStream(ctx, pbReq)
	if err != nil {
		s.circuitBreaker.RecordFailure()
		s.logger.Error("åˆ›å»ºæµå¼è°ƒç”¨å¤±è´¥", "error", err)
		return nil, s.convertError(err)
	}
	
	// 4. åˆ›å»ºè¾“å‡º channel
	chunkChan := make(chan *StreamChunk, 100)
	
	// 5. å¼‚æ­¥æ¥æ”¶æµå¼æ•°æ®
	go s.handleAgentStream(ctx, stream, chunkChan)
	
	return chunkChan, nil
}

// handleAgentStream å¤„ç† Agent æµå¼å“åº”
func (s *AIProxyServiceImpl) handleAgentStream(
	ctx context.Context,
	stream pb.AIAgentService_ExecuteAgentStreamClient,
	chunkChan chan<- *StreamChunk,
) {
	defer close(chunkChan)
	
	start := time.Now()
	chunkCount := 0
	
	for {
		select {
		case <-ctx.Done():
			s.logger.Warn("æµå¼è°ƒç”¨è¢«å–æ¶ˆ", "reason", ctx.Err())
			chunkChan <- &StreamChunk{
				Error: "è¯·æ±‚å·²å–æ¶ˆ",
			}
			return
			
		default:
			chunk, err := stream.Recv()
			if err == io.EOF {
				// æµç»“æŸ
				s.circuitBreaker.RecordSuccess()
				s.logger.Info("æµå¼è°ƒç”¨å®Œæˆ",
					"duration", time.Since(start),
					"chunks", chunkCount,
				)
				return
			}
			
			if err != nil {
				s.circuitBreaker.RecordFailure()
				s.logger.Error("æµå¼æ¥æ”¶å¤±è´¥", "error", err)
				chunkChan <- &StreamChunk{
					Error: s.convertError(err).Error(),
				}
				return
			}
			
			// å‘é€ chunk
			chunkChan <- &StreamChunk{
				Delta:     chunk.Delta,
				ChunkType: chunk.ChunkType,
				Metadata:  chunk.Metadata,
				IsFinal:   chunk.IsFinal,
			}
			chunkCount++
		}
	}
}

// convertAgentResponse è½¬æ¢ Agent å“åº”
func (s *AIProxyServiceImpl) convertAgentResponse(resp *pb.AgentResponse) *AgentResponse {
	toolCalls := make([]ToolCallRecord, len(resp.ToolCalls))
	for i, tc := range resp.ToolCalls {
		var params map[string]interface{}
		json.Unmarshal([]byte(tc.Parameters), &params)
		
		var result interface{}
		json.Unmarshal([]byte(tc.Result), &result)
		
		toolCalls[i] = ToolCallRecord{
			ToolName:   tc.ToolName,
			Parameters: params,
			Result:     result,
			DurationMs: tc.DurationMs,
			Success:    tc.Status != nil && tc.Status.Code == 0,
		}
	}
	
	return &AgentResponse{
		Output:    resp.Output,
		ToolCalls: toolCalls,
		Status:    resp.Status,
		Reasoning: resp.Reasoning,
		Stats: &AgentStats{
			TokensUsed:     int(resp.Stats.TokensUsed),
			DurationMs:     resp.Stats.DurationMs,
			ToolCallsCount: int(resp.Stats.ToolCallsCount),
			RetryCount:     int(resp.Stats.RetryCount),
		},
	}
}

// convertError é”™è¯¯è½¬æ¢
func (s *AIProxyServiceImpl) convertError(err error) error {
	st, ok := status.FromError(err)
	if !ok {
		return errors.NewInternalError("AIæœåŠ¡è°ƒç”¨å¤±è´¥").WithCause(err)
	}
	
	switch st.Code() {
	case codes.DeadlineExceeded:
		return errors.NewTimeoutError("AIæœåŠ¡å“åº”è¶…æ—¶")
	case codes.Unavailable:
		return errors.NewServiceUnavailableError("AIæœåŠ¡ä¸å¯ç”¨")
	case codes.InvalidArgument:
		return errors.NewValidationError(st.Message())
	case codes.ResourceExhausted:
		return errors.NewRateLimitError("AIæœåŠ¡èµ„æºè€—å°½")
	default:
		return errors.NewInternalError(st.Message()).WithCause(err)
	}
}

// Health å¥åº·æ£€æŸ¥
func (s *AIProxyServiceImpl) Health(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	
	resp, err := s.agentClient.HealthCheck(ctx, &pb.HealthRequest{})
	if err != nil {
		return fmt.Errorf("å¥åº·æ£€æŸ¥å¤±è´¥: %w", err)
	}
	
	if resp.Status != "healthy" {
		return fmt.Errorf("æœåŠ¡çŠ¶æ€å¼‚å¸¸: %s", resp.Status)
	}
	
	return nil
}

// healthCheckLoop å¥åº·æ£€æŸ¥å¾ªç¯
func (s *AIProxyServiceImpl) healthCheckLoop() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		err := s.Health(context.Background())
		
		s.mu.Lock()
		s.healthy = (err == nil)
		s.mu.Unlock()
		
		if err != nil {
			s.logger.Warn("å¥åº·æ£€æŸ¥å¤±è´¥", "error", err)
		}
	}
}

// Close å…³é—­è¿æ¥
func (s *AIProxyServiceImpl) Close() error {
	if s.conn != nil {
		return s.conn.Close()
	}
	return nil
}

// generateRequestID ç”Ÿæˆè¯·æ±‚ ID
func generateRequestID() string {
	return fmt.Sprintf("req_%d_%s", time.Now().UnixNano(), uuid.New().String()[:8])
}
```

---

## ä¸‰ã€æµå¼å“åº”ä»£ç†

### 3.1 SSE æµå¼å¤„ç†

```go
// api/v1/ai/stream_handler.go
package ai

import (
	"fmt"
	"net/http"
	
	"github.com/gin-gonic/gin"
	
	"Qingyu_backend/service/ai"
)

// StreamSSE SSE æµå¼å“åº”
func StreamSSE(c *gin.Context, chunkChan <-chan *ai.StreamChunk) {
	// è®¾ç½® SSE å“åº”å¤´
	c.Header("Content-Type", "text/event-stream")
	c.Header("Cache-Control", "no-cache")
	c.Header("Connection", "keep-alive")
	c.Header("X-Accel-Buffering", "no") // ç¦ç”¨ Nginx ç¼“å†²
	
	// è®¾ç½® Flusher
	flusher, ok := c.Writer.(http.Flusher)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ä¸æ”¯æŒæµå¼å“åº”"})
		return
	}
	
	// æµå¼æ¨é€
	for chunk := range chunkChan {
		// æ£€æŸ¥é”™è¯¯
		if chunk.Error != "" {
			c.SSEvent("error", gin.H{
				"error": chunk.Error,
			})
			flusher.Flush()
			break
		}
		
		// å‘é€æ•°æ®
		c.SSEvent("message", gin.H{
			"delta":     chunk.Delta,
			"type":      chunk.ChunkType,
			"metadata":  chunk.Metadata,
			"is_final":  chunk.IsFinal,
		})
		flusher.Flush()
		
		// æ£€æŸ¥æ˜¯å¦æœ€åä¸€å—
		if chunk.IsFinal {
			c.SSEvent("done", gin.H{"status": "completed"})
			flusher.Flush()
			break
		}
	}
}
```

### 3.2 WebSocket æµå¼å¤„ç†

```go
// api/v1/ai/websocket_handler.go
package ai

import (
	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
	
	"Qingyu_backend/service/ai"
)

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true // ç”Ÿäº§ç¯å¢ƒéœ€è¦æ£€æŸ¥ Origin
	},
}

// StreamWebSocket WebSocket æµå¼å“åº”
func StreamWebSocket(c *gin.Context, chunkChan <-chan *ai.StreamChunk) {
	// å‡çº§åˆ° WebSocket
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		return
	}
	defer conn.Close()
	
	// æµå¼æ¨é€
	for chunk := range chunkChan {
		// æ£€æŸ¥é”™è¯¯
		if chunk.Error != "" {
			conn.WriteJSON(map[string]interface{}{
				"type":  "error",
				"error": chunk.Error,
			})
			break
		}
		
		// å‘é€æ•°æ®
		err := conn.WriteJSON(map[string]interface{}{
			"type":      "chunk",
			"delta":     chunk.Delta,
			"chunk_type": chunk.ChunkType,
			"metadata":  chunk.Metadata,
			"is_final":  chunk.IsFinal,
		})
		
		if err != nil {
			break
		}
		
		// æ£€æŸ¥æ˜¯å¦æœ€åä¸€å—
		if chunk.IsFinal {
			conn.WriteJSON(map[string]interface{}{
				"type":   "done",
				"status": "completed",
			})
			break
		}
	}
}
```

---

## å››ã€é”™è¯¯å¤„ç†å’Œé‡è¯•

### 4.1 é”™è¯¯åˆ†ç±»å’Œè½¬æ¢

```go
// pkg/errors/ai_errors.go
package errors

// AI æœåŠ¡é”™è¯¯ç±»å‹
const (
	CategoryAI ErrorCategory = "ai"
)

// NewAIError åˆ›å»º AI é”™è¯¯
func NewAIError(code int, message string) *UnifiedError {
	return &UnifiedError{
		Code:       code,
		Category:   CategoryAI,
		Message:    message,
		HTTPStatus: 500,
		Service:    "ai_proxy",
	}
}

// AI ç‰¹å®šé”™è¯¯ç 
const (
	ErrCodeAgentExecutionFailed = 5001
	ErrCodeRAGSearchFailed      = 5002
	ErrCodeToolCallFailed       = 5003
	ErrCodeModelNotAvailable    = 5004
)
```

### 4.2 é‡è¯•ç­–ç•¥

```go
// service/ai/retry.go
package ai

import (
	"context"
	"time"
	
	"github.com/avast/retry-go"
)

// WithRetry å¸¦é‡è¯•çš„æ‰§è¡Œ
func (s *AIProxyServiceImpl) WithRetry(
	ctx context.Context,
	operation func(context.Context) error,
) error {
	return retry.Do(
		func() error {
			return operation(ctx)
		},
		retry.Attempts(uint(s.config.MaxRetries)),
		retry.Delay(1*time.Second),
		retry.DelayType(retry.BackOffDelay),
		retry.OnRetry(func(n uint, err error) {
			s.logger.Warn("é‡è¯•æ‰§è¡Œ",
				"attempt", n+1,
				"error", err,
			)
		}),
		retry.RetryIf(func(err error) bool {
			// åªé‡è¯•ä¸´æ—¶æ€§é”™è¯¯
			return isRetryableError(err)
		}),
	)
}

// isRetryableError åˆ¤æ–­æ˜¯å¦å¯é‡è¯•é”™è¯¯
func isRetryableError(err error) bool {
	if err == nil {
		return false
	}
	
	// è¶…æ—¶é”™è¯¯å¯é‡è¯•
	if errors.IsTimeout(err) {
		return true
	}
	
	// æœåŠ¡ä¸å¯ç”¨å¯é‡è¯•
	if errors.IsServiceUnavailable(err) {
		return true
	}
	
	// é™æµé”™è¯¯ä¸é‡è¯•
	if errors.IsRateLimit(err) {
		return false
	}
	
	return false
}
```

---

## äº”ã€ç›‘æ§å’ŒæŒ‡æ ‡

### 5.1 Prometheus æŒ‡æ ‡

```go
// service/ai/metrics.go
package ai

import (
	"time"
	
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

var (
	// Agent è¯·æ±‚è®¡æ•°
	agentRequestsTotal = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "ai_agent_requests_total",
			Help: "Total number of agent requests",
		},
		[]string{"agent_type", "status"},
	)
	
	// Agent æ‰§è¡Œæ—¶é•¿
	agentDurationSeconds = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "ai_agent_duration_seconds",
			Help:    "Agent execution duration in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"agent_type"},
	)
	
	// Token ä½¿ç”¨é‡
	agentTokensUsed = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "ai_agent_tokens_used",
			Help:    "Number of tokens used by agent",
			Buckets: []float64{100, 500, 1000, 2000, 5000, 10000},
		},
		[]string{"agent_type"},
	)
	
	// å·¥å…·è°ƒç”¨è®¡æ•°
	toolCallsTotal = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "ai_tool_calls_total",
			Help: "Total number of tool calls",
		},
		[]string{"tool_name", "status"},
	)
)

// recordAgentMetrics è®°å½• Agent æŒ‡æ ‡
func recordAgentMetrics(agentType string, duration time.Duration, status string, stats *AgentStats) {
	agentRequestsTotal.WithLabelValues(agentType, status).Inc()
	agentDurationSeconds.WithLabelValues(agentType).Observe(duration.Seconds())
	agentTokensUsed.WithLabelValues(agentType).Observe(float64(stats.TokensUsed))
}
```

---

## å…­ã€éƒ¨ç½²å’Œé…ç½®

### 6.1 é…ç½®ç¤ºä¾‹

```yaml
# config/config.yaml
ai:
  proxy:
    python_addr: "localhost:50051"
    timeout: 60s
    max_retries: 3
    rate_limit: 100  # 100 QPS
    circuit_max_fails: 5
    circuit_reset_time: 30s
    enable_metrics: true
```

### 6.2 æœåŠ¡åˆå§‹åŒ–

```go
// cmd/server/main.go
func initAIProxyService(cfg *config.Config) ai.AIProxyService {
	proxyConfig := &ai.ProxyConfig{
		PythonAddr:       cfg.AI.Proxy.PythonAddr,
		Timeout:          cfg.AI.Proxy.Timeout,
		MaxRetries:       cfg.AI.Proxy.MaxRetries,
		RateLimit:        cfg.AI.Proxy.RateLimit,
		CircuitMaxFails:  cfg.AI.Proxy.CircuitMaxFails,
		CircuitResetTime: cfg.AI.Proxy.CircuitResetTime,
		EnableMetrics:    cfg.AI.Proxy.EnableMetrics,
	}
	
	proxyService, err := ai.NewAIProxyService(proxyConfig, logger)
	if err != nil {
		log.Fatal("åˆå§‹åŒ– AI ä»£ç†æœåŠ¡å¤±è´¥:", err)
	}
	
	// å¥åº·æ£€æŸ¥
	if err := proxyService.Health(context.Background()); err != nil {
		log.Warn("Python AI æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥:", err)
	}
	
	return proxyService
}
```

---

## ä¸ƒã€æµ‹è¯•ç­–ç•¥

### 7.1 å•å…ƒæµ‹è¯•

```go
// service/ai/proxy_service_test.go
package ai

import (
	"context"
	"testing"
	
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// ä½¿ç”¨ mock gRPC å®¢æˆ·ç«¯æµ‹è¯•
func TestExecuteAgent(t *testing.T) {
	// Mock gRPC å®¢æˆ·ç«¯
	mockClient := new(MockAIAgentServiceClient)
	
	service := &AIProxyServiceImpl{
		agentClient: mockClient,
		// ...
	}
	
	// è®¾ç½® mock æœŸæœ›
	mockClient.On("ExecuteAgent", mock.Anything, mock.Anything).
		Return(&pb.AgentResponse{
			Output: "Test output",
			Status: "completed",
		}, nil)
	
	// æ‰§è¡Œæµ‹è¯•
	result, err := service.ExecuteAgent(context.Background(), &AgentRequest{
		AgentType: "creative",
		Task:      "Test task",
	})
	
	assert.NoError(t, err)
	assert.Equal(t, "Test output", result.Output)
	assert.Equal(t, "completed", result.Status)
}
```

---

## å…«ã€æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†å®šä¹‰äº† Go åç«¯ä¸ Python AI æœåŠ¡ä¹‹é—´çš„é€šä¿¡åè®®ï¼ŒåŒ…æ‹¬ï¼š

- âœ… å®Œæ•´çš„ gRPC Proto å®šä¹‰
- âœ… Go AI Proxy Service å®ç°
- âœ… æµå¼å“åº”ä»£ç†æœºåˆ¶ï¼ˆSSE/WebSocketï¼‰
- âœ… é”™è¯¯å¤„ç†å’Œé‡è¯•ç­–ç•¥
- âœ… ç›‘æ§æŒ‡æ ‡å’Œå¯è§‚æµ‹æ€§
- âœ… éƒ¨ç½²é…ç½®å’Œæµ‹è¯•ç­–ç•¥

**åç»­å·¥ä½œ**ï¼š
- å®ç° Python ç«¯çš„ gRPC Server
- å®Œå–„æµå¼å“åº”å¤„ç†
- æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-10-27
**ç»´æŠ¤è€…**: AIæ¶æ„ç»„
