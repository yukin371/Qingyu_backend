# 缓存策略设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库,统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考:[微服务架构划分建议](../微服务架构划分建议.md)
> 
> **文档状态**: ✅ MVP核心功能  
> **创建时间**: 2025-10-17  
> **最后更新**: 2025-10-17  
> **实施状态**: 🟡 进行中 (80%)

## 1. 需求概述

### 1.1 功能描述

缓存策略是青羽平台的核心性能优化手段,通过合理的缓存设计提升系统响应速度、降低数据库压力、改善用户体验。系统采用Redis作为缓存层,支持多级缓存、缓存预热、失效策略、缓存穿透防护等功能,确保系统的高性能和高可用性。

### 1.2 业务价值

- **性能提升**:减少数据库查询,提升接口响应速度(90%以上请求命中缓存)
- **降低成本**:减少数据库负载,延迟数据库扩容时间
- **改善体验**:快速响应用户请求,提升用户满意度
- **系统稳定**:缓存作为数据库的保护层,提升系统稳定性

### 1.3 应用场景

- 用户信息缓存(高频读取,低频更新)
- 书籍信息和章节内容缓存(热门内容)
- 推荐结果缓存(预计算结果)
- 榜单数据缓存(定时更新)
- 会话信息缓存(JWT Token校验)
- 权限信息缓存(RBAC权限检查)

### 1.4 功能边界

- **包含功能**:缓存读写、失效策略、预热、穿透防护、雪崩防护、热点数据优化
- **不包含功能**:分布式缓存一致性、缓存数据持久化、缓存集群管理

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    应用层                                │
│  Service Layer (各业务模块)                              │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                  缓存抽象层                              │
│  CacheService (统一缓存接口)                             │
│  ├─ Get/Set/Delete                                      │
│  ├─ GetOrLoad (缓存未命中时加载)                        │
│  ├─ Batch Operations (批量操作)                         │
│  └─ TTL Management (过期时间管理)                       │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                  Redis缓存层                             │
│  ├─ String (简单键值对)                                 │
│  ├─ Hash (对象存储)                                     │
│  ├─ List (列表数据)                                     │
│  ├─ Set (集合数据)                                      │
│  └─ Sorted Set (排行榜)                                 │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                  数据源层                                │
│  MongoDB (持久化数据)                                    │
└─────────────────────────────────────────────────────────┘
```

### 2.2 缓存层级

**L1缓存 - 应用内存(可选)**
- 使用场景:极高频访问的配置数据
- 容量:小于100MB
- TTL:5-30分钟
- 更新策略:定时刷新

**L2缓存 - Redis**
- 使用场景:所有需要缓存的业务数据
- 容量:根据需求扩展(初期4-8GB)
- TTL:按业务场景设置(1分钟-24小时)
- 更新策略:主动失效 + 被动过期

## 3. 缓存接口设计

### 3.1 统一缓存接口

```go
// CacheService 缓存服务接口
type CacheService interface {
    // 基础操作
    Get(ctx context.Context, key string) (string, error)
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    
    // 批量操作
    MGet(ctx context.Context, keys []string) ([]string, error)
    MSet(ctx context.Context, items map[string]interface{}, ttl time.Duration) error
    MDelete(ctx context.Context, keys []string) error
    
    // 高级操作
    GetOrLoad(ctx context.Context, key string, ttl time.Duration, loader func() (interface{}, error)) (interface{}, error)
    Increment(ctx context.Context, key string, delta int64) (int64, error)
    Expire(ctx context.Context, key string, ttl time.Duration) error
    
    // Hash操作
    HGet(ctx context.Context, key, field string) (string, error)
    HSet(ctx context.Context, key, field string, value interface{}) error
    HGetAll(ctx context.Context, key string) (map[string]string, error)
    
    // 集合操作
    SAdd(ctx context.Context, key string, members ...interface{}) error
    SMembers(ctx context.Context, key string) ([]string, error)
    
    // 有序集合操作(排行榜)
    ZAdd(ctx context.Context, key string, score float64, member string) error
    ZRange(ctx context.Context, key string, start, stop int64) ([]string, error)
    ZRevRange(ctx context.Context, key string, start, stop int64) ([]string, error)
}
```

### 3.2 GetOrLoad模式(缓存穿透防护)

```go
// GetOrLoad 缓存未命中时自动加载
func (s *CacheServiceImpl) GetOrLoad(
    ctx context.Context,
    key string,
    ttl time.Duration,
    loader func() (interface{}, error),
) (interface{}, error) {
    // 1. 尝试从缓存获取
    cached, err := s.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 2. 缓存未命中,使用分布式锁防止缓存击穿
    lockKey := "lock:" + key
    acquired, err := s.acquireLock(ctx, lockKey, 10*time.Second)
    if err != nil {
        return nil, err
    }
    
    if !acquired {
        // 等待其他线程加载完成
        time.Sleep(100 * time.Millisecond)
        return s.Get(ctx, key)
    }
    
    defer s.releaseLock(ctx, lockKey)
    
    // 3. 双重检查(可能其他线程已经加载)
    cached, err = s.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 4. 执行加载函数
    data, err := loader()
    if err != nil {
        return nil, err
    }
    
    // 5. 保存到缓存
    if data == nil {
        // 空值缓存(防止缓存穿透),TTL较短
        s.Set(ctx, key, "null", 5*time.Minute)
        return nil, errors.New("数据不存在")
    }
    
    s.Set(ctx, key, data, ttl)
    return data, nil
}
```

## 4. 缓存策略

### 4.1 缓存Key设计规范

```go
// Key命名规范: {业务模块}:{资源类型}:{资源ID}:{子资源}
const (
    // 用户相关
    KeyUserInfo        = "user:info:%s"          // 用户基本信息
    KeyUserPermissions = "user:permissions:%s"   // 用户权限列表
    KeyUserSession     = "user:session:%s"       // 用户会话
    
    // 书籍相关
    KeyBookInfo        = "book:info:%s"          // 书籍信息
    KeyBookChapter     = "book:chapter:%s:%d"    // 章节内容
    KeyBookRanking     = "book:ranking:%s"       // 书籍排行榜
    
    // 推荐相关
    KeyRecommendUser   = "recommend:user:%s"     // 用户个性化推荐
    KeyRecommendHot    = "recommend:hot:%s"      // 热门推荐
    
    // 统计相关
    KeyStatsBookView   = "stats:book:view:%s"    // 书籍浏览量
    KeyStatsUserActive = "stats:user:active:%s"  // 用户活跃度
)

// 生成缓存Key
func UserInfoKey(userID string) string {
    return fmt.Sprintf(KeyUserInfo, userID)
}

func BookChapterKey(bookID string, chapterNum int) string {
    return fmt.Sprintf(KeyBookChapter, bookID, chapterNum)
}
```

### 4.2 TTL策略

```go
// 缓存过期时间配置
const (
    // 短期缓存(高频更新)
    TTLShort         = 5 * time.Minute    // 5分钟
    TTLUserSession   = 30 * time.Minute   // 会话30分钟
    
    // 中期缓存(正常业务)
    TTLMedium        = 1 * time.Hour      // 1小时
    TTLUserInfo      = 1 * time.Hour      // 用户信息
    TTLBookInfo      = 2 * time.Hour      // 书籍信息
    
    // 长期缓存(低频更新)
    TTLLong          = 24 * time.Hour     // 24小时
    TTLBookChapter   = 24 * time.Hour     // 章节内容
    TTLConfig        = 24 * time.Hour     // 系统配置
    
    // 空值缓存(防穿透)
    TTLNull          = 5 * time.Minute    // 空值5分钟
)

// 动态TTL计算(根据访问热度)
func CalculateDynamicTTL(baseTime time.Duration, accessCount int64) time.Duration {
    // 访问越频繁,TTL越长
    if accessCount > 10000 {
        return baseTime * 2
    } else if accessCount > 1000 {
        return baseTime * 3 / 2
    }
    return baseTime
}
```

### 4.3 缓存更新策略

**1. Cache Aside模式(主要使用)**

```go
// 读操作
func GetUserInfo(ctx context.Context, userID string) (*User, error) {
    // 1. 先查缓存
    key := UserInfoKey(userID)
    cached, err := cache.Get(ctx, key)
    if err == nil && cached != "" {
        var user User
        json.Unmarshal([]byte(cached), &user)
        return &user, nil
    }
    
    // 2. 缓存未命中,查数据库
    user, err := db.GetUserByID(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    data, _ := json.Marshal(user)
    cache.Set(ctx, key, data, TTLUserInfo)
    
    return user, nil
}

// 写操作
func UpdateUserInfo(ctx context.Context, userID string, updates map[string]interface{}) error {
    // 1. 更新数据库
    err := db.UpdateUser(ctx, userID, updates)
    if err != nil {
        return err
    }
    
    // 2. 删除缓存(让下次读取时重新加载)
    key := UserInfoKey(userID)
    cache.Delete(ctx, key)
    
    return nil
}
```

**2. Write Through模式(关键数据)**

```go
// 写操作同时更新缓存
func UpdateUserInfoWithCache(ctx context.Context, userID string, updates map[string]interface{}) error {
    // 1. 更新数据库
    err := db.UpdateUser(ctx, userID, updates)
    if err != nil {
        return err
    }
    
    // 2. 更新缓存
    user, _ := db.GetUserByID(ctx, userID)
    data, _ := json.Marshal(user)
    key := UserInfoKey(userID)
    cache.Set(ctx, key, data, TTLUserInfo)
    
    return nil
}
```

### 4.4 缓存预热

```go
// CacheWarmer 缓存预热器
type CacheWarmer struct {
    cache   CacheService
    db      Database
}

// WarmupHotBooks 预热热门书籍
func (w *CacheWarmer) WarmupHotBooks(ctx context.Context) error {
    // 1. 获取热门书籍列表(Top 1000)
    hotBooks, err := w.db.GetHotBooks(ctx, 1000)
    if err != nil {
        return err
    }
    
    // 2. 批量加载到缓存
    for _, book := range hotBooks {
        key := BookInfoKey(book.ID)
        data, _ := json.Marshal(book)
        w.cache.Set(ctx, key, data, TTLBookInfo)
        
        // 预热前3章内容
        for i := 1; i <= 3; i++ {
            chapter, _ := w.db.GetChapter(ctx, book.ID, i)
            if chapter != nil {
                chapterKey := BookChapterKey(book.ID, i)
                chapterData, _ := json.Marshal(chapter)
                w.cache.Set(ctx, chapterKey, chapterData, TTLBookChapter)
            }
        }
    }
    
    return nil
}

// 定时预热任务
func StartCacheWarmupScheduler(warmer *CacheWarmer) {
    ticker := time.NewTicker(1 * time.Hour)
    go func() {
        for range ticker.C {
            ctx := context.Background()
            warmer.WarmupHotBooks(ctx)
            warmer.WarmupHotUsers(ctx)
            // ... 其他预热任务
        }
    }()
}
```

## 5. 缓存问题防护

### 5.1 缓存穿透防护(空值缓存)

```go
// 查询不存在的数据时,缓存空值
func GetBookInfo(ctx context.Context, bookID string) (*Book, error) {
    key := BookInfoKey(bookID)
    
    // 检查是否是空值缓存
    cached, err := cache.Get(ctx, key)
    if err == nil {
        if cached == "null" {
            return nil, errors.New("书籍不存在")
        }
        var book Book
        json.Unmarshal([]byte(cached), &book)
        return &book, nil
    }
    
    // 查询数据库
    book, err := db.GetBookByID(ctx, bookID)
    if err != nil {
        // 数据不存在,缓存空值
        cache.Set(ctx, key, "null", TTLNull)
        return nil, err
    }
    
    // 正常数据缓存
    data, _ := json.Marshal(book)
    cache.Set(ctx, key, data, TTLBookInfo)
    
    return book, nil
}
```

### 5.2 缓存击穿防护(分布式锁)

```go
// 使用Redis分布式锁防止缓存击穿
func GetWithLock(ctx context.Context, key string, loader func() (interface{}, error)) (interface{}, error) {
    // 1. 尝试获取数据
    cached, err := cache.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 2. 获取分布式锁
    lockKey := "lock:" + key
    lockValue := uuid.New().String()
    
    // SET key value NX EX 10
    acquired, err := cache.SetNX(ctx, lockKey, lockValue, 10*time.Second)
    if err != nil || !acquired {
        // 等待其他线程加载
        time.Sleep(100 * time.Millisecond)
        return cache.Get(ctx, key)
    }
    
    defer func() {
        // 释放锁(Lua脚本保证原子性)
        script := `
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
            else
                return 0
            end
        `
        cache.Eval(ctx, script, []string{lockKey}, lockValue)
    }()
    
    // 3. 双重检查
    cached, err = cache.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 4. 加载数据
    data, err := loader()
    if err != nil {
        return nil, err
    }
    
    cache.Set(ctx, key, data, TTLMedium)
    return data, nil
}
```

### 5.3 缓存雪崩防护(TTL随机化)

```go
// 添加随机时间,避免大量缓存同时过期
func SetWithRandomTTL(ctx context.Context, key string, value interface{}, baseTTL time.Duration) error {
    // 在基础TTL上增加±10%的随机时间
    randomOffset := time.Duration(rand.Intn(int(baseTTL.Seconds()/5))) * time.Second
    actualTTL := baseTTL + randomOffset
    
    return cache.Set(ctx, key, value, actualTTL)
}

// 批量设置时使用不同的TTL
func MSetWithRandomTTL(ctx context.Context, items map[string]interface{}, baseTTL time.Duration) error {
    for key, value := range items {
        SetWithRandomTTL(ctx, key, value, baseTTL)
    }
    return nil
}
```

### 5.4 热点Key防护

```go
// 本地缓存+Redis双层缓存
type HotKeyCache struct {
    localCache *sync.Map     // 本地缓存
    redisCache CacheService  // Redis缓存
    hotKeySet  *sync.Map     // 热点Key集合
    threshold  int64         // 热点阈值
}

func (h *HotKeyCache) Get(ctx context.Context, key string) (interface{}, error) {
    // 1. 检查是否是热点Key
    if h.isHotKey(key) {
        // 先查本地缓存
        if value, ok := h.localCache.Load(key); ok {
            return value, nil
        }
    }
    
    // 2. 查Redis缓存
    value, err := h.redisCache.Get(ctx, key)
    if err != nil {
        return nil, err
    }
    
    // 3. 增加访问计数
    h.incrementAccessCount(key)
    
    // 4. 如果成为热点Key,加入本地缓存
    if h.isHotKey(key) {
        h.localCache.Store(key, value)
        // 设置本地缓存过期时间
        go func() {
            time.Sleep(5 * time.Minute)
            h.localCache.Delete(key)
        }()
    }
    
    return value, nil
}

func (h *HotKeyCache) isHotKey(key string) bool {
    if count, ok := h.hotKeySet.Load(key); ok {
        return count.(int64) > h.threshold
    }
    return false
}

func (h *HotKeyCache) incrementAccessCount(key string) {
    value, _ := h.hotKeySet.LoadOrStore(key, int64(0))
    atomic.AddInt64(value.(*int64), 1)
}
```

## 6. 监控和统计

### 6.1 缓存监控指标

```go
// CacheMetrics 缓存监控指标
type CacheMetrics struct {
    HitCount      int64 // 命中次数
    MissCount     int64 // 未命中次数
    TotalRequests int64 // 总请求数
}

func (m *CacheMetrics) HitRate() float64 {
    if m.TotalRequests == 0 {
        return 0
    }
    return float64(m.HitCount) / float64(m.TotalRequests) * 100
}

// 监控装饰器
func (s *CacheServiceImpl) GetWithMetrics(ctx context.Context, key string) (string, error) {
    atomic.AddInt64(&s.metrics.TotalRequests, 1)
    
    value, err := s.Get(ctx, key)
    if err == nil && value != "" {
        atomic.AddInt64(&s.metrics.HitCount, 1)
    } else {
        atomic.AddInt64(&s.metrics.MissCount, 1)
    }
    
    return value, err
}

// 定期输出监控指标
func (s *CacheServiceImpl) StartMetricsReporter() {
    ticker := time.NewTicker(1 * time.Minute)
    go func() {
        for range ticker.C {
            log.Info("缓存监控指标",
                zap.Int64("total_requests", s.metrics.TotalRequests),
                zap.Int64("hit_count", s.metrics.HitCount),
                zap.Int64("miss_count", s.metrics.MissCount),
                zap.Float64("hit_rate", s.metrics.HitRate()),
            )
        }
    }()
}
```

### 6.2 Redis Info监控

```go
// Redis健康检查
func (s *CacheServiceImpl) HealthCheck(ctx context.Context) (*RedisInfo, error) {
    info, err := s.client.Info(ctx).Result()
    if err != nil {
        return nil, err
    }
    
    return &RedisInfo{
        UsedMemory:     parseInfo(info, "used_memory"),
        ConnectedClients: parseInfo(info, "connected_clients"),
        TotalCommands:  parseInfo(info, "total_commands_processed"),
        HitRate:        parseInfo(info, "keyspace_hits") / parseInfo(info, "keyspace_misses"),
    }, nil
}
```

## 7. MVP范围

### 7.1 MVP核心功能 ✅

- ✅ 基础缓存读写操作
- ✅ Cache Aside模式
- ✅ 空值缓存(防穿透)
- ✅ TTL过期策略
- ✅ 统一Key命名规范
- ✅ 基本监控指标

### 7.2 后续迭代功能 ⏸️

- ⏸️ 分布式锁(防击穿)
- ⏸️ 本地缓存(热点Key)
- ⏸️ 缓存预热
- ⏸️ 高级监控和告警
- ⏸️ 缓存管理后台

## 8. 相关文档

- [Redis数据库设计](../database/Redis数据库设计.md)
- [性能优化指南](../../ops/性能优化指南.md)
- [共享底层服务设计文档](./README_共享底层服务设计文档.md)

---

**文档维护**: 青羽后端架构团队  
**最后更新**: 2025-10-17

