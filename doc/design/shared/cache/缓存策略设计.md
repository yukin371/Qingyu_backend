# ç¼“å­˜ç­–ç•¥è®¾è®¡

> **æ¶æ„è¯´æ˜**: æœ¬æ–‡æ¡£åŸºäº**æ¨¡å—åŒ–å•ä½“æ¶æ„**è®¾è®¡ã€‚
> 
> - âœ… å½“å‰é‡‡ç”¨å•ä¸€ä»£ç åº“,ç»Ÿä¸€éƒ¨ç½²
> - âœ… é€šè¿‡æ¨¡å—åŒ–ä¿æŒæ¸…æ™°è¾¹ç•Œ
> - âœ… ä¸ºæœªæ¥å¯èƒ½çš„å¾®æœåŠ¡åŒ–é¢„ç•™ç©ºé—´
> 
> å‚è€ƒ:[å¾®æœåŠ¡æ¶æ„åˆ’åˆ†å»ºè®®](../å¾®æœåŠ¡æ¶æ„åˆ’åˆ†å»ºè®®.md)
> 
> **æ–‡æ¡£çŠ¶æ€**: âœ… MVPæ ¸å¿ƒåŠŸèƒ½  
> **åˆ›å»ºæ—¶é—´**: 2025-10-17  
> **æœ€åæ›´æ–°**: 2025-10-17  
> **å®æ–½çŠ¶æ€**: ğŸŸ¡ è¿›è¡Œä¸­ (80%)

## 1. éœ€æ±‚æ¦‚è¿°

### 1.1 åŠŸèƒ½æè¿°

ç¼“å­˜ç­–ç•¥æ˜¯é’ç¾½å¹³å°çš„æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–æ‰‹æ®µ,é€šè¿‡åˆç†çš„ç¼“å­˜è®¾è®¡æå‡ç³»ç»Ÿå“åº”é€Ÿåº¦ã€é™ä½æ•°æ®åº“å‹åŠ›ã€æ”¹å–„ç”¨æˆ·ä½“éªŒã€‚ç³»ç»Ÿé‡‡ç”¨Redisä½œä¸ºç¼“å­˜å±‚,æ”¯æŒå¤šçº§ç¼“å­˜ã€ç¼“å­˜é¢„çƒ­ã€å¤±æ•ˆç­–ç•¥ã€ç¼“å­˜ç©¿é€é˜²æŠ¤ç­‰åŠŸèƒ½,ç¡®ä¿ç³»ç»Ÿçš„é«˜æ€§èƒ½å’Œé«˜å¯ç”¨æ€§ã€‚

### 1.2 ä¸šåŠ¡ä»·å€¼

- **æ€§èƒ½æå‡**:å‡å°‘æ•°æ®åº“æŸ¥è¯¢,æå‡æ¥å£å“åº”é€Ÿåº¦(90%ä»¥ä¸Šè¯·æ±‚å‘½ä¸­ç¼“å­˜)
- **é™ä½æˆæœ¬**:å‡å°‘æ•°æ®åº“è´Ÿè½½,å»¶è¿Ÿæ•°æ®åº“æ‰©å®¹æ—¶é—´
- **æ”¹å–„ä½“éªŒ**:å¿«é€Ÿå“åº”ç”¨æˆ·è¯·æ±‚,æå‡ç”¨æˆ·æ»¡æ„åº¦
- **ç³»ç»Ÿç¨³å®š**:ç¼“å­˜ä½œä¸ºæ•°æ®åº“çš„ä¿æŠ¤å±‚,æå‡ç³»ç»Ÿç¨³å®šæ€§

### 1.3 åº”ç”¨åœºæ™¯

- ç”¨æˆ·ä¿¡æ¯ç¼“å­˜(é«˜é¢‘è¯»å–,ä½é¢‘æ›´æ–°)
- ä¹¦ç±ä¿¡æ¯å’Œç« èŠ‚å†…å®¹ç¼“å­˜(çƒ­é—¨å†…å®¹)
- æ¨èç»“æœç¼“å­˜(é¢„è®¡ç®—ç»“æœ)
- æ¦œå•æ•°æ®ç¼“å­˜(å®šæ—¶æ›´æ–°)
- ä¼šè¯ä¿¡æ¯ç¼“å­˜(JWT Tokenæ ¡éªŒ)
- æƒé™ä¿¡æ¯ç¼“å­˜(RBACæƒé™æ£€æŸ¥)

### 1.4 åŠŸèƒ½è¾¹ç•Œ

- **åŒ…å«åŠŸèƒ½**:ç¼“å­˜è¯»å†™ã€å¤±æ•ˆç­–ç•¥ã€é¢„çƒ­ã€ç©¿é€é˜²æŠ¤ã€é›ªå´©é˜²æŠ¤ã€çƒ­ç‚¹æ•°æ®ä¼˜åŒ–
- **ä¸åŒ…å«åŠŸèƒ½**:åˆ†å¸ƒå¼ç¼“å­˜ä¸€è‡´æ€§ã€ç¼“å­˜æ•°æ®æŒä¹…åŒ–ã€ç¼“å­˜é›†ç¾¤ç®¡ç†

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚                                â”‚
â”‚  Service Layer (å„ä¸šåŠ¡æ¨¡å—)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ç¼“å­˜æŠ½è±¡å±‚                              â”‚
â”‚  CacheService (ç»Ÿä¸€ç¼“å­˜æ¥å£)                             â”‚
â”‚  â”œâ”€ Get/Set/Delete                                      â”‚
â”‚  â”œâ”€ GetOrLoad (ç¼“å­˜æœªå‘½ä¸­æ—¶åŠ è½½)                        â”‚
â”‚  â”œâ”€ Batch Operations (æ‰¹é‡æ“ä½œ)                         â”‚
â”‚  â””â”€ TTL Management (è¿‡æœŸæ—¶é—´ç®¡ç†)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Redisç¼“å­˜å±‚                             â”‚
â”‚  â”œâ”€ String (ç®€å•é”®å€¼å¯¹)                                 â”‚
â”‚  â”œâ”€ Hash (å¯¹è±¡å­˜å‚¨)                                     â”‚
â”‚  â”œâ”€ List (åˆ—è¡¨æ•°æ®)                                     â”‚
â”‚  â”œâ”€ Set (é›†åˆæ•°æ®)                                      â”‚
â”‚  â””â”€ Sorted Set (æ’è¡Œæ¦œ)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ•°æ®æºå±‚                                â”‚
â”‚  MongoDB (æŒä¹…åŒ–æ•°æ®)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç¼“å­˜å±‚çº§

**L1ç¼“å­˜ - åº”ç”¨å†…å­˜(å¯é€‰)**
- ä½¿ç”¨åœºæ™¯:æé«˜é¢‘è®¿é—®çš„é…ç½®æ•°æ®
- å®¹é‡:å°äº100MB
- TTL:5-30åˆ†é’Ÿ
- æ›´æ–°ç­–ç•¥:å®šæ—¶åˆ·æ–°

**L2ç¼“å­˜ - Redis**
- ä½¿ç”¨åœºæ™¯:æ‰€æœ‰éœ€è¦ç¼“å­˜çš„ä¸šåŠ¡æ•°æ®
- å®¹é‡:æ ¹æ®éœ€æ±‚æ‰©å±•(åˆæœŸ4-8GB)
- TTL:æŒ‰ä¸šåŠ¡åœºæ™¯è®¾ç½®(1åˆ†é’Ÿ-24å°æ—¶)
- æ›´æ–°ç­–ç•¥:ä¸»åŠ¨å¤±æ•ˆ + è¢«åŠ¨è¿‡æœŸ

## 3. ç¼“å­˜æ¥å£è®¾è®¡

### 3.1 ç»Ÿä¸€ç¼“å­˜æ¥å£

```go
// CacheService ç¼“å­˜æœåŠ¡æ¥å£
type CacheService interface {
    // åŸºç¡€æ“ä½œ
    Get(ctx context.Context, key string) (string, error)
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    
    // æ‰¹é‡æ“ä½œ
    MGet(ctx context.Context, keys []string) ([]string, error)
    MSet(ctx context.Context, items map[string]interface{}, ttl time.Duration) error
    MDelete(ctx context.Context, keys []string) error
    
    // é«˜çº§æ“ä½œ
    GetOrLoad(ctx context.Context, key string, ttl time.Duration, loader func() (interface{}, error)) (interface{}, error)
    Increment(ctx context.Context, key string, delta int64) (int64, error)
    Expire(ctx context.Context, key string, ttl time.Duration) error
    
    // Hashæ“ä½œ
    HGet(ctx context.Context, key, field string) (string, error)
    HSet(ctx context.Context, key, field string, value interface{}) error
    HGetAll(ctx context.Context, key string) (map[string]string, error)
    
    // é›†åˆæ“ä½œ
    SAdd(ctx context.Context, key string, members ...interface{}) error
    SMembers(ctx context.Context, key string) ([]string, error)
    
    // æœ‰åºé›†åˆæ“ä½œ(æ’è¡Œæ¦œ)
    ZAdd(ctx context.Context, key string, score float64, member string) error
    ZRange(ctx context.Context, key string, start, stop int64) ([]string, error)
    ZRevRange(ctx context.Context, key string, start, stop int64) ([]string, error)
}
```

### 3.2 GetOrLoadæ¨¡å¼(ç¼“å­˜ç©¿é€é˜²æŠ¤)

```go
// GetOrLoad ç¼“å­˜æœªå‘½ä¸­æ—¶è‡ªåŠ¨åŠ è½½
func (s *CacheServiceImpl) GetOrLoad(
    ctx context.Context,
    key string,
    ttl time.Duration,
    loader func() (interface{}, error),
) (interface{}, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    cached, err := s.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­,ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
    lockKey := "lock:" + key
    acquired, err := s.acquireLock(ctx, lockKey, 10*time.Second)
    if err != nil {
        return nil, err
    }
    
    if !acquired {
        // ç­‰å¾…å…¶ä»–çº¿ç¨‹åŠ è½½å®Œæˆ
        time.Sleep(100 * time.Millisecond)
        return s.Get(ctx, key)
    }
    
    defer s.releaseLock(ctx, lockKey)
    
    // 3. åŒé‡æ£€æŸ¥(å¯èƒ½å…¶ä»–çº¿ç¨‹å·²ç»åŠ è½½)
    cached, err = s.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 4. æ‰§è¡ŒåŠ è½½å‡½æ•°
    data, err := loader()
    if err != nil {
        return nil, err
    }
    
    // 5. ä¿å­˜åˆ°ç¼“å­˜
    if data == nil {
        // ç©ºå€¼ç¼“å­˜(é˜²æ­¢ç¼“å­˜ç©¿é€),TTLè¾ƒçŸ­
        s.Set(ctx, key, "null", 5*time.Minute)
        return nil, errors.New("æ•°æ®ä¸å­˜åœ¨")
    }
    
    s.Set(ctx, key, data, ttl)
    return data, nil
}
```

## 4. ç¼“å­˜ç­–ç•¥

### 4.1 ç¼“å­˜Keyè®¾è®¡è§„èŒƒ

```go
// Keyå‘½åè§„èŒƒ: {ä¸šåŠ¡æ¨¡å—}:{èµ„æºç±»å‹}:{èµ„æºID}:{å­èµ„æº}
const (
    // ç”¨æˆ·ç›¸å…³
    KeyUserInfo        = "user:info:%s"          // ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    KeyUserPermissions = "user:permissions:%s"   // ç”¨æˆ·æƒé™åˆ—è¡¨
    KeyUserSession     = "user:session:%s"       // ç”¨æˆ·ä¼šè¯
    
    // ä¹¦ç±ç›¸å…³
    KeyBookInfo        = "book:info:%s"          // ä¹¦ç±ä¿¡æ¯
    KeyBookChapter     = "book:chapter:%s:%d"    // ç« èŠ‚å†…å®¹
    KeyBookRanking     = "book:ranking:%s"       // ä¹¦ç±æ’è¡Œæ¦œ
    
    // æ¨èç›¸å…³
    KeyRecommendUser   = "recommend:user:%s"     // ç”¨æˆ·ä¸ªæ€§åŒ–æ¨è
    KeyRecommendHot    = "recommend:hot:%s"      // çƒ­é—¨æ¨è
    
    // ç»Ÿè®¡ç›¸å…³
    KeyStatsBookView   = "stats:book:view:%s"    // ä¹¦ç±æµè§ˆé‡
    KeyStatsUserActive = "stats:user:active:%s"  // ç”¨æˆ·æ´»è·ƒåº¦
)

// ç”Ÿæˆç¼“å­˜Key
func UserInfoKey(userID string) string {
    return fmt.Sprintf(KeyUserInfo, userID)
}

func BookChapterKey(bookID string, chapterNum int) string {
    return fmt.Sprintf(KeyBookChapter, bookID, chapterNum)
}
```

### 4.2 TTLç­–ç•¥

```go
// ç¼“å­˜è¿‡æœŸæ—¶é—´é…ç½®
const (
    // çŸ­æœŸç¼“å­˜(é«˜é¢‘æ›´æ–°)
    TTLShort         = 5 * time.Minute    // 5åˆ†é’Ÿ
    TTLUserSession   = 30 * time.Minute   // ä¼šè¯30åˆ†é’Ÿ
    
    // ä¸­æœŸç¼“å­˜(æ­£å¸¸ä¸šåŠ¡)
    TTLMedium        = 1 * time.Hour      // 1å°æ—¶
    TTLUserInfo      = 1 * time.Hour      // ç”¨æˆ·ä¿¡æ¯
    TTLBookInfo      = 2 * time.Hour      // ä¹¦ç±ä¿¡æ¯
    
    // é•¿æœŸç¼“å­˜(ä½é¢‘æ›´æ–°)
    TTLLong          = 24 * time.Hour     // 24å°æ—¶
    TTLBookChapter   = 24 * time.Hour     // ç« èŠ‚å†…å®¹
    TTLConfig        = 24 * time.Hour     // ç³»ç»Ÿé…ç½®
    
    // ç©ºå€¼ç¼“å­˜(é˜²ç©¿é€)
    TTLNull          = 5 * time.Minute    // ç©ºå€¼5åˆ†é’Ÿ
)

// åŠ¨æ€TTLè®¡ç®—(æ ¹æ®è®¿é—®çƒ­åº¦)
func CalculateDynamicTTL(baseTime time.Duration, accessCount int64) time.Duration {
    // è®¿é—®è¶Šé¢‘ç¹,TTLè¶Šé•¿
    if accessCount > 10000 {
        return baseTime * 2
    } else if accessCount > 1000 {
        return baseTime * 3 / 2
    }
    return baseTime
}
```

### 4.3 ç¼“å­˜æ›´æ–°ç­–ç•¥

**1. Cache Asideæ¨¡å¼(ä¸»è¦ä½¿ç”¨)**

```go
// è¯»æ“ä½œ
func GetUserInfo(ctx context.Context, userID string) (*User, error) {
    // 1. å…ˆæŸ¥ç¼“å­˜
    key := UserInfoKey(userID)
    cached, err := cache.Get(ctx, key)
    if err == nil && cached != "" {
        var user User
        json.Unmarshal([]byte(cached), &user)
        return &user, nil
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­,æŸ¥æ•°æ®åº“
    user, err := db.GetUserByID(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    data, _ := json.Marshal(user)
    cache.Set(ctx, key, data, TTLUserInfo)
    
    return user, nil
}

// å†™æ“ä½œ
func UpdateUserInfo(ctx context.Context, userID string, updates map[string]interface{}) error {
    // 1. æ›´æ–°æ•°æ®åº“
    err := db.UpdateUser(ctx, userID, updates)
    if err != nil {
        return err
    }
    
    // 2. åˆ é™¤ç¼“å­˜(è®©ä¸‹æ¬¡è¯»å–æ—¶é‡æ–°åŠ è½½)
    key := UserInfoKey(userID)
    cache.Delete(ctx, key)
    
    return nil
}
```

**2. Write Throughæ¨¡å¼(å…³é”®æ•°æ®)**

```go
// å†™æ“ä½œåŒæ—¶æ›´æ–°ç¼“å­˜
func UpdateUserInfoWithCache(ctx context.Context, userID string, updates map[string]interface{}) error {
    // 1. æ›´æ–°æ•°æ®åº“
    err := db.UpdateUser(ctx, userID, updates)
    if err != nil {
        return err
    }
    
    // 2. æ›´æ–°ç¼“å­˜
    user, _ := db.GetUserByID(ctx, userID)
    data, _ := json.Marshal(user)
    key := UserInfoKey(userID)
    cache.Set(ctx, key, data, TTLUserInfo)
    
    return nil
}
```

### 4.4 ç¼“å­˜é¢„çƒ­

```go
// CacheWarmer ç¼“å­˜é¢„çƒ­å™¨
type CacheWarmer struct {
    cache   CacheService
    db      Database
}

// WarmupHotBooks é¢„çƒ­çƒ­é—¨ä¹¦ç±
func (w *CacheWarmer) WarmupHotBooks(ctx context.Context) error {
    // 1. è·å–çƒ­é—¨ä¹¦ç±åˆ—è¡¨(Top 1000)
    hotBooks, err := w.db.GetHotBooks(ctx, 1000)
    if err != nil {
        return err
    }
    
    // 2. æ‰¹é‡åŠ è½½åˆ°ç¼“å­˜
    for _, book := range hotBooks {
        key := BookInfoKey(book.ID)
        data, _ := json.Marshal(book)
        w.cache.Set(ctx, key, data, TTLBookInfo)
        
        // é¢„çƒ­å‰3ç« å†…å®¹
        for i := 1; i <= 3; i++ {
            chapter, _ := w.db.GetChapter(ctx, book.ID, i)
            if chapter != nil {
                chapterKey := BookChapterKey(book.ID, i)
                chapterData, _ := json.Marshal(chapter)
                w.cache.Set(ctx, chapterKey, chapterData, TTLBookChapter)
            }
        }
    }
    
    return nil
}

// å®šæ—¶é¢„çƒ­ä»»åŠ¡
func StartCacheWarmupScheduler(warmer *CacheWarmer) {
    ticker := time.NewTicker(1 * time.Hour)
    go func() {
        for range ticker.C {
            ctx := context.Background()
            warmer.WarmupHotBooks(ctx)
            warmer.WarmupHotUsers(ctx)
            // ... å…¶ä»–é¢„çƒ­ä»»åŠ¡
        }
    }()
}
```

## 5. ç¼“å­˜é—®é¢˜é˜²æŠ¤

### 5.1 ç¼“å­˜ç©¿é€é˜²æŠ¤(ç©ºå€¼ç¼“å­˜)

```go
// æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®æ—¶,ç¼“å­˜ç©ºå€¼
func GetBookInfo(ctx context.Context, bookID string) (*Book, error) {
    key := BookInfoKey(bookID)
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºå€¼ç¼“å­˜
    cached, err := cache.Get(ctx, key)
    if err == nil {
        if cached == "null" {
            return nil, errors.New("ä¹¦ç±ä¸å­˜åœ¨")
        }
        var book Book
        json.Unmarshal([]byte(cached), &book)
        return &book, nil
    }
    
    // æŸ¥è¯¢æ•°æ®åº“
    book, err := db.GetBookByID(ctx, bookID)
    if err != nil {
        // æ•°æ®ä¸å­˜åœ¨,ç¼“å­˜ç©ºå€¼
        cache.Set(ctx, key, "null", TTLNull)
        return nil, err
    }
    
    // æ­£å¸¸æ•°æ®ç¼“å­˜
    data, _ := json.Marshal(book)
    cache.Set(ctx, key, data, TTLBookInfo)
    
    return book, nil
}
```

### 5.2 ç¼“å­˜å‡»ç©¿é˜²æŠ¤(åˆ†å¸ƒå¼é”)

```go
// ä½¿ç”¨Redisåˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
func GetWithLock(ctx context.Context, key string, loader func() (interface{}, error)) (interface{}, error) {
    // 1. å°è¯•è·å–æ•°æ®
    cached, err := cache.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 2. è·å–åˆ†å¸ƒå¼é”
    lockKey := "lock:" + key
    lockValue := uuid.New().String()
    
    // SET key value NX EX 10
    acquired, err := cache.SetNX(ctx, lockKey, lockValue, 10*time.Second)
    if err != nil || !acquired {
        // ç­‰å¾…å…¶ä»–çº¿ç¨‹åŠ è½½
        time.Sleep(100 * time.Millisecond)
        return cache.Get(ctx, key)
    }
    
    defer func() {
        // é‡Šæ”¾é”(Luaè„šæœ¬ä¿è¯åŸå­æ€§)
        script := `
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
            else
                return 0
            end
        `
        cache.Eval(ctx, script, []string{lockKey}, lockValue)
    }()
    
    // 3. åŒé‡æ£€æŸ¥
    cached, err = cache.Get(ctx, key)
    if err == nil && cached != "" {
        return cached, nil
    }
    
    // 4. åŠ è½½æ•°æ®
    data, err := loader()
    if err != nil {
        return nil, err
    }
    
    cache.Set(ctx, key, data, TTLMedium)
    return data, nil
}
```

### 5.3 ç¼“å­˜é›ªå´©é˜²æŠ¤(TTLéšæœºåŒ–)

```go
// æ·»åŠ éšæœºæ—¶é—´,é¿å…å¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸ
func SetWithRandomTTL(ctx context.Context, key string, value interface{}, baseTTL time.Duration) error {
    // åœ¨åŸºç¡€TTLä¸Šå¢åŠ Â±10%çš„éšæœºæ—¶é—´
    randomOffset := time.Duration(rand.Intn(int(baseTTL.Seconds()/5))) * time.Second
    actualTTL := baseTTL + randomOffset
    
    return cache.Set(ctx, key, value, actualTTL)
}

// æ‰¹é‡è®¾ç½®æ—¶ä½¿ç”¨ä¸åŒçš„TTL
func MSetWithRandomTTL(ctx context.Context, items map[string]interface{}, baseTTL time.Duration) error {
    for key, value := range items {
        SetWithRandomTTL(ctx, key, value, baseTTL)
    }
    return nil
}
```

### 5.4 çƒ­ç‚¹Keyé˜²æŠ¤

```go
// æœ¬åœ°ç¼“å­˜+RedisåŒå±‚ç¼“å­˜
type HotKeyCache struct {
    localCache *sync.Map     // æœ¬åœ°ç¼“å­˜
    redisCache CacheService  // Redisç¼“å­˜
    hotKeySet  *sync.Map     // çƒ­ç‚¹Keyé›†åˆ
    threshold  int64         // çƒ­ç‚¹é˜ˆå€¼
}

func (h *HotKeyCache) Get(ctx context.Context, key string) (interface{}, error) {
    // 1. æ£€æŸ¥æ˜¯å¦æ˜¯çƒ­ç‚¹Key
    if h.isHotKey(key) {
        // å…ˆæŸ¥æœ¬åœ°ç¼“å­˜
        if value, ok := h.localCache.Load(key); ok {
            return value, nil
        }
    }
    
    // 2. æŸ¥Redisç¼“å­˜
    value, err := h.redisCache.Get(ctx, key)
    if err != nil {
        return nil, err
    }
    
    // 3. å¢åŠ è®¿é—®è®¡æ•°
    h.incrementAccessCount(key)
    
    // 4. å¦‚æœæˆä¸ºçƒ­ç‚¹Key,åŠ å…¥æœ¬åœ°ç¼“å­˜
    if h.isHotKey(key) {
        h.localCache.Store(key, value)
        // è®¾ç½®æœ¬åœ°ç¼“å­˜è¿‡æœŸæ—¶é—´
        go func() {
            time.Sleep(5 * time.Minute)
            h.localCache.Delete(key)
        }()
    }
    
    return value, nil
}

func (h *HotKeyCache) isHotKey(key string) bool {
    if count, ok := h.hotKeySet.Load(key); ok {
        return count.(int64) > h.threshold
    }
    return false
}

func (h *HotKeyCache) incrementAccessCount(key string) {
    value, _ := h.hotKeySet.LoadOrStore(key, int64(0))
    atomic.AddInt64(value.(*int64), 1)
}
```

## 6. ç›‘æ§å’Œç»Ÿè®¡

### 6.1 ç¼“å­˜ç›‘æ§æŒ‡æ ‡

```go
// CacheMetrics ç¼“å­˜ç›‘æ§æŒ‡æ ‡
type CacheMetrics struct {
    HitCount      int64 // å‘½ä¸­æ¬¡æ•°
    MissCount     int64 // æœªå‘½ä¸­æ¬¡æ•°
    TotalRequests int64 // æ€»è¯·æ±‚æ•°
}

func (m *CacheMetrics) HitRate() float64 {
    if m.TotalRequests == 0 {
        return 0
    }
    return float64(m.HitCount) / float64(m.TotalRequests) * 100
}

// ç›‘æ§è£…é¥°å™¨
func (s *CacheServiceImpl) GetWithMetrics(ctx context.Context, key string) (string, error) {
    atomic.AddInt64(&s.metrics.TotalRequests, 1)
    
    value, err := s.Get(ctx, key)
    if err == nil && value != "" {
        atomic.AddInt64(&s.metrics.HitCount, 1)
    } else {
        atomic.AddInt64(&s.metrics.MissCount, 1)
    }
    
    return value, err
}

// å®šæœŸè¾“å‡ºç›‘æ§æŒ‡æ ‡
func (s *CacheServiceImpl) StartMetricsReporter() {
    ticker := time.NewTicker(1 * time.Minute)
    go func() {
        for range ticker.C {
            log.Info("ç¼“å­˜ç›‘æ§æŒ‡æ ‡",
                zap.Int64("total_requests", s.metrics.TotalRequests),
                zap.Int64("hit_count", s.metrics.HitCount),
                zap.Int64("miss_count", s.metrics.MissCount),
                zap.Float64("hit_rate", s.metrics.HitRate()),
            )
        }
    }()
}
```

### 6.2 Redis Infoç›‘æ§

```go
// Rediså¥åº·æ£€æŸ¥
func (s *CacheServiceImpl) HealthCheck(ctx context.Context) (*RedisInfo, error) {
    info, err := s.client.Info(ctx).Result()
    if err != nil {
        return nil, err
    }
    
    return &RedisInfo{
        UsedMemory:     parseInfo(info, "used_memory"),
        ConnectedClients: parseInfo(info, "connected_clients"),
        TotalCommands:  parseInfo(info, "total_commands_processed"),
        HitRate:        parseInfo(info, "keyspace_hits") / parseInfo(info, "keyspace_misses"),
    }, nil
}
```

## 7. MVPèŒƒå›´

### 7.1 MVPæ ¸å¿ƒåŠŸèƒ½ âœ…

- âœ… åŸºç¡€ç¼“å­˜è¯»å†™æ“ä½œ
- âœ… Cache Asideæ¨¡å¼
- âœ… ç©ºå€¼ç¼“å­˜(é˜²ç©¿é€)
- âœ… TTLè¿‡æœŸç­–ç•¥
- âœ… ç»Ÿä¸€Keyå‘½åè§„èŒƒ
- âœ… åŸºæœ¬ç›‘æ§æŒ‡æ ‡

### 7.2 åç»­è¿­ä»£åŠŸèƒ½ â¸ï¸

- â¸ï¸ åˆ†å¸ƒå¼é”(é˜²å‡»ç©¿)
- â¸ï¸ æœ¬åœ°ç¼“å­˜(çƒ­ç‚¹Key)
- â¸ï¸ ç¼“å­˜é¢„çƒ­
- â¸ï¸ é«˜çº§ç›‘æ§å’Œå‘Šè­¦
- â¸ï¸ ç¼“å­˜ç®¡ç†åå°

## 8. ç›¸å…³æ–‡æ¡£

- [Redisæ•°æ®åº“è®¾è®¡](../database/Redisæ•°æ®åº“è®¾è®¡.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../../ops/æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)
- [å…±äº«åº•å±‚æœåŠ¡è®¾è®¡æ–‡æ¡£](./README_å…±äº«åº•å±‚æœåŠ¡è®¾è®¡æ–‡æ¡£.md)

---

**æ–‡æ¡£ç»´æŠ¤**: é’ç¾½åç«¯æ¶æ„å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-17

