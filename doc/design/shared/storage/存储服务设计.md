# 存储服务设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ⚠️ 部分实现，补充设计文档

---

## 1. 设计概述

### 1.1 业务价值

- 统一文件上传管理（头像、封面、附件）
- 支持多存储后端（本地、OSS、S3）
- 文件访问URL管理

### 1.2 实现情况

**已实现**：
- File数据模型：`models/shared/storage/file.go`
- 基础文件信息存储

**待实现**：
- StorageService完整业务逻辑
- 多存储后端适配器

---

## 2. 核心数据模型

### 2.1 File（文件）

```go
type File struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    FileName    string    `bson:"fileName" json:"fileName"`
    FileSize    int64     `bson:"fileSize" json:"fileSize"`  // 字节
    ContentType string    `bson:"contentType" json:"contentType"`
    StoragePath string    `bson:"storagePath" json:"storagePath"`  // 存储路径
    URL         string    `bson:"url" json:"url"`  // 访问URL
    OwnerID     string    `bson:"ownerId" json:"ownerId"`  // 上传者ID
    FileType    FileType  `bson:"fileType" json:"fileType"`  // 文件类型
    IsPublic    bool      `bson:"isPublic" json:"isPublic"`
    CreatedAt   time.Time `bson:"createdAt" json:"createdAt"`
}

type FileType string

const (
    FileTypeAvatar FileType = "avatar"   // 头像
    FileTypeCover  FileType = "cover"    // 封面
    FileTypeDoc    FileType = "document" // 文档
    FileTypeImage  FileType = "image"    // 图片
    FileTypeOther  FileType = "other"    // 其他
)
```

**索引策略**：
```javascript
db.files.createIndex({ "ownerId": 1, "createdAt": -1 })
db.files.createIndex({ "fileType": 1 })
```

---

## 3. 存储适配器设计（独特设计）

### 3.1 StorageAdapter接口

```go
type StorageAdapter interface {
    // Upload 上传文件
    Upload(ctx context.Context, file io.Reader, path string, options *UploadOptions) (*UploadResult, error)
    
    // Download 下载文件
    Download(ctx context.Context, path string) (io.ReadCloser, error)
    
    // Delete 删除文件
    Delete(ctx context.Context, path string) error
    
    // GetURL 获取访问URL
    GetURL(ctx context.Context, path string) (string, error)
    
    // Exists 检查文件是否存在
    Exists(ctx context.Context, path string) (bool, error)
}
```

### 3.2 多存储后端实现

**本地存储**：
```go
type LocalStorageAdapter struct {
    baseDir string
    baseURL string
}

func (a *LocalStorageAdapter) Upload(ctx context.Context, file io.Reader, path string, options *UploadOptions) (*UploadResult, error) {
    fullPath := filepath.Join(a.baseDir, path)
    
    // 创建目录
    os.MkdirAll(filepath.Dir(fullPath), 0755)
    
    // 保存文件
    dst, _ := os.Create(fullPath)
    defer dst.Close()
    
    size, _ := io.Copy(dst, file)
    
    return &UploadResult{
        Path: path,
        URL:  a.baseURL + "/" + path,
        Size: size,
    }, nil
}
```

**OSS存储（阿里云）**：
```go
type OSSStorageAdapter struct {
    client *oss.Client
    bucket *oss.Bucket
}

func (a *OSSStorageAdapter) Upload(ctx context.Context, file io.Reader, path string, options *UploadOptions) (*UploadResult, error) {
    err := a.bucket.PutObject(path, file, oss.ContentType(options.ContentType))
    if err != nil {
        return nil, err
    }
    
    url := a.bucket.SignURL(path, oss.HTTPGet, 3600)  // 1小时有效期
    
    return &UploadResult{
        Path: path,
        URL:  url,
    }, nil
}
```

**S3存储（兼容AWS S3）**：
```go
type S3StorageAdapter struct {
    client *s3.S3
    bucket string
}
```

### 3.3 存储策略工厂

```go
type StorageFactory struct {
    adapters map[string]StorageAdapter
    defaultAdapter StorageAdapter
}

func NewStorageFactory(config *StorageConfig) *StorageFactory {
    factory := &StorageFactory{
        adapters: make(map[string]StorageAdapter),
    }
    
    // 根据配置注册存储适配器
    if config.LocalStorage.Enabled {
        factory.adapters["local"] = NewLocalStorageAdapter(config.LocalStorage)
    }
    
    if config.OSS.Enabled {
        factory.adapters["oss"] = NewOSSStorageAdapter(config.OSS)
    }
    
    if config.S3.Enabled {
        factory.adapters["s3"] = NewS3StorageAdapter(config.S3)
    }
    
    factory.defaultAdapter = factory.adapters[config.Default]
    
    return factory
}

func (f *StorageFactory) GetAdapter(name string) StorageAdapter {
    if adapter, ok := f.adapters[name]; ok {
        return adapter
    }
    return f.defaultAdapter
}
```

---

## 4. StorageService设计

### 4.1 核心方法

```go
type StorageService interface {
    // UploadFile 上传文件
    UploadFile(ctx context.Context, req *UploadFileRequest) (*FileInfo, error)
    
    // GetFileURL 获取文件访问URL
    GetFileURL(ctx context.Context, fileID string) (string, error)
    
    // DeleteFile 删除文件
    DeleteFile(ctx context.Context, fileID string, userID string) error
    
    // GetUserFiles 获取用户文件列表
    GetUserFiles(ctx context.Context, userID string, fileType FileType) ([]*File, error)
}
```

### 4.2 上传流程

```go
func (s *StorageService) UploadFile(ctx context.Context, req *UploadFileRequest) (*FileInfo, error) {
    // 1. 验证文件类型和大小
    if err := s.validateFile(req); err != nil {
        return nil, err
    }
    
    // 2. 生成存储路径
    path := s.generateStoragePath(req.FileType, req.OwnerID, req.FileName)
    
    // 3. 上传到存储后端
    adapter := s.storageFactory.GetAdapter(s.config.Default)
    result, err := adapter.Upload(ctx, req.FileReader, path, &UploadOptions{
        ContentType: req.ContentType,
    })
    if err != nil {
        return nil, err
    }
    
    // 4. 保存文件记录
    file := &File{
        FileName:    req.FileName,
        FileSize:    result.Size,
        ContentType: req.ContentType,
        StoragePath: result.Path,
        URL:         result.URL,
        OwnerID:     req.OwnerID,
        FileType:    req.FileType,
        IsPublic:    req.IsPublic,
        CreatedAt:   time.Now(),
    }
    
    s.fileRepo.Create(ctx, file)
    
    return &FileInfo{
        FileID: file.ID,
        URL:    file.URL,
    }, nil
}
```

---

## 5. 文件验证

### 5.1 文件类型验证

```go
var AllowedContentTypes = map[FileType][]string{
    FileTypeAvatar: {"image/jpeg", "image/png", "image/gif"},
    FileTypeCover:  {"image/jpeg", "image/png"},
    FileTypeImage:  {"image/jpeg", "image/png", "image/gif", "image/webp"},
    FileTypeDoc:    {"application/pdf", "text/plain"},
}

func (s *StorageService) validateFile(req *UploadFileRequest) error {
    // 1. 检查文件大小
    maxSize := s.getMaxFileSize(req.FileType)
    if req.FileSize > maxSize {
        return fmt.Errorf("文件大小超过限制: %d bytes", maxSize)
    }
    
    // 2. 检查内容类型
    allowed := AllowedContentTypes[req.FileType]
    if !contains(allowed, req.ContentType) {
        return fmt.Errorf("不支持的文件类型: %s", req.ContentType)
    }
    
    return nil
}

func (s *StorageService) getMaxFileSize(fileType FileType) int64 {
    switch fileType {
    case FileTypeAvatar:
        return 2 * 1024 * 1024  // 2MB
    case FileTypeCover:
        return 5 * 1024 * 1024  // 5MB
    case FileTypeImage:
        return 10 * 1024 * 1024 // 10MB
    default:
        return 20 * 1024 * 1024 // 20MB
    }
}
```

### 5.2 路径生成策略

```go
func (s *StorageService) generateStoragePath(fileType FileType, ownerID string, fileName string) string {
    // 格式: {fileType}/{year}/{month}/{day}/{ownerID}/{uuid}_{fileName}
    now := time.Now()
    uuid := generateUUID()
    ext := filepath.Ext(fileName)
    
    return fmt.Sprintf("%s/%d/%02d/%02d/%s/%s%s",
        fileType,
        now.Year(),
        now.Month(),
        now.Day(),
        ownerID,
        uuid,
        ext,
    )
}
```

---

## 6. API设计

```
POST   /api/v1/storage/upload       - 上传文件
GET    /api/v1/storage/files        - 获取文件列表
GET    /api/v1/storage/files/:id    - 获取文件信息
DELETE /api/v1/storage/files/:id    - 删除文件
```

---

## 7. 与v2.1架构的关系

```
Shared Module
  └─ Storage Module
      ├─ StorageAdapter (适配器接口)
      │   ├─ LocalStorageAdapter
      │   ├─ OSSStorageAdapter
      │   └─ S3StorageAdapter
      ├─ StorageFactory (工厂)
      └─ StorageService (存储服务)
```

---

## 8. 实现参考

**代码文件**：
- `models/shared/storage/file.go` - 文件模型
- `service/shared/storage/storage_service.go`（待创建） - 存储服务
- `service/shared/storage/adapters/`（待创建） - 存储适配器
- `api/v1/shared/storage_api.go`（待创建） - 存储API

**配置示例**：
```yaml
storage:
  default: local  # local/oss/s3
  local:
    enabled: true
    base_dir: ./uploads
    base_url: http://localhost:8080/uploads
  oss:
    enabled: false
    endpoint: oss-cn-shanghai.aliyuncs.com
    access_key: xxx
    secret_key: xxx
    bucket: qingyu
```

---

**文档状态**: ✅ 已完成  
**优先级**: P0

