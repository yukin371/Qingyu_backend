# 通知服务设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库,统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考:[微服务架构划分建议](../微服务架构划分建议.md)
> 
> **文档状态**: ✅ MVP核心功能  
> **创建时间**: 2025-10-17  
> **最后更新**: 2025-10-17  
> **实施状态**: 🟡 进行中 (75%)

## 1. 需求概述

### 1.1 功能描述

通知服务是青羽平台的关键基础设施服务,为业务模块提供统一的消息通知能力。系统支持多种通知渠道(邮件、短信、站内信、推送),提供模板化消息、批量发送、发送状态追踪、失败重试等功能,确保重要消息能够及时、准确地送达用户。

### 1.2 业务价值

- **用户触达**:提供多渠道消息触达能力,提升用户活跃度
- **及时通知**:重要业务事件及时通知,提升用户体验
- **营销推广**:支持批量消息推送,助力营销活动
- **系统监控**:异常告警和系统通知,保障系统稳定运行

### 1.3 用户场景

- 用户注册后发送欢迎邮件和短信验证码
- 用户订阅的小说更新时发送站内通知
- 作者作品审核通过后发送系统通知
- 充值成功、消费扣款等交易通知
- 活动推广和运营消息批量推送
- 系统异常告警通知管理员

### 1.4 功能边界

- **包含功能**:邮件通知、短信通知、站内通知、推送通知、模板管理、批量发送、状态追踪
- **不包含功能**:短信/邮件服务商接口实现、消息内容审核、用户偏好设置

## 2. 架构设计

### 2.1 整体架构(模块化单体)

```
┌─────────────────────────────────────────────────────────┐
│                 青羽写作平台 (单一应用)                  │
│                                                         │
│  ┌───────────────────────────────────────────────┐    │
│  │           业务模块层                           │    │
│  │  用户模块 + 阅读模块 + 钱包模块 + 内容模块      │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓                              │
│  ┌───────────────────────────────────────────────┐    │
│  │       通知服务模块 (Notification Module)        │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 通知调度器 (Notification Scheduler)      │  │    │
│  │  │  - 消息接收和路由                       │  │    │
│  │  │  - 模板渲染                             │  │    │
│  │  │  - 渠道选择                             │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 渠道适配器 (Channel Adapters)            │  │    │
│  │  │  - 邮件发送器                           │  │    │
│  │  │  - 短信发送器                           │  │    │
│  │  │  - 站内消息存储                         │  │    │
│  │  │  - 推送通知发送器                       │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 状态追踪器 (Status Tracker)              │  │    │
│  │  │  - 发送状态记录                         │  │    │
│  │  │  - 失败重试                             │  │    │
│  │  │  - 统计分析                             │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓                              │
│  ┌───────────────────────────────────────────────┐    │
│  │         消息队列 (Redis Streams)               │    │
│  │  notification.email / notification.sms / ...   │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓                              │
│  ┌───────────────────────────────────────────────┐    │
│  │              数据存储层                        │    │
│  │  MongoDB (模板+记录) + Redis (队列+缓存)       │    │
│  └───────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

**架构说明**:
- 通知服务作为主应用的一个模块,与其他业务模块在同一进程
- 使用Redis Streams作为消息队列,实现异步发送
- 通过消息队列解耦业务模块和通知模块
- 渠道适配器模式支持多种通知方式

### 2.2 模块划分

- **通知调度模块**:消息接收、模板渲染、渠道路由
- **渠道适配模块**:邮件、短信、站内消息、推送的具体实现
- **模板管理模块**:消息模板的增删改查
- **状态追踪模块**:发送状态记录、失败重试、统计分析

## 3. 详细设计

### 3.1 Service层设计

#### 3.1.1 核心接口

```go
// NotificationService 通知服务接口
type NotificationService interface {
    // 发送邮件通知
    SendEmail(ctx context.Context, to, subject, content string) error
    
    // 使用模板发送邮件
    SendEmailWithTemplate(ctx context.Context, to, templateName string, variables map[string]string) error
    
    // 发送短信通知
    SendSMS(ctx context.Context, phone, content string) error
    
    // 发送推送通知
    SendPush(ctx context.Context, userID, title, content string) error
    
    // 发送系统通知(站内消息)
    SendSystemNotification(ctx context.Context, userID, title, content string) error
    
    // 批量发送通知
    SendBatch(ctx context.Context, notifications []*Notification) error
}

// TemplateService 模板管理接口
type TemplateService interface {
    // 创建模板
    CreateTemplate(ctx context.Context, template *MessageTemplate) error
    
    // 获取模板
    GetTemplate(ctx context.Context, name string) (*MessageTemplate, error)
    
    // 更新模板
    UpdateTemplate(ctx context.Context, name string, template *MessageTemplate) error
    
    // 删除模板
    DeleteTemplate(ctx context.Context, name string) error
    
    // 列出所有模板
    ListTemplates(ctx context.Context, filter *TemplateFilter) ([]*MessageTemplate, error)
}
```

#### 3.1.2 服务实现

```go
// NotificationServiceImpl 通知服务实现
type NotificationServiceImpl struct {
    messagingService MessagingService  // 消息队列服务
    templateStore    TemplateStore     // 模板存储
}

// SendEmailWithTemplate 使用模板发送邮件
func (s *NotificationServiceImpl) SendEmailWithTemplate(
    ctx context.Context, 
    to, templateName string, 
    variables map[string]string,
) error {
    // 1. 获取模板
    template, err := s.templateStore.GetTemplate(ctx, templateName)
    if err != nil {
        return fmt.Errorf("获取模板失败: %w", err)
    }
    
    // 2. 渲染模板
    content := s.renderTemplate(template.Content, variables)
    subject := s.renderTemplate(template.Subject, variables)
    
    // 3. 发送邮件
    return s.SendEmail(ctx, to, subject, content)
}

// renderTemplate 渲染模板
func (s *NotificationServiceImpl) renderTemplate(template string, variables map[string]string) string {
    result := template
    for key, value := range variables {
        placeholder := "{{" + key + "}}"
        result = strings.ReplaceAll(result, placeholder, value)
    }
    return result
}

// SendBatch 批量发送通知
func (s *NotificationServiceImpl) SendBatch(ctx context.Context, notifications []*Notification) error {
    // 分批发送,避免一次性处理过多消息
    batchSize := 100
    for i := 0; i < len(notifications); i += batchSize {
        end := i + batchSize
        if end > len(notifications) {
            end = len(notifications)
        }
        
        batch := notifications[i:end]
        for _, notification := range batch {
            // 根据类型选择发送方式
            switch notification.Type {
            case NotificationTypeEmail:
                s.SendEmail(ctx, notification.To, notification.Subject, notification.Content)
            case NotificationTypeSMS:
                s.SendSMS(ctx, notification.To, notification.Content)
            case NotificationTypePush:
                s.SendPush(ctx, notification.UserID, notification.Title, notification.Content)
            case NotificationTypeSystem:
                s.SendSystemNotification(ctx, notification.UserID, notification.Title, notification.Content)
            }
        }
    }
    
    return nil
}
```

### 3.2 Repository层设计

```go
// NotificationRepository 通知记录Repository
type NotificationRepository interface {
    // 保存通知记录
    Save(ctx context.Context, notification *Notification) error
    
    // 更新通知状态
    UpdateStatus(ctx context.Context, id string, status NotificationStatus) error
    
    // 查询用户通知
    FindByUserID(ctx context.Context, userID string, filter *NotificationFilter) ([]*Notification, error)
    
    // 标记为已读
    MarkAsRead(ctx context.Context, id string) error
    
    // 批量标记为已读
    MarkAllAsRead(ctx context.Context, userID string) error
    
    // 获取未读数量
    CountUnread(ctx context.Context, userID string) (int64, error)
}

// TemplateRepository 模板Repository
type TemplateRepository interface {
    Create(ctx context.Context, template *MessageTemplate) error
    GetByName(ctx context.Context, name string) (*MessageTemplate, error)
    Update(ctx context.Context, name string, template *MessageTemplate) error
    Delete(ctx context.Context, name string) error
    List(ctx context.Context, filter *TemplateFilter) ([]*MessageTemplate, error)
}
```

### 3.3 数据模型设计

```go
// 通知类型
type NotificationType string

const (
    NotificationTypeEmail  NotificationType = "email"   // 邮件
    NotificationTypeSMS    NotificationType = "sms"     // 短信
    NotificationTypePush   NotificationType = "push"    // 推送
    NotificationTypeSystem NotificationType = "system"  // 站内消息
)

// 通知状态
type NotificationStatus string

const (
    NotificationStatusPending NotificationStatus = "pending" // 待发送
    NotificationStatusSent    NotificationStatus = "sent"    // 已发送
    NotificationStatusFailed  NotificationStatus = "failed"  // 发送失败
    NotificationStatusRead    NotificationStatus = "read"    // 已读(仅站内消息)
)

// Notification 通知记录
type Notification struct {
    ID        string              `bson:"_id,omitempty" json:"id"`
    UserID    string              `bson:"user_id" json:"user_id"`           // 用户ID
    Type      NotificationType    `bson:"type" json:"type"`                 // 通知类型
    To        string              `bson:"to" json:"to"`                     // 接收地址(邮箱/手机号)
    Title     string              `bson:"title,omitempty" json:"title"`     // 标题
    Subject   string              `bson:"subject,omitempty" json:"subject"` // 邮件主题
    Content   string              `bson:"content" json:"content"`           // 内容
    Status    NotificationStatus  `bson:"status" json:"status"`             // 状态
    IsRead    bool                `bson:"is_read" json:"is_read"`           // 是否已读
    ErrorMsg  string              `bson:"error_msg,omitempty" json:"error_msg"` // 错误信息
    RetryCount int                `bson:"retry_count" json:"retry_count"`   // 重试次数
    Metadata  map[string]interface{} `bson:"metadata,omitempty" json:"metadata"` // 元数据
    CreatedAt time.Time           `bson:"created_at" json:"created_at"`
    UpdatedAt time.Time           `bson:"updated_at" json:"updated_at"`
    SentAt    *time.Time          `bson:"sent_at,omitempty" json:"sent_at"`
}

// MessageTemplate 消息模板
type MessageTemplate struct {
    ID          string              `bson:"_id,omitempty" json:"id"`
    Name        string              `bson:"name" json:"name"`           // 模板名称
    Type        NotificationType    `bson:"type" json:"type"`           // 通知类型
    Subject     string              `bson:"subject,omitempty" json:"subject"` // 邮件主题模板
    Content     string              `bson:"content" json:"content"`     // 内容模板
    Variables   []string            `bson:"variables" json:"variables"` // 变量列表
    Description string              `bson:"description" json:"description"` // 描述
    IsActive    bool                `bson:"is_active" json:"is_active"` // 是否启用
    CreatedBy   string              `bson:"created_by" json:"created_by"`
    CreatedAt   time.Time           `bson:"created_at" json:"created_at"`
    UpdatedAt   time.Time           `bson:"updated_at" json:"updated_at"`
}
```

### 3.4 API层设计

```go
// 用户获取自己的通知列表
GET /api/v1/notifications
Query参数:
- page: 页码
- page_size: 每页数量
- type: 通知类型筛选
- is_read: 是否已读

// 获取未读通知数量
GET /api/v1/notifications/unread-count

// 标记通知为已读
PUT /api/v1/notifications/:id/read

// 标记所有通知为已读
PUT /api/v1/notifications/read-all

// 管理员: 创建消息模板
POST /admin/api/v1/notification-templates
Body:
{
    "name": "welcome_email",
    "type": "email",
    "subject": "欢迎加入青羽平台",
    "content": "尊敬的{{username}},欢迎您...",
    "variables": ["username"],
    "description": "用户注册欢迎邮件"
}

// 管理员: 批量发送通知
POST /admin/api/v1/notifications/batch
Body:
{
    "template": "activity_notice",
    "users": ["user1", "user2", ...],
    "variables": {
        "activity_name": "双十一活动"
    }
}
```

## 4. 技术实现

### 4.1 消息队列Topic设计

```go
const (
    TopicNotificationEmail  = "notification.email"   // 邮件通知队列
    TopicNotificationSMS    = "notification.sms"     // 短信通知队列
    TopicNotificationPush   = "notification.push"    // 推送通知队列
    TopicNotificationSystem = "notification.system"  // 站内消息队列
)
```

### 4.2 消息发送流程

```
业务模块 → NotificationService.SendEmail() 
    ↓
渲染模板(如果使用模板)
    ↓
发布消息到Redis Streams (notification.email)
    ↓
后台Worker订阅队列
    ↓
调用邮件服务商API发送
    ↓
记录发送状态到MongoDB
    ↓
失败重试(最多3次)
```

### 4.3 失败重试机制

```go
// RetryPolicy 重试策略
type RetryPolicy struct {
    MaxRetries    int           // 最大重试次数
    RetryInterval time.Duration // 重试间隔
    BackoffFactor float64       // 退避因子(指数退避)
}

// 默认重试策略
var DefaultRetryPolicy = RetryPolicy{
    MaxRetries:    3,
    RetryInterval: 1 * time.Minute,
    BackoffFactor: 2.0, // 1分钟 → 2分钟 → 4分钟
}

// 重试逻辑
func (s *NotificationServiceImpl) retryFailedNotifications(ctx context.Context) {
    // 查询失败的通知
    failedNotifications := s.repo.FindFailedNotifications(ctx, DefaultRetryPolicy.MaxRetries)
    
    for _, notification := range failedNotifications {
        // 计算下次重试时间(指数退避)
        nextRetryTime := notification.UpdatedAt.Add(
            time.Duration(math.Pow(DefaultRetryPolicy.BackoffFactor, float64(notification.RetryCount))) * DefaultRetryPolicy.RetryInterval,
        )
        
        if time.Now().Before(nextRetryTime) {
            continue // 还未到重试时间
        }
        
        // 重新发送
        err := s.resendNotification(ctx, notification)
        if err != nil {
            // 更新重试次数
            s.repo.IncrementRetryCount(ctx, notification.ID)
        } else {
            // 标记为已发送
            s.repo.UpdateStatus(ctx, notification.ID, NotificationStatusSent)
        }
    }
}
```

### 4.4 模板渲染引擎

```go
// TemplateEngine 模板渲染引擎
type TemplateEngine interface {
    Render(template string, variables map[string]string) (string, error)
}

// SimpleTemplateEngine 简单模板引擎(使用{{variable}}语法)
type SimpleTemplateEngine struct{}

func (e *SimpleTemplateEngine) Render(template string, variables map[string]string) (string, error) {
    result := template
    
    // 替换所有变量
    for key, value := range variables {
        placeholder := "{{" + key + "}}"
        result = strings.ReplaceAll(result, placeholder, value)
    }
    
    // 检查是否还有未替换的变量
    if strings.Contains(result, "{{") {
        return "", errors.New("模板中存在未提供的变量")
    }
    
    return result, nil
}
```

### 4.5 邮件发送适配器(示例)

```go
// EmailAdapter 邮件发送适配器接口
type EmailAdapter interface {
    Send(ctx context.Context, to, subject, content string) error
}

// SMTPEmailAdapter SMTP邮件适配器
type SMTPEmailAdapter struct {
    host     string
    port     int
    username string
    password string
    from     string
}

func (a *SMTPEmailAdapter) Send(ctx context.Context, to, subject, content string) error {
    auth := smtp.PlainAuth("", a.username, a.password, a.host)
    
    msg := []byte(fmt.Sprintf(
        "To: %s\r\n"+
            "Subject: %s\r\n"+
            "Content-Type: text/html; charset=UTF-8\r\n"+
            "\r\n"+
            "%s\r\n",
        to, subject, content,
    ))
    
    addr := fmt.Sprintf("%s:%d", a.host, a.port)
    return smtp.SendMail(addr, auth, a.from, []string{to}, msg)
}
```

## 5. 数据库设计

### 5.1 MongoDB集合

```javascript
// notifications 集合
{
    "_id": ObjectId("..."),
    "user_id": "user123",
    "type": "email",
    "to": "user@example.com",
    "subject": "欢迎加入青羽",
    "content": "尊敬的用户...",
    "status": "sent",
    "is_read": false,
    "retry_count": 0,
    "created_at": ISODate("2025-10-17T10:00:00Z"),
    "sent_at": ISODate("2025-10-17T10:00:05Z")
}

// 索引设计
db.notifications.createIndex({ "user_id": 1, "created_at": -1 })
db.notifications.createIndex({ "user_id": 1, "is_read": 1 })
db.notifications.createIndex({ "status": 1, "retry_count": 1 })

// message_templates 集合
{
    "_id": ObjectId("..."),
    "name": "welcome_email",
    "type": "email",
    "subject": "欢迎加入青羽平台",
    "content": "尊敬的{{username}},欢迎您加入青羽...",
    "variables": ["username"],
    "description": "用户注册欢迎邮件",
    "is_active": true,
    "created_by": "admin",
    "created_at": ISODate("2025-10-17T10:00:00Z")
}

// 索引设计
db.message_templates.createIndex({ "name": 1 }, { unique: true })
db.message_templates.createIndex({ "type": 1, "is_active": 1 })
```

## 6. 性能优化

### 6.1 异步发送

- 所有通知通过消息队列异步发送,避免阻塞业务流程
- 使用Redis Streams作为消息队列,支持高吞吐量

### 6.2 批量发送优化

```go
// 批量发送时,使用goroutine并发处理
func (s *NotificationServiceImpl) SendBatch(ctx context.Context, notifications []*Notification) error {
    // 并发控制
    sem := make(chan struct{}, 10) // 最多10个并发
    var wg sync.WaitGroup
    
    for _, notification := range notifications {
        wg.Add(1)
        go func(n *Notification) {
            defer wg.Done()
            sem <- struct{}{}        // 获取信号量
            defer func() { <-sem }() // 释放信号量
            
            s.sendSingleNotification(ctx, n)
        }(notification)
    }
    
    wg.Wait()
    return nil
}
```

### 6.3 缓存优化

- 消息模板缓存到Redis,避免频繁查询MongoDB
- TTL设置为1小时

## 7. 监控和统计

### 7.1 监控指标

- 每分钟发送数量(按类型统计)
- 发送成功率
- 发送失败率
- 平均发送延迟
- 队列积压数量

### 7.2 统计报表

```go
// NotificationStats 通知统计
type NotificationStats struct {
    TotalSent     int64             // 总发送数
    SuccessCount  int64             // 成功数
    FailedCount   int64             // 失败数
    ByType        map[string]int64  // 按类型统计
    AvgDelay      time.Duration     // 平均延迟
}

// GetStats 获取统计数据
func (s *NotificationServiceImpl) GetStats(ctx context.Context, startTime, endTime time.Time) (*NotificationStats, error) {
    // 从MongoDB聚合查询统计数据
    pipeline := []bson.M{
        {"$match": bson.M{
            "created_at": bson.M{
                "$gte": startTime,
                "$lte": endTime,
            },
        }},
        {"$group": bson.M{
            "_id": "$type",
            "count": bson.M{"$sum": 1},
            "success": bson.M{"$sum": bson.M{"$cond": []interface{}{
                bson.M{"$eq": []string{"$status", "sent"}}, 1, 0,
            }}},
        }},
    }
    
    // ... 执行聚合查询
}
```

## 8. 安全设计

### 8.1 权限控制

- 普通用户只能查看自己的通知
- 管理员可以创建模板和批量发送通知
- API需要JWT认证

### 8.2 防滥用

- 批量发送限制(单次最多1000条)
- 发送频率限制(每用户每小时最多100条)
- 敏感操作需要二次确认

### 8.3 数据脱敏

- 记录日志时脱敏手机号和邮箱
- 例如: 138****1234, user***@example.com

## 9. MVP范围

### 9.1 MVP核心功能 ✅

- ✅ 邮件通知(SMTP)
- ✅ 站内消息通知
- ✅ 消息模板管理
- ✅ 基本的失败重试机制
- ✅ 通知记录查询

### 9.2 后续迭代功能 ⏸️

- ⏸️ 短信通知(接入第三方服务商)
- ⏸️ 推送通知(接入极光推送等)
- ⏸️ 高级模板引擎(支持条件、循环)
- ⏸️ 用户通知偏好设置
- ⏸️ 通知统计报表和仪表盘

## 10. 相关文档

- [消息队列设计](./消息队列设计.md)
- [管理后台设计](./管理后台设计.md)
- [共享底层服务设计文档](./README_共享底层服务设计文档.md)
- [项目开发规则](../../architecture/项目开发规则.md)

---

**文档维护**: 青羽后端架构团队  
**最后更新**: 2025-10-17

