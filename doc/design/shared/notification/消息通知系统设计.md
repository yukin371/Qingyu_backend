# 消息通知系统设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ⚠️ 部分实现，补充设计文档

---

## 1. 设计概述

### 1.1 业务价值

- 用户消息推送（系统通知、评论回复、点赞提醒等）
- 站内信管理
- 支持多渠道通知（站内、邮件、短信）

### 1.2 实现情况

**已实现**：
- Message数据模型：`models/shared/message/message.go`
- 基础消息存储

**待实现**：
- MessagingService完整业务逻辑
- 多渠道通知发送
- 消息模板管理

---

## 2. 核心数据模型

### 2.1 Message（消息）

```go
type Message struct {
    ID          string                 `bson:"_id,omitempty" json:"id"`
    UserID      string                 `bson:"userId" json:"userId"`       // 接收者ID
    Type        MessageType            `bson:"type" json:"type"`           // 消息类型
    Title       string                 `bson:"title" json:"title"`
    Content     string                 `bson:"content" json:"content"`
    Data        map[string]interface{} `bson:"data,omitempty" json:"data"` // 扩展数据
    IsRead      bool                   `bson:"isRead" json:"isRead"`
    ReadAt      *time.Time             `bson:"readAt,omitempty" json:"readAt"`
    CreatedAt   time.Time              `bson:"createdAt" json:"createdAt"`
    ExpiresAt   *time.Time             `bson:"expiresAt,omitempty" json:"expiresAt"`
}

type MessageType string

const (
    TypeSystem    MessageType = "system"     // 系统通知
    TypeComment   MessageType = "comment"    // 评论回复
    TypeLike      MessageType = "like"       // 点赞通知
    TypeFollow    MessageType = "follow"     // 关注通知
    TypeReward    MessageType = "reward"     // 打赏通知
    TypeAnnouncement MessageType = "announcement" // 公告
)
```

**索引策略**：
```javascript
db.messages.createIndex({ "userId": 1, "createdAt": -1 })
db.messages.createIndex({ "userId": 1, "isRead": 1 })
db.messages.createIndex({ "type": 1, "createdAt": -1 })
db.messages.createIndex({ "expiresAt": 1 })  // 过期清理
```

---

## 3. 消息模板设计

### 3.1 MessageTemplate（消息模板）

```go
type MessageTemplate struct {
    Type        MessageType
    Title       string  // 支持变量：{{username}}, {{bookTitle}}等
    Content     string
    Variables   []string
}

var Templates = map[MessageType]MessageTemplate{
    TypeComment: {
        Type:    TypeComment,
        Title:   "{{username}}回复了你的评论",
        Content: "{{username}}在《{{bookTitle}}》中回复了你：{{comment}}",
        Variables: []string{"username", "bookTitle", "comment"},
    },
    TypeLike: {
        Type:    TypeLike,
        Title:   "{{username}}赞了你的作品",
        Content: "你的作品《{{bookTitle}}》获得了{{username}}的点赞",
        Variables: []string{"username", "bookTitle"},
    },
}
```

### 3.2 模板渲染

```go
func RenderTemplate(tmpl MessageTemplate, data map[string]string) string {
    content := tmpl.Content
    for _, varName := range tmpl.Variables {
        if value, ok := data[varName]; ok {
            content = strings.ReplaceAll(content, "{{"+varName+"}}", value)
        }
    }
    return content
}
```

---

## 4. 多渠道通知设计

### 4.1 NotificationChannel（通知渠道）

```go
type NotificationChannel interface {
    Send(ctx context.Context, recipient string, message *Message) error
    GetName() string
}

// 站内信通知
type InAppChannel struct {
    messageRepo MessageRepository
}

// 邮件通知
type EmailChannel struct {
    smtpConfig SMTPConfig
}

// 短信通知（可选）
type SMSChannel struct {
    smsProvider SMSProvider
}
```

### 4.2 通知发送策略

```go
type NotificationService struct {
    channels map[string]NotificationChannel
}

func (s *NotificationService) SendNotification(ctx context.Context, notification *Notification) error {
    // 根据用户配置选择通知渠道
    userPrefs := s.getUserPreferences(notification.UserID)
    
    for _, channelName := range userPrefs.Channels {
        if channel, ok := s.channels[channelName]; ok {
            go channel.Send(ctx, notification.UserID, notification.Message)
        }
    }
    
    return nil
}
```

---

## 5. 消息聚合设计（独特设计）

### 5.1 消息合并

**问题**：大量相似消息（如：100个点赞）会造成消息轰炸

**解决方案**：时间窗口内消息聚合

```go
type AggregatedMessage struct {
    Type      MessageType
    Count     int
    Users     []string  // 参与用户列表（最多显示3个）
    Summary   string    // "张三等10人赞了你的作品"
    CreatedAt time.Time
}

func AggregateMessages(messages []*Message) *AggregatedMessage {
    if len(messages) <= 1 {
        return nil
    }
    
    users := make([]string, 0)
    for _, msg := range messages {
        if username, ok := msg.Data["username"].(string); ok {
            users = append(users, username)
        }
    }
    
    summary := buildSummary(users, len(messages))
    
    return &AggregatedMessage{
        Type:    messages[0].Type,
        Count:   len(messages),
        Users:   users[:min(len(users), 3)],
        Summary: summary,
    }
}

func buildSummary(users []string, count int) string {
    if count == 1 {
        return users[0] + "赞了你的作品"
    } else if count <= 3 {
        return strings.Join(users, "、") + "赞了你的作品"
    } else {
        return fmt.Sprintf("%s等%d人赞了你的作品", users[0], count)
    }
}
```

### 5.2 聚合策略

- **时间窗口**：5分钟内相同类型的消息合并
- **最大数量**：每次聚合最多100条消息
- **实时性平衡**：超过10条立即聚合推送

---

## 6. Service层设计

### 6.1 MessagingService核心方法

```go
type MessagingService interface {
    // SendMessage 发送消息
    SendMessage(ctx context.Context, req *SendMessageRequest) error
    
    // GetUserMessages 获取用户消息列表
    GetUserMessages(ctx context.Context, userID string, page, pageSize int) ([]*Message, error)
    
    // MarkAsRead 标记为已读
    MarkAsRead(ctx context.Context, userID string, messageIDs []string) error
    
    // MarkAllAsRead 全部标记为已读
    MarkAllAsRead(ctx context.Context, userID string) error
    
    // GetUnreadCount 获取未读数量
    GetUnreadCount(ctx context.Context, userID string) (int64, error)
    
    // DeleteMessage 删除消息
    DeleteMessage(ctx context.Context, userID string, messageID string) error
}
```

---

## 7. API设计

```
GET    /api/v1/messages              - 获取消息列表
GET    /api/v1/messages/unread/count - 获取未读数量
PUT    /api/v1/messages/read         - 批量标记已读
PUT    /api/v1/messages/:id/read     - 标记单条已读
DELETE /api/v1/messages/:id          - 删除消息
```

---

## 8. 实时推送集成

### 8.1 WebSocket推送

```go
// 新消息实时推送
func (s *MessagingService) NotifyUser(userID string, message *Message) {
    // 通过WebSocket推送给在线用户
    wsManager.SendToUser(userID, map[string]interface{}{
        "type": "new_message",
        "data": message,
    })
}
```

### 8.2 长轮询兼容

```go
// 为不支持WebSocket的客户端提供长轮询
GET /api/v1/messages/poll?lastMessageID=xxx&timeout=30s
```

---

## 9. 与v2.1架构的关系

```
Shared Module
  └─ Messaging Module
      ├─ Message (消息数据)
      ├─ MessageTemplate (消息模板)
      ├─ NotificationChannels (多渠道通知)
      └─ MessagingService (消息服务)
```

**事件订阅**：
```go
// 监听业务事件自动发送通知
eventBus.Subscribe("book.commented", sendCommentNotification)
eventBus.Subscribe("book.liked", sendLikeNotification)
eventBus.Subscribe("user.followed", sendFollowNotification)
```

---

## 10. 实现参考

**代码文件**：
- `models/shared/message/message.go` - 消息模型
- `service/shared/messaging/messaging_service.go`（待创建） - 消息服务
- `service/shared/messaging/notification_channels.go`（待创建） - 通知渠道
- `api/v1/shared/message_api.go`（待创建） - 消息API

---

**文档状态**: ✅ 已完成  
**优先级**: P0

