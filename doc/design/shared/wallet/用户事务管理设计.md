# 用户事务管理设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ⚠️ 待实现

---

## 1. 设计概述

### 1.1 业务价值

- 钱包交易事务管理
- 保证数据一致性
- 支持事务回滚

### 1.2 设计目标

- ACID特性保证
- 分布式事务支持
- 补偿机制

---

## 2. 事务类型

### 2.1 本地事务（MongoDB）

```go
type TransactionManager interface {
    // BeginTransaction 开始事务
    BeginTransaction(ctx context.Context) (Transaction, error)
    
    // Commit 提交事务
    Commit(ctx context.Context, txn Transaction) error
    
    // Rollback 回滚事务
    Rollback(ctx context.Context, txn Transaction) error
}
```

### 2.2 跨服务事务（Saga模式）

```go
type SagaTransaction struct {
    ID           string
    Steps        []SagaStep
    CurrentStep  int
    Status       string  // pending/completed/failed
    Compensations []CompensationFunc
}

type SagaStep struct {
    Name        string
    Execute     func(ctx context.Context) error
    Compensate  func(ctx context.Context) error
}
```

---

## 3. 钱包交易事务

### 3.1 充值事务

```go
func (m *TransactionManager) Recharge(ctx context.Context, userID string, amount float64) error {
    // 1. 开始事务
    txn, err := m.BeginTransaction(ctx)
    if err != nil {
        return err
    }
    defer txn.Rollback()
    
    // 2. 创建交易记录
    transaction := &WalletTransaction{
        UserID:    userID,
        Type:      "recharge",
        Amount:    amount,
        Status:    "pending",
        CreatedAt: time.Now(),
    }
    
    if err := m.transactionRepo.Create(ctx, transaction); err != nil {
        return err
    }
    
    // 3. 更新钱包余额
    if err := m.walletRepo.IncreaseBalance(ctx, userID, amount); err != nil {
        return err
    }
    
    // 4. 提交事务
    return txn.Commit()
}
```

### 3.2 消费事务（VIP购买）

```go
func (m *TransactionManager) PurchaseVIP(ctx context.Context, userID string, vipLevel string, price float64) error {
    saga := NewSaga("purchase_vip")
    
    // Step 1: 扣款
    saga.AddStep(SagaStep{
        Name: "deduct_balance",
        Execute: func(ctx context.Context) error {
            return m.walletRepo.DecreaseBalance(ctx, userID, price)
        },
        Compensate: func(ctx context.Context) error {
            return m.walletRepo.IncreaseBalance(ctx, userID, price)
        },
    })
    
    // Step 2: 激活VIP
    saga.AddStep(SagaStep{
        Name: "activate_vip",
        Execute: func(ctx context.Context) error {
            return m.vipService.ActivateVIP(ctx, userID, vipLevel, 30*24*time.Hour)
        },
        Compensate: func(ctx context.Context) error {
            return m.vipService.DeactivateVIP(ctx, userID)
        },
    })
    
    // Step 3: 创建订单
    saga.AddStep(SagaStep{
        Name: "create_order",
        Execute: func(ctx context.Context) error {
            order := &Order{
                UserID:    userID,
                Type:      "vip",
                Amount:    price,
                Status:    "completed",
                CreatedAt: time.Now(),
            }
            return m.orderRepo.Create(ctx, order)
        },
        Compensate: func(ctx context.Context) error {
            // 标记订单为失败
            return m.orderRepo.UpdateStatus(ctx, orderID, "failed")
        },
    })
    
    // 执行Saga
    return saga.Execute(ctx)
}
```

---

## 4. Saga事务引擎

### 4.1 Saga执行器

```go
type SagaExecutor struct {
    logger *log.Logger
}

func (e *SagaExecutor) Execute(ctx context.Context, saga *SagaTransaction) error {
    // 1. 依次执行每个步骤
    for i, step := range saga.Steps {
        saga.CurrentStep = i
        
        if err := step.Execute(ctx); err != nil {
            e.logger.Errorf("Saga step %s failed: %v", step.Name, err)
            
            // 2. 执行失败，触发补偿
            if err := e.compensate(ctx, saga, i); err != nil {
                e.logger.Errorf("Compensation failed: %v", err)
                return fmt.Errorf("saga failed and compensation failed: %w", err)
            }
            
            return fmt.Errorf("saga step %s failed: %w", step.Name, err)
        }
    }
    
    // 3. 所有步骤成功
    saga.Status = "completed"
    return nil
}

func (e *SagaExecutor) compensate(ctx context.Context, saga *SagaTransaction, failedStep int) error {
    // 逆序执行补偿操作
    for i := failedStep - 1; i >= 0; i-- {
        step := saga.Steps[i]
        
        if err := step.Compensate(ctx); err != nil {
            return fmt.Errorf("compensation for step %s failed: %w", step.Name, err)
        }
        
        e.logger.Infof("Compensated step: %s", step.Name)
    }
    
    saga.Status = "compensated"
    return nil
}
```

---

## 5. 事务日志

### 5.1 SagaLog（事务日志）

```go
type SagaLog struct {
    ID         string    `bson:"_id,omitempty" json:"id"`
    SagaID     string    `bson:"sagaId" json:"sagaId"`
    Step       int       `bson:"step" json:"step"`
    StepName   string    `bson:"stepName" json:"stepName"`
    Action     string    `bson:"action" json:"action"`  // execute/compensate
    Status     string    `bson:"status" json:"status"`  // success/failed
    Error      string    `bson:"error,omitempty" json:"error,omitempty"`
    CreatedAt  time.Time `bson:"createdAt" json:"createdAt"`
}

// 记录事务日志
func (e *SagaExecutor) logStep(sagaID string, step int, stepName string, action string, status string, err error) {
    log := &SagaLog{
        SagaID:    sagaID,
        Step:      step,
        StepName:  stepName,
        Action:    action,
        Status:    status,
        CreatedAt: time.Now(),
    }
    
    if err != nil {
        log.Error = err.Error()
    }
    
    sagaLogRepo.Create(context.Background(), log)
}
```

---

## 6. 幂等性保证

### 6.1 幂等性Token

```go
type IdempotencyToken struct {
    Token     string
    UserID    string
    Action    string
    Result    interface{}
    CreatedAt time.Time
}

func (m *TransactionManager) ExecuteWithIdempotency(ctx context.Context, token string, action func() error) error {
    // 1. 检查Token是否已存在
    existing, _ := m.tokenRepo.GetByToken(ctx, token)
    if existing != nil {
        // Token已存在，返回之前的结果
        return nil
    }
    
    // 2. 创建Token
    idempToken := &IdempotencyToken{
        Token:     token,
        CreatedAt: time.Now(),
    }
    m.tokenRepo.Create(ctx, idempToken)
    
    // 3. 执行操作
    err := action()
    
    // 4. 更新Token结果
    if err == nil {
        m.tokenRepo.MarkSuccess(ctx, token)
    } else {
        m.tokenRepo.MarkFailed(ctx, token, err.Error())
    }
    
    return err
}
```

---

## 7. 与v2.1架构的关系

```
Shared Module
  └─ TransactionManager
      ├─ LocalTransaction (本地事务)
      ├─ SagaTransaction (分布式事务)
      ├─ IdempotencyToken (幂等性保证)
      └─ SagaLog (事务日志)
```

---

## 8. 实现参考

**代码文件**：
- `service/shared/transaction/transaction_manager.go`（待创建）
- `service/shared/transaction/saga_executor.go`（待创建）

---

**文档状态**: ✅ 已完成  
**优先级**: P1

