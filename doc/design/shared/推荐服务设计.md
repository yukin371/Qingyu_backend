# 推荐服务设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库，统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考：[微服务架构划分建议](../微服务架构划分建议.md)

## 1. 需求概述

### 1.1 功能描述
推荐服务是青羽平台的核心智能服务，基于用户行为数据、内容特征和协同过滤算法，为用户提供个性化的书籍和章节推荐。系统支持多种推荐策略，包括热门推荐、相似推荐、个性化推荐和实时推荐，提升用户阅读体验和平台内容消费效率。

### 1.2 业务价值
- **用户体验提升**：为用户推荐感兴趣的内容，提高阅读满意度
- **内容分发优化**：帮助优质内容获得更多曝光，提升作者收益
- **用户粘性增强**：通过精准推荐延长用户停留时间和阅读时长
- **商业价值最大化**：提高付费转化率和用户生命周期价值

### 1.3 用户场景
- 新用户注册后获得基于热门度的初始推荐
- 老用户基于历史阅读行为获得个性化推荐
- 用户阅读完一本书后获得相似书籍推荐
- 实时推荐基于当前浏览行为动态调整

### 1.4 功能边界
- **包含功能**：个性化推荐、热门推荐、相似推荐、实时推荐、推荐解释
- **不包含功能**：内容审核、用户画像构建、A/B测试平台

## 2. 架构设计

### 2.1 整体架构（模块化单体）
```
┌─────────────────────────────────────────────────────────┐
│                 青羽写作平台 (单一应用)                  │
│                                                         │
│  ┌───────────────────────────────────────────────┐    │
│  │         Gin HTTP Server                          │    │
│  │  Router (路由管理) + Middleware (缓存/认证)     │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓↑                             │
│  ┌───────────────────────────────────────────────┐    │
│  │       推荐模块 (Recommendation Module)           │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 推荐引擎 (Recommendation Engine)         │  │    │
│  │  │  - 推荐算法调度                        │  │    │
│  │  │  - 策略管理                            │  │    │
│  │  │  - 结果后处理                          │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 算法层 (Algorithm Layer)                │  │    │
│  │  │  - 协同过滤算法                        │  │    │
│  │  │  - 内容过滤算法                        │  │    │
│  │  │  - 特征工程                            │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ Repository层                            │  │    │
│  │  │  - UserBehaviorRepository                │  │    │
│  │  │  - ContentRepository                     │  │    │
│  │  │  - RecommendResultRepository             │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓↑                             │
│  ┌───────────────────────────────────────────────┐    │
│  │            数据存储层                          │    │
│  │  MongoDB(推荐数据) + Redis(缓存/实时特征)      │    │
│  └───────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

**说明**：
- 推荐模块作为主应用的一部分，不是独立服务
- Gin Router直接调用推荐服务，无需独立网关
- 模块间通过Go接口直接调用

### 2.2 模块划分
- **推荐引擎模块**：核心推荐算法实现和策略调度
- **特征工程模块**：用户特征、内容特征、上下文特征提取
- **实时计算模块**：实时行为处理和在线推荐计算
- **效果评估模块**：推荐效果监控和算法优化

### 2.3 技术选型（分阶段演进）

| 技术方案 | 优点 | 缺点 | 适用场景 | 当前采用 |
|---------|------|------|---------|----------|
| **内存缓存** | 极快、简单 | 容量有限 | 热点推荐结果 | ✅ 采用 |
| **Redis** | 高性能、持久化 | 需额外组件 | 用户画像、特征缓存 | ✅ 采用 |
| **MongoDB** | 灵活的文档模型 | 查询性能一般 | 推荐结果存储 | ✅ 采用 |
| **Elasticsearch** | 强大搜索能力 | 复杂、资源消耗大 | 大规模内容搜索 | ❌ 未来考虑 |
| **Kafka** | 高吞吐消息队列 | 复杂、运维成本高 | 实时行为流 | ❌ 未来考虑 |

**当前推荐**: MongoDB + Redis + 内存缓存

**未来升级条件**:
- 搜索需求复杂度高时，考虑Elasticsearch
- 实时流处理需求大时，考虑Kafka
- 日活用户 > 10万时，重新评估技术架构

## 3. 详细设计

### 3.1 Router层设计
- **路由分组**：/api/v1/recommend
- **中间件**：身份认证、限流、缓存、日志记录
- **路径规范**：RESTful风格，如 /recommend/books, /recommend/chapters
- **参数处理**：用户ID、推荐类型、数量限制、过滤条件

### 3.2 API层设计
- **接口定义**：书籍推荐、章节推荐、相似推荐、热门推荐接口
- **请求验证**：参数格式验证、用户权限验证、频率限制
- **响应格式**：统一的JSON响应结构，包含推荐列表和解释信息
- **错误处理**：降级策略，推荐失败时返回热门内容

### 3.3 Service层设计
- **推荐策略**：多策略融合，包括协同过滤、内容过滤、热门推荐
- **特征处理**：用户画像构建、内容特征提取、实时特征更新
- **算法调度**：根据用户类型和场景选择合适的推荐算法
- **结果后处理**：去重、过滤、排序、多样性优化
- **Repository交互**：通过Repository接口进行数据访问
- **模块间调用**：通过Go接口直接调用其他业务模块（如用户模块、书城模块）

**示例**：
```go
// 推荐服务调用用户服务
type RecommendationService struct {
    userService     interfaces.UserService      // 直接依赖注入
    bookstoreService interfaces.BookstoreService
    repository      repository.RecommendRepository
}

func (s *RecommendationService) GetRecommendations(userID string) ([]*models.Content, error) {
    // 直接调用用户服务获取用户画像
    user, err := s.userService.GetUserProfile(userID)
    // 推荐算法处理...
}
```

### 3.4 Repository层设计
- **接口抽象**：UserBehaviorRepository、ContentRepository、RecommendRepository
- **数据查询**：用户行为查询、内容信息查询、推荐结果存储
- **缓存策略**：热点数据缓存、推荐结果缓存、特征数据缓存
- **异常处理**：数据库连接异常、查询超时处理
- **与Model关系**：UserBehavior、Content、RecommendResult模型的数据映射

### 3.5 Model层设计
- **数据模型**：UserBehavior、Content、RecommendResult、UserProfile
- **特征模型**：用户特征向量、内容特征向量、相似度矩阵
- **验证逻辑**：数据完整性验证、特征有效性检查
- **Repository接口**：定义数据访问方法签名

## 4. 数据设计

### 4.1 数据模型

#### 用户行为模型 (UserBehavior)
```go
type UserBehavior struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    UserID      string    `bson:"user_id" json:"userId"`
    ContentID   string    `bson:"content_id" json:"contentId"`
    ContentType string    `bson:"content_type" json:"contentType"` // book, chapter
    ActionType  string    `bson:"action_type" json:"actionType"`   // view, like, share, purchase
    Duration    int64     `bson:"duration" json:"duration"`        // 阅读时长(秒)
    Progress    float64   `bson:"progress" json:"progress"`        // 阅读进度(0-1)
    Rating      int       `bson:"rating" json:"rating"`            // 评分(1-5)
    DeviceType  string    `bson:"device_type" json:"deviceType"`   // web, ios, android
    Timestamp   time.Time `bson:"timestamp" json:"timestamp"`
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`
}
```

#### 内容特征模型 (ContentFeature)
```go
type ContentFeature struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    ContentID   string    `bson:"content_id" json:"contentId"`
    ContentType string    `bson:"content_type" json:"contentType"`
    Title       string    `bson:"title" json:"title"`
    Category    string    `bson:"category" json:"category"`
    Tags        []string  `bson:"tags" json:"tags"`
    AuthorID    string    `bson:"author_id" json:"authorId"`
    WordCount   int64     `bson:"word_count" json:"wordCount"`
    PublishTime time.Time `bson:"publish_time" json:"publishTime"`
    ViewCount   int64     `bson:"view_count" json:"viewCount"`
    LikeCount   int64     `bson:"like_count" json:"likeCount"`
    Rating      float64   `bson:"rating" json:"rating"`
    Features    []float64 `bson:"features" json:"features"`        // 特征向量
    UpdatedAt   time.Time `bson:"updated_at" json:"updatedAt"`
}
```

#### 用户画像模型 (UserProfile)
```go
type UserProfile struct {
    ID              string            `bson:"_id,omitempty" json:"id"`
    UserID          string            `bson:"user_id" json:"userId"`
    PreferCategories []string         `bson:"prefer_categories" json:"preferCategories"`
    PreferTags      []string          `bson:"prefer_tags" json:"preferTags"`
    PreferAuthors   []string          `bson:"prefer_authors" json:"preferAuthors"`
    ReadingHabits   map[string]interface{} `bson:"reading_habits" json:"readingHabits"`
    Features        []float64         `bson:"features" json:"features"`        // 用户特征向量
    ActiveLevel     string            `bson:"active_level" json:"activeLevel"` // high, medium, low
    LastActiveTime  time.Time         `bson:"last_active_time" json:"lastActiveTime"`
    CreatedAt       time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt       time.Time         `bson:"updated_at" json:"updatedAt"`
}
```

#### 推荐结果模型 (RecommendResult)
```go
type RecommendResult struct {
    ID          string    `bson:"_id,omitempty" json:"id"`
    UserID      string    `bson:"user_id" json:"userId"`
    ContentID   string    `bson:"content_id" json:"contentId"`
    ContentType string    `bson:"content_type" json:"contentType"`
    Algorithm   string    `bson:"algorithm" json:"algorithm"`      // collaborative, content, hybrid
    Score       float64   `bson:"score" json:"score"`              // 推荐分数
    Rank        int       `bson:"rank" json:"rank"`                // 推荐排名
    Reason      string    `bson:"reason" json:"reason"`            // 推荐理由
    Context     map[string]interface{} `bson:"context" json:"context"` // 上下文信息
    IsClicked   bool      `bson:"is_clicked" json:"isClicked"`     // 是否点击
    ClickTime   time.Time `bson:"click_time" json:"clickTime"`
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`
}
```

### 4.2 数据关系
- UserBehavior 与 User：多对一关系，一个用户有多个行为记录
- ContentFeature 与 Content：一对一关系，每个内容有对应的特征
- UserProfile 与 User：一对一关系，每个用户有一个画像
- RecommendResult 与 User：多对一关系，一个用户有多个推荐结果

### 4.3 索引策略
| 集合名称 | 索引字段 | 索引类型 | 说明 |
|---------|---------|---------|------|
| user_behaviors | user_id, timestamp | compound | 用户行为时间复合索引 |
| user_behaviors | content_id, action_type | compound | 内容行为类型复合索引 |
| content_features | content_id | unique | 内容特征唯一索引 |
| content_features | category, rating | compound | 分类评分复合索引 |
| user_profiles | user_id | unique | 用户画像唯一索引 |
| recommend_results | user_id, created_at | compound | 用户推荐时间复合索引 |

### 4.4 数据迁移
- 从现有用户行为数据构建初始用户画像
- 计算内容特征向量和相似度矩阵
- 初始化推荐算法参数和模型

## 5. 接口设计

### 5.1 API概览

| 方法 | 路径 | 功能描述 | 权限要求 |
|-----|------|---------|---------|
| GET | /api/v1/recommend/books | 书籍推荐 | 用户认证 |
| GET | /api/v1/recommend/chapters | 章节推荐 | 用户认证 |
| GET | /api/v1/recommend/similar | 相似内容推荐 | 用户认证 |
| GET | /api/v1/recommend/hot | 热门内容推荐 | 无 |
| POST | /api/v1/recommend/feedback | 推荐反馈 | 用户认证 |
| GET | /api/v1/recommend/explain | 推荐解释 | 用户认证 |

### 5.2 请求与响应格式

#### 5.2.1 书籍推荐 (GET /api/v1/recommend/books)

**请求参数**:
- limit: 推荐数量，默认10，最大50
- category: 分类过滤，可选
- exclude: 排除的书籍ID列表，可选

**响应格式**:
```json
{
  "code": 200,
  "message": "推荐成功",
  "data": {
    "recommendations": [
      {
        "contentId": "book_123456",
        "title": "修仙传奇",
        "author": "青羽作者",
        "category": "玄幻",
        "tags": ["修仙", "热血", "升级"],
        "score": 0.95,
        "reason": "基于您对玄幻类小说的喜好",
        "coverUrl": "https://cdn.qingyu.com/covers/book_123456.jpg",
        "rating": 4.8,
        "wordCount": 1000000,
        "isVip": false
      }
    ],
    "algorithm": "hybrid",
    "requestId": "req_123456789"
  }
}
```

#### 5.2.2 相似内容推荐 (GET /api/v1/recommend/similar)

**请求参数**:
- contentId: 基准内容ID，必填
- contentType: 内容类型(book/chapter)，必填
- limit: 推荐数量，默认5

**响应格式**:
```json
{
  "code": 200,
  "message": "推荐成功",
  "data": {
    "baseContent": {
      "contentId": "book_123456",
      "title": "修仙传奇",
      "category": "玄幻"
    },
    "recommendations": [
      {
        "contentId": "book_789012",
        "title": "仙路争锋",
        "similarity": 0.87,
        "reason": "同为修仙题材，情节相似度高",
        "author": "另一作者",
        "rating": 4.6
      }
    ]
  }
}
```

#### 5.2.3 推荐反馈 (POST /api/v1/recommend/feedback)

**请求参数**:
```json
{
  "recommendId": "rec_123456789",
  "contentId": "book_123456",
  "action": "click",
  "rating": 4,
  "context": {
    "position": 1,
    "page": "home"
  }
}
```

**响应格式**:
```json
{
  "code": 200,
  "message": "反馈记录成功",
  "data": {
    "feedbackId": "fb_123456789"
  }
}
```

**状态码**:
- 200: 成功
- 400: 请求参数错误
- 401: 用户未认证
- 429: 请求过于频繁
- 500: 服务器错误

## 6. 算法设计

### 6.1 推荐算法策略

#### 6.1.1 协同过滤算法
- **用户协同过滤**：基于用户相似度推荐相似用户喜欢的内容
- **物品协同过滤**：基于内容相似度推荐用户历史喜欢内容的相似内容
- **矩阵分解**：使用SVD、NMF等方法降维处理稀疏评分矩阵

#### 6.1.2 内容过滤算法
- **特征匹配**：基于内容特征(分类、标签、作者)进行匹配推荐
- **文本相似度**：使用TF-IDF、Word2Vec计算内容文本相似度
- **深度学习**：使用BERT、GPT等模型提取内容语义特征

#### 6.1.3 混合推荐算法
- **加权融合**：对不同算法结果进行加权平均
- **切换策略**：根据用户类型和数据丰富度选择算法
- **混合排序**：综合多种因素进行最终排序

### 6.2 实时推荐（简化版）
- **行为收集**：通过消息队列模块（Redis Streams）处理实时用户行为
- **在线学习**：实时更新用户画像和推荐模型
- **热点检测**：识别热门内容并快速推荐
- **缓存策略**：Redis缓存实时特征和推荐结果

**实现方案**：
```go
// 实时行为处理
func (s *RecommendationService) ProcessUserBehavior(behavior *models.UserBehavior) {
    // 1. 发送到消息队列
    s.messageQueue.Send("user_behavior", behavior)
    
    // 2. 异步消费者处理
    // 3. 更新Redis中的实时特征
    // 4. 刷新推荐缓存
}
```

### 6.3 冷启动处理
- **新用户**：基于人口统计学信息和热门内容推荐
- **新内容**：基于内容特征和作者历史表现推荐
- **探索与利用**：平衡推荐准确性和内容多样性

## 7. 安全设计

### 7.1 数据安全
- 用户行为数据脱敏处理，保护用户隐私
- 推荐结果不泄露其他用户的行为信息
- 敏感特征数据加密存储

### 7.2 算法安全
- 防止推荐结果被恶意操控
- 检测和过滤异常行为数据
- 推荐多样性保证，避免信息茧房

### 7.3 性能安全
- 推荐请求频率限制
- 算法计算资源限制
- 缓存击穿和雪崩防护

## 8. 测试设计

### 8.1 测试策略
- 单元测试：覆盖所有算法模块和Service方法
- 集成测试：测试推荐流程和数据流转
- 算法测试：离线评估推荐算法效果
- 性能测试：高并发推荐请求处理能力

### 8.2 评估指标
- **准确性指标**：精确率(Precision)、召回率(Recall)、F1分数
- **排序指标**：NDCG、MAP、AUC
- **多样性指标**：内容多样性、类别覆盖度
- **业务指标**：点击率(CTR)、转化率、用户满意度

### 8.3 A/B测试
- 不同算法策略对比测试
- 推荐数量和展示方式测试
- 推荐解释效果测试

## 9. 部署和运维

### 9.1 部署方案（模块化单体）

**阶段1：开发环境**（当前）
```bash
# 使用 Docker Compose
docker-compose up -d
```
- 推荐模块集成在主应用中
- MongoDB + Redis 作为数据存储
- 本地开发和测试

**阶段2：生产环境**
```bash
# 单机/多实例 + Nginx负载均衡
nginx → app_instance_1 (含推荐模块)
      → app_instance_2 (含推荐模块)
```
- Docker容器化部署
- 水平扩展多个应用实例
- Redis缓存推荐结果，减少计算压力

**阶段3：大规模部署**（日活 > 10万）
- 可选：将推荐模块拆分为独立微服务
- 需要条件：推荐成为性能瓶颈、需要独立扩展

**算法模型管理**：
- 模型文件存储在本地或对象存储
- 灰度发布新算法，监控效果指标
- 支持快速回滚到旧版本

### 9.2 监控指标
- 服务可用性：99.9%以上
- 推荐响应时间：<200ms
- 算法准确性：CTR>5%
- 系统吞吐量：10000+QPS

### 9.3 运维策略

**监控指标**：
```go
// 关键指标
- 推荐接口响应时间 (P95 < 200ms)
- 推荐点击率 (CTR > 3%)
- 缓存命中率 (> 80%)
- 算法计算失败率 (< 0.1%)
```

**日志系统**：
- 使用Zap记录推荐请求、算法调用、缓存命中
- 本地文件 + 日志轮转

**告警机制**：
- 推荐响应时间超限告警
- CTR下降告警
- 缓存雪崩告警

**质量保障**：
- A/B测试新算法
- 定期人工抽检推荐结果
- 用户反馈收集

## 10. 风险评估

### 10.1 技术风险
- 算法模型过拟合：定期重训练和验证
- 数据稀疏性问题：多策略融合和冷启动处理
- 计算资源瓶颈：分布式计算和缓存优化

### 10.2 业务风险
- 推荐偏差风险：多样性保证和公平性检查
- 用户隐私风险：数据脱敏和权限控制
- 内容质量风险：推荐内容质量监控

### 10.3 运营风险
- 推荐效果下降：持续优化和A/B测试
- 系统故障风险：降级策略和备份方案
- 恶意刷量风险：异常检测和防护机制

## 11. 实施计划

### 11.1 开发阶段
- 第1-2周：基础架构搭建，数据模型设计
- 第3-4周：基础推荐算法实现
- 第5-6周：实时推荐和特征工程
- 第7-8周：API接口开发和测试

### 11.2 算法优化阶段
- 第9-10周：算法效果评估和优化
- 第11-12周：A/B测试和策略调优
- 第13周：性能优化和压力测试

### 11.3 上线计划
- 第14周：生产环境部署
- 灰度发布和效果监控
- 全量上线和持续优化