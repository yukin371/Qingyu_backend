# 会话管理系统设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **最后更新**: 2025-10-21  
> **状态**: ⚠️ 需要补充实现

---

## 1. 为什么需要这个设计

### 1.1 业务背景

会话管理系统是用户认证和安全的核心组件，负责：
- 用户登录会话管理
- 多设备登录控制
- 会话超时和续期
- 在线状态管理
- 安全登出和会话撤销

### 1.2 实际实现情况

当前已实现：
- **JWT认证**：`service/shared/auth/jwt_service.go`
- **AuthService**：`service/shared/auth/auth_service.go`
- **JWT中间件**：`middleware/jwt.go`

**缺失部分**：
- 会话数据模型（Session）
- 会话持久化存储
- 多设备管理
- 会话刷新机制
- 在线状态追踪

---

## 2. 系统架构设计

### 2.1 整体架构

```
┌──────────────────────────────────────────────┐
│            Client (客户端)                    │
│  - Web浏览器                                  │
│  - 移动App                                    │
│  - 桌面应用                                   │
└──────────────────────────────────────────────┘
                    ↓ HTTP + JWT
┌──────────────────────────────────────────────┐
│         API Gateway (API网关)                 │
│         JWT认证中间件                          │
└──────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────┐
│       SessionService (会话服务)               │
│  - createSession()                            │
│  - validateSession()                          │
│  - refreshSession()                           │
│  - terminateSession()                         │
│  - getUserSessions()                          │
└──────────────────────────────────────────────┘
                    ↓
┌─────────────────────┬────────────────────────┐
│  SessionRepository  │  Redis Cache            │
│  (MongoDB)          │  (快速访问)             │
└─────────────────────┴────────────────────────┘
```

### 2.2 核心组件

| 组件 | 职责 |
|------|------|
| SessionService | 会话业务逻辑，创建/验证/刷新会话 |
| SessionRepository | 会话数据持久化 |
| Redis Cache | 会话快速查询缓存 |
| JWT Middleware | 请求拦截，JWT解析验证 |
| RefreshToken Manager | 刷新令牌管理 |

---

## 3. 数据模型设计

### 3.1 Session（会话）

#### 3.1.1 数据结构

```go
type Session struct {
    ID           string                 `bson:"_id,omitempty" json:"id"`
    UserID       string                 `bson:"userId" json:"userId" validate:"required"`
    DeviceID     string                 `bson:"deviceId" json:"deviceId"`                    // 设备唯一标识
    DeviceInfo   DeviceInfo             `bson:"deviceInfo" json:"deviceInfo"`                // 设备信息
    AccessToken  string                 `bson:"accessToken" json:"accessToken"`              // JWT访问令牌
    RefreshToken string                 `bson:"refreshToken" json:"refreshToken"`            // 刷新令牌
    IPAddress    string                 `bson:"ipAddress" json:"ipAddress"`                  // IP地址
    Location     string                 `bson:"location,omitempty" json:"location"`          // 地理位置
    UserAgent    string                 `bson:"userAgent" json:"userAgent"`                  // User-Agent
    Status       SessionStatus          `bson:"status" json:"status"`                        // 会话状态
    IsActive     bool                   `bson:"isActive" json:"isActive"`                    // 是否活跃
    LastActivity time.Time              `bson:"lastActivity" json:"lastActivity"`            // 最后活动时间
    CreatedAt    time.Time              `bson:"createdAt" json:"createdAt"`
    ExpiresAt    time.Time              `bson:"expiresAt" json:"expiresAt"`                  // 过期时间
    TerminatedAt *time.Time             `bson:"terminatedAt,omitempty" json:"terminatedAt"`  // 终止时间
    Metadata     map[string]interface{} `bson:"metadata,omitempty" json:"metadata"`          // 扩展元数据
}
```

#### 3.1.2 SessionStatus（会话状态）

```go
type SessionStatus string

const (
    SessionStatusActive     SessionStatus = "active"      // 活跃
    SessionStatusExpired    SessionStatus = "expired"     // 已过期
    SessionStatusTerminated SessionStatus = "terminated"  // 已终止
    SessionStatusRevoked    SessionStatus = "revoked"     // 已撤销
)
```

#### 3.1.3 DeviceInfo（设备信息）

```go
type DeviceInfo struct {
    DeviceType string `bson:"deviceType" json:"deviceType"` // web/ios/android/windows/macos
    DeviceName string `bson:"deviceName" json:"deviceName"` // 设备名称
    OS         string `bson:"os" json:"os"`                 // 操作系统
    OSVersion  string `bson:"osVersion" json:"osVersion"`   // 系统版本
    Browser    string `bson:"browser" json:"browser"`       // 浏览器
    AppVersion string `bson:"appVersion" json:"appVersion"` // 应用版本
}
```

#### 3.1.4 业务方法

```go
// IsExpired 是否已过期
func (s *Session) IsExpired() bool {
    return time.Now().After(s.ExpiresAt)
}

// IsValid 是否有效
func (s *Session) IsValid() bool {
    return s.Status == SessionStatusActive && 
           s.IsActive && 
           !s.IsExpired()
}

// UpdateActivity 更新活动时间
func (s *Session) UpdateActivity() {
    s.LastActivity = time.Now()
}

// Terminate 终止会话
func (s *Session) Terminate() {
    s.Status = SessionStatusTerminated
    s.IsActive = false
    now := time.Now()
    s.TerminatedAt = &now
}

// Revoke 撤销会话
func (s *Session) Revoke() {
    s.Status = SessionStatusRevoked
    s.IsActive = false
}

// GetDeviceLabel 获取设备标签
func (s *Session) GetDeviceLabel() string {
    if s.DeviceInfo.DeviceName != "" {
        return s.DeviceInfo.DeviceName
    }
    return fmt.Sprintf("%s (%s)", s.DeviceInfo.Browser, s.DeviceInfo.OS)
}
```

#### 3.1.5 索引策略

```javascript
// MongoDB索引
db.sessions.createIndex({ "userId": 1, "isActive": 1, "createdAt": -1 })  // 查询用户活跃会话
db.sessions.createIndex({ "accessToken": 1 })                              // 根据Token查询
db.sessions.createIndex({ "refreshToken": 1 })                             // 刷新令牌查询
db.sessions.createIndex({ "expiresAt": 1 })                                // 过期清理
db.sessions.createIndex({ "status": 1, "lastActivity": -1 })               // 按状态查询
db.sessions.createIndex({ "deviceId": 1, "userId": 1 })                    // 设备会话查询
```

---

### 3.2 RefreshToken（刷新令牌）

```go
type RefreshToken struct {
    Token      string    `bson:"token" json:"token" validate:"required"`
    SessionID  string    `bson:"sessionId" json:"sessionId"`
    UserID     string    `bson:"userId" json:"userId"`
    IsUsed     bool      `bson:"isUsed" json:"isUsed"`
    IsRevoked  bool      `bson:"isRevoked" json:"isRevoked"`
    ExpiresAt  time.Time `bson:"expiresAt" json:"expiresAt"`
    CreatedAt  time.Time `bson:"createdAt" json:"createdAt"`
}

// IsValid 是否有效
func (rt *RefreshToken) IsValid() bool {
    return !rt.IsUsed && 
           !rt.IsRevoked && 
           time.Now().Before(rt.ExpiresAt)
}
```

---

## 4. Repository接口设计

### 4.1 SessionRepository接口

```go
package interfaces

type SessionRepository interface {
    // Create 创建会话
    Create(ctx context.Context, session *Session) error
    
    // GetByID 根据ID获取会话
    GetByID(ctx context.Context, id string) (*Session, error)
    
    // GetByAccessToken 根据访问令牌获取会话
    GetByAccessToken(ctx context.Context, token string) (*Session, error)
    
    // GetByRefreshToken 根据刷新令牌获取会话
    GetByRefreshToken(ctx context.Context, token string) (*Session, error)
    
    // GetUserActiveSessions 获取用户的所有活跃会话
    GetUserActiveSessions(ctx context.Context, userID string) ([]*Session, error)
    
    // GetUserSessionsByDevice 获取用户在特定设备上的会话
    GetUserSessionsByDevice(ctx context.Context, userID string, deviceID string) ([]*Session, error)
    
    // Update 更新会话
    Update(ctx context.Context, id string, updates map[string]interface{}) error
    
    // UpdateActivity 更新会话活动时间
    UpdateActivity(ctx context.Context, id string) error
    
    // Terminate 终止会话
    Terminate(ctx context.Context, id string) error
    
    // TerminateByUserID 终止用户的所有会话
    TerminateByUserID(ctx context.Context, userID string) error
    
    // TerminateOtherSessions 终止用户的其他会话（排除当前会话）
    TerminateOtherSessions(ctx context.Context, userID string, currentSessionID string) error
    
    // CleanupExpiredSessions 清理过期会话
    CleanupExpiredSessions(ctx context.Context) error
    
    // CountActiveSessions 统计活跃会话数量
    CountActiveSessions(ctx context.Context, userID string) (int64, error)
    
    // Health 健康检查
    Health(ctx context.Context) error
}
```

---

## 5. Service层设计

### 5.1 SessionService结构

```go
type SessionService struct {
    sessionRepo  interfaces.SessionRepository
    userRepo     interfaces.UserRepository
    jwtService   *JWTService
    cache        cache.Cache
    eventBus     base.EventBus
    validator    base.Validator
    serviceName  string
    
    // 配置
    accessTokenTTL  time.Duration  // 访问令牌有效期（默认1小时）
    refreshTokenTTL time.Duration  // 刷新令牌有效期（默认30天）
    maxSessions     int            // 每个用户最大会话数（默认5）
}

func NewSessionService(
    sessionRepo interfaces.SessionRepository,
    userRepo interfaces.UserRepository,
    jwtService *JWTService,
    cache cache.Cache,
    eventBus base.EventBus,
) *SessionService {
    return &SessionService{
        sessionRepo:     sessionRepo,
        userRepo:        userRepo,
        jwtService:      jwtService,
        cache:           cache,
        eventBus:        eventBus,
        validator:       base.NewBaseValidator(),
        serviceName:     "SessionService",
        accessTokenTTL:  1 * time.Hour,
        refreshTokenTTL: 30 * 24 * time.Hour,
        maxSessions:     5,
    }
}
```

### 5.2 核心业务方法

#### 5.2.1 创建会话

```go
// CreateSession 创建新会话（用户登录）
func (s *SessionService) CreateSession(ctx context.Context, req *CreateSessionRequest) (*CreateSessionResponse, error) {
    // 1. 验证用户
    user, err := s.userRepo.GetByID(ctx, req.UserID)
    if err != nil || user == nil {
        return nil, errors.NewNotFoundError("用户不存在")
    }
    
    // 2. 检查会话数量限制
    activeCount, _ := s.sessionRepo.CountActiveSessions(ctx, req.UserID)
    if activeCount >= int64(s.maxSessions) {
        // 终止最老的会话
        s.terminateOldestSession(ctx, req.UserID)
    }
    
    // 3. 生成JWT访问令牌
    accessToken, err := s.jwtService.GenerateToken(req.UserID, user.Role, s.accessTokenTTL)
    if err != nil {
        return nil, errors.NewInternalError("生成访问令牌失败").WithCause(err)
    }
    
    // 4. 生成刷新令牌
    refreshToken, err := s.generateRefreshToken()
    if err != nil {
        return nil, errors.NewInternalError("生成刷新令牌失败").WithCause(err)
    }
    
    // 5. 解析设备信息
    deviceInfo := parseDeviceInfo(req.UserAgent)
    
    // 6. 创建会话
    session := &Session{
        UserID:       req.UserID,
        DeviceID:     req.DeviceID,
        DeviceInfo:   deviceInfo,
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        IPAddress:    req.IPAddress,
        Location:     s.getLocationByIP(req.IPAddress),
        UserAgent:    req.UserAgent,
        Status:       SessionStatusActive,
        IsActive:     true,
        LastActivity: time.Now(),
        CreatedAt:    time.Now(),
        ExpiresAt:    time.Now().Add(s.refreshTokenTTL),
    }
    
    // 7. 保存会话
    if err := s.sessionRepo.Create(ctx, session); err != nil {
        return nil, errors.NewInternalError("创建会话失败").WithCause(err)
    }
    
    // 8. 缓存会话（快速查询）
    s.cacheSession(ctx, session)
    
    // 9. 发布事件
    event := &base.BaseEvent{
        EventType: "session.created",
        EventData: map[string]interface{}{
            "session_id": session.ID,
            "user_id":    session.UserID,
            "device_id":  session.DeviceID,
            "ip_address": session.IPAddress,
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    // 10. 返回响应
    return &CreateSessionResponse{
        SessionID:    session.ID,
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        ExpiresAt:    session.ExpiresAt,
    }, nil
}
```

#### 5.2.2 验证会话

```go
// ValidateSession 验证会话
func (s *SessionService) ValidateSession(ctx context.Context, accessToken string) (*Session, error) {
    // 1. 尝试从缓存获取
    cachedSession := s.getSessionFromCache(ctx, accessToken)
    if cachedSession != nil && cachedSession.IsValid() {
        // 更新活动时间
        s.sessionRepo.UpdateActivity(ctx, cachedSession.ID)
        return cachedSession, nil
    }
    
    // 2. 从数据库查询
    session, err := s.sessionRepo.GetByAccessToken(ctx, accessToken)
    if err != nil || session == nil {
        return nil, errors.NewAuthError("会话不存在")
    }
    
    // 3. 验证会话
    if !session.IsValid() {
        return nil, errors.NewAuthError("会话无效或已过期")
    }
    
    // 4. 验证JWT
    claims, err := s.jwtService.ValidateToken(accessToken)
    if err != nil {
        session.Terminate()
        s.sessionRepo.Update(ctx, session.ID, map[string]interface{}{
            "status":   SessionStatusExpired,
            "isActive": false,
        })
        return nil, errors.NewAuthError("令牌验证失败")
    }
    
    // 5. 检查用户ID匹配
    if claims.UserID != session.UserID {
        return nil, errors.NewAuthError("令牌与会话不匹配")
    }
    
    // 6. 更新活动时间
    s.sessionRepo.UpdateActivity(ctx, session.ID)
    session.UpdateActivity()
    
    // 7. 更新缓存
    s.cacheSession(ctx, session)
    
    return session, nil
}
```

#### 5.2.3 刷新会话

```go
// RefreshSession 刷新会话（使用刷新令牌获取新的访问令牌）
func (s *SessionService) RefreshSession(ctx context.Context, refreshToken string) (*RefreshSessionResponse, error) {
    // 1. 查询会话
    session, err := s.sessionRepo.GetByRefreshToken(ctx, refreshToken)
    if err != nil || session == nil {
        return nil, errors.NewAuthError("刷新令牌无效")
    }
    
    // 2. 验证会话状态
    if session.Status != SessionStatusActive {
        return nil, errors.NewAuthError("会话已失效")
    }
    
    // 3. 检查刷新令牌是否过期
    if session.IsExpired() {
        session.Terminate()
        s.sessionRepo.Update(ctx, session.ID, map[string]interface{}{
            "status":   SessionStatusExpired,
            "isActive": false,
        })
        return nil, errors.NewAuthError("刷新令牌已过期")
    }
    
    // 4. 获取用户信息
    user, err := s.userRepo.GetByID(ctx, session.UserID)
    if err != nil || user == nil {
        return nil, errors.NewNotFoundError("用户不存在")
    }
    
    // 5. 生成新的访问令牌
    newAccessToken, err := s.jwtService.GenerateToken(user.ID, user.Role, s.accessTokenTTL)
    if err != nil {
        return nil, errors.NewInternalError("生成访问令牌失败").WithCause(err)
    }
    
    // 6. 更新会话
    updates := map[string]interface{}{
        "accessToken":  newAccessToken,
        "lastActivity": time.Now(),
    }
    
    if err := s.sessionRepo.Update(ctx, session.ID, updates); err != nil {
        return nil, errors.NewInternalError("更新会话失败").WithCause(err)
    }
    
    // 7. 更新缓存
    session.AccessToken = newAccessToken
    session.UpdateActivity()
    s.cacheSession(ctx, session)
    
    // 8. 发布事件
    event := &base.BaseEvent{
        EventType: "session.refreshed",
        EventData: map[string]interface{}{
            "session_id": session.ID,
            "user_id":    session.UserID,
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    // 9. 返回新令牌
    return &RefreshSessionResponse{
        AccessToken: newAccessToken,
        ExpiresIn:   int(s.accessTokenTTL.Seconds()),
    }, nil
}
```

#### 5.2.4 终止会话

```go
// TerminateSession 终止会话（用户登出）
func (s *SessionService) TerminateSession(ctx context.Context, sessionID string, userID string) error {
    // 1. 获取会话
    session, err := s.sessionRepo.GetByID(ctx, sessionID)
    if err != nil || session == nil {
        return errors.NewNotFoundError("会话不存在")
    }
    
    // 2. 验证权限（确保是会话所有者）
    if session.UserID != userID {
        return errors.NewAuthError("无权终止此会话")
    }
    
    // 3. 终止会话
    if err := s.sessionRepo.Terminate(ctx, sessionID); err != nil {
        return errors.NewInternalError("终止会话失败").WithCause(err)
    }
    
    // 4. 清除缓存
    s.invalidateSessionCache(ctx, session.AccessToken)
    
    // 5. 发布事件
    event := &base.BaseEvent{
        EventType: "session.terminated",
        EventData: map[string]interface{}{
            "session_id": sessionID,
            "user_id":    userID,
            "device_id":  session.DeviceID,
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}

// TerminateAllSessions 终止用户的所有会话
func (s *SessionService) TerminateAllSessions(ctx context.Context, userID string) error {
    // 1. 获取所有活跃会话
    sessions, err := s.sessionRepo.GetUserActiveSessions(ctx, userID)
    if err != nil {
        return err
    }
    
    // 2. 终止所有会话
    if err := s.sessionRepo.TerminateByUserID(ctx, userID); err != nil {
        return err
    }
    
    // 3. 清除缓存
    for _, session := range sessions {
        s.invalidateSessionCache(ctx, session.AccessToken)
    }
    
    // 4. 发布事件
    event := &base.BaseEvent{
        EventType: "session.all_terminated",
        EventData: map[string]interface{}{
            "user_id":       userID,
            "session_count": len(sessions),
        },
        Timestamp: time.Now(),
        Source:    s.serviceName,
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}
```

#### 5.2.5 获取用户会话列表

```go
// GetUserSessions 获取用户的所有会话
func (s *SessionService) GetUserSessions(ctx context.Context, userID string) ([]*SessionInfo, error) {
    // 1. 查询会话
    sessions, err := s.sessionRepo.GetUserActiveSessions(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    // 2. 转换为响应格式
    result := make([]*SessionInfo, len(sessions))
    for i, session := range sessions {
        result[i] = &SessionInfo{
            SessionID:    session.ID,
            DeviceLabel:  session.GetDeviceLabel(),
            DeviceType:   session.DeviceInfo.DeviceType,
            IPAddress:    session.IPAddress,
            Location:     session.Location,
            LastActivity: session.LastActivity,
            CreatedAt:    session.CreatedAt,
            IsCurrent:    false,  // 需要调用方标记当前会话
        }
    }
    
    return result, nil
}
```

### 5.3 辅助方法

```go
// generateRefreshToken 生成刷新令牌
func (s *SessionService) generateRefreshToken() (string, error) {
    tokenBytes := make([]byte, 32)
    if _, err := rand.Read(tokenBytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(tokenBytes), nil
}

// cacheSession 缓存会话
func (s *SessionService) cacheSession(ctx context.Context, session *Session) {
    cacheKey := fmt.Sprintf("session:%s", session.AccessToken)
    s.cache.Set(ctx, cacheKey, session, s.accessTokenTTL)
}

// getSessionFromCache 从缓存获取会话
func (s *SessionService) getSessionFromCache(ctx context.Context, accessToken string) *Session {
    cacheKey := fmt.Sprintf("session:%s", accessToken)
    cached, err := s.cache.Get(ctx, cacheKey)
    if err != nil || cached == nil {
        return nil
    }
    return cached.(*Session)
}

// invalidateSessionCache 清除会话缓存
func (s *SessionService) invalidateSessionCache(ctx context.Context, accessToken string) {
    cacheKey := fmt.Sprintf("session:%s", accessToken)
    s.cache.Delete(ctx, cacheKey)
}

// parseDeviceInfo 解析设备信息
func parseDeviceInfo(userAgent string) DeviceInfo {
    // 使用user-agent解析库，如github.com/mssola/user_agent
    ua := user_agent.New(userAgent)
    
    return DeviceInfo{
        Browser:    ua.Browser(),
        OS:         ua.OS(),
        DeviceType: detectDeviceType(ua),
    }
}

// detectDeviceType 检测设备类型
func detectDeviceType(ua *user_agent.UserAgent) string {
    if ua.Mobile() {
        return "mobile"
    }
    if ua.Bot() {
        return "bot"
    }
    return "web"
}
```

---

## 6. 事件设计

```go
// 会话创建事件
type SessionCreatedEvent struct {
    SessionID string
    UserID    string
    DeviceID  string
    IPAddress string
    Timestamp time.Time
}

// 会话刷新事件
type SessionRefreshedEvent struct {
    SessionID string
    UserID    string
    Timestamp time.Time
}

// 会话终止事件
type SessionTerminatedEvent struct {
    SessionID string
    UserID    string
    DeviceID  string
    Reason    string
    Timestamp time.Time
}
```

---

## 7. 与v2.1架构的关系

### 7.1 在整体架构中的位置

```
Shared Module (共享模块)
  └─ Auth Module (认证授权模块)
      ├─ SessionService (会话服务)
      ├─ JWTService (JWT服务)
      └─ AuthService (认证服务)
```

### 7.2 与其他模块的协作

1. **User Module**: 获取用户信息，验证用户状态
2. **Permission Module**: 结合会话验证权限
3. **Audit Module**: 记录会话创建/销毁事件

---

## 8. 定时任务

### 8.1 清理过期会话

```go
// ScheduleSessionCleanup 定时清理过期会话（每小时执行）
func (s *SessionService) ScheduleSessionCleanup() {
    ticker := time.NewTicker(1 * time.Hour)
    
    go func() {
        for range ticker.C {
            s.sessionRepo.CleanupExpiredSessions(context.Background())
        }
    }()
}
```

---

## 9. 实现参考

### 9.1 需要创建的文件

- `models/shared/auth/session.go` - Session数据模型
- `repository/interfaces/session/SessionRepository_interface.go` - Repository接口
- `repository/mongodb/session/session_repository_mongo.go` - MongoDB实现
- `service/shared/auth/session_service.go` - SessionService实现
- `service/shared/auth/session_dto.go` - DTO定义

### 9.2 已有相关文件

- ✅ `service/shared/auth/jwt_service.go` - JWT服务
- ✅ `middleware/jwt.go` - JWT中间件

---

**文档状态**: ✅ 已完成  
**最后审核**: 2025-10-21  
**优先级**: P0 - 基础设施

