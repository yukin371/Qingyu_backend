# 会话管理设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库,统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考:[微服务架构划分建议](../微服务架构划分建议.md)
> 
> **文档状态**: ✅ MVP核心功能  
> **创建时间**: 2025-10-17  
> **最后更新**: 2025-10-17  
> **实施状态**: ✅ 已完成 (95%)

## 1. 需求概述

### 1.1 功能描述

会话管理系统是青羽平台身份认证的核心组件,负责管理用户登录会话、Token生命周期、多端登录控制等功能。系统采用JWT Token + Redis会话存储的方案,实现无状态认证和灵活的会话控制,确保用户身份安全和良好的登录体验。

### 1.2 业务价值

- **安全认证**:JWT Token机制保证身份认证的安全性
- **灵活控制**:支持单点登录、多端登录、强制下线等会话管理
- **性能优化**:Redis存储会话信息,快速验证用户身份
- **用户体验**:自动续期机制减少用户重新登录次数

### 1.3 用户场景

- 用户登录后获得JWT Token访问受保护资源
- 用户在多个设备上登录(Web、手机App、平板)
- 管理员强制用户下线(封禁、异常登录)
- 用户主动退出登录
- Token过期自动刷新

### 1.4 功能边界

- **包含功能**:会话创建、Token验证、会话刷新、多端登录、强制下线、会话查询
- **不包含功能**:OAuth2.0第三方登录、单点登录(SSO)跨系统集成

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    客户端层                              │
│  Web浏览器 + 移动App + 桌面应用                          │
└─────────────────────────────────────────────────────────┘
                         ↓ (带JWT Token的HTTP请求)
┌─────────────────────────────────────────────────────────┐
│                  JWT中间件层                             │
│  - 提取Token                                            │
│  - 验证签名                                             │
│  - 检查过期                                             │
│  - 检查黑名单                                           │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                会话管理服务层                            │
│  SessionService                                         │
│  ├─ CreateSession (创建会话)                           │
│  ├─ ValidateSession (验证会话)                         │
│  ├─ RefreshSession (刷新会话)                          │
│  ├─ RevokeSession (撤销会话)                           │
│  └─ ListUserSessions (查询用户会话)                    │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                Redis会话存储                             │
│  - session:{user_id}:{device_id} (会话详情)             │
│  - user_sessions:{user_id} (用户的所有会话Set)          │
│  - token_blacklist:{token} (Token黑名单)                │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Token结构

**JWT Token Payload**:
```json
{
    "user_id": "user_123456",
    "username": "zhangsan",
    "role": "author",
    "device_id": "device_abc123",
    "session_id": "session_xyz789",
    "iat": 1697529600,
    "exp": 1697616000
}
```

**Session数据结构**(Redis):
```json
{
    "session_id": "session_xyz789",
    "user_id": "user_123456",
    "device_id": "device_abc123",
    "device_type": "web",
    "device_info": "Chrome 118 on Windows 10",
    "ip_address": "192.168.1.100",
    "created_at": "2025-10-17T10:00:00Z",
    "last_active_at": "2025-10-17T12:30:00Z",
    "expires_at": "2025-10-18T10:00:00Z"
}
```

## 3. 详细设计

### 3.1 Service层接口

```go
// SessionService 会话管理服务接口
type SessionService interface {
    // 创建会话
    CreateSession(ctx context.Context, userID, deviceID, deviceType, deviceInfo, ipAddress string) (*Session, error)
    
    // 验证会话
    ValidateSession(ctx context.Context, sessionID string) (*Session, error)
    
    // 刷新会话(续期)
    RefreshSession(ctx context.Context, sessionID string) (*Session, error)
    
    // 撤销会话(退出登录)
    RevokeSession(ctx context.Context, sessionID string) error
    
    // 撤销用户所有会话(强制全部下线)
    RevokeAllUserSessions(ctx context.Context, userID string) error
    
    // 撤销用户在指定设备的会话
    RevokeDeviceSession(ctx context.Context, userID, deviceID string) error
    
    // 查询用户所有会话
    ListUserSessions(ctx context.Context, userID string) ([]*Session, error)
    
    // 更新会话活跃时间
    UpdateLastActive(ctx context.Context, sessionID string) error
}
```

### 3.2 核心实现

#### 3.2.1 创建会话

```go
func (s *SessionServiceImpl) CreateSession(
    ctx context.Context,
    userID, deviceID, deviceType, deviceInfo, ipAddress string,
) (*Session, error) {
    // 1. 生成会话ID
    sessionID := uuid.New().String()
    
    // 2. 创建会话对象
    session := &Session{
        SessionID:     sessionID,
        UserID:        userID,
        DeviceID:      deviceID,
        DeviceType:    deviceType,
        DeviceInfo:    deviceInfo,
        IPAddress:     ipAddress,
        CreatedAt:     time.Now(),
        LastActiveAt:  time.Now(),
        ExpiresAt:     time.Now().Add(s.sessionTTL),
    }
    
    // 3. 检查是否允许多端登录
    if !s.allowMultiDevice {
        // 单点登录:撤销用户其他所有会话
        s.RevokeAllUserSessions(ctx, userID)
    } else if s.maxDevices > 0 {
        // 限制设备数量
        sessions, _ := s.ListUserSessions(ctx, userID)
        if len(sessions) >= s.maxDevices {
            // 踢出最早的会话
            s.RevokeSession(ctx, sessions[0].SessionID)
        }
    }
    
    // 4. 保存会话到Redis
    key := fmt.Sprintf("session:%s:%s", userID, deviceID)
    data, _ := json.Marshal(session)
    err := s.cacheClient.Set(ctx, key, data, s.sessionTTL)
    if err != nil {
        return nil, err
    }
    
    // 5. 添加到用户会话集合
    userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
    s.cacheClient.SAdd(ctx, userSessionsKey, sessionID)
    s.cacheClient.Expire(ctx, userSessionsKey, s.sessionTTL)
    
    return session, nil
}
```

#### 3.2.2 验证会话

```go
func (s *SessionServiceImpl) ValidateSession(ctx context.Context, sessionID string) (*Session, error) {
    // 1. 从JWT Claims中提取user_id和device_id
    // (在实际调用中会从Token中解析)
    
    // 2. 构建Redis Key
    // key := fmt.Sprintf("session:%s:%s", userID, deviceID)
    
    // 3. 查询会话
    key := fmt.Sprintf("session:*:*") // 实际使用时需要完整Key
    data, err := s.cacheClient.Get(ctx, key)
    if err != nil {
        return nil, errors.New("会话不存在或已过期")
    }
    
    // 4. 反序列化会话
    var session Session
    err = json.Unmarshal([]byte(data), &session)
    if err != nil {
        return nil, err
    }
    
    // 5. 检查会话是否过期
    if time.Now().After(session.ExpiresAt) {
        s.RevokeSession(ctx, sessionID)
        return nil, errors.New("会话已过期")
    }
    
    // 6. 更新最后活跃时间
    s.UpdateLastActive(ctx, sessionID)
    
    return &session, nil
}
```

#### 3.2.3 刷新会话

```go
func (s *SessionServiceImpl) RefreshSession(ctx context.Context, sessionID string) (*Session, error) {
    // 1. 验证会话是否存在
    session, err := s.ValidateSession(ctx, sessionID)
    if err != nil {
        return nil, err
    }
    
    // 2. 检查是否在刷新窗口内(距离过期还有5分钟内才允许刷新)
    refreshWindow := 5 * time.Minute
    if time.Until(session.ExpiresAt) > refreshWindow {
        return session, nil // 不需要刷新
    }
    
    // 3. 更新过期时间
    session.ExpiresAt = time.Now().Add(s.sessionTTL)
    session.LastActiveAt = time.Now()
    
    // 4. 保存到Redis
    key := fmt.Sprintf("session:%s:%s", session.UserID, session.DeviceID)
    data, _ := json.Marshal(session)
    s.cacheClient.Set(ctx, key, data, s.sessionTTL)
    
    return session, nil
}
```

#### 3.2.4 撤销会话

```go
func (s *SessionServiceImpl) RevokeSession(ctx context.Context, sessionID string) error {
    // 1. 查询会话信息
    session, err := s.ValidateSession(ctx, sessionID)
    if err != nil {
        return nil // 会话已不存在
    }
    
    // 2. 删除会话
    key := fmt.Sprintf("session:%s:%s", session.UserID, session.DeviceID)
    s.cacheClient.Delete(ctx, key)
    
    // 3. 从用户会话集合中移除
    userSessionsKey := fmt.Sprintf("user_sessions:%s", session.UserID)
    s.cacheClient.SRem(ctx, userSessionsKey, sessionID)
    
    // 4. 将Token加入黑名单(如果有对应Token)
    // tokenBlacklistKey := fmt.Sprintf("token_blacklist:%s", token)
    // s.cacheClient.Set(ctx, tokenBlacklistKey, "1", 24*time.Hour)
    
    return nil
}

func (s *SessionServiceImpl) RevokeAllUserSessions(ctx context.Context, userID string) error {
    // 1. 获取用户所有会话
    userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
    sessionIDs, err := s.cacheClient.SMembers(ctx, userSessionsKey)
    if err != nil {
        return err
    }
    
    // 2. 逐个撤销
    for _, sessionID := range sessionIDs {
        s.RevokeSession(ctx, sessionID)
    }
    
    // 3. 清空用户会话集合
    s.cacheClient.Delete(ctx, userSessionsKey)
    
    return nil
}
```

### 3.3 中间件集成

```go
// JWT认证中间件
func JWTAuthMiddleware(sessionService SessionService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 提取Token
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(401, gin.H{"error": "未提供认证Token"})
            c.Abort()
            return
        }
        
        token = strings.TrimPrefix(token, "Bearer ")
        
        // 2. 验证Token签名和过期时间
        claims, err := jwt.ValidateToken(token)
        if err != nil {
            c.JSON(401, gin.H{"error": "Token无效或已过期"})
            c.Abort()
            return
        }
        
        // 3. 检查Token黑名单
        blacklistKey := fmt.Sprintf("token_blacklist:%s", token)
        isBlacklisted, _ := cache.Exists(c.Request.Context(), blacklistKey)
        if isBlacklisted {
            c.JSON(401, gin.H{"error": "Token已被撤销"})
            c.Abort()
            return
        }
        
        // 4. 验证会话是否存在
        session, err := sessionService.ValidateSession(c.Request.Context(), claims.SessionID)
        if err != nil {
            c.JSON(401, gin.H{"error": "会话不存在或已过期"})
            c.Abort()
            return
        }
        
        // 5. 将用户信息存入Context
        c.Set("user_id", session.UserID)
        c.Set("session_id", session.SessionID)
        c.Set("device_id", session.DeviceID)
        
        c.Next()
    }
}
```

## 4. API接口设计

```go
// 用户登录(创建会话)
POST /api/v1/auth/login
Body:
{
    "username": "zhangsan",
    "password": "password123",
    "device_type": "web",
    "device_info": "Chrome 118"
}
Response:
{
    "access_token": "eyJhbGc...",
    "refresh_token": "eyJhbGc...",
    "expires_in": 86400
}

// 刷新Token
POST /api/v1/auth/refresh
Body:
{
    "refresh_token": "eyJhbGc..."
}
Response:
{
    "access_token": "eyJhbGc...",
    "expires_in": 86400
}

// 退出登录(撤销当前会话)
POST /api/v1/auth/logout
Header: Authorization: Bearer {token}
Response:
{
    "message": "退出成功"
}

// 查询当前用户所有会话
GET /api/v1/auth/sessions
Header: Authorization: Bearer {token}
Response:
{
    "sessions": [
        {
            "session_id": "session_xyz",
            "device_type": "web",
            "device_info": "Chrome 118",
            "ip_address": "192.168.1.100",
            "last_active_at": "2025-10-17T12:30:00Z",
            "is_current": true
        }
    ]
}

// 撤销指定会话
DELETE /api/v1/auth/sessions/:session_id
Header: Authorization: Bearer {token}
Response:
{
    "message": "会话已撤销"
}

// 管理员:强制用户下线
POST /admin/api/v1/users/:user_id/revoke-sessions
Header: Authorization: Bearer {admin_token}
Response:
{
    "message": "已强制用户下线",
    "revoked_count": 3
}
```

## 5. 配置参数

```go
// SessionConfig 会话配置
type SessionConfig struct {
    SessionTTL        time.Duration // 会话有效期(默认24小时)
    RefreshWindow     time.Duration // 刷新窗口(默认5分钟)
    AllowMultiDevice  bool          // 是否允许多端登录(默认true)
    MaxDevices        int           // 最大设备数(0表示不限制)
    InactiveTimeout   time.Duration // 无活动超时(默认30分钟)
}

// 默认配置
var DefaultSessionConfig = SessionConfig{
    SessionTTL:        24 * time.Hour,
    RefreshWindow:     5 * time.Minute,
    AllowMultiDevice:  true,
    MaxDevices:        5,
    InactiveTimeout:   30 * time.Minute,
}
```

## 6. Redis数据结构

```redis
# 会话详情(Hash)
HSET session:user_123:device_abc session_id "session_xyz"
HSET session:user_123:device_abc user_id "user_123"
HSET session:user_123:device_abc device_type "web"
EXPIRE session:user_123:device_abc 86400

# 用户会话集合(Set)
SADD user_sessions:user_123 "session_xyz" "session_abc"
EXPIRE user_sessions:user_123 86400

# Token黑名单(String)
SET token_blacklist:eyJhbGc... "1" EX 86400
```

## 7. 监控和统计

```go
// 监控指标
type SessionMetrics struct {
    ActiveSessions    int64 // 活跃会话数
    TotalLoginCount   int64 // 总登录次数
    TotalLogoutCount  int64 // 总退出次数
    AvgSessionDuration time.Duration // 平均会话时长
}

// 统计活跃会话数
func (s *SessionServiceImpl) GetActiveSessionsCount(ctx context.Context) (int64, error) {
    keys, err := s.cacheClient.Keys(ctx, "session:*:*")
    if err != nil {
        return 0, err
    }
    return int64(len(keys)), nil
}
```

## 8. 安全考虑

### 8.1 Token安全

- JWT使用HS256签名算法,密钥定期轮换
- Token payload不包含敏感信息
- 短生命周期(24小时) + 刷新机制

### 8.2 会话安全

- IP地址绑定(可选):会话创建时记录IP,验证时检查
- 设备指纹识别:基于User-Agent和其他设备信息
- 异常登录检测:异地登录、同时多地登录告警

### 8.3 防护措施

- 限制登录频率(防暴力破解)
- Token黑名单(撤销Token)
- 强制密码修改后撤销所有会话

## 9. MVP范围

### 9.1 MVP核心功能 ✅

- ✅ 基于JWT的无状态认证
- ✅ Redis会话存储
- ✅ 多端登录支持
- ✅ 会话刷新机制
- ✅ 主动退出登录
- ✅ 管理员强制下线

### 9.2 后续迭代功能 ⏸️

- ⏸️ IP地址绑定
- ⏸️ 异常登录检测和告警
- ⏸️ 设备管理(设备命名、信任设备)
- ⏸️ 会话详细日志和审计
- ⏸️ Remember Me(长期会话)

## 10. 相关文档

- [JWT身份认证设计](../core/JWT身份认证设计.md)
- [账号权限系统设计](./账号权限系统设计.md)
- [缓存策略设计](./缓存策略设计.md)
- [共享底层服务设计文档](./README_共享底层服务设计文档.md)

---

**文档维护**: 青羽后端架构团队  
**最后更新**: 2025-10-17

