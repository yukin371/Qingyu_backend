# 消息队列设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库，统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考：[微服务架构划分建议](../微服务架构划分建议.md)

## 1. 需求概述

### 1.1 功能描述
消息队列是青羽平台的核心基础设施服务，提供异步消息传递、事件驱动架构支持和系统解耦能力。系统支持多种消息模式，包括点对点消息、发布订阅模式、延时消息和事务消息，确保系统的高可用性、可扩展性和数据一致性。

### 1.2 业务价值
- **模块解耦**：降低模块间的直接依赖，提高系统的灵活性和可维护性
- **异步处理**：提升系统响应速度，改善用户体验
- **流量削峰**：缓解高并发场景下的系统压力
- **数据一致性**：通过事务消息保证最终一致性
- **可扩展性**：为未来扩展预留空间

### 1.3 用户场景
- 用户注册后发送欢迎邮件和短信通知
- 内容发布后触发推荐算法更新和搜索索引重建
- 支付成功后更新用户钱包余额和订单状态
- 系统监控告警和日志收集处理
- 数据同步和备份任务调度

### 1.4 功能边界
- **包含功能**：消息发送、消息消费、消息持久化、死信处理、消息重试
- **不包含功能**：消息内容审核、业务逻辑处理、数据存储

## 2. 架构设计

### 2.1 整体架构（模块化单体）
```
┌─────────────────────────────────────────────────────────┐
│                 青羽写作平台 (单一应用)                  │
│                                                         │
│  ┌───────────────────────────────────────────────┐    │
│  │           业务模块层                           │    │
│  │  用户模块 + 内容模块 + 支付模块 + 推荐模块      │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓↑                             │
│  ┌───────────────────────────────────────────────┐    │
│  │         消息队列模块 (Message Queue)            │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 消息服务 (Message Service)              │  │    │
│  │  │  - 消息发送                             │  │    │
│  │  │  - 消息路由                             │  │    │
│  │  │  - 消费者管理                           │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │ 消息处理 (Message Handler)              │  │    │
│  │  │  - 重试机制                             │  │    │
│  │  │  - 死信处理                             │  │    │
│  │  │  - 事务支持                             │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  └───────────────────────────────────────────────┘    │
│                         ↓↑                             │
│  ┌───────────────────────────────────────────────┐    │
│  │            数据存储层                          │    │
│  │  Redis Streams + MongoDB (元数据)              │    │
│  └───────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### 2.2 模块划分
- **消息服务模块**：消息发送、接收、路由、序列化处理
- **消息处理模块**：消费者管理、重试机制、死信处理、事务支持
- **监控管理模块**：性能监控、告警处理、统计分析

### 2.3 技术选型（分阶段演进）

| 技术方案 | 优点 | 缺点 | 适用场景 | 当前采用 |
|---------|------|------|---------|----------|
| **Redis Streams** | 简单、易维护、支持持久化 | 性能有限(日消息量<100万) | 初期阶段 | ✅ 采用 |
| **Go Channel** | 极简、高性能 | 无持久化、不可靠 | 开发环境 | ⚠️ 可选 |
| **Kafka** | 高性能、高可靠 | 复杂、运维成本高 | 大规模场景 | ❌ 未来考虑 |
| **RabbitMQ** | 功能丰富 | 复杂度高 | 复杂消息场景 | ❌ 暂不采用 |

**当前推荐**: Redis Streams

**升级条件**:
- 日消息量 > 100万
- 团队具备Kafka运维能力
- 出现明显性能瓶颈

**决策理由**:
- ✅ 降低运维复杂度
- ✅ 开发效率高
- ✅ 足够支持当前业务规模
- ⚠️ 需在达到性能瓶颈前规划升级

## 3. 详细设计

### 3.1 Router层设计
- **路由分组**：/api/v1/mq
- **中间件**：身份认证、限流、日志记录、监控统计
- **路径规范**：RESTful风格，如 /mq/topics, /mq/messages
- **参数处理**：主题名称、消息内容、消费者组、配置参数
- **路由注册**：在主应用的Gin Router中注册消息队列相关路由

### 3.2 API层设计
- **接口定义**：消息发送、主题管理、消费者管理、监控查询接口
- **请求验证**：参数格式验证、权限验证、频率限制
- **响应格式**：统一的JSON响应结构，包含操作结果和元数据信息
- **错误处理**：消息发送失败重试、降级处理

### 3.3 Service层设计
- **消息服务**：消息发送、接收、路由、序列化处理
- **主题管理**：主题创建、删除、配置更新、权限控制
- **消费者管理**：消费者注册、消息消费、消费确认
- **监控服务**：性能监控、告警处理、统计分析
- **Repository交互**：通过Repository接口进行元数据访问
- **模块间调用**：通过Go接口直接调用其他业务模块（如用户模块、通知模块）

### 3.4 Repository层设计
- **接口抽象**：TopicRepository、MessageRepository、ConsumerRepository
- **数据查询**：主题信息查询、消息状态查询、消费者状态查询
- **缓存策略**：主题配置缓存、消费者信息缓存、监控数据缓存
- **异常处理**：数据库连接异常、查询超时处理
- **与Model关系**：Topic、Message、Consumer模型的数据映射

### 3.5 Model层设计
- **数据模型**：Topic、Message、Consumer、ConsumerGroup
- **配置模型**：TopicConfig、ConsumerConfig、ProducerConfig
- **验证逻辑**：消息格式验证、配置参数验证
- **Repository接口**：定义数据访问方法签名

## 4. 数据设计

### 4.1 数据模型

#### 主题模型 (Topic)
```go
type Topic struct {
    ID              string            `bson:"_id,omitempty" json:"id"`
    Name            string            `bson:"name" json:"name"`
    Description     string            `bson:"description" json:"description"`
    Partitions      int               `bson:"partitions" json:"partitions"`
    ReplicationFactor int             `bson:"replication_factor" json:"replicationFactor"`
    RetentionMs     int64             `bson:"retention_ms" json:"retentionMs"`
    MaxMessageSize  int64             `bson:"max_message_size" json:"maxMessageSize"`
    Config          map[string]string `bson:"config" json:"config"`
    Status          string            `bson:"status" json:"status"`           // active, inactive, deleted
    CreatedBy       string            `bson:"created_by" json:"createdBy"`
    CreatedAt       time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt       time.Time         `bson:"updated_at" json:"updatedAt"`
}
```

#### 消息模型 (Message)
```go
type Message struct {
    ID          string            `bson:"_id,omitempty" json:"id"`
    TopicName   string            `bson:"topic_name" json:"topicName"`
    Partition   int               `bson:"partition" json:"partition"`
    Offset      int64             `bson:"offset" json:"offset"`
    Key         string            `bson:"key" json:"key"`
    Value       []byte            `bson:"value" json:"value"`
    Headers     map[string]string `bson:"headers" json:"headers"`
    Timestamp   time.Time         `bson:"timestamp" json:"timestamp"`
    ProducerID  string            `bson:"producer_id" json:"producerId"`
    MessageType string            `bson:"message_type" json:"messageType"`   // normal, delay, transaction
    DelayUntil  time.Time         `bson:"delay_until" json:"delayUntil"`
    RetryCount  int               `bson:"retry_count" json:"retryCount"`
    Status      string            `bson:"status" json:"status"`              // pending, sent, consumed, failed
    CreatedAt   time.Time         `bson:"created_at" json:"createdAt"`
}
```

#### 消费者组模型 (ConsumerGroup)
```go
type ConsumerGroup struct {
    ID              string            `bson:"_id,omitempty" json:"id"`
    GroupID         string            `bson:"group_id" json:"groupId"`
    TopicName       string            `bson:"topic_name" json:"topicName"`
    ConsumerCount   int               `bson:"consumer_count" json:"consumerCount"`
    Status          string            `bson:"status" json:"status"`           // active, inactive, rebalancing
    Config          map[string]string `bson:"config" json:"config"`
    LastCommitTime  time.Time         `bson:"last_commit_time" json:"lastCommitTime"`
    CreatedAt       time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt       time.Time         `bson:"updated_at" json:"updatedAt"`
}
```

#### 消费者模型 (Consumer)
```go
type Consumer struct {
    ID              string            `bson:"_id,omitempty" json:"id"`
    ConsumerID      string            `bson:"consumer_id" json:"consumerId"`
    GroupID         string            `bson:"group_id" json:"groupId"`
    TopicName       string            `bson:"topic_name" json:"topicName"`
    Partition       int               `bson:"partition" json:"partition"`
    CurrentOffset   int64             `bson:"current_offset" json:"currentOffset"`
    CommittedOffset int64             `bson:"committed_offset" json:"committedOffset"`
    Lag             int64             `bson:"lag" json:"lag"`
    Status          string            `bson:"status" json:"status"`           // active, inactive, error
    LastHeartbeat   time.Time         `bson:"last_heartbeat" json:"lastHeartbeat"`
    ClientInfo      map[string]string `bson:"client_info" json:"clientInfo"`
    CreatedAt       time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt       time.Time         `bson:"updated_at" json:"updatedAt"`
}
```

#### 死信消息模型 (DeadLetterMessage)
```go
type DeadLetterMessage struct {
    ID              string            `bson:"_id,omitempty" json:"id"`
    OriginalTopicName string          `bson:"original_topic_name" json:"originalTopicName"`
    OriginalMessageID string          `bson:"original_message_id" json:"originalMessageId"`
    ConsumerGroupID string            `bson:"consumer_group_id" json:"consumerGroupId"`
    FailureReason   string            `bson:"failure_reason" json:"failureReason"`
    RetryCount      int               `bson:"retry_count" json:"retryCount"`
    MessageContent  []byte            `bson:"message_content" json:"messageContent"`
    Headers         map[string]string `bson:"headers" json:"headers"`
    FailedAt        time.Time         `bson:"failed_at" json:"failedAt"`
    CreatedAt       time.Time         `bson:"created_at" json:"createdAt"`
}
```

### 4.2 数据关系
- Topic 与 Message：一对多关系，一个主题包含多个消息
- ConsumerGroup 与 Consumer：一对多关系，一个消费者组包含多个消费者
- Topic 与 ConsumerGroup：多对多关系，一个主题可被多个消费者组订阅
- Message 与 DeadLetterMessage：一对一关系，失败消息对应死信消息

### 4.3 索引策略
| 集合名称 | 索引字段 | 索引类型 | 说明 |
|---------|---------|---------|------|
| topics | name | unique | 主题名称唯一索引 |
| topics | status, created_at | compound | 状态时间复合索引 |
| messages | topic_name, partition, offset | compound | 主题分区偏移量复合索引 |
| messages | timestamp, status | compound | 时间状态复合索引 |
| consumer_groups | group_id, topic_name | compound | 消费者组主题复合索引 |
| consumers | consumer_id | unique | 消费者唯一索引 |
| consumers | group_id, status | compound | 消费者组状态复合索引 |
| dead_letter_messages | original_topic_name, failed_at | compound | 原主题失败时间复合索引 |

### 4.4 数据迁移
- 从现有消息系统迁移主题配置和消费者组信息
- 历史消息数据清理和归档策略
- 监控数据和统计信息的初始化

## 5. 接口设计

### 5.1 API概览

| 方法 | 路径 | 功能描述 | 权限要求 |
|-----|------|---------|---------|
| POST | /api/v1/mq/messages | 发送消息 | 服务认证 |
| GET | /api/v1/mq/topics | 获取主题列表 | 管理员 |
| POST | /api/v1/mq/topics | 创建主题 | 管理员 |
| PUT | /api/v1/mq/topics/{name} | 更新主题配置 | 管理员 |
| DELETE | /api/v1/mq/topics/{name} | 删除主题 | 管理员 |
| GET | /api/v1/mq/consumers | 获取消费者状态 | 管理员 |
| GET | /api/v1/mq/monitoring | 获取监控数据 | 管理员 |
| POST | /api/v1/mq/dead-letters/retry | 重试死信消息 | 管理员 |

### 5.2 请求与响应格式

#### 5.2.1 发送消息 (POST /api/v1/mq/messages)

**请求参数**:
```json
{
  "topicName": "user-events",
  "key": "user_123456",
  "value": {
    "eventType": "user_registered",
    "userId": "123456",
    "timestamp": "2024-01-15T10:30:00Z",
    "data": {
      "email": "user@example.com",
      "username": "testuser"
    }
  },
  "headers": {
    "source": "user-service",
    "version": "1.0"
  },
  "messageType": "normal",
  "delaySeconds": 0
}
```

**响应格式**:
```json
{
  "code": 200,
  "message": "消息发送成功",
  "data": {
    "messageId": "msg_123456789",
    "topicName": "user-events",
    "partition": 2,
    "offset": 12345,
    "timestamp": "2024-01-15T10:30:01Z"
  }
}
```

#### 5.2.2 创建主题 (POST /api/v1/mq/topics)

**请求参数**:
```json
{
  "name": "payment-events",
  "description": "支付相关事件主题",
  "partitions": 6,
  "replicationFactor": 3,
  "retentionMs": 604800000,
  "maxMessageSize": 1048576,
  "config": {
    "cleanup.policy": "delete",
    "compression.type": "gzip"
  }
}
```

**响应格式**:
```json
{
  "code": 200,
  "message": "主题创建成功",
  "data": {
    "topicId": "topic_123456789",
    "name": "payment-events",
    "status": "active",
    "createdAt": "2024-01-15T10:30:00Z"
  }
}
```

#### 5.2.3 获取监控数据 (GET /api/v1/mq/monitoring)

**请求参数**:
- topicName: 主题名称，可选
- timeRange: 时间范围，默认1小时
- metrics: 指标类型，可选

**响应格式**:
```json
{
  "code": 200,
  "message": "获取监控数据成功",
  "data": {
    "topics": [
      {
        "name": "user-events",
        "messageCount": 12345,
        "messageRate": 150.5,
        "consumerLag": 23,
        "partitions": [
          {
            "partition": 0,
            "offset": 5678,
            "messageRate": 75.2
          }
        ]
      }
    ],
    "consumers": [
      {
        "groupId": "user-service-group",
        "topicName": "user-events",
        "consumerCount": 3,
        "totalLag": 45,
        "status": "active"
      }
    ],
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

**状态码**:
- 200: 成功
- 400: 请求参数错误
- 401: 认证失败
- 403: 权限不足
- 409: 资源冲突
- 500: 服务器错误

## 6. 消息模式设计

### 6.1 点对点模式
- **队列模型**：消息发送到队列，由单个消费者处理
- **负载均衡**：多个消费者竞争消费消息，实现负载分担
- **消息确认**：消费者处理完成后确认消息，确保消息不丢失

### 6.2 发布订阅模式
- **主题模型**：消息发布到主题，多个订阅者接收消息
- **消费者组**：同一组内的消费者负载均衡，不同组独立消费
- **消息广播**：每个订阅者都能收到完整的消息流

### 6.3 延时消息
- **延时队列**：消息在指定时间后才能被消费
- **时间轮算法**：高效的延时消息调度机制
- **应用场景**：订单超时取消、定时任务触发

### 6.4 事务消息
- **两阶段提交**：确保消息发送与本地事务的一致性
- **事务状态**：Prepare、Commit、Rollback三种状态
- **补偿机制**：事务失败时的回滚和补偿处理

## 7. 安全设计

### 7.1 访问控制
- **身份认证**：基于Token的服务间认证
- **权限管理**：细粒度的主题和操作权限控制
- **IP白名单**：限制消息队列的访问来源

### 7.2 数据安全
- **消息加密**：敏感消息内容加密传输和存储
- **数据脱敏**：日志和监控数据中的敏感信息脱敏
- **审计日志**：记录所有关键操作的审计信息

### 7.3 网络安全
- **TLS加密**：客户端与服务端之间的通信加密
- **网络隔离**：消息队列集群的网络访问控制
- **DDoS防护**：防止恶意攻击和异常流量

## 8. 测试设计

### 8.1 测试策略
- 单元测试：覆盖所有核心模块和Service方法
- 集成测试：测试消息发送、接收和处理流程
- 性能测试：高并发消息处理能力测试
- 故障测试：网络分区、节点故障等异常场景测试

### 8.2 测试用例
- **功能测试**：消息发送、接收、持久化、重试机制
- **性能测试**：吞吐量、延迟、资源使用率
- **可靠性测试**：消息不丢失、不重复、顺序保证
- **扩展性测试**：集群扩容、分区重平衡

### 8.3 监控指标
- **吞吐量指标**：消息发送速率、消费速率
- **延迟指标**：端到端延迟、处理延迟
- **可用性指标**：服务可用性、错误率
- **资源指标**：CPU、内存、磁盘、网络使用率

## 9. 部署和运维

### 9.1 部署方案（分阶段）

**阶段1：开发环境**（当前）
```bash
# 使用 Docker Compose
docker-compose up -d
```
- 单一应用部署
- Redis Streams作为消息队列
- 本地开发和测试

**阶段2：生产环境初期**
```bash
# 单机/多实例 + Nginx负载均衡
nginx → app_instance_1 (含消息队列模块)
      → app_instance_2 (含消息队列模块)
      ↓
   Redis Cluster (消息存储)
```
- Docker容器化部署
- 水平扩展多个应用实例
- Redis Cluster保证消息队列高可用

**阶段3：大规模部署**（日活 > 10万）
```bash
# 可选：Kubernetes集群
# 需要条件：
# - 专职运维团队
# - 多地域部署需求
# - 复杂的流量调度
```

**当前推荐**: Docker Compose（简单、够用）

**灰度发布策略**：
- 按百分比灰度发布新版本
- 监控关键指标，出现问题快速回滚

### 9.2 监控告警

**监控指标**：
- 消息发送/消费速率
- 消息积压数量
- 消费者延迟
- 死信消息统计

**日志系统**（简化版）：
```go
// 使用 Zap 结构化日志
logger.Info("消息发送",
    zap.String("topic", topicName),
    zap.String("message_id", messageID),
    zap.Duration("latency", latency),
)
```

**日志存储**：
- 本地文件 + 日志轮转
- 按日期归档
- 保留最近7天

**告警机制**：
- 消息积压告警（积压 > 1000条）
- 消费延迟告警（延迟 > 1分钟）
- 死信消息告警（出现死信消息）

**未来升级**（流量增长后）：
- 考虑 ELK Stack 进行日志分析
- Prometheus + Grafana 监控大盘

### 9.3 运维管理

**配置管理**：
```yaml
# config.yaml
message_queue:
  provider: redis_streams
  redis:
    host: localhost
    port: 6379
    db: 0
  retention_hours: 168  # 7天
  max_len: 10000
```
- 使用Viper读取配置文件
- 支持环境变量覆盖
- 配置热更新（可选）

**备份恢复**：
- Redis持久化（RDB + AOF）
- 定期备份元数据到MongoDB
- 重要消息归档到对象存储

**性能调优**：
- Redis连接池优化
- 消息批量处理
- 合理设置消息过期时间

**容量规划**：
- 监控消息增长趋势
- 预留50%性能余量
- 制定扩容预案

## 10. 风险评估

### 10.1 技术风险
- **消息丢失风险**：通过持久化和副本机制降低风险
- **消息重复风险**：幂等性设计和去重机制
- **性能瓶颈风险**：水平扩展和负载均衡

### 10.2 业务风险
- **消息积压风险**：监控和告警机制，及时处理积压
- **数据一致性风险**：事务消息和补偿机制
- **服务依赖风险**：降级策略和熔断机制

### 10.3 运营风险
- **运维复杂性**：自动化运维和标准化流程
- **人员风险**：技术培训和文档完善
- **成本控制**：资源使用优化和成本监控

## 11. 实施计划

### 11.1 基础建设阶段
- 第1-2周：技术选型和架构设计
- 第3-4周：基础框架搭建和核心功能开发
- 第5-6周：消息发送和接收功能实现

### 11.2 功能完善阶段
- 第7-8周：延时消息和事务消息功能
- 第9-10周：监控告警和管理界面开发
- 第11-12周：性能优化和压力测试

### 11.3 上线部署阶段
- 第13周：生产环境部署和配置
- 第14周：灰度发布和功能验证
- 第15周：全量上线和运维交接