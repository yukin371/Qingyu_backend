> ⚠️ **文档状态**: 已归档（2025-10-21）
> 
> 本文档基于v1.0架构设计，已被新的v2.1架构取代。
> 
> **替代文档**：
> - [Python AI Agent系统架构设计](../07.Python_AI_Agent系统架构设计.md)
> - [Go AI代理层设计](../08.Go_AI代理层设计.md)
> - [青羽平台模块化架构设计v2.1](../../青羽平台模块化架构设计v2.1.md)

---

# AI服务架构设计

> **架构说明**: 本文档基于**模块化单体架构**设计。
> 
> - ✅ 当前采用单一代码库，统一部署
> - ✅ 通过模块化保持清晰边界
> - ✅ 为未来可能的微服务化预留空间
> 
> 参考：[微服务架构划分建议](../微服务架构划分建议.md)

## 1. 需求概述

### 1.1 功能描述

设计统一的AI服务架构，支持多种AI服务提供商的接入，为青语小说创作平台提供稳定、高效的AI能力。

### 1.2 业务价值

- **统一接口**：为不同AI服务提供商提供统一的API接口
- **可扩展性**：支持快速接入新的AI服务提供商
- **高可用性**：实现故障转移和负载均衡
- **成本优化**：通过智能路由和缓存降低调用成本

### 1.3 用户场景

- **服务接入**：快速接入OpenAI、Claude、百度文心一言等AI服务
- **智能路由**：根据请求类型和服务状态智能选择最优服务
- **故障转移**：当某个AI服务不可用时自动切换到备用服务
- **性能监控**：实时监控各AI服务的性能和可用性

### 1.4 功能边界

- **支持功能**：多AI服务商适配、智能路由、故障转移、性能监控
- **不支持功能**：AI模型训练、自定义模型部署
- **技术限制**：依赖第三方AI服务的API限制
- **扩展限制**：最多支持10个AI服务提供商

## 2. 架构设计

### 2.1 整体架构（模块化单体）

```
青羽写作平台 (单一应用)
┌─────────────────────────────────────────┐
│  Gin HTTP Server                        │
│  Router + Middleware (认证/限流/日志)   │
└─────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────┐
│  AI模块 (AI Module)                     │
│  ┌───────────────────────────────────┐  │
│  │ AI Service                        │  │
│  │  - 统一AI接口                     │  │
│  │  - 智能路由                       │  │
│  │  - 故障转移                       │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │ Adapter Manager                   │  │
│  │  - OpenAI Adapter                 │  │
│  │  - Claude Adapter                 │  │
│  │  - 百度文心 Adapter               │  │
│  │  - Gemini Adapter                 │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │ Context Manager                   │  │
│  │  - 对话上下文管理                 │  │
│  │  - 上下文缓存                     │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────┐
│  数据存储层                             │
│  MongoDB + Redis (缓存)                 │
└─────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────┐
│  外部AI服务                             │
│  OpenAI + Claude + 百度文心 + Gemini    │
└─────────────────────────────────────────┘
```

**说明**：
- AI模块作为主应用的一部分，不是独立服务
- Gin Router直接调用AI Service，无需独立网关
- 通过适配器模式统一不同AI服务商的接口

### 2.2 模块划分

#### 2.2.1 Router层

**文件路径**：`router/ai/ai_router.go`
**职责**：

- 路由注册和管理（在主应用的Gin Router中）
- 中间件配置
- 请求分发到AI Service
- 版本控制

**说明**：Router层直接集成在主应用中，不是独立的API网关

#### 2.2.2 中间件层 (Middleware)

**文件路径**：`middleware/`
**职责**：

- JWT认证验证
- 请求限流控制
- 日志记录
- CORS处理

#### 2.2.3 API控制层 (Controller)
**文件路径**：`api/v1/ai/`
**职责**：
- HTTP请求处理
- 参数验证
- 响应格式化
- 错误处理

#### 2.2.4 服务层 (Service)
**文件路径**：`service/ai/`
**职责**：
- 业务逻辑处理
- 适配器管理
- 路由策略
- 缓存管理

#### 2.2.5 适配器层 (Adapter)
**文件路径**：`service/ai/adapters/`
**职责**：
- 统一接口实现
- 协议转换
- 错误处理
- 重试机制

#### 2.2.6 数据层 (Model)
**文件路径**：`models/ai/`
**职责**：
- 数据模型定义
- 数据库操作
- 数据验证
- 索引管理

### 2.3 数据流向
1. 客户端请求 → API网关 → 中间件验证
2. 中间件 → API控制层 → 参数验证
3. API控制层 → 服务层 → 业务处理
4. 服务层 → 适配器层 → AI服务调用
5. 适配器层 → 外部AI服务 → 获取响应
6. 响应数据 → 缓存层 → 返回客户端

### 2.4 技术选型
- **Web框架**：Gin Web Framework
- **数据库**：MongoDB
- **缓存**：Redis
- **配置管理**：Viper
- **日志**：Logrus
- **监控**：Prometheus + Grafana
- **容器化**：Docker + Kubernetes

## 3. 详细设计

### 3.1 Router层设计

**路由配置**：
```go
// ai_router.go
func InitAIRouter(router *gin.RouterGroup) {
    aiGroup := router.Group("/ai")
    aiGroup.Use(
        middleware.JWTAuth(),
        middleware.RateLimit(),
        middleware.Logger(),
        middleware.CORS(),
    )
    
    // 文本生成相关
    aiGroup.POST("/generate", aiApi.GenerateContent)
    aiGroup.POST("/continue", aiApi.ContinueWriting)
    aiGroup.POST("/optimize", aiApi.OptimizeText)
    aiGroup.POST("/analyze", aiApi.AnalyzeContent)
    aiGroup.POST("/outline", aiApi.GenerateOutline)
    
    // 流式响应
    aiGroup.POST("/stream/generate", aiApi.StreamGenerate)
    aiGroup.POST("/stream/chat", aiApi.StreamChat)
    
    // 健康检查
    aiGroup.GET("/health", aiApi.HealthCheck)
    aiGroup.GET("/providers", aiApi.ListProviders)
}
```

### 3.2 API层设计

**统一响应格式**：
```go
type APIResponse struct {
    Code      int         `json:"code"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    Timestamp int64       `json:"timestamp"`
}

type ErrorResponse struct {
    Code      int           `json:"code"`
    Message   string        `json:"message"`
    Details   []ErrorDetail `json:"details,omitempty"`
    Timestamp int64         `json:"timestamp"`
}

type ErrorDetail struct {
    Field   string `json:"field"`
    Message string `json:"message"`
}
```

**请求验证**：
```go
type GenerateRequest struct {
    Prompt      string  `json:"prompt" binding:"required,min=1,max=10000"`
    MaxTokens   int     `json:"max_tokens" binding:"min=1,max=4000"`
    Temperature float64 `json:"temperature" binding:"min=0,max=2"`
    Model       string  `json:"model" binding:"required"`
    Provider    string  `json:"provider"`
    Stream      bool    `json:"stream"`
}
```

### 3.3 Service层设计

**核心服务结构**：
```go
type AIService struct {
    adapterManager *AdapterManager
    routingService *RoutingService
    cacheService   *CacheService
    configService  *ConfigService
    monitorService *MonitorService
}

type AdapterManager struct {
    adapters map[string]AIAdapter
    mutex    sync.RWMutex
}

type RoutingService struct {
    strategies []RoutingStrategy
    fallback   RoutingStrategy
}
```

**路由策略**：
```go
type RoutingStrategy interface {
    SelectProvider(request *AIRequest) (*AIProvider, error)
    GetPriority() int
}

// 负载均衡策略
type LoadBalanceStrategy struct {
    providers []*AIProvider
    current   int64
}

// 故障转移策略
type FailoverStrategy struct {
    primary   *AIProvider
    secondary []*AIProvider
}

// 成本优化策略
type CostOptimizedStrategy struct {
    providers []*AIProvider
    costMap   map[string]float64
}
```

### 3.4 Model层设计

**AI服务提供商模型**：
```go
type AIProvider struct {
    ID          primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Name        string             `bson:"name" json:"name"`
    Type        string             `bson:"type" json:"type"`
    APIKey      string             `bson:"api_key" json:"-"`
    BaseURL     string             `bson:"base_url" json:"base_url"`
    Enabled     bool               `bson:"enabled" json:"enabled"`
    Priority    int                `bson:"priority" json:"priority"`
    MaxTokens   int                `bson:"max_tokens" json:"max_tokens"`
    RateLimit   RateLimit          `bson:"rate_limit" json:"rate_limit"`
    HealthCheck HealthCheck        `bson:"health_check" json:"health_check"`
    CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
    UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}

type RateLimit struct {
    RequestsPerMinute int `bson:"requests_per_minute" json:"requests_per_minute"`
    TokensPerMinute   int `bson:"tokens_per_minute" json:"tokens_per_minute"`
}

type HealthCheck struct {
    Status      string    `bson:"status" json:"status"`
    LastCheck   time.Time `bson:"last_check" json:"last_check"`
    ResponseTime int64     `bson:"response_time" json:"response_time"`
    ErrorCount   int       `bson:"error_count" json:"error_count"`
}
```

**AI模型配置**：
```go
type AIModel struct {
    ID          primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Provider    string             `bson:"provider" json:"provider"`
    Name        string             `bson:"name" json:"name"`
    Type        string             `bson:"type" json:"type"`
    MaxTokens   int                `bson:"max_tokens" json:"max_tokens"`
    InputCost   float64            `bson:"input_cost" json:"input_cost"`
    OutputCost  float64            `bson:"output_cost" json:"output_cost"`
    Enabled     bool               `bson:"enabled" json:"enabled"`
    Description string             `bson:"description" json:"description"`
    CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
    UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}
```

## 4. 数据设计

### 4.1 数据模型
详见上述Model层设计中的数据模型定义。

### 4.2 数据关系
- **AI提供商 ↔ AI模型**：一对多关系
- **AI提供商 ↔ 健康检查记录**：一对多关系
- **用户 ↔ API调用记录**：一对多关系
- **AI模型 ↔ 使用统计**：一对多关系

### 4.3 索引策略
```javascript
// ai_providers集合
db.ai_providers.createIndex({"name": 1}, {"unique": true})
db.ai_providers.createIndex({"enabled": 1, "priority": -1})
db.ai_providers.createIndex({"type": 1})

// ai_models集合
db.ai_models.createIndex({"provider": 1, "name": 1}, {"unique": true})
db.ai_models.createIndex({"enabled": 1})
db.ai_models.createIndex({"type": 1})

// api_calls集合
db.api_calls.createIndex({"user_id": 1, "timestamp": -1})
db.api_calls.createIndex({"provider": 1, "timestamp": -1})
db.api_calls.createIndex({"status": 1})

// health_checks集合
db.health_checks.createIndex({"provider_id": 1, "timestamp": -1})
db.health_checks.createIndex({"status": 1})
```

### 4.4 数据迁移
- **版本控制**：使用语义化版本号管理数据库结构
- **迁移脚本**：自动化的数据库迁移脚本
- **回滚策略**：支持快速回滚到上一版本
- **数据备份**：迁移前自动备份数据

## 5. 接口设计

### 5.1 API规范
遵循RESTful设计原则，使用统一的JSON响应格式。

### 5.2 核心接口

#### 5.2.1 文本生成接口
```http
POST /api/v1/ai/generate
Authorization: Bearer <token>
Content-Type: application/json

{
  "prompt": "请写一段关于春天的描述",
  "max_tokens": 500,
  "temperature": 0.7,
  "model": "gpt-4",
  "provider": "openai"
}
```

**响应**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": "gen_123456789",
    "content": "春天来了，万物复苏...",
    "provider": "openai",
    "model": "gpt-4",
    "usage": {
      "prompt_tokens": 15,
      "completion_tokens": 120,
      "total_tokens": 135
    },
    "cost": 0.0027
  },
  "timestamp": 1703123456789
}
```

#### 5.2.2 健康检查接口
```http
GET /api/v1/ai/health
Authorization: Bearer <token>
```

**响应**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "providers": [
      {
        "name": "openai",
        "status": "healthy",
        "response_time": 150,
        "last_check": "2023-12-01T10:00:00Z"
      },
      {
        "name": "claude",
        "status": "degraded",
        "response_time": 800,
        "last_check": "2023-12-01T10:00:00Z"
      }
    ],
    "overall_status": "healthy"
  },
  "timestamp": 1703123456789
}
```

### 5.3 错误处理
```json
{
  "code": 5001,
  "message": "AI服务不可用",
  "details": [
    {
      "field": "provider",
      "message": "OpenAI服务当前不可用，已自动切换到备用服务"
    }
  ],
  "timestamp": 1703123456789
}
```

### 5.4 性能要求
- **响应时间**：健康检查 < 100ms，文本生成 < 2s
- **可用性**：99.9%服务可用性
- **并发处理**：支持1000+并发请求
- **故障转移**：< 5s自动故障转移

## 6. 安全设计

### 6.1 权限控制
- **API认证**：JWT Token验证
- **服务认证**：AI服务API密钥管理
- **权限分级**：管理员、普通用户权限分离

### 6.2 数据安全
- **密钥管理**：API密钥加密存储，定期轮换
- **传输安全**：HTTPS加密传输
- **访问控制**：基于IP白名单的访问控制

### 6.3 输入验证
- **参数校验**：严格的参数类型和范围验证
- **内容过滤**：敏感内容检测和过滤
- **注入防护**：防止各种注入攻击

### 6.4 审计日志
- **API调用日志**：记录所有API调用详情
- **安全事件日志**：记录认证失败、异常访问等安全事件
- **系统操作日志**：记录配置变更、服务重启等操作

## 7. 测试设计

### 7.1 测试策略
- **单元测试**：各适配器、服务组件的单元测试
- **集成测试**：AI服务集成、数据库集成测试
- **端到端测试**：完整的API调用流程测试
- **性能测试**：负载测试、压力测试

### 7.2 测试用例

#### 7.2.1 适配器测试
```go
func TestOpenAIAdapter_TextGeneration(t *testing.T) {
    adapter := NewOpenAIAdapter(config)
    request := &AIRequest{
        Prompt: "Hello, world!",
        MaxTokens: 100,
    }
    
    response, err := adapter.TextGeneration(request)
    assert.NoError(t, err)
    assert.NotEmpty(t, response.Content)
}
```

#### 7.2.2 路由策略测试
```go
func TestLoadBalanceStrategy_SelectProvider(t *testing.T) {
    strategy := NewLoadBalanceStrategy(providers)
    
    // 测试负载均衡
    for i := 0; i < 10; i++ {
        provider, err := strategy.SelectProvider(request)
        assert.NoError(t, err)
        assert.NotNil(t, provider)
    }
}
```

### 7.3 性能测试
- **并发测试**：1000并发用户同时调用API
- **负载测试**：持续1小时的稳定负载
- **压力测试**：逐步增加负载直到系统极限
- **故障恢复测试**：模拟服务故障和恢复

### 7.4 安全测试
- **认证测试**：无效Token、过期Token测试
- **授权测试**：越权访问测试
- **输入验证测试**：恶意输入、边界值测试

## 8. 部署和运维

### 8.1 部署方案

#### 8.1.1 容器化部署
```dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go mod download
RUN go build -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
COPY --from=builder /app/config ./config
CMD ["./main"]
```

#### 8.1.2 Kubernetes部署
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ai-service
  template:
    metadata:
      labels:
        app: ai-service
    spec:
      containers:
      - name: ai-service
        image: qingyu/ai-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: mongodb-uri
```

### 8.2 监控指标

#### 8.2.1 业务指标
- API调用量（QPS）
- 成功率
- 平均响应时间
- 各AI服务商使用分布
- 成本统计

#### 8.2.2 系统指标
- CPU使用率
- 内存使用率
- 网络I/O
- 磁盘I/O
- 连接池状态

#### 8.2.3 告警规则
```yaml
groups:
- name: ai-service
  rules:
  - alert: HighErrorRate
    expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "AI服务错误率过高"
      
  - alert: SlowResponse
    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "AI服务响应时间过慢"
```

### 8.3 日志策略

#### 8.3.1 日志格式
```json
{
  "timestamp": "2023-12-01T10:00:00Z",
  "level": "INFO",
  "service": "ai-service",
  "trace_id": "abc123",
  "user_id": "user123",
  "provider": "openai",
  "model": "gpt-4",
  "tokens": 150,
  "cost": 0.003,
  "duration": 1200,
  "message": "AI request completed successfully"
}
```

#### 8.3.2 日志级别
- **DEBUG**：详细的调试信息
- **INFO**：一般信息，如API调用成功
- **WARN**：警告信息，如服务降级
- **ERROR**：错误信息，如API调用失败

### 8.4 故障处理

#### 8.4.1 故障类型
- **AI服务不可用**：自动切换到备用服务
- **网络超时**：重试机制和降级处理
- **配额耗尽**：切换到其他服务商
- **系统过载**：限流和熔断保护

#### 8.4.2 恢复流程
1. **故障检测**：健康检查发现异常
2. **自动处理**：触发故障转移机制
3. **告警通知**：发送告警给运维团队
4. **手动介入**：必要时进行手动处理
5. **故障复盘**：分析故障原因和改进措施

## 9. 风险评估

### 9.1 技术风险

#### 9.1.1 外部依赖风险
- **风险**：AI服务商API不稳定或变更
- **影响**：服务中断或功能异常
- **应对**：多服务商支持、版本兼容性处理

#### 9.1.2 性能风险
- **风险**：高并发下系统性能瓶颈
- **影响**：响应时间增长、服务不可用
- **应对**：负载均衡、缓存优化、水平扩展

#### 9.1.3 数据一致性风险
- **风险**：分布式环境下数据不一致
- **影响**：业务逻辑错误、数据丢失
- **应对**：事务管理、数据校验、定期同步

### 9.2 业务风险

#### 9.2.1 成本风险
- **风险**：AI服务调用成本过高
- **影响**：运营成本增加
- **应对**：成本监控、智能路由、配额控制

#### 9.2.2 质量风险
- **风险**：AI生成内容质量不稳定
- **影响**：用户体验下降
- **应对**：多模型对比、质量评估、人工审核

### 9.3 安全风险

#### 9.3.1 数据泄露风险
- **风险**：API密钥或用户数据泄露
- **影响**：安全事故、法律风险
- **应对**：加密存储、访问控制、安全审计

#### 9.3.2 恶意攻击风险
- **风险**：DDoS攻击、恶意请求
- **影响**：服务中断、资源消耗
- **应对**：限流保护、IP黑名单、WAF防护

## 10. 实施计划

### 10.1 开发阶段

#### 第一阶段（2周）：基础架构
- [ ] 项目结构搭建
- [ ] 基础中间件开发
- [ ] 数据模型设计
- [ ] 配置管理实现

#### 第二阶段（2周）：适配器开发
- [ ] OpenAI适配器实现
- [ ] Claude适配器实现
- [ ] 百度文心适配器实现
- [ ] 适配器接口统一

#### 第三阶段（1周）：路由和监控
- [ ] 路由策略实现
- [ ] 健康检查机制
- [ ] 监控指标收集
- [ ] 告警规则配置

#### 第四阶段（1周）：测试和优化
- [ ] 单元测试编写
- [ ] 集成测试执行
- [ ] 性能测试和优化
- [ ] 文档完善

### 10.2 测试阶段

#### 功能测试（1周）
- [ ] API接口测试
- [ ] 适配器功能测试
- [ ] 路由策略测试
- [ ] 错误处理测试

#### 性能测试（3天）
- [ ] 负载测试
- [ ] 压力测试
- [ ] 并发测试
- [ ] 故障恢复测试

#### 安全测试（2天）
- [ ] 认证授权测试
- [ ] 输入验证测试
- [ ] 安全漏洞扫描
- [ ] 渗透测试

### 10.3 上线计划

#### 灰度发布（1周）
- [ ] 小范围用户测试
- [ ] 监控数据收集
- [ ] 问题修复和优化
- [ ] 用户反馈收集

#### 正式发布（3天）
- [ ] 全量用户发布
- [ ] 监控告警配置
- [ ] 运维文档交付
- [ ] 培训和支持

### 10.4 后续优化

#### 功能完善（持续）
- [ ] 新AI服务商接入
- [ ] 路由策略优化
- [ ] 性能持续优化
- [ ] 用户体验改进

#### 技术升级（季度）
- [ ] 依赖库升级
- [ ] 安全补丁更新
- [ ] 架构优化调整
- [ ] 新技术引入评估
