# Python AI Agentç³»ç»Ÿæ¶æ„è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-21  
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡é’ç¾½å¹³å°çš„Python AI Agentç³»ç»Ÿï¼ŒåŒ…æ‹¬Agentæ¡†æ¶ã€å·¥å…·è°ƒç”¨ç³»ç»Ÿã€RAGæ£€ç´¢å¢å¼ºã€å¤šAgentåä½œå’Œè®°å¿†ç³»ç»Ÿã€‚è¿™æ˜¯é’ç¾½å¹³å°AIèƒ½åŠ›çš„æ ¸å¿ƒåˆ›æ–°ï¼Œèƒ½å¤Ÿå®ç°ä»"æ–‡æœ¬ç”Ÿæˆ"åˆ°"æ“ä½œæ‰§è¡Œ"çš„è·¨è¶Šã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **å·¥å…·è°ƒç”¨èƒ½åŠ›**ï¼šAgentèƒ½å¤Ÿç›´æ¥è°ƒç”¨å†™ä½œç«¯çš„å„ç§å·¥å…·ï¼ˆå¤§çº²ã€è§’è‰²å¡ã€å…³ç³»å›¾è°±ç­‰ï¼‰
2. **RAGå¢å¼º**ï¼šåŸºäºç”¨æˆ·ç§æœ‰çŸ¥è¯†åº“çš„æ™ºèƒ½æ£€ç´¢å¢å¼ºç”Ÿæˆ
3. **å¤šAgentåä½œ**ï¼šä¸åŒä¸“ä¸šAgentååŒå®Œæˆå¤æ‚ä»»åŠ¡
4. **è®°å¿†ç³»ç»Ÿ**ï¼šçŸ­æœŸã€é•¿æœŸå’Œå·¥ä½œè®°å¿†çš„æœ‰æœºç»“åˆ
5. **é«˜æ€§èƒ½**ï¼šæ”¯æŒæµå¼å“åº”ï¼Œé™ä½ç”¨æˆ·æ„ŸçŸ¥å»¶è¿Ÿ

---

## ä¸€ã€æ•´ä½“æ¶æ„è®¾è®¡

### 1.1 ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Python AI Agent Service                     â”‚
â”‚                      (FastAPIæœåŠ¡)                              â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              gRPC/HTTP Server Layer                    â”‚   â”‚
â”‚  â”‚  - gRPC Servicer (ä¸»è¦)                                â”‚   â”‚
â”‚  â”‚  - FastAPI Endpoints (å¤‡ç”¨)                            â”‚   â”‚
â”‚  â”‚  - è¯·æ±‚éªŒè¯                                             â”‚   â”‚
â”‚  â”‚  - é”™è¯¯å¤„ç†                                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           Agent Orchestrator (Agentç¼–æ’å™¨)            â”‚   â”‚
â”‚  â”‚  - Agentè·¯ç”±ï¼ˆæ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©Agentï¼‰                  â”‚   â”‚
â”‚  â”‚  - å¤šAgentç¼–æ’ï¼ˆååŒæ‰§è¡Œï¼‰                             â”‚   â”‚
â”‚  â”‚  - ä»»åŠ¡åˆ†è§£                                            â”‚   â”‚
â”‚  â”‚  - ç»“æœæ±‡æ€»                                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Agent Engine Layer                        â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚   â”‚
â”‚  â”‚  â”‚ Creative     â”‚ Analysis     â”‚ Review       â”‚        â”‚   â”‚
â”‚  â”‚  â”‚ Agent        â”‚ Agent        â”‚ Agent        â”‚        â”‚   â”‚
â”‚  â”‚  â”‚              â”‚              â”‚              â”‚        â”‚   â”‚
â”‚  â”‚  â”‚ åˆ›ä½œè¾…åŠ©     â”‚ æ–‡æœ¬åˆ†æ     â”‚ å†…å®¹å®¡æ ¸     â”‚        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
â”‚  â”‚  â”‚ Assistant    â”‚ Data Analysis â”‚ ... (å¯æ‰©å±•)  â”‚       â”‚   â”‚
â”‚  â”‚  â”‚ Agent        â”‚ Agent         â”‚              â”‚       â”‚   â”‚
â”‚  â”‚  â”‚              â”‚               â”‚              â”‚       â”‚   â”‚
â”‚  â”‚  â”‚ é€šç”¨åŠ©æ‰‹     â”‚ æ•°æ®ç»Ÿè®¡      â”‚              â”‚       â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  æ¯ä¸ªAgentåŒ…å«ï¼š                                        â”‚   â”‚
â”‚  â”‚  - ä»»åŠ¡ç†è§£æ¨¡å—                                         â”‚   â”‚
â”‚  â”‚  - æ­¥éª¤è§„åˆ’æ¨¡å—                                         â”‚   â”‚
â”‚  â”‚  - æ‰§è¡Œç¼–æ’æ¨¡å—                                         â”‚   â”‚
â”‚  â”‚  - ç»“æœæ±‡æ€»æ¨¡å—                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         Tool Calling System (æ ¸å¿ƒåˆ›æ–°)                 â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚          Tool Registry (å·¥å…·æ³¨å†Œä¸­å¿ƒ)          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - å·¥å…·å‘ç°                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - å·¥å…·å…ƒæ•°æ®ç®¡ç†                               â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - æƒé™é…ç½®                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - ç‰ˆæœ¬ç®¡ç†                                     â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚        Writing Tools (å†™ä½œå·¥å…·é›†æˆ)            â”‚    â”‚   â”‚
â”‚  â”‚  â”‚                                                  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  å¤§çº²å·¥å…· | è§’è‰²å¡å·¥å…· | å…³ç³»å›¾è°±å·¥å…·          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  æ—¶é—´çº¿å·¥å…· | ä¸–ç•Œè§‚å·¥å…· | è®¾å®šç™¾ç§‘å·¥å…·        â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  æ–‡æ¡£æ“ä½œå·¥å…· | æ•°æ®ç»Ÿè®¡å·¥å…·                    â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚      Tool Execution Engine (æ‰§è¡Œå¼•æ“)          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - å‚æ•°éªŒè¯                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - è°ƒç”¨Go APIï¼ˆHTTPå›è°ƒï¼‰                       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - ç»“æœè§£æ                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - é”™è¯¯å¤„ç†ä¸é‡è¯•                               â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - æ‰§è¡Œç›‘æ§                                     â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           RAG Retrieval Engine                         â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚      Vectorization Module (å‘é‡åŒ–æ¨¡å—)         â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - æ–‡æœ¬é¢„å¤„ç†                                   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Chunk Splitting                              â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Embedding (BGE/M3E/OpenAI)                   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - æ‰¹é‡å‘é‡åŒ–                                   â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚      Vector Search Module (å‘é‡æ£€ç´¢æ¨¡å—)       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Semantic Search (è¯­ä¹‰æ£€ç´¢)                   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Keyword Search (BM25)                        â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Hybrid Search (æ··åˆæ£€ç´¢)                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Rerank (é‡æ’åº)                              â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚      RAG Workflow Engine (RAGå·¥ä½œæµå¼•æ“)       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - æŸ¥è¯¢ç†è§£                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - å¤šæºæ£€ç´¢                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - ä¸Šä¸‹æ–‡æ„å»º                                   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Promptå¢å¼º                                   â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            Memory System (è®°å¿†ç³»ç»Ÿ)                     â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  çŸ­æœŸè®°å¿†(Redis) | é•¿æœŸè®°å¿†(MongoDB) | å·¥ä½œè®°å¿†(Cache)  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         External Services Integration                  â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚   â”‚
â”‚  â”‚  â”‚ OpenAI   â”‚ Claude   â”‚ Local LLM    â”‚ Go APIs  â”‚     â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚   â”‚
â”‚  â”‚  â”‚ Milvus   â”‚ Qdrant   â”‚ MongoDB      â”‚               â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯æ ˆé€‰å‹ ğŸ”¥ **å·²æ›´æ–°**

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | ç†ç”± |
|------|---------|------|
| **Webæ¡†æ¶** | FastAPI | é«˜æ€§èƒ½å¼‚æ­¥æ¡†æ¶ï¼ŒåŸç”Ÿæ”¯æŒgRPC |
| **Agentæ¡†æ¶** | **LangGraph** ğŸ† | **å›¾çŠ¶å·¥ä½œæµ + ç»§æ‰¿LangChainå…¨éƒ¨ç”Ÿæ€**<br>- æ”¯æŒå¤æ‚æµç¨‹ç¼–æ’ï¼ˆæ¡ä»¶ã€å¾ªç¯ã€åˆ†æ”¯ï¼‰<br>- ç»§æ‰¿LangChainå·¥å…·ã€RAGã€LLMé€‚é…å™¨<br>- å¤šAgentåä½œèƒ½åŠ›å¼º<br>**è¯¦è§**ï¼š[Agentæ¡†æ¶æŠ€æœ¯é€‰å‹å¯¹æ¯”](./Agentæ¡†æ¶æŠ€æœ¯é€‰å‹å¯¹æ¯”.md) |
| **å·¥å…·&RAG** | LangChainç”Ÿæ€ | LangGraphå®Œå…¨å…¼å®¹LangChainï¼š<br>- 100+å†…ç½®å·¥å…·<br>- å®Œå–„çš„RAGæ”¯æŒï¼ˆ10+å‘é‡æ•°æ®åº“ï¼‰<br>- 50+LLMé€‚é…å™¨ |
| **å‘é‡åŒ–** | sentence-transformers | æ”¯æŒå¤šç§ä¸­æ–‡å‘é‡æ¨¡å‹ï¼ˆBGE-large-zh-v1.5ç­‰ï¼‰ |
| **å‘é‡æ•°æ®åº“** | Milvus/Qdrant | é«˜æ€§èƒ½å‘é‡æ£€ç´¢ï¼ŒLangChainåŸç”Ÿæ”¯æŒ |
| **å¼‚æ­¥æ¡†æ¶** | asyncio | PythonåŸç”Ÿå¼‚æ­¥æ”¯æŒ |
| **åºåˆ—åŒ–** | Pydantic | ç±»å‹å®‰å…¨ï¼Œæ•°æ®éªŒè¯ |
| **æ—¥å¿—** | structlog | ç»“æ„åŒ–æ—¥å¿— |
| **ç›‘æ§** | prometheus-client | Prometheusé›†æˆ |

**é‡è¦è¯´æ˜**ï¼š
- âœ… **é€‰æ‹©LangGraphè€ŒéLangChain**ï¼šLangGraphæ˜¯LangChainçš„è¶…é›†ï¼Œæä¾›å›¾çŠ¶å·¥ä½œæµçš„åŒæ—¶ç»§æ‰¿å…¨éƒ¨LangChainç”Ÿæ€
- âœ… **é’ç¾½é¡¹ç›®å®Œç¾åŒ¹é…**ï¼šå¤æ‚åˆ›ä½œæµç¨‹éœ€è¦æ¡ä»¶åˆ†æ”¯ã€å¾ªç¯æ§åˆ¶ï¼ŒLangGraphå¤©ç„¶æ”¯æŒ
- âœ… **æ— éœ€ç‰ºç‰²ä»»ä½•èƒ½åŠ›**ï¼šå¯ä»¥ä½¿ç”¨LangChainçš„æ‰€æœ‰å·¥å…·ã€RAGã€LLMé€‚é…å™¨

---

## äºŒã€Agentæ¡†æ¶è®¾è®¡ ğŸ”¥ **åŸºäºLangGraph**

### ğŸ¯ è®¾è®¡è¯´æ˜

**æ ¸å¿ƒæ¶æ„ï¼šLangGraph + LangChainç”Ÿæ€**

æœ¬ç« èŠ‚çš„`BaseAgent`æŠ½è±¡ç±»å®šä¹‰äº†é’ç¾½é¡¹ç›®Agentçš„é€šç”¨æ¥å£å’Œæ‰§è¡Œæµç¨‹ã€‚**å®é™…å®ç°å°†åŸºäºLangGraphæ¡†æ¶**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            é’ç¾½Agentæ¶æ„ï¼ˆåŸºäºLangGraphï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  BaseAgentï¼ˆæŠ½è±¡æ¥å£ï¼‰                                  â”‚
â”‚       â†“                                                â”‚
â”‚  LangGraphAgentï¼ˆå…·ä½“å®ç°ï¼‰                             â”‚
â”‚       â”œâ”€ StateGraphï¼ˆçŠ¶æ€å›¾ï¼‰                          â”‚
â”‚       â”‚    â”œâ”€ èŠ‚ç‚¹ï¼ˆç†è§£ä»»åŠ¡ã€è§„åˆ’ã€æ‰§è¡Œã€å®¡æ ¸ï¼‰          â”‚
â”‚       â”‚    â”œâ”€ è¾¹ï¼ˆæ¡ä»¶è·¯ç”±ã€å¾ªç¯æ§åˆ¶ï¼‰                  â”‚
â”‚       â”‚    â””â”€ çŠ¶æ€ï¼ˆAgentState with memoryï¼‰         â”‚
â”‚       â”‚                                                â”‚
â”‚       â”œâ”€ LangChainå·¥å…·é›†æˆ                             â”‚
â”‚       â”‚    â”œâ”€ Tool Callingï¼ˆToolNodeï¼‰                â”‚
â”‚       â”‚    â”œâ”€ RAGæ£€ç´¢ï¼ˆVectorStoreRetrieverï¼‰         â”‚
â”‚       â”‚    â””â”€ LLMé€‚é…å™¨ï¼ˆOpenAI/DeepSeekç­‰ï¼‰          â”‚
â”‚       â”‚                                                â”‚
â”‚       â””â”€ Checkpointerï¼ˆæŒä¹…åŒ–ï¼‰                        â”‚
â”‚            â””â”€ PostgresSaverï¼ˆçŠ¶æ€ä¿å­˜ï¼‰                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**LangGraphçš„ä¼˜åŠ¿ä½“ç°**ï¼š
- âœ… **å›¾çŠ¶å·¥ä½œæµ**ï¼šç†è§£â†’è§„åˆ’â†’æ‰§è¡Œâ†’å®¡æ ¸â†’å¾ªç¯ï¼Œå®Œç¾æ˜ å°„åˆ°StateGraph
- âœ… **æ¡ä»¶è·¯ç”±**ï¼šæ ¹æ®å®¡æ ¸ç»“æœå†³å®šé‡æ–°ç”Ÿæˆæˆ–ç»§ç»­
- âœ… **çŠ¶æ€ç®¡ç†**ï¼šæ˜¾å¼çš„AgentStateï¼Œä¾¿äºè°ƒè¯•å’ŒæŒä¹…åŒ–
- âœ… **LangChainç»§æ‰¿**ï¼šæ— ç¼ä½¿ç”¨LangChainçš„æ‰€æœ‰å·¥å…·å’ŒRAGèƒ½åŠ›

**å®ç°å¯¹åº”å…³ç³»**ï¼š

| BaseAgentæ–¹æ³• | LangGraphå®ç° | è¯´æ˜ |
|--------------|--------------|------|
| `execute()` | `StateGraph.invoke()` | æ‰§è¡Œæ•´ä¸ªå·¥ä½œæµ |
| `understand_task()` | å›¾èŠ‚ç‚¹ï¼š`understand_node` | ä»»åŠ¡ç†è§£èŠ‚ç‚¹ |
| `plan_steps()` | å›¾èŠ‚ç‚¹ï¼š`plan_node` | è§„åˆ’èŠ‚ç‚¹ |
| `execute_step()` | å›¾èŠ‚ç‚¹ï¼š`execute_node` + `ToolNode` | æ‰§è¡ŒèŠ‚ç‚¹+å·¥å…·è°ƒç”¨ |
| `tools` | LangChain Tools | ä½¿ç”¨LangChainå·¥å…·ç”Ÿæ€ |
| `memory_system` | StateGraphçš„State + Checkpointer | LangGraphçŠ¶æ€ç®¡ç† |

**è¯¦ç»†å®ç°ç¤ºä¾‹**è§æœ¬æ–‡æ¡£æœ«å°¾çš„"é™„å½•ï¼šLangGraphå®ç°ç¤ºä¾‹"ã€‚

---

### 2.1 BaseAgentæŠ½è±¡ç±»

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
import asyncio

class Task(BaseModel):
    """ä»»åŠ¡å®šä¹‰"""
    task_id: str
    description: str
    context: Dict[str, Any]
    priority: int = 0
    timeout: int = 300  # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰

class ToolCall(BaseModel):
    """å·¥å…·è°ƒç”¨è®°å½•"""
    tool_name: str
    parameters: Dict[str, Any]
    result: Any
    duration_ms: int
    success: bool
    error: Optional[str] = None

class AgentResult(BaseModel):
    """Agentæ‰§è¡Œç»“æœ"""
    task_id: str
    output: str
    tool_calls: List[ToolCall] = []
    reasoning: List[str] = []  # æ¨ç†è¿‡ç¨‹
    confidence: float = 0.0
    metadata: Dict[str, Any] = {}

class BaseAgent(ABC):
    """AgentåŸºç±»"""
    
    def __init__(
        self,
        name: str,
        llm_client,  # LLMå®¢æˆ·ç«¯
        tool_registry,  # å·¥å…·æ³¨å†Œä¸­å¿ƒ
        memory_system,  # è®°å¿†ç³»ç»Ÿ
        config: Dict[str, Any] = None
    ):
        self.name = name
        self.llm_client = llm_client
        self.tool_registry = tool_registry
        self.memory_system = memory_system
        self.config = config or {}
        self.tools: List[Tool] = []
        
    def register_tool(self, tool: 'Tool'):
        """æ³¨å†Œå·¥å…·"""
        self.tools.append(tool)
        
    async def execute(self, task: Task) -> AgentResult:
        """æ‰§è¡Œä»»åŠ¡ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰"""
        # 1. ç†è§£ä»»åŠ¡
        understanding = await self.understand_task(task)
        
        # 2. è§„åˆ’æ­¥éª¤
        plan = await self.plan_steps(understanding)
        
        # 3. æ‰§è¡Œè®¡åˆ’
        results = []
        tool_calls = []
        
        for step in plan:
            result = await self.execute_step(step)
            results.append(result)
            
            if result.get('need_tool'):
                tool_result = await self.call_tool(
                    result['tool_name'],
                    result['tool_params']
                )
                tool_calls.append(tool_result)
                results[-1]['tool_result'] = tool_result
        
        # 4. æ±‡æ€»ç»“æœ
        final_result = await self.summarize_results(results)
        
        return AgentResult(
            task_id=task.task_id,
            output=final_result,
            tool_calls=tool_calls,
            reasoning=self._extract_reasoning(results)
        )
    
    @abstractmethod
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """ç†è§£ä»»åŠ¡ï¼ˆå­ç±»å®ç°ï¼‰"""
        pass
    
    @abstractmethod
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """è§„åˆ’æ‰§è¡Œæ­¥éª¤ï¼ˆå­ç±»å®ç°ï¼‰"""
        pass
    
    async def execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå•ä¸ªæ­¥éª¤"""
        # åŸºç¡€å®ç°ï¼Œå­ç±»å¯ä»¥è¦†ç›–
        prompt = self._build_prompt(step)
        response = await self.llm_client.generate(prompt)
        
        # åˆ¤æ–­æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·
        need_tool = self._detect_tool_call(response)
        
        return {
            'step_output': response,
            'need_tool': need_tool,
            'tool_name': need_tool and self._extract_tool_name(response),
            'tool_params': need_tool and self._extract_tool_params(response)
        }
    
    async def call_tool(self, tool_name: str, params: Dict[str, Any]) -> ToolCall:
        """è°ƒç”¨å·¥å…·"""
        import time
        start_time = time.time()
        
        try:
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.execute(params)
            
            return ToolCall(
                tool_name=tool_name,
                parameters=params,
                result=result,
                duration_ms=int((time.time() - start_time) * 1000),
                success=True
            )
        except Exception as e:
            return ToolCall(
                tool_name=tool_name,
                parameters=params,
                result=None,
                duration_ms=int((time.time() - start_time) * 1000),
                success=False,
                error=str(e)
            )
    
    @abstractmethod
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """æ±‡æ€»ç»“æœï¼ˆå­ç±»å®ç°ï¼‰"""
        pass
    
    def _build_prompt(self, step: Dict[str, Any]) -> str:
        """æ„å»ºPrompt"""
        # TODO: å®ç°Promptæ¨¡æ¿
        pass
    
    def _detect_tool_call(self, response: str) -> bool:
        """æ£€æµ‹å“åº”ä¸­æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·"""
        # TODO: å®ç°å·¥å…·è°ƒç”¨æ£€æµ‹é€»è¾‘
        pass
    
    def _extract_tool_name(self, response: str) -> str:
        """ä»å“åº”ä¸­æå–å·¥å…·åç§°"""
        # TODO: å®ç°æå–é€»è¾‘
        pass
    
    def _extract_tool_params(self, response: str) -> Dict[str, Any]:
        """ä»å“åº”ä¸­æå–å·¥å…·å‚æ•°"""
        # TODO: å®ç°æå–é€»è¾‘
        pass
    
    def _extract_reasoning(self, results: List[Dict[str, Any]]) -> List[str]:
        """æå–æ¨ç†è¿‡ç¨‹"""
        return [r.get('reasoning', '') for r in results if r.get('reasoning')]
```

### 2.2 ä¸“ä¸šAgentå®ç°

#### Creative Agent (åˆ›ä½œAgent)

```python
class CreativeAgent(BaseAgent):
    """åˆ›ä½œåŠ©æ‰‹Agent
    
    ä¸“é•¿ï¼š
    - æƒ…èŠ‚ç»­å†™
    - å¯¹è¯ç”Ÿæˆ
    - åœºæ™¯æå†™
    - è§’è‰²å¡‘é€ 
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(name="CreativeAgent", *args, **kwargs)
        
        # æ³¨å†Œä¸“ç”¨å·¥å…·
        self.register_tool(OutlineTool())
        self.register_tool(CharacterTool())
        self.register_tool(RelationshipTool())
        self.register_tool(TimelineTool())
        self.register_tool(WorldviewTool())
        self.register_tool(DocumentTool())
        
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """ç†è§£åˆ›ä½œä»»åŠ¡"""
        # æå–ä»»åŠ¡ç±»å‹
        task_type = self._classify_creative_task(task.description)
        
        # ä»ä¸Šä¸‹æ–‡ä¸­æå–å…³é”®ä¿¡æ¯
        characters = task.context.get('characters', [])
        setting = task.context.get('setting', {})
        previous_content = task.context.get('previous_content', '')
        
        return {
            'type': task_type,  # 'continue', 'dialogue', 'scene', 'character'
            'characters': characters,
            'setting': setting,
            'previous_content': previous_content,
            'requirements': task.context.get('requirements', {})
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """è§„åˆ’åˆ›ä½œæ­¥éª¤"""
        task_type = understanding['type']
        
        if task_type == 'continue':
            # ç»­å†™ä»»åŠ¡
            return [
                {
                    'action': 'retrieve_context',
                    'description': 'æ£€ç´¢ç›¸å…³è§’è‰²å’Œè®¾å®š',
                    'tools': ['character', 'worldview', 'timeline']
                },
                {
                    'action': 'generate_plot',
                    'description': 'ç”Ÿæˆæƒ…èŠ‚å‘å±•'
                },
                {
                    'action': 'write_content',
                    'description': 'æ’°å†™å…·ä½“å†…å®¹'
                },
                {
                    'action': 'consistency_check',
                    'description': 'ä¸€è‡´æ€§æ£€æŸ¥',
                    'tools': ['timeline', 'character']
                }
            ]
        elif task_type == 'dialogue':
            # å¯¹è¯ç”Ÿæˆ
            return [
                {
                    'action': 'retrieve_characters',
                    'description': 'è·å–è§’è‰²ä¿¡æ¯',
                    'tools': ['character']
                },
                {
                    'action': 'analyze_relationship',
                    'description': 'åˆ†æè§’è‰²å…³ç³»',
                    'tools': ['relationship']
                },
                {
                    'action': 'generate_dialogue',
                    'description': 'ç”Ÿæˆå¯¹è¯å†…å®¹'
                }
            ]
        # ... å…¶ä»–ä»»åŠ¡ç±»å‹
        
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """æ±‡æ€»åˆ›ä½œç»“æœ"""
        # æå–æ‰€æœ‰ç”Ÿæˆçš„å†…å®¹
        generated_content = []
        for result in results:
            if result.get('step_output'):
                generated_content.append(result['step_output'])
        
        # åˆå¹¶å¹¶æ¶¦è‰²
        combined = '\n\n'.join(generated_content)
        
        # å¯é€‰ï¼šè°ƒç”¨LLMè¿›è¡Œæœ€åçš„æ¶¦è‰²
        polished = await self.llm_client.generate(
            f"è¯·å¯¹ä»¥ä¸‹å†…å®¹è¿›è¡Œæ¶¦è‰²ï¼Œä½¿å…¶æ›´åŠ æµç•…ï¼š\n\n{combined}"
        )
        
        return polished
    
    def _classify_creative_task(self, description: str) -> str:
        """åˆ†ç±»åˆ›ä½œä»»åŠ¡ç±»å‹"""
        if 'ç»­å†™' in description or 'ç»§ç»­' in description:
            return 'continue'
        elif 'å¯¹è¯' in description or 'å°è¯' in description:
            return 'dialogue'
        elif 'åœºæ™¯' in description or 'æå†™' in description:
            return 'scene'
        elif 'è§’è‰²' in description or 'äººç‰©' in description:
            return 'character'
        else:
            return 'general'
```

#### Analysis Agent (åˆ†æAgent)

```python
class AnalysisAgent(BaseAgent):
    """åˆ†æåŠ©æ‰‹Agent
    
    ä¸“é•¿ï¼š
    - æ–‡æœ¬åˆ†æ
    - æƒ…æ„Ÿåˆ†æ
    - èŠ‚å¥åˆ†æ
    - è´¨é‡è¯„ä¼°
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """ç†è§£åˆ†æä»»åŠ¡"""
        return {
            'type': self._classify_analysis_task(task.description),
            'target_content': task.context.get('content', ''),
            'analysis_aspects': task.context.get('aspects', [])
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """è§„åˆ’åˆ†ææ­¥éª¤"""
        task_type = understanding['type']
        
        if task_type == 'comprehensive':
            return [
                {'action': 'style_analysis', 'description': 'æ–‡é£åˆ†æ'},
                {'action': 'emotion_analysis', 'description': 'æƒ…æ„Ÿåˆ†æ'},
                {'action': 'pace_analysis', 'description': 'èŠ‚å¥åˆ†æ'},
                {'action': 'quality_assessment', 'description': 'è´¨é‡è¯„ä¼°'},
                {'action': 'generate_report', 'description': 'ç”Ÿæˆåˆ†ææŠ¥å‘Š'}
            ]
        # ... å…¶ä»–ç±»å‹
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """æ±‡æ€»åˆ†æç»“æœ"""
        # ç”Ÿæˆç»“æ„åŒ–åˆ†ææŠ¥å‘Š
        report = {
            'style': results[0].get('step_output'),
            'emotion': results[1].get('step_output'),
            'pace': results[2].get('step_output'),
            'quality': results[3].get('step_output')
        }
        
        # ç”Ÿæˆå¯è¯»æ€§æŠ¥å‘Š
        formatted_report = self._format_analysis_report(report)
        return formatted_report
    
    def _classify_analysis_task(self, description: str) -> str:
        if 'ç»¼åˆ' in description or 'å…¨é¢' in description:
            return 'comprehensive'
        elif 'æ–‡é£' in description or 'é£æ ¼' in description:
            return 'style'
        elif 'æƒ…æ„Ÿ' in description:
            return 'emotion'
        else:
            return 'general'
    
    def _format_analysis_report(self, report: Dict[str, Any]) -> str:
        """æ ¼å¼åŒ–åˆ†ææŠ¥å‘Š"""
        return f"""
# æ–‡æœ¬åˆ†ææŠ¥å‘Š

## æ–‡é£åˆ†æ
{report['style']}

## æƒ…æ„Ÿåˆ†æ
{report['emotion']}

## èŠ‚å¥åˆ†æ
{report['pace']}

## è´¨é‡è¯„ä¼°
{report['quality']}

## ç»¼åˆå»ºè®®
...
"""
```

#### Review Agent (å®¡æ ¸Agent)

```python
class ReviewAgent(BaseAgent):
    """å®¡æ ¸åŠ©æ‰‹Agent
    
    ä¸“é•¿ï¼š
    - å†…å®¹å®¡æ ¸
    - åˆè§„æ£€æŸ¥
    - åŸåˆ›åº¦æ£€æµ‹
    - æ•æ„Ÿè¯æ£€æµ‹
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        return {
            'type': 'review',
            'content': task.context.get('content', ''),
            'review_level': task.context.get('level', 'standard')
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        return [
            {'action': 'sensitive_word_check', 'description': 'æ•æ„Ÿè¯æ£€æµ‹'},
            {'action': 'originality_check', 'description': 'åŸåˆ›åº¦æ£€æµ‹'},
            {'action': 'compliance_check', 'description': 'åˆè§„æ€§æ£€æŸ¥'},
            {'action': 'generate_review_report', 'description': 'ç”Ÿæˆå®¡æ ¸æŠ¥å‘Š'}
        ]
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """ç”Ÿæˆå®¡æ ¸æŠ¥å‘Š"""
        return f"""
# å†…å®¹å®¡æ ¸æŠ¥å‘Š

## æ•æ„Ÿè¯æ£€æµ‹
{results[0].get('step_output')}

## åŸåˆ›åº¦æ£€æµ‹
{results[1].get('step_output')}

## åˆè§„æ€§æ£€æŸ¥
{results[2].get('step_output')}

## å®¡æ ¸ç»“è®º
...
"""
```

#### Assistant Agent (é€šç”¨åŠ©æ‰‹Agent)

```python
class AssistantAgent(BaseAgent):
    """é€šç”¨åŠ©æ‰‹Agent
    
    ä¸“é•¿ï¼š
    - é—®ç­”
    - è®¾å®šæŸ¥è¯¢
    - æ“ä½œæŒ‡å¯¼
    - é€šç”¨ä»»åŠ¡
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        return {
            'type': self._classify_query_type(task.description),
            'query': task.description,
            'context': task.context
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        query_type = understanding['type']
        
        if query_type == 'setting_query':
            # è®¾å®šæŸ¥è¯¢
            return [
                {'action': 'search_knowledge', 'description': 'RAGæ£€ç´¢'},
                {'action': 'generate_answer', 'description': 'ç”Ÿæˆå›ç­”'}
            ]
        elif query_type == 'general_qa':
            # é€šç”¨é—®ç­”
            return [
                {'action': 'understand_question', 'description': 'ç†è§£é—®é¢˜'},
                {'action': 'generate_answer', 'description': 'ç”Ÿæˆå›ç­”'}
            ]
        # ... å…¶ä»–ç±»å‹
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        return results[-1].get('step_output', '')
    
    def _classify_query_type(self, query: str) -> str:
        if 'è®¾å®š' in query or 'ä¸–ç•Œè§‚' in query:
            return 'setting_query'
        else:
            return 'general_qa'
```

---

## ä¸‰ã€å·¥å…·è°ƒç”¨ç³»ç»Ÿè®¾è®¡

### 3.1 ToolåŸºç±»

```python
from abc import ABC, abstractmethod
from pydantic import BaseModel
from typing import Any, Dict

class ToolMetadata(BaseModel):
    """å·¥å…·å…ƒæ•°æ®"""
    name: str
    description: str
    parameters_schema: Dict[str, Any]  # JSON Schema
    category: str  # 'writing', 'analysis', 'admin'
    requires_auth: bool = True
    version: str = "1.0.0"

class Tool(ABC):
    """å·¥å…·åŸºç±»"""
    
    def __init__(self, metadata: ToolMetadata, go_api_client):
        self.metadata = metadata
        self.go_api_client = go_api_client
    
    def validate_parameters(self, params: Dict[str, Any]) -> bool:
        """éªŒè¯å‚æ•°"""
        # ä½¿ç”¨JSON SchemaéªŒè¯
        from jsonschema import validate, ValidationError
        try:
            validate(instance=params, schema=self.metadata.parameters_schema)
            return True
        except ValidationError:
            return False
    
    @abstractmethod
    async def execute(self, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå·¥å…·ï¼ˆå­ç±»å®ç°ï¼‰"""
        pass
    
    def get_description(self) -> str:
        """è·å–å·¥å…·æè¿°ï¼ˆç”¨äºLLM Promptï¼‰"""
        return f"""
å·¥å…·åç§°: {self.metadata.name}
åŠŸèƒ½æè¿°: {self.metadata.description}
å‚æ•°æ ¼å¼: {self.metadata.parameters_schema}
"""
```

### 3.2 å†™ä½œå·¥å…·å®ç°

#### å¤§çº²å·¥å…·

```python
class OutlineTool(Tool):
    """å¤§çº²å·¥å…·"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="outline_tool",
            description="åˆ›å»ºå’Œç®¡ç†å°è¯´å¤§çº²ï¼Œæ”¯æŒè‡ªåŠ¨ç”Ÿæˆå¤§çº²ã€ç« èŠ‚è§„åˆ’ã€æƒ…èŠ‚å‘å±•å»ºè®®",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get", "generate_auto"]
                    },
                    "project_id": {"type": "string"},
                    "outline_data": {"type": "object"},
                    "structure_type": {
                        "type": "string",
                        "enum": ["three_act", "hero_journey", "custom"],
                        "description": "å¤§çº²ç»“æ„ç±»å‹ï¼šä¸‰å¹•å¼ã€è‹±é›„ä¹‹æ—…ã€è‡ªå®šä¹‰"
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå¤§çº²æ“ä½œ"""
        if not self.validate_parameters(params):
            raise ValueError("å‚æ•°éªŒè¯å¤±è´¥")
        
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            # è°ƒç”¨Go APIåˆ›å»ºå¤§çº²
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/outline",
                json=params.get('outline_data')
            )
            return response.json()
        
        elif action == 'generate_auto':
            # è‡ªåŠ¨ç”Ÿæˆå¤§çº²
            structure_type = params.get('structure_type', 'three_act')
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/outline/generate",
                json={'structure_type': structure_type}
            )
            return response.json()
        
        elif action == 'get':
            # è·å–å¤§çº²
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/outline"
            )
            return response.json()
        
        # ... å…¶ä»–æ“ä½œ
```

#### è§’è‰²å¡å·¥å…·

```python
class CharacterTool(Tool):
    """è§’è‰²å¡å·¥å…·"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="character_tool",
            description="ç®¡ç†è§’è‰²å¡ç‰‡ï¼ŒåŒ…æ‹¬åˆ›å»ºè§’è‰²æ¡£æ¡ˆã€è§’è‰²å‘å±•å¼§çº¿ã€è§’è‰²å†²çªåˆ†æ",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get", "list", "analyze_arc"]
                    },
                    "project_id": {"type": "string"},
                    "character_id": {"type": "string"},
                    "character_data": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "age": {"type": "integer"},
                            "personality": {"type": "string"},
                            "background": {"type": "string"},
                            "goals": {"type": "string"},
                            "conflicts": {"type": "string"}
                        }
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/characters",
                json=params.get('character_data')
            )
            return response.json()
        
        elif action == 'get':
            character_id = params.get('character_id')
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/characters/{character_id}"
            )
            return response.json()
        
        elif action == 'list':
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/characters"
            )
            return response.json()
        
        elif action == 'analyze_arc':
            # åˆ†æè§’è‰²å‘å±•å¼§çº¿
            character_id = params.get('character_id')
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/characters/{character_id}/analyze-arc"
            )
            return response.json()
```

#### å…³ç³»å›¾è°±å·¥å…·

```python
class RelationshipTool(Tool):
    """å…³ç³»å›¾è°±å·¥å…·"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="relationship_tool",
            description="ç®¡ç†è§’è‰²å…³ç³»ç½‘ç»œï¼ŒåŒ…æ‹¬åˆ›å»ºå…³ç³»ã€å…³ç³»æ¼”å˜è¿½è¸ªã€å†²çªå…³ç³»å¯è§†åŒ–",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get_graph", "analyze"]
                    },
                    "project_id": {"type": "string"},
                    "from_character": {"type": "string"},
                    "to_character": {"type": "string"},
                    "relationship_type": {
                        "type": "string",
                        "enum": ["friend", "enemy", "family", "lover", "rival"]
                    },
                    "strength": {"type": "number", "minimum": 0, "maximum": 1}
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/relationships",
                json={
                    'from': params['from_character'],
                    'to': params['to_character'],
                    'type': params['relationship_type'],
                    'strength': params.get('strength', 0.5)
                }
            )
            return response.json()
        
        elif action == 'get_graph':
            # è·å–å…³ç³»ç½‘ç»œå›¾
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/relationships/graph"
            )
            return response.json()
        
        elif action == 'analyze':
            # åˆ†æå…³ç³»ç½‘ç»œï¼ˆä¸­å¿ƒåº¦ã€ç¤¾åŒºæ£€æµ‹ç­‰ï¼‰
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/relationships/analyze"
            )
            return response.json()
```

#### æ—¶é—´çº¿å·¥å…·

```python
class TimelineTool(Tool):
    """æ—¶é—´çº¿å·¥å…·"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="timeline_tool",
            description="ç®¡ç†æ•…äº‹æ—¶é—´çº¿ï¼Œæ”¯æŒå¤šçº¿ç´¢å¹¶è¡Œã€æ—¶é—´çº¿å†²çªæ£€æµ‹ã€äº‹ä»¶æ·»åŠ æŸ¥è¯¢",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create_event", "get_timeline", "check_conflicts"]
                    },
                    "project_id": {"type": "string"},
                    "event_data": {
                        "type": "object",
                        "properties": {
                            "title": {"type": "string"},
                            "description": {"type": "string"},
                            "timestamp": {"type": "string"},
                            "participants": {"type": "array", "items": {"type": "string"}}
                        }
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create_event':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/timeline/events",
                json=params.get('event_data')
            )
            return response.json()
        
        elif action == 'get_timeline':
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/timeline"
            )
            return response.json()
        
        elif action == 'check_conflicts':
            # æ£€æµ‹æ—¶é—´çº¿å†²çª
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/timeline/check-conflicts"
            )
            return response.json()
```

#### æ–‡æ¡£æ“ä½œå·¥å…·

```python
class DocumentTool(Tool):
    """æ–‡æ¡£æ“ä½œå·¥å…·"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="document_tool",
            description="æ“ä½œæ–‡æ¡£å†…å®¹ï¼ŒåŒ…æ‹¬è¯»å–ã€ä¿®æ”¹ã€ç‰ˆæœ¬ç®¡ç†ã€æ‰¹é‡æ“ä½œ",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["read", "write", "update", "list", "create_version"]
                    },
                    "project_id": {"type": "string"},
                    "document_id": {"type": "string"},
                    "content": {"type": "string"}
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'read':
            document_id = params['document_id']
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/documents/{document_id}"
            )
            return response.json()
        
        elif action == 'write':
            document_id = params['document_id']
            content = params['content']
            response = await self.go_api_client.put(
                f"/api/v1/projects/{project_id}/documents/{document_id}",
                json={'content': content}
            )
            return response.json()
        
        elif action == 'create_version':
            # åˆ›å»ºç‰ˆæœ¬
            document_id = params['document_id']
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/documents/{document_id}/versions"
            )
            return response.json()
```

### 3.3 å·¥å…·æ³¨å†Œä¸­å¿ƒ

```python
class ToolRegistry:
    """å·¥å…·æ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self, go_api_client):
        self.tools: Dict[str, Tool] = {}
        self.go_api_client = go_api_client
        self._init_default_tools()
    
    def _init_default_tools(self):
        """åˆå§‹åŒ–é»˜è®¤å·¥å…·"""
        self.register(OutlineTool(self.go_api_client))
        self.register(CharacterTool(self.go_api_client))
        self.register(RelationshipTool(self.go_api_client))
        self.register(TimelineTool(self.go_api_client))
        self.register(WorldviewTool(self.go_api_client))
        self.register(DocumentTool(self.go_api_client))
        # ... æ³¨å†Œå…¶ä»–å·¥å…·
    
    def register(self, tool: Tool):
        """æ³¨å†Œå·¥å…·"""
        self.tools[tool.metadata.name] = tool
    
    def get_tool(self, name: str) -> Tool:
        """è·å–å·¥å…·"""
        if name not in self.tools:
            raise ValueError(f"å·¥å…· {name} ä¸å­˜åœ¨")
        return self.tools[name]
    
    def list_tools(self, category: str = None) -> List[ToolMetadata]:
        """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
        tools = self.tools.values()
        if category:
            tools = [t for t in tools if t.metadata.category == category]
        return [t.metadata for t in tools]
    
    def get_tools_description_for_llm(self) -> str:
        """è·å–å·¥å…·æè¿°ï¼ˆç”¨äºLLM Promptï¼‰"""
        descriptions = []
        for tool in self.tools.values():
            descriptions.append(tool.get_description())
        return "\n\n".join(descriptions)
```

---

## å››ã€å¤šAgentåä½œæœºåˆ¶

### 4.1 Agentç¼–æ’å™¨

```python
class AgentOrchestrator:
    """Agentç¼–æ’å™¨"""
    
    def __init__(self, agents: Dict[str, BaseAgent]):
        self.agents = agents
    
    async def route_task(self, task: Task) -> BaseAgent:
        """è·¯ç”±ä»»åŠ¡åˆ°åˆé€‚çš„Agent"""
        # ç®€å•å®ç°ï¼šåŸºäºå…³é”®è¯åŒ¹é…
        description = task.description.lower()
        
        if 'ç»­å†™' in description or 'åˆ›ä½œ' in description:
            return self.agents['creative']
        elif 'åˆ†æ' in description:
            return self.agents['analysis']
        elif 'å®¡æ ¸' in description:
            return self.agents['review']
        else:
            return self.agents['assistant']
    
    async def execute_task(self, task: Task) -> AgentResult:
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        agent = await self.route_task(task)
        return await agent.execute(task)
    
    async def execute_multi_agent_task(
        self,
        task: Task,
        agent_sequence: List[str]
    ) -> List[AgentResult]:
        """å¤šAgentååŒæ‰§è¡Œä»»åŠ¡"""
        results = []
        context = task.context.copy()
        
        for agent_name in agent_sequence:
            agent = self.agents[agent_name]
            
            # å°†å‰ä¸€ä¸ªAgentçš„ç»“æœåŠ å…¥context
            sub_task = Task(
                task_id=f"{task.task_id}-{agent_name}",
                description=task.description,
                context=context
            )
            
            result = await agent.execute(sub_task)
            results.append(result)
            
            # æ›´æ–°context
            context[f'{agent_name}_result'] = result.output
        
        return results
```

### 4.2 ä½¿ç”¨ç¤ºä¾‹

```python
# åœºæ™¯ï¼šåˆ›å»ºå°è¯´æ¡†æ¶
async def create_novel_framework(user_input: str, project_id: str):
    """
    ç”¨æˆ·: "æˆ‘æƒ³å†™ä¸€éƒ¨ä¿®ä»™å°è¯´ï¼Œä¸»è§’å«æ—é£"
    
    Agentè‡ªåŠ¨æ‰§è¡Œï¼š
    1. CreativeAgent â†’ ç”Ÿæˆå¤§çº²
    2. CreativeAgent â†’ åˆ›å»ºè§’è‰²å¡
    3. CreativeAgent â†’ ç”Ÿæˆå…³ç³»å›¾è°±
    4. CreativeAgent â†’ æ„å»ºä¸–ç•Œè§‚
    5. CreativeAgent â†’ åˆ›å»ºæ—¶é—´çº¿
    6. AssistantAgent â†’ å½’æ¡£åˆ°è®¾å®šç™¾ç§‘
    """
    
    task = Task(
        task_id="create-framework-001",
        description=user_input,
        context={'project_id': project_id}
    )
    
    orchestrator = AgentOrchestrator({
        'creative': CreativeAgent(...),
        'assistant': AssistantAgent(...)
    })
    
    # å¤šAgentååŒæ‰§è¡Œ
    results = await orchestrator.execute_multi_agent_task(
        task,
        agent_sequence=['creative', 'creative', 'creative', 'assistant']
    )
    
    return {
        'framework_created': True,
        'outline': results[0].output,
        'characters': results[1].output,
        'worldview': results[2].output,
        'archived': results[3].output
    }
```

---

## äº”ã€è®°å¿†ç³»ç»Ÿè®¾è®¡

### 5.1 çŸ­æœŸè®°å¿†ï¼ˆRedisï¼‰

```python
class ShortTermMemory:
    """çŸ­æœŸè®°å¿†ï¼ˆä¼šè¯çº§åˆ«ï¼‰"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.ttl = 3600  # 1å°æ—¶è¿‡æœŸ
    
    async def store(self, session_id: str, key: str, value: Any):
        """å­˜å‚¨è®°å¿†"""
        memory_key = f"memory:short:{session_id}:{key}"
        await self.redis.set(memory_key, json.dumps(value), ex=self.ttl)
    
    async def retrieve(self, session_id: str, key: str) -> Any:
        """æ£€ç´¢è®°å¿†"""
        memory_key = f"memory:short:{session_id}:{key}"
        data = await self.redis.get(memory_key)
        return json.loads(data) if data else None
    
    async def clear_session(self, session_id: str):
        """æ¸…é™¤ä¼šè¯è®°å¿†"""
        pattern = f"memory:short:{session_id}:*"
        keys = await self.redis.keys(pattern)
        if keys:
            await self.redis.delete(*keys)
```

### 5.2 é•¿æœŸè®°å¿†ï¼ˆMongoDBï¼‰

```python
class LongTermMemory:
    """é•¿æœŸè®°å¿†ï¼ˆæŒä¹…åŒ–ï¼‰"""
    
    def __init__(self, mongo_client):
        self.db = mongo_client.ai_memory
        self.collection = self.db.long_term_memory
    
    async def store(self, user_id: str, memory_type: str, content: Dict[str, Any]):
        """å­˜å‚¨é•¿æœŸè®°å¿†"""
        document = {
            'user_id': user_id,
            'memory_type': memory_type,  # 'preference', 'history', 'knowledge'
            'content': content,
            'created_at': datetime.now(),
            'updated_at': datetime.now()
        }
        await self.collection.insert_one(document)
    
    async def retrieve(
        self,
        user_id: str,
        memory_type: str = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """æ£€ç´¢é•¿æœŸè®°å¿†"""
        query = {'user_id': user_id}
        if memory_type:
            query['memory_type'] = memory_type
        
        cursor = self.collection.find(query).sort('created_at', -1).limit(limit)
        return await cursor.to_list(length=limit)
```

### 5.3 å·¥ä½œè®°å¿†ï¼ˆContext Windowï¼‰

```python
class WorkingMemory:
    """å·¥ä½œè®°å¿†ï¼ˆå½“å‰ä»»åŠ¡ä¸Šä¸‹æ–‡ï¼‰"""
    
    def __init__(self, max_tokens: int = 8000):
        self.max_tokens = max_tokens
        self.context = []
    
    def add(self, item: Dict[str, Any]):
        """æ·»åŠ åˆ°å·¥ä½œè®°å¿†"""
        self.context.append(item)
        self._trim_to_limit()
    
    def get_context(self) -> List[Dict[str, Any]]:
        """è·å–å½“å‰ä¸Šä¸‹æ–‡"""
        return self.context
    
    def clear(self):
        """æ¸…ç©ºå·¥ä½œè®°å¿†"""
        self.context = []
    
    def _trim_to_limit(self):
        """è£å‰ªåˆ°Tokené™åˆ¶"""
        # TODO: å®ç°Tokenè®¡æ•°å’Œè£å‰ªé€»è¾‘
        pass
```

---

## å…­ã€å®æ–½å»ºè®®

### 6.1 å¼€å‘é˜¶æ®µ

| é˜¶æ®µ | æ—¶é—´ | ä»»åŠ¡ |
|------|------|------|
| **é˜¶æ®µ1ï¼šæ¡†æ¶æ­å»º** | 1å‘¨ | FastAPIé¡¹ç›®æ­å»ºã€gRPCé›†æˆã€åŸºç¡€Agentå®ç° |
| **é˜¶æ®µ2ï¼šå·¥å…·å¼€å‘** | 2å‘¨ | å®ç°æ‰€æœ‰å†™ä½œå·¥å…·ã€å·¥å…·æ³¨å†Œä¸­å¿ƒ |
| **é˜¶æ®µ3ï¼šRAGé›†æˆ** | 1å‘¨ | å‘é‡åŒ–å¼•æ“ã€å‘é‡æ•°æ®åº“é›†æˆ |
| **é˜¶æ®µ4ï¼šAgentå®Œå–„** | 1å‘¨ | ä¸“ä¸šAgentå®ç°ã€å¤šAgentåä½œ |
| **é˜¶æ®µ5ï¼šæµ‹è¯•ä¼˜åŒ–** | 1å‘¨ | å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½ä¼˜åŒ– |

### 6.2 æŠ€æœ¯é£é™©

| é£é™© | ç­‰çº§ | åº”å¯¹æªæ–½ |
|------|------|---------|
| å·¥å…·è°ƒç”¨å»¶è¿Ÿ | ä¸­ | å¼‚æ­¥è°ƒç”¨ã€ç»“æœç¼“å­˜ã€è¶…æ—¶æ§åˆ¶ |
| RAGå‡†ç¡®æ€§ | ä¸­ | å¤šç§æ£€ç´¢ç­–ç•¥ã€é‡æ’åºã€è´¨é‡è¯„ä¼° |
| LLMæˆæœ¬ | é«˜ | ç»“æœç¼“å­˜ã€Promptä¼˜åŒ–ã€æœ¬åœ°æ¨¡å‹å¤‡é€‰ |
| æœåŠ¡ç¨³å®šæ€§ | é«˜ | å®¹é”™æœºåˆ¶ã€é™çº§æ–¹æ¡ˆã€ç›‘æ§å‘Šè­¦ |

---

## é™„å½•ï¼šLangGraphå®ç°ç¤ºä¾‹ ğŸ”¥

### A.1 åˆ›ä½œAgentå®Œæ•´å®ç°ï¼ˆLangGraphç‰ˆï¼‰

åŸºäºå‰é¢çš„`BaseAgent`æŠ½è±¡è®¾è®¡ï¼Œè¿™é‡Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨**LangGraph**å®ç°ä¸€ä¸ªå®Œæ•´çš„åˆ›ä½œAgentï¼ŒåŒ…å«**ç†è§£â†’è§„åˆ’â†’æ‰§è¡Œâ†’å®¡æ ¸â†’å¾ªç¯**çš„å¤æ‚å·¥ä½œæµã€‚

```python
from typing import TypedDict, Annotated, Sequence
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.postgres import PostgresSaver
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langchain_openai import ChatOpenAI
from langchain.tools import Tool
import operator

# ====== 1. å®šä¹‰çŠ¶æ€ ======
class AgentState(TypedDict):
    """LangGraphçŠ¶æ€å®šä¹‰"""
    # è¾“å…¥
    task_description: str
    user_id: str
    project_id: str
    
    # å·¥ä½œæµçŠ¶æ€
    messages: Annotated[Sequence[BaseMessage], operator.add]
    plan: list[dict]  # è§„åˆ’çš„æ­¥éª¤
    current_step: int
    
    # æ‰§è¡Œç»“æœ
    generated_content: str
    tool_calls: list[dict]
    
    # å®¡æ ¸ç»“æœ
    review_result: dict
    review_passed: bool
    retry_count: int
    
    # æœ€ç»ˆè¾“å‡º
    final_output: str
    reasoning: list[str]


# ====== 2. å®šä¹‰å·¥å…·ï¼ˆä½¿ç”¨LangChainå·¥å…·ï¼‰ ======
from langchain.tools import BaseTool

class CharacterCreateTool(BaseTool):
    """è§’è‰²åˆ›å»ºå·¥å…·ï¼ˆè°ƒç”¨Go APIï¼‰"""
    name = "character_create"
    description = "åˆ›å»ºæ–°çš„å°è¯´è§’è‰²å¡ï¼ŒåŒ…å«å§“åã€æ€§æ ¼ã€èƒŒæ™¯ç­‰ä¿¡æ¯"
    
    def _run(self, name: str, personality: str, background: str, **kwargs) -> str:
        # è°ƒç”¨Go Backend API
        import requests
        response = requests.post(
            f"{GO_API_BASE}/api/v1/projects/{kwargs['project_id']}/characters",
            json={"name": name, "personality": personality, "background": background},
            headers={"Authorization": f"Bearer {kwargs['token']}"}
        )
        return response.json()
    
    async def _arun(self, *args, **kwargs):
        # å¼‚æ­¥ç‰ˆæœ¬
        return self._run(*args, **kwargs)

class RAGRetrievalTool(BaseTool):
    """RAGæ£€ç´¢å·¥å…·ï¼ˆä½¿ç”¨LangChain RAGï¼‰"""
    name = "rag_retrieve"
    description = "æ£€ç´¢ç›¸å…³çš„èƒŒæ™¯çŸ¥è¯†ã€è§’è‰²è®¾å®šã€æƒ…èŠ‚ç‰‡æ®µ"
    
    def __init__(self):
        from langchain_community.vectorstores import Milvus
        from langchain_openai import OpenAIEmbeddings
        
        self.vectorstore = Milvus(
            embedding_function=OpenAIEmbeddings(),
            connection_args={"host": "milvus", "port": "19530"}
        )
    
    def _run(self, query: str, **kwargs) -> list[str]:
        docs = self.vectorstore.similarity_search(query, k=5)
        return [doc.page_content for doc in docs]


# ====== 3. å®šä¹‰å›¾èŠ‚ç‚¹ ======

def understand_node(state: AgentState) -> AgentState:
    """ç†è§£ä»»åŠ¡èŠ‚ç‚¹"""
    llm = ChatOpenAI(model="gpt-4", temperature=0)
    
    prompt = f"""
    åˆ†æä»¥ä¸‹åˆ›ä½œä»»åŠ¡ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š
    ä»»åŠ¡ï¼š{state['task_description']}
    
    è¯·è¯†åˆ«ï¼š
    1. ä»»åŠ¡ç±»å‹ï¼ˆè§’è‰²åˆ›å»º/æƒ…èŠ‚è§„åˆ’/å†…å®¹ç”Ÿæˆç­‰ï¼‰
    2. å…³é”®è¦ç´ 
    3. æ‰€éœ€å·¥å…·
    """
    
    response = llm.invoke([HumanMessage(content=prompt)])
    
    state['messages'].append(HumanMessage(content=prompt))
    state['messages'].append(response)
    state['reasoning'].append(f"ä»»åŠ¡ç†è§£ï¼š{response.content}")
    
    return state


def plan_node(state: AgentState) -> AgentState:
    """è§„åˆ’èŠ‚ç‚¹"""
    llm = ChatOpenAI(model="gpt-4", temperature=0)
    
    prompt = f"""
    åŸºäºä»»åŠ¡ç†è§£ï¼Œåˆ¶å®šè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼š
    ä»»åŠ¡ï¼š{state['task_description']}
    ç†è§£ç»“æœï¼š{state['messages'][-1].content}
    
    è¯·è¾“å‡ºJSONæ ¼å¼çš„æ­¥éª¤åˆ—è¡¨ï¼š
    [
        {{"step": 1, "action": "rag_retrieve", "params": {{"query": "..."}} }},
        {{"step": 2, "action": "character_create", "params": {{...}} }}
    ]
    """
    
    response = llm.invoke([HumanMessage(content=prompt)])
    
    # è§£æè®¡åˆ’ï¼ˆç®€åŒ–å¤„ç†ï¼‰
    import json
    plan = json.loads(response.content)
    
    state['plan'] = plan
    state['current_step'] = 0
    state['reasoning'].append(f"åˆ¶å®šè®¡åˆ’ï¼š{len(plan)}ä¸ªæ­¥éª¤")
    
    return state


def execute_node(state: AgentState) -> AgentState:
    """æ‰§è¡ŒèŠ‚ç‚¹ï¼ˆè°ƒç”¨å·¥å…·ï¼‰"""
    current_plan = state['plan'][state['current_step']]
    action = current_plan['action']
    params = current_plan['params']
    
    # æ„å»ºå·¥å…·è°ƒç”¨æ¶ˆæ¯
    tool_call_msg = AIMessage(
        content="",
        additional_kwargs={
            "tool_calls": [{
                "id": f"call_{state['current_step']}",
                "function": {"name": action, "arguments": json.dumps(params)},
                "type": "function"
            }]
        }
    )
    
    state['messages'].append(tool_call_msg)
    return state


def review_node(state: AgentState) -> AgentState:
    """å®¡æ ¸èŠ‚ç‚¹"""
    llm = ChatOpenAI(model="gpt-4", temperature=0)
    
    prompt = f"""
    å®¡æ ¸ç”Ÿæˆçš„å†…å®¹ï¼š
    {state['generated_content']}
    
    æ£€æŸ¥ï¼š
    1. é€»è¾‘ä¸€è‡´æ€§
    2. æ–‡é£ç»Ÿä¸€æ€§
    3. äººç‰©æ€§æ ¼ç¬¦åˆè®¾å®š
    4. æƒ…èŠ‚åˆç†æ€§
    
    è¾“å‡ºJSONï¼š{{"passed": true/false, "issues": [...], "suggestions": [...]}}
    """
    
    response = llm.invoke([HumanMessage(content=prompt)])
    review_result = json.loads(response.content)
    
    state['review_result'] = review_result
    state['review_passed'] = review_result['passed']
    state['reasoning'].append(f"å®¡æ ¸ç»“æœï¼š{'é€šè¿‡' if review_result['passed'] else 'æœªé€šè¿‡'}")
    
    return state


def regenerate_node(state: AgentState) -> AgentState:
    """é‡æ–°ç”ŸæˆèŠ‚ç‚¹"""
    llm = ChatOpenAI(model="gpt-4", temperature=0.7)
    
    prompt = f"""
    æ ¹æ®å®¡æ ¸åé¦ˆé‡æ–°ç”Ÿæˆå†…å®¹ï¼š
    åŸå†…å®¹ï¼š{state['generated_content']}
    é—®é¢˜ï¼š{state['review_result']['issues']}
    å»ºè®®ï¼š{state['review_result']['suggestions']}
    
    è¯·æ”¹è¿›åé‡æ–°ç”Ÿæˆã€‚
    """
    
    response = llm.invoke([HumanMessage(content=prompt)])
    
    state['generated_content'] = response.content
    state['retry_count'] += 1
    state['reasoning'].append(f"ç¬¬{state['retry_count']}æ¬¡é‡æ–°ç”Ÿæˆ")
    
    return state


def finalize_node(state: AgentState) -> AgentState:
    """æœ€ç»ˆåŒ–èŠ‚ç‚¹"""
    state['final_output'] = state['generated_content']
    state['reasoning'].append("å·¥ä½œæµå®Œæˆ")
    return state


# ====== 4. å®šä¹‰æ¡ä»¶è·¯ç”± ======

def should_continue(state: AgentState) -> str:
    """å†³å®šæ˜¯å¦ç»§ç»­æ‰§è¡Œæ­¥éª¤"""
    if state['current_step'] < len(state['plan']) - 1:
        state['current_step'] += 1
        return "continue"
    else:
        return "review"


def should_regenerate(state: AgentState) -> str:
    """å†³å®šæ˜¯å¦éœ€è¦é‡æ–°ç”Ÿæˆ"""
    if state['review_passed']:
        return "finalize"
    elif state['retry_count'] < 3:
        return "regenerate"
    else:
        # è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå¼ºåˆ¶ç»“æŸ
        return "finalize"


# ====== 5. æ„å»ºStateGraph ======

# åˆå§‹åŒ–å·¥å…·
tools = [
    CharacterCreateTool(),
    RAGRetrievalTool(),
    # ... æ›´å¤šå·¥å…·
]

# åˆ›å»ºå·¥å…·èŠ‚ç‚¹ï¼ˆLangGraphå†…ç½®ï¼‰
tool_node = ToolNode(tools)

# æ„å»ºå›¾
workflow = StateGraph(AgentState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("understand", understand_node)
workflow.add_node("plan", plan_node)
workflow.add_node("execute", execute_node)
workflow.add_node("tools", tool_node)  # å·¥å…·æ‰§è¡ŒèŠ‚ç‚¹
workflow.add_node("review", review_node)
workflow.add_node("regenerate", regenerate_node)
workflow.add_node("finalize", finalize_node)

# å®šä¹‰è¾¹
workflow.set_entry_point("understand")
workflow.add_edge("understand", "plan")
workflow.add_edge("plan", "execute")
workflow.add_edge("execute", "tools")  # æ‰§è¡Œåè°ƒç”¨å·¥å…·
workflow.add_conditional_edges(
    "tools",
    should_continue,
    {
        "continue": "execute",  # ç»§ç»­ä¸‹ä¸€æ­¥
        "review": "review"      # è¿›å…¥å®¡æ ¸
    }
)
workflow.add_conditional_edges(
    "review",
    should_regenerate,
    {
        "regenerate": "regenerate",
        "finalize": "finalize"
    }
)
workflow.add_edge("regenerate", "review")  # é‡æ–°ç”Ÿæˆåå†æ¬¡å®¡æ ¸
workflow.add_edge("finalize", END)

# æ·»åŠ æŒä¹…åŒ–ï¼ˆå¯é€‰ï¼‰
checkpointer = PostgresSaver.from_conn_string("postgresql://user:pass@localhost/db")
app = workflow.compile(checkpointer=checkpointer)


# ====== 6. ä½¿ç”¨ç¤ºä¾‹ ======

async def create_character_workflow():
    """å®Œæ•´çš„åˆ›ä½œå·¥ä½œæµ"""
    
    initial_state = {
        "task_description": "åˆ›å»ºä¸€ä¸ªæ­¦ä¾ å°è¯´ä¸­çš„ä¸»è§’ï¼Œåå«'æ—é£'ï¼Œæ€§æ ¼å†·é™ä½†å†…å¿ƒç‚½çƒ­",
        "user_id": "user123",
        "project_id": "proj456",
        "messages": [],
        "plan": [],
        "current_step": 0,
        "generated_content": "",
        "tool_calls": [],
        "review_result": {},
        "review_passed": False,
        "retry_count": 0,
        "final_output": "",
        "reasoning": []
    }
    
    # æ‰§è¡Œå·¥ä½œæµ
    result = await app.ainvoke(
        initial_state,
        config={"configurable": {"thread_id": "thread_001"}}  # æ”¯æŒå¤šè½®å¯¹è¯
    )
    
    print("=== å·¥ä½œæµæ‰§è¡Œç»“æœ ===")
    print(f"æœ€ç»ˆè¾“å‡ºï¼š{result['final_output']}")
    print(f"æ¨ç†è¿‡ç¨‹ï¼š{result['reasoning']}")
    print(f"å·¥å…·è°ƒç”¨ï¼š{result['tool_calls']}")
    
    return result


# ====== 7. å¯è§†åŒ–å·¥ä½œæµï¼ˆè°ƒè¯•ï¼‰ ======

from IPython.display import Image, display

# ç”Ÿæˆå·¥ä½œæµå›¾
display(Image(app.get_graph().draw_mermaid_png()))
```

### A.2 LangGraphæ ¸å¿ƒä¼˜åŠ¿ä½“ç°

| åŠŸèƒ½éœ€æ±‚ | LangChainå®ç° | LangGraphå®ç° | ä¼˜åŠ¿ |
|---------|--------------|--------------|------|
| **å¤æ‚æµç¨‹ç¼–æ’** | æ‰‹åŠ¨if-else | StateGraph + æ¡ä»¶è¾¹ | âœ… å£°æ˜å¼ï¼Œæ˜“ç»´æŠ¤ |
| **å¾ªç¯é‡è¯•** | whileå¾ªç¯ | è¾¹æŒ‡å‘è‡ªèº« | âœ… å¯è§†åŒ–ï¼Œå¯è°ƒè¯• |
| **çŠ¶æ€ç®¡ç†** | å…¨å±€å˜é‡/ç±»å±æ€§ | TypedDict State | âœ… ç±»å‹å®‰å…¨ï¼Œå¯æŒä¹…åŒ– |
| **å·¥å…·è°ƒç”¨** | æ‰‹åŠ¨è°ƒç”¨ | ToolNode | âœ… è‡ªåŠ¨è§£æï¼Œæ”¯æŒå¹¶è¡Œ |
| **RAGé›†æˆ** | æ‰‹åŠ¨æ£€ç´¢ | ç»§æ‰¿LangChain RAG | âœ… æ— ç¼é›†æˆ |
| **ä¸­æ–­æ¢å¤** | ä¸æ”¯æŒ | Checkpointer | âœ… æ”¯æŒäººå·¥ä»‹å…¥ |
| **å¤šAgentåä½œ** | å¤æ‚åè°ƒ | å­å›¾åµŒå¥— | âœ… æ¸…æ™°çš„å±‚æ¬¡ç»“æ„ |

### A.3 ä¸å…¶ä»–æ¡†æ¶å¯¹æ¯”ï¼ˆå®æˆ˜è§†è§’ï¼‰

**ä¸ºä»€ä¹ˆä¸é€‰AutoGenï¼Ÿ**
- AutoGenæ“…é•¿å¤šAgentå¯¹è¯ï¼Œä½†**æµç¨‹æ§åˆ¶å¼±**ï¼ˆæ— å›¾çŠ¶å·¥ä½œæµï¼‰
- é’ç¾½éœ€è¦**ç²¾ç¡®çš„æ­¥éª¤æ§åˆ¶**ï¼ˆç†è§£â†’è§„åˆ’â†’æ‰§è¡Œâ†’å®¡æ ¸ï¼‰ï¼ŒAutoGenåšä¸åˆ°

**ä¸ºä»€ä¹ˆä¸é€‰CrewAIï¼Ÿ**
- CrewAIæ˜¯é«˜çº§æŠ½è±¡ï¼ˆç±»ä¼¼Djangoï¼‰ï¼Œä½†**çµæ´»æ€§å·®**
- é’ç¾½éœ€è¦**å®šåˆ¶åŒ–æµç¨‹**ï¼ˆå¦‚å®¡æ ¸å¾ªç¯ï¼‰ï¼ŒCrewAIå¤ªå›ºå®š

**ä¸ºä»€ä¹ˆä¸é€‰MetaGPTï¼Ÿ**
- MetaGPTä¸“æ³¨è½¯ä»¶å¼€å‘ï¼Œ**ä¸é€‚åˆåˆ›ä½œåœºæ™¯**
- ç¼ºå°‘RAGæ”¯æŒ

**LangGraphçš„ç‹¬ç‰¹ä»·å€¼**ï¼š
1. **å›¾ + LangChainç”Ÿæ€** = æ—¢æœ‰æ§åˆ¶åŠ›åˆæœ‰å·¥å…·ä¸°å¯Œåº¦
2. **çŠ¶æ€æŒä¹…åŒ–** = é•¿æµç¨‹å¯ä¸­æ–­æ¢å¤
3. **å¯è§†åŒ–è°ƒè¯•** = å¤æ‚æµç¨‹ä¸€ç›®äº†ç„¶

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1 ğŸ”¥ **å·²æ›´æ–°ä¸ºLangGraph**  
**åˆ›å»ºæ—¶é—´**: 2025-10-21  
**æ›´æ–°æ—¶é—´**: 2025-10-21  
**è´Ÿè´£äºº**: AIå›¢é˜Ÿ  
**å®¡æ ¸çŠ¶æ€**: å¾…è¯„å®¡

