# Python AI Agent系统架构设计

> **文档版本**: v1.0  
> **创建时间**: 2025-10-21  
> **实施状态**: 设计阶段

## 📋 文档概述

本文档详细设计青羽平台的Python AI Agent系统，包括Agent框架、工具调用系统、RAG检索增强、多Agent协作和记忆系统。这是青羽平台AI能力的核心创新，能够实现从"文本生成"到"操作执行"的跨越。

## 🎯 设计目标

1. **工具调用能力**：Agent能够直接调用写作端的各种工具（大纲、角色卡、关系图谱等）
2. **RAG增强**：基于用户私有知识库的智能检索增强生成
3. **多Agent协作**：不同专业Agent协同完成复杂任务
4. **记忆系统**：短期、长期和工作记忆的有机结合
5. **高性能**：支持流式响应，降低用户感知延迟

---

## 一、整体架构设计

### 1.1 系统架构图

```
┌────────────────────────────────────────────────────────────────┐
│                    Python AI Agent Service                     │
│                      (FastAPI服务)                              │
│                                                                  │
│  ┌────────────────────────────────────────────────────────┐   │
│  │              gRPC/HTTP Server Layer                    │   │
│  │  - gRPC Servicer (主要)                                │   │
│  │  - FastAPI Endpoints (备用)                            │   │
│  │  - 请求验证                                             │   │
│  │  - 错误处理                                             │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │           Agent Orchestrator (Agent编排器)            │   │
│  │  - Agent路由（根据任务类型选择Agent）                  │   │
│  │  - 多Agent编排（协同执行）                             │   │
│  │  - 任务分解                                            │   │
│  │  - 结果汇总                                            │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │              Agent Engine Layer                        │   │
│  │                                                          │   │
│  │  ┌──────────────┬──────────────┬──────────────┐        │   │
│  │  │ Creative     │ Analysis     │ Review       │        │   │
│  │  │ Agent        │ Agent        │ Agent        │        │   │
│  │  │              │              │              │        │   │
│  │  │ 创作辅助     │ 文本分析     │ 内容审核     │        │   │
│  │  └──────────────┴──────────────┴──────────────┘        │   │
│  │  ┌──────────────┬──────────────────────────────┐       │   │
│  │  │ Assistant    │ Data Analysis │ ... (可扩展)  │       │   │
│  │  │ Agent        │ Agent         │              │       │   │
│  │  │              │               │              │       │   │
│  │  │ 通用助手     │ 数据统计      │              │       │   │
│  │  └──────────────┴──────────────┴──────────────┘        │   │
│  │                                                          │   │
│  │  每个Agent包含：                                        │   │
│  │  - 任务理解模块                                         │   │
│  │  - 步骤规划模块                                         │   │
│  │  - 执行编排模块                                         │   │
│  │  - 结果汇总模块                                         │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │         Tool Calling System (核心创新)                 │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │          Tool Registry (工具注册中心)          │    │   │
│  │  │  - 工具发现                                     │    │   │
│  │  │  - 工具元数据管理                               │    │   │
│  │  │  - 权限配置                                     │    │   │
│  │  │  - 版本管理                                     │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │        Writing Tools (写作工具集成)            │    │   │
│  │  │                                                  │    │   │
│  │  │  大纲工具 | 角色卡工具 | 关系图谱工具          │    │   │
│  │  │  时间线工具 | 世界观工具 | 设定百科工具        │    │   │
│  │  │  文档操作工具 | 数据统计工具                    │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │      Tool Execution Engine (执行引擎)          │    │   │
│  │  │  - 参数验证                                     │    │   │
│  │  │  - 调用Go API（HTTP回调）                       │    │   │
│  │  │  - 结果解析                                     │    │   │
│  │  │  - 错误处理与重试                               │    │   │
│  │  │  - 执行监控                                     │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │           RAG Retrieval Engine                         │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │      Vectorization Module (向量化模块)         │    │   │
│  │  │  - 文本预处理                                   │    │   │
│  │  │  - Chunk Splitting                              │    │   │
│  │  │  - Embedding (BGE/M3E/OpenAI)                   │    │   │
│  │  │  - 批量向量化                                   │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │      Vector Search Module (向量检索模块)       │    │   │
│  │  │  - Semantic Search (语义检索)                   │    │   │
│  │  │  - Keyword Search (BM25)                        │    │   │
│  │  │  - Hybrid Search (混合检索)                     │    │   │
│  │  │  - Rerank (重排序)                              │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────┐    │   │
│  │  │      RAG Workflow Engine (RAG工作流引擎)       │    │   │
│  │  │  - 查询理解                                     │    │   │
│  │  │  - 多源检索                                     │    │   │
│  │  │  - 上下文构建                                   │    │   │
│  │  │  - Prompt增强                                   │    │   │
│  │  └────────────────────────────────────────────────┘    │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │            Memory System (记忆系统)                     │   │
│  │                                                          │   │
│  │  短期记忆(Redis) | 长期记忆(MongoDB) | 工作记忆(Cache)  │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                       │
│  ┌──────────────────────▼─────────────────────────────────┐   │
│  │         External Services Integration                  │   │
│  │                                                          │   │
│  │  ┌──────────┬──────────┬──────────────┬──────────┐     │   │
│  │  │ OpenAI   │ Claude   │ Local LLM    │ Go APIs  │     │   │
│  │  └──────────┴──────────┴──────────────┴──────────┘     │   │
│  │  ┌──────────┬──────────┬──────────────┐               │   │
│  │  │ Milvus   │ Qdrant   │ MongoDB      │               │   │
│  │  └──────────┴──────────┴──────────────┘               │   │
│  └──────────────────────────────────────────────────────┘   │
└────────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选型

| 组件 | 技术选型 | 理由 |
|------|---------|------|
| **Web框架** | FastAPI | 高性能异步框架，原生支持gRPC |
| **LLM集成** | LangChain | 丰富的LLM抽象和工具生态 |
| **向量化** | sentence-transformers | 支持多种中文向量模型 |
| **向量数据库** | Milvus/Qdrant | 高性能向量检索 |
| **异步框架** | asyncio | Python原生异步支持 |
| **序列化** | Pydantic | 类型安全，数据验证 |
| **日志** | structlog | 结构化日志 |
| **监控** | prometheus-client | Prometheus集成 |

---

## 二、Agent框架设计

### 2.1 BaseAgent抽象类

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
import asyncio

class Task(BaseModel):
    """任务定义"""
    task_id: str
    description: str
    context: Dict[str, Any]
    priority: int = 0
    timeout: int = 300  # 超时时间（秒）

class ToolCall(BaseModel):
    """工具调用记录"""
    tool_name: str
    parameters: Dict[str, Any]
    result: Any
    duration_ms: int
    success: bool
    error: Optional[str] = None

class AgentResult(BaseModel):
    """Agent执行结果"""
    task_id: str
    output: str
    tool_calls: List[ToolCall] = []
    reasoning: List[str] = []  # 推理过程
    confidence: float = 0.0
    metadata: Dict[str, Any] = {}

class BaseAgent(ABC):
    """Agent基类"""
    
    def __init__(
        self,
        name: str,
        llm_client,  # LLM客户端
        tool_registry,  # 工具注册中心
        memory_system,  # 记忆系统
        config: Dict[str, Any] = None
    ):
        self.name = name
        self.llm_client = llm_client
        self.tool_registry = tool_registry
        self.memory_system = memory_system
        self.config = config or {}
        self.tools: List[Tool] = []
        
    def register_tool(self, tool: 'Tool'):
        """注册工具"""
        self.tools.append(tool)
        
    async def execute(self, task: Task) -> AgentResult:
        """执行任务（模板方法）"""
        # 1. 理解任务
        understanding = await self.understand_task(task)
        
        # 2. 规划步骤
        plan = await self.plan_steps(understanding)
        
        # 3. 执行计划
        results = []
        tool_calls = []
        
        for step in plan:
            result = await self.execute_step(step)
            results.append(result)
            
            if result.get('need_tool'):
                tool_result = await self.call_tool(
                    result['tool_name'],
                    result['tool_params']
                )
                tool_calls.append(tool_result)
                results[-1]['tool_result'] = tool_result
        
        # 4. 汇总结果
        final_result = await self.summarize_results(results)
        
        return AgentResult(
            task_id=task.task_id,
            output=final_result,
            tool_calls=tool_calls,
            reasoning=self._extract_reasoning(results)
        )
    
    @abstractmethod
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """理解任务（子类实现）"""
        pass
    
    @abstractmethod
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """规划执行步骤（子类实现）"""
        pass
    
    async def execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """执行单个步骤"""
        # 基础实现，子类可以覆盖
        prompt = self._build_prompt(step)
        response = await self.llm_client.generate(prompt)
        
        # 判断是否需要调用工具
        need_tool = self._detect_tool_call(response)
        
        return {
            'step_output': response,
            'need_tool': need_tool,
            'tool_name': need_tool and self._extract_tool_name(response),
            'tool_params': need_tool and self._extract_tool_params(response)
        }
    
    async def call_tool(self, tool_name: str, params: Dict[str, Any]) -> ToolCall:
        """调用工具"""
        import time
        start_time = time.time()
        
        try:
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.execute(params)
            
            return ToolCall(
                tool_name=tool_name,
                parameters=params,
                result=result,
                duration_ms=int((time.time() - start_time) * 1000),
                success=True
            )
        except Exception as e:
            return ToolCall(
                tool_name=tool_name,
                parameters=params,
                result=None,
                duration_ms=int((time.time() - start_time) * 1000),
                success=False,
                error=str(e)
            )
    
    @abstractmethod
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """汇总结果（子类实现）"""
        pass
    
    def _build_prompt(self, step: Dict[str, Any]) -> str:
        """构建Prompt"""
        # TODO: 实现Prompt模板
        pass
    
    def _detect_tool_call(self, response: str) -> bool:
        """检测响应中是否需要调用工具"""
        # TODO: 实现工具调用检测逻辑
        pass
    
    def _extract_tool_name(self, response: str) -> str:
        """从响应中提取工具名称"""
        # TODO: 实现提取逻辑
        pass
    
    def _extract_tool_params(self, response: str) -> Dict[str, Any]:
        """从响应中提取工具参数"""
        # TODO: 实现提取逻辑
        pass
    
    def _extract_reasoning(self, results: List[Dict[str, Any]]) -> List[str]:
        """提取推理过程"""
        return [r.get('reasoning', '') for r in results if r.get('reasoning')]
```

### 2.2 专业Agent实现

#### Creative Agent (创作Agent)

```python
class CreativeAgent(BaseAgent):
    """创作助手Agent
    
    专长：
    - 情节续写
    - 对话生成
    - 场景描写
    - 角色塑造
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(name="CreativeAgent", *args, **kwargs)
        
        # 注册专用工具
        self.register_tool(OutlineTool())
        self.register_tool(CharacterTool())
        self.register_tool(RelationshipTool())
        self.register_tool(TimelineTool())
        self.register_tool(WorldviewTool())
        self.register_tool(DocumentTool())
        
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """理解创作任务"""
        # 提取任务类型
        task_type = self._classify_creative_task(task.description)
        
        # 从上下文中提取关键信息
        characters = task.context.get('characters', [])
        setting = task.context.get('setting', {})
        previous_content = task.context.get('previous_content', '')
        
        return {
            'type': task_type,  # 'continue', 'dialogue', 'scene', 'character'
            'characters': characters,
            'setting': setting,
            'previous_content': previous_content,
            'requirements': task.context.get('requirements', {})
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """规划创作步骤"""
        task_type = understanding['type']
        
        if task_type == 'continue':
            # 续写任务
            return [
                {
                    'action': 'retrieve_context',
                    'description': '检索相关角色和设定',
                    'tools': ['character', 'worldview', 'timeline']
                },
                {
                    'action': 'generate_plot',
                    'description': '生成情节发展'
                },
                {
                    'action': 'write_content',
                    'description': '撰写具体内容'
                },
                {
                    'action': 'consistency_check',
                    'description': '一致性检查',
                    'tools': ['timeline', 'character']
                }
            ]
        elif task_type == 'dialogue':
            # 对话生成
            return [
                {
                    'action': 'retrieve_characters',
                    'description': '获取角色信息',
                    'tools': ['character']
                },
                {
                    'action': 'analyze_relationship',
                    'description': '分析角色关系',
                    'tools': ['relationship']
                },
                {
                    'action': 'generate_dialogue',
                    'description': '生成对话内容'
                }
            ]
        # ... 其他任务类型
        
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """汇总创作结果"""
        # 提取所有生成的内容
        generated_content = []
        for result in results:
            if result.get('step_output'):
                generated_content.append(result['step_output'])
        
        # 合并并润色
        combined = '\n\n'.join(generated_content)
        
        # 可选：调用LLM进行最后的润色
        polished = await self.llm_client.generate(
            f"请对以下内容进行润色，使其更加流畅：\n\n{combined}"
        )
        
        return polished
    
    def _classify_creative_task(self, description: str) -> str:
        """分类创作任务类型"""
        if '续写' in description or '继续' in description:
            return 'continue'
        elif '对话' in description or '台词' in description:
            return 'dialogue'
        elif '场景' in description or '描写' in description:
            return 'scene'
        elif '角色' in description or '人物' in description:
            return 'character'
        else:
            return 'general'
```

#### Analysis Agent (分析Agent)

```python
class AnalysisAgent(BaseAgent):
    """分析助手Agent
    
    专长：
    - 文本分析
    - 情感分析
    - 节奏分析
    - 质量评估
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        """理解分析任务"""
        return {
            'type': self._classify_analysis_task(task.description),
            'target_content': task.context.get('content', ''),
            'analysis_aspects': task.context.get('aspects', [])
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """规划分析步骤"""
        task_type = understanding['type']
        
        if task_type == 'comprehensive':
            return [
                {'action': 'style_analysis', 'description': '文风分析'},
                {'action': 'emotion_analysis', 'description': '情感分析'},
                {'action': 'pace_analysis', 'description': '节奏分析'},
                {'action': 'quality_assessment', 'description': '质量评估'},
                {'action': 'generate_report', 'description': '生成分析报告'}
            ]
        # ... 其他类型
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """汇总分析结果"""
        # 生成结构化分析报告
        report = {
            'style': results[0].get('step_output'),
            'emotion': results[1].get('step_output'),
            'pace': results[2].get('step_output'),
            'quality': results[3].get('step_output')
        }
        
        # 生成可读性报告
        formatted_report = self._format_analysis_report(report)
        return formatted_report
    
    def _classify_analysis_task(self, description: str) -> str:
        if '综合' in description or '全面' in description:
            return 'comprehensive'
        elif '文风' in description or '风格' in description:
            return 'style'
        elif '情感' in description:
            return 'emotion'
        else:
            return 'general'
    
    def _format_analysis_report(self, report: Dict[str, Any]) -> str:
        """格式化分析报告"""
        return f"""
# 文本分析报告

## 文风分析
{report['style']}

## 情感分析
{report['emotion']}

## 节奏分析
{report['pace']}

## 质量评估
{report['quality']}

## 综合建议
...
"""
```

#### Review Agent (审核Agent)

```python
class ReviewAgent(BaseAgent):
    """审核助手Agent
    
    专长：
    - 内容审核
    - 合规检查
    - 原创度检测
    - 敏感词检测
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        return {
            'type': 'review',
            'content': task.context.get('content', ''),
            'review_level': task.context.get('level', 'standard')
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        return [
            {'action': 'sensitive_word_check', 'description': '敏感词检测'},
            {'action': 'originality_check', 'description': '原创度检测'},
            {'action': 'compliance_check', 'description': '合规性检查'},
            {'action': 'generate_review_report', 'description': '生成审核报告'}
        ]
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        """生成审核报告"""
        return f"""
# 内容审核报告

## 敏感词检测
{results[0].get('step_output')}

## 原创度检测
{results[1].get('step_output')}

## 合规性检查
{results[2].get('step_output')}

## 审核结论
...
"""
```

#### Assistant Agent (通用助手Agent)

```python
class AssistantAgent(BaseAgent):
    """通用助手Agent
    
    专长：
    - 问答
    - 设定查询
    - 操作指导
    - 通用任务
    """
    
    async def understand_task(self, task: Task) -> Dict[str, Any]:
        return {
            'type': self._classify_query_type(task.description),
            'query': task.description,
            'context': task.context
        }
    
    async def plan_steps(self, understanding: Dict[str, Any]) -> List[Dict[str, Any]]:
        query_type = understanding['type']
        
        if query_type == 'setting_query':
            # 设定查询
            return [
                {'action': 'search_knowledge', 'description': 'RAG检索'},
                {'action': 'generate_answer', 'description': '生成回答'}
            ]
        elif query_type == 'general_qa':
            # 通用问答
            return [
                {'action': 'understand_question', 'description': '理解问题'},
                {'action': 'generate_answer', 'description': '生成回答'}
            ]
        # ... 其他类型
    
    async def summarize_results(self, results: List[Dict[str, Any]]) -> str:
        return results[-1].get('step_output', '')
    
    def _classify_query_type(self, query: str) -> str:
        if '设定' in query or '世界观' in query:
            return 'setting_query'
        else:
            return 'general_qa'
```

---

## 三、工具调用系统设计

### 3.1 Tool基类

```python
from abc import ABC, abstractmethod
from pydantic import BaseModel
from typing import Any, Dict

class ToolMetadata(BaseModel):
    """工具元数据"""
    name: str
    description: str
    parameters_schema: Dict[str, Any]  # JSON Schema
    category: str  # 'writing', 'analysis', 'admin'
    requires_auth: bool = True
    version: str = "1.0.0"

class Tool(ABC):
    """工具基类"""
    
    def __init__(self, metadata: ToolMetadata, go_api_client):
        self.metadata = metadata
        self.go_api_client = go_api_client
    
    def validate_parameters(self, params: Dict[str, Any]) -> bool:
        """验证参数"""
        # 使用JSON Schema验证
        from jsonschema import validate, ValidationError
        try:
            validate(instance=params, schema=self.metadata.parameters_schema)
            return True
        except ValidationError:
            return False
    
    @abstractmethod
    async def execute(self, params: Dict[str, Any]) -> Any:
        """执行工具（子类实现）"""
        pass
    
    def get_description(self) -> str:
        """获取工具描述（用于LLM Prompt）"""
        return f"""
工具名称: {self.metadata.name}
功能描述: {self.metadata.description}
参数格式: {self.metadata.parameters_schema}
"""
```

### 3.2 写作工具实现

#### 大纲工具

```python
class OutlineTool(Tool):
    """大纲工具"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="outline_tool",
            description="创建和管理小说大纲，支持自动生成大纲、章节规划、情节发展建议",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get", "generate_auto"]
                    },
                    "project_id": {"type": "string"},
                    "outline_data": {"type": "object"},
                    "structure_type": {
                        "type": "string",
                        "enum": ["three_act", "hero_journey", "custom"],
                        "description": "大纲结构类型：三幕式、英雄之旅、自定义"
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        """执行大纲操作"""
        if not self.validate_parameters(params):
            raise ValueError("参数验证失败")
        
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            # 调用Go API创建大纲
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/outline",
                json=params.get('outline_data')
            )
            return response.json()
        
        elif action == 'generate_auto':
            # 自动生成大纲
            structure_type = params.get('structure_type', 'three_act')
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/outline/generate",
                json={'structure_type': structure_type}
            )
            return response.json()
        
        elif action == 'get':
            # 获取大纲
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/outline"
            )
            return response.json()
        
        # ... 其他操作
```

#### 角色卡工具

```python
class CharacterTool(Tool):
    """角色卡工具"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="character_tool",
            description="管理角色卡片，包括创建角色档案、角色发展弧线、角色冲突分析",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get", "list", "analyze_arc"]
                    },
                    "project_id": {"type": "string"},
                    "character_id": {"type": "string"},
                    "character_data": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "age": {"type": "integer"},
                            "personality": {"type": "string"},
                            "background": {"type": "string"},
                            "goals": {"type": "string"},
                            "conflicts": {"type": "string"}
                        }
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/characters",
                json=params.get('character_data')
            )
            return response.json()
        
        elif action == 'get':
            character_id = params.get('character_id')
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/characters/{character_id}"
            )
            return response.json()
        
        elif action == 'list':
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/characters"
            )
            return response.json()
        
        elif action == 'analyze_arc':
            # 分析角色发展弧线
            character_id = params.get('character_id')
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/characters/{character_id}/analyze-arc"
            )
            return response.json()
```

#### 关系图谱工具

```python
class RelationshipTool(Tool):
    """关系图谱工具"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="relationship_tool",
            description="管理角色关系网络，包括创建关系、关系演变追踪、冲突关系可视化",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create", "update", "get_graph", "analyze"]
                    },
                    "project_id": {"type": "string"},
                    "from_character": {"type": "string"},
                    "to_character": {"type": "string"},
                    "relationship_type": {
                        "type": "string",
                        "enum": ["friend", "enemy", "family", "lover", "rival"]
                    },
                    "strength": {"type": "number", "minimum": 0, "maximum": 1}
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/relationships",
                json={
                    'from': params['from_character'],
                    'to': params['to_character'],
                    'type': params['relationship_type'],
                    'strength': params.get('strength', 0.5)
                }
            )
            return response.json()
        
        elif action == 'get_graph':
            # 获取关系网络图
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/relationships/graph"
            )
            return response.json()
        
        elif action == 'analyze':
            # 分析关系网络（中心度、社区检测等）
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/relationships/analyze"
            )
            return response.json()
```

#### 时间线工具

```python
class TimelineTool(Tool):
    """时间线工具"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="timeline_tool",
            description="管理故事时间线，支持多线索并行、时间线冲突检测、事件添加查询",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["create_event", "get_timeline", "check_conflicts"]
                    },
                    "project_id": {"type": "string"},
                    "event_data": {
                        "type": "object",
                        "properties": {
                            "title": {"type": "string"},
                            "description": {"type": "string"},
                            "timestamp": {"type": "string"},
                            "participants": {"type": "array", "items": {"type": "string"}}
                        }
                    }
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'create_event':
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/timeline/events",
                json=params.get('event_data')
            )
            return response.json()
        
        elif action == 'get_timeline':
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/timeline"
            )
            return response.json()
        
        elif action == 'check_conflicts':
            # 检测时间线冲突
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/timeline/check-conflicts"
            )
            return response.json()
```

#### 文档操作工具

```python
class DocumentTool(Tool):
    """文档操作工具"""
    
    def __init__(self, go_api_client):
        metadata = ToolMetadata(
            name="document_tool",
            description="操作文档内容，包括读取、修改、版本管理、批量操作",
            parameters_schema={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": ["read", "write", "update", "list", "create_version"]
                    },
                    "project_id": {"type": "string"},
                    "document_id": {"type": "string"},
                    "content": {"type": "string"}
                },
                "required": ["action", "project_id"]
            },
            category="writing"
        )
        super().__init__(metadata, go_api_client)
    
    async def execute(self, params: Dict[str, Any]) -> Any:
        action = params['action']
        project_id = params['project_id']
        
        if action == 'read':
            document_id = params['document_id']
            response = await self.go_api_client.get(
                f"/api/v1/projects/{project_id}/documents/{document_id}"
            )
            return response.json()
        
        elif action == 'write':
            document_id = params['document_id']
            content = params['content']
            response = await self.go_api_client.put(
                f"/api/v1/projects/{project_id}/documents/{document_id}",
                json={'content': content}
            )
            return response.json()
        
        elif action == 'create_version':
            # 创建版本
            document_id = params['document_id']
            response = await self.go_api_client.post(
                f"/api/v1/projects/{project_id}/documents/{document_id}/versions"
            )
            return response.json()
```

### 3.3 工具注册中心

```python
class ToolRegistry:
    """工具注册中心"""
    
    def __init__(self, go_api_client):
        self.tools: Dict[str, Tool] = {}
        self.go_api_client = go_api_client
        self._init_default_tools()
    
    def _init_default_tools(self):
        """初始化默认工具"""
        self.register(OutlineTool(self.go_api_client))
        self.register(CharacterTool(self.go_api_client))
        self.register(RelationshipTool(self.go_api_client))
        self.register(TimelineTool(self.go_api_client))
        self.register(WorldviewTool(self.go_api_client))
        self.register(DocumentTool(self.go_api_client))
        # ... 注册其他工具
    
    def register(self, tool: Tool):
        """注册工具"""
        self.tools[tool.metadata.name] = tool
    
    def get_tool(self, name: str) -> Tool:
        """获取工具"""
        if name not in self.tools:
            raise ValueError(f"工具 {name} 不存在")
        return self.tools[name]
    
    def list_tools(self, category: str = None) -> List[ToolMetadata]:
        """列出所有工具"""
        tools = self.tools.values()
        if category:
            tools = [t for t in tools if t.metadata.category == category]
        return [t.metadata for t in tools]
    
    def get_tools_description_for_llm(self) -> str:
        """获取工具描述（用于LLM Prompt）"""
        descriptions = []
        for tool in self.tools.values():
            descriptions.append(tool.get_description())
        return "\n\n".join(descriptions)
```

---

## 四、多Agent协作机制

### 4.1 Agent编排器

```python
class AgentOrchestrator:
    """Agent编排器"""
    
    def __init__(self, agents: Dict[str, BaseAgent]):
        self.agents = agents
    
    async def route_task(self, task: Task) -> BaseAgent:
        """路由任务到合适的Agent"""
        # 简单实现：基于关键词匹配
        description = task.description.lower()
        
        if '续写' in description or '创作' in description:
            return self.agents['creative']
        elif '分析' in description:
            return self.agents['analysis']
        elif '审核' in description:
            return self.agents['review']
        else:
            return self.agents['assistant']
    
    async def execute_task(self, task: Task) -> AgentResult:
        """执行单个任务"""
        agent = await self.route_task(task)
        return await agent.execute(task)
    
    async def execute_multi_agent_task(
        self,
        task: Task,
        agent_sequence: List[str]
    ) -> List[AgentResult]:
        """多Agent协同执行任务"""
        results = []
        context = task.context.copy()
        
        for agent_name in agent_sequence:
            agent = self.agents[agent_name]
            
            # 将前一个Agent的结果加入context
            sub_task = Task(
                task_id=f"{task.task_id}-{agent_name}",
                description=task.description,
                context=context
            )
            
            result = await agent.execute(sub_task)
            results.append(result)
            
            # 更新context
            context[f'{agent_name}_result'] = result.output
        
        return results
```

### 4.2 使用示例

```python
# 场景：创建小说框架
async def create_novel_framework(user_input: str, project_id: str):
    """
    用户: "我想写一部修仙小说，主角叫林风"
    
    Agent自动执行：
    1. CreativeAgent → 生成大纲
    2. CreativeAgent → 创建角色卡
    3. CreativeAgent → 生成关系图谱
    4. CreativeAgent → 构建世界观
    5. CreativeAgent → 创建时间线
    6. AssistantAgent → 归档到设定百科
    """
    
    task = Task(
        task_id="create-framework-001",
        description=user_input,
        context={'project_id': project_id}
    )
    
    orchestrator = AgentOrchestrator({
        'creative': CreativeAgent(...),
        'assistant': AssistantAgent(...)
    })
    
    # 多Agent协同执行
    results = await orchestrator.execute_multi_agent_task(
        task,
        agent_sequence=['creative', 'creative', 'creative', 'assistant']
    )
    
    return {
        'framework_created': True,
        'outline': results[0].output,
        'characters': results[1].output,
        'worldview': results[2].output,
        'archived': results[3].output
    }
```

---

## 五、记忆系统设计

### 5.1 短期记忆（Redis）

```python
class ShortTermMemory:
    """短期记忆（会话级别）"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.ttl = 3600  # 1小时过期
    
    async def store(self, session_id: str, key: str, value: Any):
        """存储记忆"""
        memory_key = f"memory:short:{session_id}:{key}"
        await self.redis.set(memory_key, json.dumps(value), ex=self.ttl)
    
    async def retrieve(self, session_id: str, key: str) -> Any:
        """检索记忆"""
        memory_key = f"memory:short:{session_id}:{key}"
        data = await self.redis.get(memory_key)
        return json.loads(data) if data else None
    
    async def clear_session(self, session_id: str):
        """清除会话记忆"""
        pattern = f"memory:short:{session_id}:*"
        keys = await self.redis.keys(pattern)
        if keys:
            await self.redis.delete(*keys)
```

### 5.2 长期记忆（MongoDB）

```python
class LongTermMemory:
    """长期记忆（持久化）"""
    
    def __init__(self, mongo_client):
        self.db = mongo_client.ai_memory
        self.collection = self.db.long_term_memory
    
    async def store(self, user_id: str, memory_type: str, content: Dict[str, Any]):
        """存储长期记忆"""
        document = {
            'user_id': user_id,
            'memory_type': memory_type,  # 'preference', 'history', 'knowledge'
            'content': content,
            'created_at': datetime.now(),
            'updated_at': datetime.now()
        }
        await self.collection.insert_one(document)
    
    async def retrieve(
        self,
        user_id: str,
        memory_type: str = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """检索长期记忆"""
        query = {'user_id': user_id}
        if memory_type:
            query['memory_type'] = memory_type
        
        cursor = self.collection.find(query).sort('created_at', -1).limit(limit)
        return await cursor.to_list(length=limit)
```

### 5.3 工作记忆（Context Window）

```python
class WorkingMemory:
    """工作记忆（当前任务上下文）"""
    
    def __init__(self, max_tokens: int = 8000):
        self.max_tokens = max_tokens
        self.context = []
    
    def add(self, item: Dict[str, Any]):
        """添加到工作记忆"""
        self.context.append(item)
        self._trim_to_limit()
    
    def get_context(self) -> List[Dict[str, Any]]:
        """获取当前上下文"""
        return self.context
    
    def clear(self):
        """清空工作记忆"""
        self.context = []
    
    def _trim_to_limit(self):
        """裁剪到Token限制"""
        # TODO: 实现Token计数和裁剪逻辑
        pass
```

---

## 六、实施建议

### 6.1 开发阶段

| 阶段 | 时间 | 任务 |
|------|------|------|
| **阶段1：框架搭建** | 1周 | FastAPI项目搭建、gRPC集成、基础Agent实现 |
| **阶段2：工具开发** | 2周 | 实现所有写作工具、工具注册中心 |
| **阶段3：RAG集成** | 1周 | 向量化引擎、向量数据库集成 |
| **阶段4：Agent完善** | 1周 | 专业Agent实现、多Agent协作 |
| **阶段5：测试优化** | 1周 | 单元测试、集成测试、性能优化 |

### 6.2 技术风险

| 风险 | 等级 | 应对措施 |
|------|------|---------|
| 工具调用延迟 | 中 | 异步调用、结果缓存、超时控制 |
| RAG准确性 | 中 | 多种检索策略、重排序、质量评估 |
| LLM成本 | 高 | 结果缓存、Prompt优化、本地模型备选 |
| 服务稳定性 | 高 | 容错机制、降级方案、监控告警 |

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21  
**负责人**: AI团队  
**审核状态**: 待评审

