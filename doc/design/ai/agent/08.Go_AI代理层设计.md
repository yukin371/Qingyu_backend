# Go AIä»£ç†å±‚è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-21  
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡Go AIä»£ç†å±‚çš„æ¶æ„ï¼Œä½œä¸ºGinåç«¯ä¸Python AI Agent Serviceä¹‹é—´çš„æ¡¥æ¢ï¼Œè´Ÿè´£è¯·æ±‚è½¬å‘ã€æµå¼å“åº”ä»£ç†ã€ç†”æ–­é™æµã€é”™è¯¯è½¬æ¢ç­‰å…³é”®åŠŸèƒ½ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **é«˜æ€§èƒ½ä»£ç†**ï¼šä½å»¶è¿Ÿçš„è¯·æ±‚è½¬å‘ï¼Œé«˜å¹¶å‘å¤„ç†èƒ½åŠ›
2. **æµå¼å“åº”**ï¼šSSE/WebSocketæµå¼å“åº”ä»£ç†ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
3. **æœåŠ¡ä¿æŠ¤**ï¼šç†”æ–­å™¨ã€é™æµå™¨ã€è¶…æ—¶æ§åˆ¶ï¼Œä¿æŠ¤PythonæœåŠ¡
4. **é”™è¯¯è½¬æ¢**ï¼šå°†Pythonå¼‚å¸¸è½¬æ¢ä¸ºç»Ÿä¸€çš„Goé”™è¯¯æ ¼å¼
5. **å¯è§‚æµ‹æ€§**ï¼šå®Œå–„çš„æ—¥å¿—ã€ç›‘æ§ã€è¿½è¸ª

---

## ä¸€ã€æ¶æ„è®¾è®¡

### 1.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Gin Web Framework                         â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚            Router Layer                          â”‚      â”‚
â”‚  â”‚  POST /api/v1/ai/generate                        â”‚      â”‚
â”‚  â”‚  POST /api/v1/ai/chat                            â”‚      â”‚
â”‚  â”‚  GET  /api/v1/ai/rag/search                      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                     â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚            API Layer                             â”‚      â”‚
â”‚  â”‚  - å‚æ•°éªŒè¯ (validator)                          â”‚      â”‚
â”‚  â”‚  - è®¤è¯æˆæƒ (JWT middleware)                     â”‚      â”‚
â”‚  â”‚  - è¯·æ±‚æ—¥å¿—                                       â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                     â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚         AI Proxy Service                         â”‚      â”‚
â”‚  â”‚                                                    â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚
â”‚  â”‚  â”‚  Request Handler                         â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - å‚æ•°è½¬æ¢                              â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - ä¸Šä¸‹æ–‡ä¼ é€’                            â”‚    â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚
â”‚  â”‚             â”‚                                     â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚
â”‚  â”‚  â”‚  Service Protection Layer                â”‚    â”‚      â”‚
â”‚  â”‚  â”‚                                           â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  â”‚Rate Limiterâ”‚Circuit   â”‚Timeout     â”‚ â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  â”‚(é™æµå™¨)    â”‚Breaker   â”‚Control     â”‚ â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  â”‚            â”‚(ç†”æ–­å™¨)  â”‚(è¶…æ—¶æ§åˆ¶)  â”‚ â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚
â”‚  â”‚             â”‚                                     â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚
â”‚  â”‚  â”‚  gRPC Client Pool                        â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - è¿æ¥æ± ç®¡ç†                            â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - è´Ÿè½½å‡è¡¡                              â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - å¥åº·æ£€æŸ¥                              â”‚    â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚
â”‚  â”‚             â”‚                                     â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚
â”‚  â”‚  â”‚  Stream Response Handler                 â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - gRPC Stream â†’ SSE                     â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - WebSocket support                     â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - é”™è¯¯æ¢å¤                              â”‚    â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚
â”‚  â”‚             â”‚                                     â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚
â”‚  â”‚  â”‚  Error Converter                         â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - gRPCé”™è¯¯ â†’ Goé”™è¯¯                     â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - é”™è¯¯ç æ˜ å°„                            â”‚    â”‚      â”‚
â”‚  â”‚  â”‚  - é”™è¯¯æ—¥å¿—                              â”‚    â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ gRPC
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Python AI Agent Service                         â”‚
â”‚                (gRPC Server)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ¨¡å—èŒè´£

| æ¨¡å— | èŒè´£ | ä¸è´Ÿè´£ |
|------|------|--------|
| **AI Proxy Service** | è¯·æ±‚è½¬å‘ã€æµå¼ä»£ç†ã€ç†”æ–­é™æµã€é”™è¯¯è½¬æ¢ | AIé€»è¾‘ã€å·¥å…·æ‰§è¡Œã€RAGæ£€ç´¢ |
| **gRPC Client Pool** | è¿æ¥ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€å¥åº·æ£€æŸ¥ | ä¸šåŠ¡é€»è¾‘ |
| **Stream Handler** | æµå¼å“åº”ä»£ç†ã€SSEè½¬æ¢ | æ•°æ®ç”Ÿæˆ |
| **Circuit Breaker** | æœåŠ¡ä¿æŠ¤ã€æ•…éšœéš”ç¦» | æœåŠ¡å®ç° |

---

## äºŒã€æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 2.1 AI Proxy Serviceæ¥å£

```go
package ai

import (
    "context"
    "io"
    "time"
)

// AIProxyService AIä»£ç†æœåŠ¡æ¥å£
type AIProxyService interface {
    // æ–‡æœ¬ç”Ÿæˆ
    GenerateText(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error)
    GenerateTextStream(ctx context.Context, req *GenerateRequest) (<-chan *StreamChunk, error)
    
    // å¯¹è¯
    Chat(ctx context.Context, req *ChatRequest) (*ChatResponse, error)
    ChatStream(ctx context.Context, req *ChatRequest) (<-chan *StreamChunk, error)
    
    // RAGå¢å¼ºç”Ÿæˆ
    RAGGenerate(ctx context.Context, req *RAGRequest) (*RAGResponse, error)
    
    // Agentæ‰§è¡Œ
    ExecuteAgent(ctx context.Context, req *AgentRequest) (*AgentResponse, error)
    
    // å¥åº·æ£€æŸ¥
    Health(ctx context.Context) error
    
    // å…³é—­è¿æ¥
    Close() error
}

// GenerateRequest ç”Ÿæˆè¯·æ±‚
type GenerateRequest struct {
    Prompt      string            `json:"prompt" validate:"required"`
    Model       string            `json:"model"`
    Temperature float32           `json:"temperature"`
    MaxTokens   int               `json:"maxTokens"`
    Stream      bool              `json:"stream"`
    Metadata    map[string]string `json:"metadata"`
}

// StreamChunk æµå¼å“åº”å—
type StreamChunk struct {
    Delta   string `json:"delta"`
    IsFinal bool   `json:"isFinal"`
    Error   string `json:"error,omitempty"`
}

// ChatRequest å¯¹è¯è¯·æ±‚
type ChatRequest struct {
    SessionID   string    `json:"sessionId"`
    Messages    []Message `json:"messages" validate:"required"`
    Model       string    `json:"model"`
    Temperature float32   `json:"temperature"`
    Stream      bool      `json:"stream"`
}

// Message æ¶ˆæ¯
type Message struct {
    Role    string `json:"role" validate:"required,oneof=system user assistant"`
    Content string `json:"content" validate:"required"`
}

// AgentRequest Agentæ‰§è¡Œè¯·æ±‚
type AgentRequest struct {
    AgentType string            `json:"agentType" validate:"required,oneof=creative analysis review assistant"`
    Task      string            `json:"task" validate:"required"`
    Context   map[string]string `json:"context"`
    Tools     []string          `json:"tools"`
}

// AgentResponse Agentæ‰§è¡Œå“åº”
type AgentResponse struct {
    Result    string     `json:"result"`
    ToolCalls []ToolCall `json:"toolCalls"`
    Status    string     `json:"status"`
    Reasoning []string   `json:"reasoning"`
}

// ToolCall å·¥å…·è°ƒç”¨è®°å½•
type ToolCall struct {
    ToolName   string                 `json:"toolName"`
    Parameters map[string]interface{} `json:"parameters"`
    Result     interface{}            `json:"result"`
}
```

### 2.2 AI Proxy Serviceå®ç°

```go
package ai

import (
    "context"
    "fmt"
    "io"
    "sync"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    
    pb "Qingyu_backend/proto/ai"
    "Qingyu_backend/pkg/errors"
    "Qingyu_backend/pkg/logger"
)

// AIProxyServiceImpl AIä»£ç†æœåŠ¡å®ç°
type AIProxyServiceImpl struct {
    // gRPCå®¢æˆ·ç«¯
    grpcClient pb.AIAgentServiceClient
    conn       *grpc.ClientConn
    
    // æœåŠ¡ä¿æŠ¤ç»„ä»¶
    circuitBreaker *CircuitBreaker
    rateLimiter    *RateLimiter
    
    // é…ç½®
    config *ProxyConfig
    
    // æ—¥å¿—
    logger logger.Logger
    
    // è¿æ¥æ± 
    pool *ConnectionPool
}

// ProxyConfig ä»£ç†é…ç½®
type ProxyConfig struct {
    PythonAddr      string        `mapstructure:"python_addr"`
    Timeout         time.Duration `mapstructure:"timeout"`
    MaxRetries      int           `mapstructure:"max_retries"`
    RateLimit       int           `mapstructure:"rate_limit"` // QPS
    CircuitMaxFails int           `mapstructure:"circuit_max_fails"`
    CircuitResetTime time.Duration `mapstructure:"circuit_reset_time"`
}

// NewAIProxyService åˆ›å»ºAIä»£ç†æœåŠ¡
func NewAIProxyService(config *ProxyConfig, logger logger.Logger) (*AIProxyServiceImpl, error) {
    // 1. å»ºç«‹gRPCè¿æ¥
    conn, err := grpc.Dial(
        config.PythonAddr,
        grpc.WithInsecure(),
        grpc.WithBlock(),
        grpc.WithTimeout(10*time.Second),
        grpc.WithKeepaliveParams(keepalive.ClientParameters{
            Time:                10 * time.Second,
            Timeout:             3 * time.Second,
            PermitWithoutStream: true,
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("è¿æ¥Python AIæœåŠ¡å¤±è´¥: %w", err)
    }
    
    // 2. åˆ›å»ºgRPCå®¢æˆ·ç«¯
    client := pb.NewAIAgentServiceClient(conn)
    
    // 3. åˆ›å»ºæœåŠ¡ä¿æŠ¤ç»„ä»¶
    circuitBreaker := NewCircuitBreaker(
        config.CircuitMaxFails,
        config.CircuitResetTime,
    )
    
    rateLimiter := NewRateLimiter(
        config.RateLimit,
        time.Second,
    )
    
    return &AIProxyServiceImpl{
        grpcClient:     client,
        conn:           conn,
        circuitBreaker: circuitBreaker,
        rateLimiter:    rateLimiter,
        config:         config,
        logger:         logger,
    }, nil
}

// GenerateText æ–‡æœ¬ç”Ÿæˆï¼ˆåŒæ­¥ï¼‰
func (s *AIProxyServiceImpl) GenerateText(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error) {
    // 1. é™æµæ£€æŸ¥
    if !s.rateLimiter.Allow() {
        s.logger.Warn("è¯·æ±‚è¢«é™æµæ‹’ç»")
        return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    }
    
    // 2. ç†”æ–­æ£€æŸ¥
    if !s.circuitBreaker.Allow() {
        s.logger.Warn("ç†”æ–­å™¨å¼€å¯ï¼Œæ‹’ç»è¯·æ±‚")
        return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•")
    }
    
    // 3. è®¾ç½®è¶…æ—¶
    ctx, cancel := context.WithTimeout(ctx, s.config.Timeout)
    defer cancel()
    
    // 4. è½¬æ¢è¯·æ±‚
    pbReq := &pb.GenerateRequest{
        Prompt:      req.Prompt,
        Model:       req.Model,
        Temperature: req.Temperature,
        MaxTokens:   int32(req.MaxTokens),
        Metadata:    req.Metadata,
    }
    
    // 5. è°ƒç”¨PythonæœåŠ¡
    s.logger.Info("è°ƒç”¨Python AIæœåŠ¡ç”Ÿæˆæ–‡æœ¬", 
        "model", req.Model,
        "prompt_len", len(req.Prompt))
    
    start := time.Now()
    resp, err := s.grpcClient.GenerateText(ctx, pbReq)
    duration := time.Since(start)
    
    if err != nil {
        s.circuitBreaker.RecordFailure()
        s.logger.Error("è°ƒç”¨Python AIæœåŠ¡å¤±è´¥", 
            "error", err,
            "duration", duration)
        return nil, s.convertError(err)
    }
    
    s.circuitBreaker.RecordSuccess()
    s.logger.Info("Python AIæœåŠ¡è°ƒç”¨æˆåŠŸ",
        "duration", duration,
        "tokens_used", resp.TokensUsed)
    
    // 6. è½¬æ¢å“åº”
    return &GenerateResponse{
        Text:       resp.Text,
        TokensUsed: int(resp.TokensUsed),
        Model:      resp.Model,
    }, nil
}

// GenerateTextStream æµå¼æ–‡æœ¬ç”Ÿæˆ
func (s *AIProxyServiceImpl) GenerateTextStream(ctx context.Context, req *GenerateRequest) (<-chan *StreamChunk, error) {
    // 1. é™æµå’Œç†”æ–­æ£€æŸ¥
    if !s.rateLimiter.Allow() {
        return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹")
    }
    if !s.circuitBreaker.Allow() {
        return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
    }
    
    // 2. è½¬æ¢è¯·æ±‚
    pbReq := &pb.GenerateRequest{
        Prompt:      req.Prompt,
        Model:       req.Model,
        Temperature: req.Temperature,
        MaxTokens:   int32(req.MaxTokens),
    }
    
    // 3. è°ƒç”¨gRPCæµå¼æ¥å£
    s.logger.Info("è°ƒç”¨Python AIæœåŠ¡æµå¼ç”Ÿæˆ", "model", req.Model)
    
    stream, err := s.grpcClient.GenerateTextStream(ctx, pbReq)
    if err != nil {
        s.circuitBreaker.RecordFailure()
        s.logger.Error("åˆ›å»ºæµå¼è°ƒç”¨å¤±è´¥", "error", err)
        return nil, s.convertError(err)
    }
    
    // 4. åˆ›å»ºè¾“å‡ºchannel
    chunkChan := make(chan *StreamChunk, 100)
    
    // 5. å¼‚æ­¥æ¥æ”¶æµå¼æ•°æ®
    go s.handleStream(ctx, stream, chunkChan)
    
    return chunkChan, nil
}

// handleStream å¤„ç†æµå¼å“åº”
func (s *AIProxyServiceImpl) handleStream(
    ctx context.Context,
    stream pb.AIAgentService_GenerateTextStreamClient,
    chunkChan chan<- *StreamChunk,
) {
    defer close(chunkChan)
    
    start := time.Now()
    chunkCount := 0
    
    for {
        select {
        case <-ctx.Done():
            s.logger.Warn("æµå¼è°ƒç”¨è¢«å–æ¶ˆ", "reason", ctx.Err())
            chunkChan <- &StreamChunk{
                Error: "è¯·æ±‚å·²å–æ¶ˆ",
            }
            return
            
        default:
            chunk, err := stream.Recv()
            if err == io.EOF {
                // æµç»“æŸ
                s.circuitBreaker.RecordSuccess()
                s.logger.Info("æµå¼è°ƒç”¨å®Œæˆ",
                    "duration", time.Since(start),
                    "chunks", chunkCount)
                return
            }
            
            if err != nil {
                s.circuitBreaker.RecordFailure()
                s.logger.Error("æµå¼æ¥æ”¶å¤±è´¥", "error", err)
                chunkChan <- &StreamChunk{
                    Error: s.convertError(err).Error(),
                }
                return
            }
            
            // å‘é€chunk
            chunkChan <- &StreamChunk{
                Delta:   chunk.Delta,
                IsFinal: chunk.IsFinal,
            }
            chunkCount++
        }
    }
}

// ChatStream æµå¼å¯¹è¯
func (s *AIProxyServiceImpl) ChatStream(ctx context.Context, req *ChatRequest) (<-chan *StreamChunk, error) {
    if !s.rateLimiter.Allow() {
        return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹")
    }
    if !s.circuitBreaker.Allow() {
        return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
    }
    
    // è½¬æ¢æ¶ˆæ¯
    messages := make([]*pb.Message, len(req.Messages))
    for i, msg := range req.Messages {
        messages[i] = &pb.Message{
            Role:    msg.Role,
            Content: msg.Content,
        }
    }
    
    pbReq := &pb.ChatRequest{
        SessionId:   req.SessionID,
        Messages:    messages,
        Model:       req.Model,
        Temperature: req.Temperature,
    }
    
    stream, err := s.grpcClient.ChatStream(ctx, pbReq)
    if err != nil {
        s.circuitBreaker.RecordFailure()
        return nil, s.convertError(err)
    }
    
    chunkChan := make(chan *StreamChunk, 100)
    go s.handleStream(ctx, stream, chunkChan)
    
    return chunkChan, nil
}

// ExecuteAgent æ‰§è¡ŒAgent
func (s *AIProxyServiceImpl) ExecuteAgent(ctx context.Context, req *AgentRequest) (*AgentResponse, error) {
    if !s.rateLimiter.Allow() {
        return nil, errors.NewRateLimitError("è¯·æ±‚è¿‡äºé¢‘ç¹")
    }
    if !s.circuitBreaker.Allow() {
        return nil, errors.NewServiceUnavailableError("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
    }
    
    ctx, cancel := context.WithTimeout(ctx, 5*time.Minute) // Agentä»»åŠ¡å¯èƒ½è¾ƒé•¿
    defer cancel()
    
    pbReq := &pb.AgentRequest{
        AgentType: req.AgentType,
        Task:      req.Task,
        Context:   req.Context,
        Tools:     req.Tools,
    }
    
    s.logger.Info("æ‰§è¡ŒAgentä»»åŠ¡", "type", req.AgentType, "task", req.Task)
    
    start := time.Now()
    resp, err := s.grpcClient.ExecuteAgent(ctx, pbReq)
    duration := time.Since(start)
    
    if err != nil {
        s.circuitBreaker.RecordFailure()
        s.logger.Error("Agentæ‰§è¡Œå¤±è´¥", "error", err, "duration", duration)
        return nil, s.convertError(err)
    }
    
    s.circuitBreaker.RecordSuccess()
    s.logger.Info("Agentæ‰§è¡ŒæˆåŠŸ", "duration", duration, "tool_calls", len(resp.ToolCalls))
    
    // è½¬æ¢å·¥å…·è°ƒç”¨
    toolCalls := make([]ToolCall, len(resp.ToolCalls))
    for i, tc := range resp.ToolCalls {
        var params map[string]interface{}
        json.Unmarshal([]byte(tc.Parameters), &params)
        
        toolCalls[i] = ToolCall{
            ToolName:   tc.ToolName,
            Parameters: params,
            Result:     tc.Result,
        }
    }
    
    return &AgentResponse{
        Result:    resp.Result,
        ToolCalls: toolCalls,
        Status:    resp.Status,
    }, nil
}

// Health å¥åº·æ£€æŸ¥
func (s *AIProxyServiceImpl) Health(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    resp, err := s.grpcClient.HealthCheck(ctx, &pb.HealthRequest{})
    if err != nil {
        return fmt.Errorf("å¥åº·æ£€æŸ¥å¤±è´¥: %w", err)
    }
    
    if resp.Status != "healthy" {
        return fmt.Errorf("æœåŠ¡çŠ¶æ€å¼‚å¸¸: %s", resp.Status)
    }
    
    return nil
}

// Close å…³é—­è¿æ¥
func (s *AIProxyServiceImpl) Close() error {
    if s.conn != nil {
        return s.conn.Close()
    }
    return nil
}

// convertError é”™è¯¯è½¬æ¢
func (s *AIProxyServiceImpl) convertError(err error) error {
    // è½¬æ¢gRPCé”™è¯¯ä¸ºGoé”™è¯¯
    st, ok := status.FromError(err)
    if !ok {
        return errors.NewInternalError("AIæœåŠ¡è°ƒç”¨å¤±è´¥").WithCause(err)
    }
    
    switch st.Code() {
    case codes.DeadlineExceeded:
        return errors.NewTimeoutError("AIæœåŠ¡å“åº”è¶…æ—¶")
    case codes.Unavailable:
        return errors.NewServiceUnavailableError("AIæœåŠ¡ä¸å¯ç”¨")
    case codes.InvalidArgument:
        return errors.NewValidationError(st.Message())
    case codes.ResourceExhausted:
        return errors.NewRateLimitError("AIæœåŠ¡èµ„æºè€—å°½")
    default:
        return errors.NewInternalError(st.Message()).WithCause(err)
    }
}
```

### 2.3 ç†”æ–­å™¨å®ç°

```go
package ai

import (
    "sync"
    "time"
)

// CircuitState ç†”æ–­å™¨çŠ¶æ€
type CircuitState int

const (
    StateClosed   CircuitState = iota // å…³é—­ï¼ˆæ­£å¸¸ï¼‰
    StateHalfOpen                      // åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰
    StateOpen                          // å¼€å¯ï¼ˆæ‹’ç»è¯·æ±‚ï¼‰
)

// CircuitBreaker ç†”æ–­å™¨
type CircuitBreaker struct {
    maxFailures int           // æœ€å¤§å¤±è´¥æ¬¡æ•°
    resetTime   time.Duration // é‡ç½®æ—¶é—´
    
    mu           sync.RWMutex
    state        CircuitState
    failures     int
    lastFailTime time.Time
}

// NewCircuitBreaker åˆ›å»ºç†”æ–­å™¨
func NewCircuitBreaker(maxFailures int, resetTime time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures: maxFailures,
        resetTime:   resetTime,
        state:       StateClosed,
    }
}

// Allow æ˜¯å¦å…è®¸è¯·æ±‚
func (cb *CircuitBreaker) Allow() bool {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    now := time.Now()
    
    switch cb.state {
    case StateClosed:
        return true
        
    case StateOpen:
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•æ¢å¤
        if now.Sub(cb.lastFailTime) > cb.resetTime {
            cb.state = StateHalfOpen
            return true
        }
        return false
        
    case StateHalfOpen:
        return true
        
    default:
        return false
    }
}

// RecordSuccess è®°å½•æˆåŠŸ
func (cb *CircuitBreaker) RecordSuccess() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.failures = 0
    if cb.state == StateHalfOpen {
        cb.state = StateClosed
    }
}

// RecordFailure è®°å½•å¤±è´¥
func (cb *CircuitBreaker) RecordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.failures++
    cb.lastFailTime = time.Now()
    
    if cb.failures >= cb.maxFailures {
        cb.state = StateOpen
    }
}

// GetState è·å–çŠ¶æ€
func (cb *CircuitBreaker) GetState() CircuitState {
    cb.mu.RLock()
    defer cb.mu.RUnlock()
    return cb.state
}
```

### 2.4 é™æµå™¨å®ç°

```go
package ai

import (
    "sync"
    "time"
)

// RateLimiter é™æµå™¨ï¼ˆä»¤ç‰Œæ¡¶ç®—æ³•ï¼‰
type RateLimiter struct {
    capacity int           // æ¡¶å®¹é‡
    refillRate time.Duration // è¡¥å……é€Ÿç‡
    
    mu sync.Mutex
    tokens int
    lastRefill time.Time
}

// NewRateLimiter åˆ›å»ºé™æµå™¨
func NewRateLimiter(ratePerSecond int, interval time.Duration) *RateLimiter {
    return &RateLimiter{
        capacity:   ratePerSecond,
        refillRate: interval,
        tokens:     ratePerSecond,
        lastRefill: time.Now(),
    }
}

// Allow æ˜¯å¦å…è®¸è¯·æ±‚
func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    // è¡¥å……ä»¤ç‰Œ
    rl.refill()
    
    if rl.tokens > 0 {
        rl.tokens--
        return true
    }
    
    return false
}

// refill è¡¥å……ä»¤ç‰Œ
func (rl *RateLimiter) refill() {
    now := time.Now()
    elapsed := now.Sub(rl.lastRefill)
    
    tokensToAdd := int(elapsed / rl.refillRate)
    if tokensToAdd > 0 {
        rl.tokens += tokensToAdd
        if rl.tokens > rl.capacity {
            rl.tokens = rl.capacity
        }
        rl.lastRefill = now
    }
}
```

---

## ä¸‰ã€APIå±‚é›†æˆ

### 3.1 HTTP Handler

```go
package api

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
    
    "Qingyu_backend/service/ai"
    "Qingyu_backend/pkg/response"
)

// AIApi AI APIå¤„ç†å™¨
type AIApi struct {
    proxyService ai.AIProxyService
    validator    *validator.Validate
}

// NewAIApi åˆ›å»ºAI APIå¤„ç†å™¨
func NewAIApi(proxyService ai.AIProxyService) *AIApi {
    return &AIApi{
        proxyService: proxyService,
        validator:    validator.New(),
    }
}

// GenerateText æ–‡æœ¬ç”Ÿæˆ
func (api *AIApi) GenerateText(c *gin.Context) {
    var req ai.GenerateRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "å‚æ•°é”™è¯¯", err.Error())
        return
    }
    
    if err := api.validator.Struct(&req); err != nil {
        response.ValidationError(c, err)
        return
    }
    
    // åˆ¤æ–­æ˜¯å¦æµå¼
    if req.Stream {
        api.GenerateTextStream(c, &req)
        return
    }
    
    // åŒæ­¥ç”Ÿæˆ
    resp, err := api.proxyService.GenerateText(c.Request.Context(), &req)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "ç”ŸæˆæˆåŠŸ", resp)
}

// GenerateTextStream æµå¼æ–‡æœ¬ç”Ÿæˆ
func (api *AIApi) GenerateTextStream(c *gin.Context, req *ai.GenerateRequest) {
    // è®¾ç½®SSEå“åº”å¤´
    c.Header("Content-Type", "text/event-stream")
    c.Header("Cache-Control", "no-cache")
    c.Header("Connection", "keep-alive")
    c.Header("X-Accel-Buffering", "no") // ç¦ç”¨Nginxç¼“å†²
    
    // è·å–æµå¼channel
    chunkChan, err := api.proxyService.GenerateTextStream(c.Request.Context(), req)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    // æµå¼æ¨é€
    c.Stream(func(w io.Writer) bool {
        if chunk, ok := <-chunkChan; ok {
            if chunk.Error != "" {
                c.SSEvent("error", chunk.Error)
                return false
            }
            
            c.SSEvent("message", gin.H{
                "delta":   chunk.Delta,
                "isFinal": chunk.IsFinal,
            })
            
            return !chunk.IsFinal
        }
        return false
    })
}

// ExecuteAgent æ‰§è¡ŒAgent
func (api *AIApi) ExecuteAgent(c *gin.Context) {
    var req ai.AgentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "å‚æ•°é”™è¯¯", err.Error())
        return
    }
    
    if err := api.validator.Struct(&req); err != nil {
        response.ValidationError(c, err)
        return
    }
    
    resp, err := api.proxyService.ExecuteAgent(c.Request.Context(), &req)
    if err != nil {
        api.handleError(c, err)
        return
    }
    
    response.Success(c, http.StatusOK, "æ‰§è¡ŒæˆåŠŸ", resp)
}

// handleError é”™è¯¯å¤„ç†
func (api *AIApi) handleError(c *gin.Context, err error) {
    // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ç›¸åº”çš„HTTPçŠ¶æ€ç 
    switch e := err.(type) {
    case *errors.RateLimitError:
        response.Error(c, http.StatusTooManyRequests, e.Message, e.Details)
    case *errors.ServiceUnavailableError:
        response.Error(c, http.StatusServiceUnavailable, e.Message, e.Details)
    case *errors.TimeoutError:
        response.Error(c, http.StatusGatewayTimeout, e.Message, e.Details)
    case *errors.ValidationError:
        response.Error(c, http.StatusBadRequest, e.Message, e.Details)
    default:
        response.Error(c, http.StatusInternalServerError, "æœåŠ¡é”™è¯¯", err.Error())
    }
}
```

### 3.2 è·¯ç”±æ³¨å†Œ

```go
package router

func InitAIRouter(r *gin.RouterGroup, container *service.ServiceContainer) {
    // è·å–AI Proxy Service
    proxyService := container.GetAIProxyService()
    
    aiApi := api.NewAIApi(proxyService)
    
    aiGroup := r.Group("/ai")
    aiGroup.Use(middleware.JWTAuth()) // éœ€è¦è®¤è¯
    {
        // æ–‡æœ¬ç”Ÿæˆ
        aiGroup.POST("/generate", aiApi.GenerateText)
        
        // å¯¹è¯
        aiGroup.POST("/chat", aiApi.Chat)
        
        // Agentæ‰§è¡Œ
        aiGroup.POST("/agent/execute", aiApi.ExecuteAgent)
        
        // RAGæ£€ç´¢
        aiGroup.POST("/rag/search", aiApi.RAGSearch)
        
        // å¥åº·æ£€æŸ¥ï¼ˆæ— éœ€è®¤è¯ï¼‰
        aiGroup.GET("/health", aiApi.Health)
    }
}
```

---

## å››ã€ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 4.1 PrometheusæŒ‡æ ‡

```go
package ai

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // è¯·æ±‚è®¡æ•°
    requestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "ai_proxy_requests_total",
            Help: "Total number of AI proxy requests",
        },
        []string{"method", "status"},
    )
    
    // è¯·æ±‚å»¶è¿Ÿ
    requestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "ai_proxy_request_duration_seconds",
            Help:    "AI proxy request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method"},
    )
    
    // ç†”æ–­å™¨çŠ¶æ€
    circuitBreakerState = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "ai_proxy_circuit_breaker_state",
            Help: "Circuit breaker state (0=closed, 1=half-open, 2=open)",
        },
        []string{"service"},
    )
    
    // é™æµæ‹’ç»æ•°
    rateLimitRejections = promauto.NewCounter(
        prometheus.CounterOpts{
            Name: "ai_proxy_rate_limit_rejections_total",
            Help: "Total number of requests rejected by rate limiter",
        },
    )
)

// è®°å½•æŒ‡æ ‡
func (s *AIProxyServiceImpl) recordMetrics(method string, duration time.Duration, err error) {
    status := "success"
    if err != nil {
        status = "error"
    }
    
    requestsTotal.WithLabelValues(method, status).Inc()
    requestDuration.WithLabelValues(method).Observe(duration.Seconds())
    
    circuitBreakerState.WithLabelValues("python_ai").Set(float64(s.circuitBreaker.GetState()))
}
```

### 4.2 ç»“æ„åŒ–æ—¥å¿—

```go
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
s.logger.Info("AIè¯·æ±‚å¼€å§‹",
    "method", "GenerateText",
    "user_id", userID,
    "request_id", requestID,
    "model", req.Model,
)

s.logger.Error("AIè¯·æ±‚å¤±è´¥",
    "method", "GenerateText",
    "error", err,
    "duration", duration,
    "circuit_state", s.circuitBreaker.GetState(),
)
```

---

## äº”ã€éƒ¨ç½²ä¸é…ç½®

### 5.1 é…ç½®ç¤ºä¾‹

```yaml
# config.yaml
ai:
  proxy:
    python_addr: "localhost:50051"
    timeout: 30s
    max_retries: 3
    rate_limit: 100  # 100 QPS
    circuit_max_fails: 5
    circuit_reset_time: 30s
```

### 5.2 æœåŠ¡åˆå§‹åŒ–

```go
// cmd/server/main.go
func initAIProxyService(cfg *config.Config) ai.AIProxyService {
    proxyConfig := &ai.ProxyConfig{
        PythonAddr:       cfg.AI.Proxy.PythonAddr,
        Timeout:          cfg.AI.Proxy.Timeout,
        MaxRetries:       cfg.AI.Proxy.MaxRetries,
        RateLimit:        cfg.AI.Proxy.RateLimit,
        CircuitMaxFails:  cfg.AI.Proxy.CircuitMaxFails,
        CircuitResetTime: cfg.AI.Proxy.CircuitResetTime,
    }
    
    proxyService, err := ai.NewAIProxyService(proxyConfig, logger)
    if err != nil {
        log.Fatal("åˆå§‹åŒ–AIä»£ç†æœåŠ¡å¤±è´¥:", err)
    }
    
    // å¥åº·æ£€æŸ¥
    if err := proxyService.Health(context.Background()); err != nil {
        log.Warn("Python AIæœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥:", err)
    }
    
    return proxyService
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-21  
**è´Ÿè´£äºº**: åç«¯å›¢é˜Ÿ  
**å®¡æ ¸çŠ¶æ€**: å¾…è¯„å®¡

