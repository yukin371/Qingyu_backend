# Agent工具调用集成设计

> **文档版本**: v1.0  
> **创建时间**: 2025-10-21  
> **实施状态**: 设计阶段

## 📋 文档概述

本文档设计Python Agent如何回调Go API实现工具调用，包括认证授权传递、参数序列化、超时重试、权限控制等关键机制。

## 🎯 设计目标

1. **安全回调**：Agent调用Go API时必须通过认证和权限检查
2. **参数标准化**：统一的Tool接口和参数Schema
3. **容错机制**：超时控制、重试策略、错误恢复
4. **审计日志**：完整的工具调用记录和审计
5. **权限隔离**：工具级别和用户级别的权限控制

---

## 一、工具调用流程图

```
┌──────────────────────────────────────────────────────────┐
│             Python AI Agent Service                      │
│                                                            │
│  ┌──────────────────────────────────────────────┐        │
│  │      Creative Agent                          │        │
│  │                                               │        │
│  │  1. 理解任务："创建角色卡-林风"              │        │
│  │  2. 规划步骤：[调用CharacterTool.create]     │        │
│  │  3. 执行步骤                                  │        │
│  └──────────────────┬───────────────────────────┘        │
│                     │                                     │
│  ┌──────────────────▼───────────────────────────┐        │
│  │      Tool Execution Engine                   │        │
│  │                                               │        │
│  │  1. 获取工具：CharacterTool                  │        │
│  │  2. 验证参数                                  │        │
│  │  3. 构建HTTP请求                              │        │
│  └──────────────────┬───────────────────────────┘        │
│                     │                                     │
│                     │ HTTP POST                           │
│                     │ /api/v1/projects/{id}/characters   │
│                     │                                     │
│                     │ Headers:                            │
│                     │   Authorization: Bearer {token}    │
│                     │   X-Agent-Call-ID: {uuid}          │
│                     │   X-User-ID: {user_id}             │
└─────────────────────┼─────────────────────────────────────┘
                      │
┌─────────────────────▼─────────────────────────────────────┐
│                  Go Backend Service                        │
│                                                              │
│  ┌──────────────────────────────────────────────┐          │
│  │       Middleware Chain                       │          │
│  │                                               │          │
│  │  1. JWT验证（识别用户）                      │          │
│  │  2. Agent调用识别（X-Agent-Call-ID）         │          │
│  │  3. 权限检查（用户+工具权限）                │          │
│  │  4. 审计日志记录                              │          │
│  └──────────────────┬───────────────────────────┘          │
│                     │                                       │
│  ┌──────────────────▼───────────────────────────┐          │
│  │       Character API Handler                  │          │
│  │                                               │          │
│  │  1. 参数验证                                  │          │
│  │  2. 调用CharacterService                      │          │
│  │  3. 创建角色卡                                │          │
│  │  4. 返回结果                                  │          │
│  └──────────────────┬───────────────────────────┘          │
│                     │                                       │
│                     │ Response                              │
│                     │ {                                     │
│                     │   "id": "char-001",                   │
│                     │   "name": "林风",                     │
│                     │   ...                                 │
│                     │ }                                     │
└─────────────────────┼─────────────────────────────────────┘
                      │
┌─────────────────────▼─────────────────────────────────────┐
│             Python AI Agent Service                        │
│                                                              │
│  ┌──────────────────────────────────────────────┐          │
│  │      Tool Execution Engine                   │          │
│  │                                               │          │
│  │  4. 解析响应                                  │          │
│  │  5. 返回ToolCall结果                          │          │
│  └──────────────────┬───────────────────────────┘          │
│                     │                                       │
│  ┌──────────────────▼───────────────────────────┐          │
│  │      Creative Agent                          │          │
│  │                                               │          │
│  │  4. 接收工具结果                              │          │
│  │  5. 继续执行后续步骤                          │          │
│  └──────────────────────────────────────────────┘          │
└────────────────────────────────────────────────────────────┘
```

---

## 二、认证授权设计

### 2.1 Token传递机制

```python
# Python端：HTTP Client配置
class GoAPIClient:
    """Go API客户端"""
    
    def __init__(self, base_url: str, auth_token: str):
        self.base_url = base_url
        self.auth_token = auth_token  # JWT Token
        self.session = aiohttp.ClientSession()
    
    async def call_api(
        self,
        method: str,
        endpoint: str,
        data: Dict[str, Any] = None,
        params: Dict[str, Any] = None,
        user_id: str = None,
        agent_call_id: str = None
    ) -> Dict[str, Any]:
        """调用Go API"""
        
        # 构建headers
        headers = {
            'Authorization': f'Bearer {self.auth_token}',
            'Content-Type': 'application/json',
        }
        
        # Agent调用标识
        if agent_call_id:
            headers['X-Agent-Call-ID'] = agent_call_id
        
        # 用户ID
        if user_id:
            headers['X-User-ID'] = user_id
        
        url = f"{self.base_url}{endpoint}"
        
        async with self.session.request(
            method=method,
            url=url,
            json=data,
            params=params,
            headers=headers,
            timeout=aiohttp.ClientTimeout(total=30)
        ) as response:
            if response.status >= 400:
                error_data = await response.json()
                raise APIError(
                    status=response.status,
                    message=error_data.get('message', 'API调用失败'),
                    details=error_data.get('error')
                )
            
            return await response.json()
```

### 2.2 Go端中间件

```go
// middleware/agent_call.go
package middleware

// AgentCallMiddleware Agent调用识别中间件
func AgentCallMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        agentCallID := c.GetHeader("X-Agent-Call-ID")
        
        if agentCallID != "" {
            // 标记为Agent调用
            c.Set("is_agent_call", true)
            c.Set("agent_call_id", agentCallID)
            
            // 记录Agent调用日志
            log.Info("Agent工具调用",
                "call_id", agentCallID,
                "user_id", c.GetString("user_id"),
                "path", c.Request.URL.Path,
                "method", c.Request.Method,
            )
        }
        
        c.Next()
    }
}

// ToolPermissionMiddleware 工具权限检查中间件
func ToolPermissionMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 只对Agent调用进行工具权限检查
        if !c.GetBool("is_agent_call") {
            c.Next()
            return
        }
        
        userID := c.GetString("user_id")
        toolName := c.GetString("tool_name") // 由具体API设置
        
        // 检查用户是否有权限使用该工具
        hasPermission, err := checkToolPermission(c.Request.Context(), userID, toolName)
        if err != nil {
            c.JSON(500, gin.H{"error": "权限检查失败"})
            c.Abort()
            return
        }
        
        if !hasPermission {
            c.JSON(403, gin.H{"error": "无权限使用该工具"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

---

## 三、工具接口标准化

### 3.1 Python端Tool基类

```python
from abc import ABC, abstractmethod
from typing import Any, Dict
from pydantic import BaseModel, validator
import json

class ToolParameter(BaseModel):
    """工具参数定义"""
    name: str
    type: str  # 'string', 'number', 'boolean', 'object', 'array'
    description: str
    required: bool = False
    default: Any = None
    
class ToolMetadata(BaseModel):
    """工具元数据"""
    name: str
    description: str
    parameters: List[ToolParameter]
    category: str
    requires_auth: bool = True
    api_endpoint: str
    http_method: str = 'POST'

class Tool(ABC):
    """工具基类"""
    
    def __init__(self, metadata: ToolMetadata, go_api_client: GoAPIClient):
        self.metadata = metadata
        self.api_client = go_api_client
    
    def validate_parameters(self, params: Dict[str, Any]) -> bool:
        """验证参数"""
        for param in self.metadata.parameters:
            if param.required and param.name not in params:
                raise ValueError(f"缺少必需参数: {param.name}")
            
            if param.name in params:
                # 类型检查
                value = params[param.name]
                if not self._check_type(value, param.type):
                    raise ValueError(f"参数 {param.name} 类型错误，期望 {param.type}")
        
        return True
    
    def _check_type(self, value: Any, expected_type: str) -> bool:
        """检查类型"""
        type_map = {
            'string': str,
            'number': (int, float),
            'boolean': bool,
            'object': dict,
            'array': list
        }
        expected = type_map.get(expected_type)
        return isinstance(value, expected) if expected else False
    
    async def execute(
        self,
        params: Dict[str, Any],
        user_id: str = None,
        agent_call_id: str = None
    ) -> Any:
        """执行工具"""
        # 1. 验证参数
        self.validate_parameters(params)
        
        # 2. 准备API调用
        endpoint = self._build_endpoint(params)
        request_data = self._build_request_data(params)
        
        # 3. 调用Go API
        try:
            response = await self.api_client.call_api(
                method=self.metadata.http_method,
                endpoint=endpoint,
                data=request_data,
                user_id=user_id,
                agent_call_id=agent_call_id
            )
            
            # 4. 解析响应
            return self._parse_response(response)
            
        except APIError as e:
            # 错误处理
            raise ToolExecutionError(
                tool_name=self.metadata.name,
                error=str(e),
                status_code=e.status
            )
    
    @abstractmethod
    def _build_endpoint(self, params: Dict[str, Any]) -> str:
        """构建API端点（子类实现）"""
        pass
    
    @abstractmethod
    def _build_request_data(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """构建请求数据（子类实现）"""
        pass
    
    def _parse_response(self, response: Dict[str, Any]) -> Any:
        """解析响应（可被子类覆盖）"""
        return response.get('data')
```

### 3.2 具体工具实现示例

```python
class CharacterTool(Tool):
    """角色卡工具"""
    
    def __init__(self, go_api_client: GoAPIClient):
        metadata = ToolMetadata(
            name="character_tool",
            description="管理角色卡片",
            parameters=[
                ToolParameter(
                    name="action",
                    type="string",
                    description="操作类型: create, update, get, list",
                    required=True
                ),
                ToolParameter(
                    name="project_id",
                    type="string",
                    description="项目ID",
                    required=True
                ),
                ToolParameter(
                    name="character_id",
                    type="string",
                    description="角色ID（update/get时需要）",
                    required=False
                ),
                ToolParameter(
                    name="character_data",
                    type="object",
                    description="角色数据",
                    required=False
                )
            ],
            category="writing",
            api_endpoint="/api/v1/projects/{project_id}/characters",
            http_method="POST"
        )
        super().__init__(metadata, go_api_client)
    
    def _build_endpoint(self, params: Dict[str, Any]) -> str:
        """构建API端点"""
        project_id = params['project_id']
        action = params['action']
        
        if action == 'create':
            return f"/api/v1/projects/{project_id}/characters"
        elif action == 'get':
            character_id = params.get('character_id')
            return f"/api/v1/projects/{project_id}/characters/{character_id}"
        elif action == 'list':
            return f"/api/v1/projects/{project_id}/characters"
        elif action == 'update':
            character_id = params.get('character_id')
            return f"/api/v1/projects/{project_id}/characters/{character_id}"
    
    def _build_request_data(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """构建请求数据"""
        action = params['action']
        
        if action in ['create', 'update']:
            return params.get('character_data', {})
        
        return {}
```

---

## 四、超时与重试策略

### 4.1 超时控制

```python
class ToolExecutionEngine:
    """工具执行引擎"""
    
    def __init__(
        self,
        api_client: GoAPIClient,
        default_timeout: int = 30,
        max_retries: int = 3
    ):
        self.api_client = api_client
        self.default_timeout = default_timeout
        self.max_retries = max_retries
    
    async def execute_with_timeout(
        self,
        tool: Tool,
        params: Dict[str, Any],
        timeout: int = None,
        **kwargs
    ) -> Any:
        """带超时控制的工具执行"""
        timeout = timeout or self.default_timeout
        
        try:
            return await asyncio.wait_for(
                tool.execute(params, **kwargs),
                timeout=timeout
            )
        except asyncio.TimeoutError:
            raise ToolExecutionError(
                tool_name=tool.metadata.name,
                error=f"工具执行超时（{timeout}秒）"
            )
```

### 4.2 重试机制

```python
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)

class ToolExecutionEngine:
    
    @retry(
        stop=stop_after_attempt(3),  # 最多重试3次
        wait=wait_exponential(multiplier=1, min=1, max=10),  # 指数退避
        retry=retry_if_exception_type((aiohttp.ClientError, asyncio.TimeoutError))
    )
    async def execute_with_retry(
        self,
        tool: Tool,
        params: Dict[str, Any],
        **kwargs
    ) -> Any:
        """带重试的工具执行"""
        return await tool.execute(params, **kwargs)
```

---

## 五、权限控制设计

### 5.1 工具权限模型

```go
// models/shared/auth/tool_permission.go
package auth

type ToolPermission struct {
    ID       string   `bson:"_id" json:"id"`
    ToolName string   `bson:"tool_name" json:"toolName"` // 工具名称
    UserID   string   `bson:"user_id" json:"userId"`     // 用户ID
    Actions  []string `bson:"actions" json:"actions"`    // 允许的操作: create, read, update, delete
    Enabled  bool     `bson:"enabled" json:"enabled"`
    ExpiresAt *time.Time `bson:"expires_at,omitempty" json:"expiresAt,omitempty"`
    CreatedAt time.Time `bson:"created_at" json:"createdAt"`
}

type ToolAccessLog struct {
    ID          string    `bson:"_id" json:"id"`
    ToolName    string    `bson:"tool_name" json:"toolName"`
    UserID      string    `bson:"user_id" json:"userId"`
    AgentCallID string    `bson:"agent_call_id" json:"agentCallId"`
    Action      string    `bson:"action" json:"action"`
    Parameters  string    `bson:"parameters" json:"parameters"` // JSON
    Success     bool      `bson:"success" json:"success"`
    Error       string    `bson:"error,omitempty" json:"error,omitempty"`
    Duration    int64     `bson:"duration" json:"duration"` // 毫秒
    CreatedAt   time.Time `bson:"created_at" json:"createdAt"`
}
```

### 5.2 权限检查Service

```go
package auth

type ToolPermissionService interface {
    // 检查工具权限
    CheckToolPermission(ctx context.Context, userID, toolName, action string) (bool, error)
    
    // 授予工具权限
    GrantToolPermission(ctx context.Context, userID, toolName string, actions []string) error
    
    // 撤销工具权限
    RevokeToolPermission(ctx context.Context, userID, toolName string) error
    
    // 记录工具访问日志
    LogToolAccess(ctx context.Context, log *ToolAccessLog) error
}

type ToolPermissionServiceImpl struct {
    permissionRepo ToolPermissionRepository
    logRepo        ToolAccessLogRepository
}

func (s *ToolPermissionServiceImpl) CheckToolPermission(
    ctx context.Context,
    userID, toolName, action string,
) (bool, error) {
    // 1. 查询权限
    permission, err := s.permissionRepo.GetByUserAndTool(ctx, userID, toolName)
    if err != nil {
        return false, err
    }
    
    if permission == nil {
        return false, nil
    }
    
    // 2. 检查是否启用
    if !permission.Enabled {
        return false, nil
    }
    
    // 3. 检查是否过期
    if permission.ExpiresAt != nil && time.Now().After(*permission.ExpiresAt) {
        return false, nil
    }
    
    // 4. 检查操作权限
    for _, allowedAction := range permission.Actions {
        if allowedAction == action || allowedAction == "*" {
            return true, nil
        }
    }
    
    return false, nil
}
```

---

## 六、审计日志

### 6.1 日志记录中间件

```go
// middleware/tool_audit.go
package middleware

func ToolAuditMiddleware(toolPermissionService auth.ToolPermissionService) gin.HandlerFunc {
    return func(c *gin.Context) {
        if !c.GetBool("is_agent_call") {
            c.Next()
            return
        }
        
        start := time.Now()
        
        // 执行请求
        c.Next()
        
        duration := time.Since(start)
        
        // 记录审计日志
        log := &auth.ToolAccessLog{
            ID:          uuid.New().String(),
            ToolName:    c.GetString("tool_name"),
            UserID:      c.GetString("user_id"),
            AgentCallID: c.GetString("agent_call_id"),
            Action:      c.Request.Method,
            Success:     c.Writer.Status() < 400,
            Duration:    duration.Milliseconds(),
            CreatedAt:   time.Now(),
        }
        
        if c.Writer.Status() >= 400 {
            if err, exists := c.Get("error"); exists {
                log.Error = fmt.Sprintf("%v", err)
            }
        }
        
        // 异步记录日志
        go func() {
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            defer cancel()
            
            if err := toolPermissionService.LogToolAccess(ctx, log); err != nil {
                logger.Error("记录工具访问日志失败", "error", err)
            }
        }()
    }
}
```

---

## 七、错误处理

### 7.1 Python端错误类型

```python
class ToolExecutionError(Exception):
    """工具执行错误"""
    
    def __init__(self, tool_name: str, error: str, status_code: int = 500):
        self.tool_name = tool_name
        self.error = error
        self.status_code = status_code
        super().__init__(f"Tool {tool_name} execution failed: {error}")

class APIError(Exception):
    """API调用错误"""
    
    def __init__(self, status: int, message: str, details: str = None):
        self.status = status
        self.message = message
        self.details = details
        super().__init__(f"API Error {status}: {message}")
```

### 7.2 错误恢复策略

```python
class ToolExecutionEngine:
    
    async def execute_with_fallback(
        self,
        tool: Tool,
        params: Dict[str, Any],
        fallback_value: Any = None,
        **kwargs
    ) -> Any:
        """带降级的工具执行"""
        try:
            return await self.execute_with_retry(tool, params, **kwargs)
        except ToolExecutionError as e:
            logger.error(f"工具执行失败，使用降级值: {e}")
            return fallback_value
```

---

## 八、实施建议

### 8.1 开发步骤

1. **阶段1：基础框架**（3天）
   - Python GoAPIClient实现
   - Go Agent调用中间件
   - 基础Tool类和ToolRegistry

2. **阶段2：权限系统**（2天）
   - ToolPermission数据模型
   - ToolPermissionService实现
   - 权限检查中间件

3. **阶段3：审计日志**（1天）
   - ToolAccessLog数据模型
   - 审计日志中间件
   - 日志查询API

4. **阶段4：错误处理**（1天）
   - 重试机制
   - 降级策略
   - 错误日志

5. **阶段5：测试**（2天）
   - 单元测试
   - 集成测试
   - 性能测试

### 8.2 技术风险

| 风险 | 等级 | 应对措施 |
|------|------|---------|
| 网络延迟 | 中 | 异步调用、超时控制 |
| 权限漏洞 | 高 | 多层权限检查、审计日志 |
| 调用失败 | 中 | 重试机制、降级策略 |
| 并发问题 | 中 | 连接池、限流控制 |

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21  
**负责人**: 架构组  
**审核状态**: 待评审

