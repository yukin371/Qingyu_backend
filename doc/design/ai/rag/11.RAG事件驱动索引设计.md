# RAG事件驱动索引设计

> **文档版本**: v1.0  
> **创建时间**: 2025-10-21

## 📋 文档概述

本文档设计RAG系统的事件驱动索引机制，通过订阅文档事件自动触发向量化和索引更新。

---

## 一、事件触发机制

### 1.1 订阅的事件类型

| 事件 | 触发时机 | RAG操作 |
|------|---------|---------|
| `document.version_created` | 文档版本创建 | 向量化文档内容 |
| `character.created` | 角色创建 | 向量化角色信息 |
| `character.updated` | 角色更新 | 更新向量索引 |
| `setting.updated` | 设定更新 | 更新设定索引 |
| `outline.created` | 大纲创建 | 索引大纲结构 |
| `chat.session_created` | 聊天会话创建 | 准备知识库 |

### 1.2 事件处理器实现

```python
class DocumentVersionCreatedHandler(EventHandler):
    """文档版本创建事件处理器"""
    
    def __init__(self, rag_service: RAGService):
        self.rag_service = rag_service
    
    async def handle(self, event: Event):
        """处理文档创建事件"""
        data = event.data
        
        # 1. 获取文档内容
        document = Document(
            id=data['version_id'],
            user_id=data.get('user_id'),
            project_id=data['project_id'],
            content=data['content'],
            content_type=data['content_type']
        )
        
        # 2. 异步向量化
        await self.rag_service.vectorize_document(document)
        
        logger.info(f"文档已索引: {document.id}")
```

---

## 二、异步向量化队列

### 2.1 RabbitMQ队列设计

```python
class RAGIndexQueue:
    """RAG索引队列"""
    
    def __init__(self, rabbitmq_url: str):
        self.connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
        self.channel = self.connection.channel()
        
        # 声明队列
        self.channel.queue_declare(
            queue='rag.vectorize',
            durable=True,
            arguments={
                'x-max-priority': 10,  # 支持优先级
                'x-message-ttl': 3600000,  # 1小时TTL
                'x-dead-letter-exchange': 'rag.dlx'  # 死信队列
            }
        )
    
    def publish(self, document: Document, priority: int = 5):
        """发布向量化任务"""
        message = {
            'document_id': document.id,
            'content': document.content,
            'content_type': document.content_type
        }
        
        self.channel.basic_publish(
            exchange='',
            routing_key='rag.vectorize',
            body=json.dumps(message),
            properties=pika.BasicProperties(
                delivery_mode=2,  # 持久化
                priority=priority
            )
        )
```

---

## 三、增量索引策略

### 3.1 增量更新

```python
class IncrementalIndexer:
    """增量索引器"""
    
    async def update_document(self, document_id: str, new_content: str):
        """增量更新文档"""
        # 1. 删除旧索引
        await self.kb_manager.delete_document(document_id)
        
        # 2. 创建新索引
        document = Document(id=document_id, content=new_content)
        await self.kb_manager.index_document(document)
```

### 3.2 批量索引

```python
async def batch_index_documents(documents: List[Document]):
    """批量索引"""
    for batch in chunked(documents, batch_size=100):
        embeddings = embedding_engine.encode([d.content for d in batch])
        await vector_db.batch_insert(batch, embeddings)
```

---

## 四、失败重试机制

### 4.1 重试策略

```python
from tenacity import retry, stop_after_attempt, wait_exponential

class VectorizationWorker:
    """向量化工作者"""
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10)
    )
    async def vectorize(self, document: Document):
        """向量化（带重试）"""
        try:
            await self.rag_service.vectorize_document(document)
        except Exception as e:
            logger.error(f"向量化失败: {e}")
            raise
```

---

**文档版本**: v1.0  
**创建时间**: 2025-10-21

