# LangGraph Agent 工作流架构

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段
> **负责人**: AI架构组

---

## 📋 文档概述

本文档详细设计基于 LangGraph 的 Agent 工作流架构，包括 State Schema 设计、Agent 节点定义、条件路由、并行执行、错误恢复等核心机制。

**适用范围**：
- LangGraph 工作流架构
- State Schema 设计
- Agent 节点实现
- 条件路由和循环控制
- 工作流可视化和调试

---

## 🎯 设计目标

### 核心目标

1. **清晰的状态管理**：使用 TypedDict 定义显式状态
2. **灵活的流程控制**：支持条件分支、循环、并行
3. **可追踪性**：每个节点的输入输出都可追踪
4. **可调试性**：支持断点调试和状态检查
5. **可扩展性**：易于添加新节点和新工作流

### 非目标

- ❌ 不实现业务逻辑（由 Tool 完成）
- ❌ 不直接操作数据库（调用 Go API）

---

## 一、State Schema 设计

### 1.1 基础 State

```python
# src/core/agents/states/base_state.py
from typing import TypedDict, Annotated, Sequence, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator
from dataclasses import dataclass


class BaseAgentState(TypedDict):
    """Agent 基础状态"""
    
    # 输入
    task: str                                    # 任务描述
    user_id: str                                 # 用户 ID
    project_id: str                              # 项目 ID
    
    # 消息历史（自动累积）
    messages: Annotated[Sequence[BaseMessage], operator.add]
    
    # 工作流控制
    current_step: str                            # 当前步骤
    max_iterations: int                          # 最大迭代次数
    iteration_count: int                         # 当前迭代次数
    
    # 错误处理
    errors: Annotated[List[str], operator.add]   # 错误列表
    warnings: Annotated[List[str], operator.add] # 警告列表
    
    # 推理过程
    reasoning: Annotated[List[str], operator.add] # 推理步骤
    
    # 元数据
    metadata: Dict[str, Any]                     # 元数据


# Custom Reducer 示例
def merge_dict_values(current: Dict[str, Any], new: Dict[str, Any]) -> Dict[str, Any]:
    """合并字典值"""
    result = current.copy()
    result.update(new)
    return result
```

### 1.2 Creative Agent State

```python
# src/core/agents/states/creative_state.py
from typing import TypedDict, Annotated, Sequence, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator


class CreativeAgentState(TypedDict):
    """创作 Agent 状态"""
    
    # ===== 输入 =====
    task: str                                    # 创作任务
    user_id: str
    project_id: str
    
    # 创作约束
    constraints: Dict[str, Any]                  # 创作约束（字数、类型等）
    context: Dict[str, Any]                      # 上下文信息
    
    # ===== 消息和推理 =====
    messages: Annotated[Sequence[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]
    
    # ===== 工作流状态 =====
    current_step: str                            # 当前步骤
    plan: List[Dict[str, Any]]                   # 执行计划
    current_plan_index: int                      # 当前计划索引
    
    # ===== RAG 检索 =====
    rag_results: List[Dict[str, Any]]           # RAG 检索结果
    retrieved_context: str                       # 检索到的上下文
    
    # ===== 生成内容 =====
    generated_content: str                       # 生成的内容
    content_draft: str                           # 内容草稿
    
    # ===== 工具调用 =====
    tool_calls: Annotated[List[Dict[str, Any]], operator.add]
    tools_to_use: List[str]                      # 待使用的工具
    
    # ===== 审核和迭代 =====
    review_result: Optional[Dict[str, Any]]      # 审核结果
    review_passed: bool                          # 审核是否通过
    retry_count: int                             # 重试次数
    max_retries: int                             # 最大重试次数
    
    # ===== 最终输出 =====
    final_output: str                            # 最终输出
    output_metadata: Dict[str, Any]              # 输出元数据
    
    # ===== 错误处理 =====
    errors: Annotated[List[str], operator.add]
    warnings: Annotated[List[str], operator.add]
    
    # ===== 性能指标 =====
    start_time: float                            # 开始时间
    tokens_used: int                             # Token 使用量
```

### 1.3 Outline Agent State

```python
# src/core/agents/states/outline_state.py
from typing import TypedDict, Annotated, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator


class OutlineAgentState(TypedDict):
    """大纲 Agent 状态"""
    
    # 输入
    task: str                                    # 任务描述
    user_id: str
    project_id: str
    
    # 大纲需求
    outline_requirements: Dict[str, Any]         # 大纲需求（章节数、结构等）
    genre: str                                   # 小说类型
    target_audience: str                         # 目标读者
    
    # 消息和推理
    messages: Annotated[Sequence[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]
    
    # RAG 检索
    rag_results: List[Dict[str, Any]]           # RAG 检索结果（参考大纲）
    
    # 大纲生成
    outline_structure: List[Dict[str, Any]]      # 大纲结构（树形）
    outline_summary: str                         # 大纲总结
    chapter_count: int                           # 章节数
    
    # 工具调用
    tool_calls: Annotated[List[Dict[str, Any]], operator.add]
    
    # 审核
    review_result: Optional[Dict[str, Any]]
    review_passed: bool
    retry_count: int
    max_retries: int
    
    # 输出
    final_outline: List[Dict[str, Any]]          # 最终大纲
    
    # 错误处理
    errors: Annotated[List[str], operator.add]
```

---

## 二、Agent 节点实现

### 2.1 Understanding Node（理解任务节点）

```python
# src/core/agents/nodes/understanding.py
from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


async def understand_task_node(state: CreativeAgentState) -> CreativeAgentState:
    """理解任务节点
    
    职责：
    1. 分析用户任务
    2. 提取关键要素
    3. 制定执行计划
    
    Args:
        state: 当前状态
        
    Returns:
        更新后的状态
    """
    logger.info("Understanding task...", task=state["task"][:100])
    
    # 初始化 LLM
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    # 构建 Prompt
    system_message = SystemMessage(content="""
你是一个专业的写作助手。你的任务是理解用户的创作需求，并制定详细的执行计划。

请分析用户的任务，提取以下信息：
1. 任务类型（续写、创作、改写等）
2. 关键要素（角色、情节、场景等）
3. 创作约束（字数、风格、类型等）
4. 所需工具（角色卡、大纲、RAG 检索等）

输出格式：JSON
{
  "task_type": "任务类型",
  "key_elements": ["要素1", "要素2"],
  "constraints": {"字数": 1000, "风格": "悬疑"},
  "required_tools": ["rag_tool", "character_tool"],
  "plan": [
    {"step": "检索相关设定", "tool": "rag_tool"},
    {"step": "查询角色信息", "tool": "character_tool"},
    {"step": "生成内容", "tool": "llm"}
  ]
}
""")
    
    user_message = HumanMessage(content=f"""
任务：{state['task']}

项目 ID：{state['project_id']}
用户 ID：{state['user_id']}

请分析这个任务并制定执行计划。
""")
    
    # 调用 LLM
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析响应
    import json
    try:
        analysis = json.loads(response.content)
    except:
        analysis = {
            "task_type": "general",
            "key_elements": [],
            "constraints": {},
            "required_tools": ["rag_tool"],
            "plan": [
                {"step": "检索相关信息", "tool": "rag_tool"},
                {"step": "生成内容", "tool": "llm"}
            ]
        }
    
    # 更新状态
    return {
        **state,
        "messages": state["messages"] + [system_message, user_message, response],
        "plan": analysis.get("plan", []),
        "current_plan_index": 0,
        "constraints": analysis.get("constraints", {}),
        "tools_to_use": analysis.get("required_tools", []),
        "reasoning": state["reasoning"] + [
            f"任务分析完成：{analysis.get('task_type')}",
            f"关键要素：{', '.join(analysis.get('key_elements', []))}",
            f"执行计划：{len(analysis.get('plan', []))} 个步骤"
        ],
        "current_step": "rag_retrieval"
    }
```

### 2.2 RAG Retrieval Node（RAG 检索节点）

```python
# src/core/agents/nodes/retrieval.py
from typing import Dict, Any
from core.agents.states.creative_state import CreativeAgentState
from core.tools.langchain.rag_tool import RAGTool
from utils.logging import get_logger

logger = get_logger(__name__)


async def rag_retrieval_node(state: CreativeAgentState) -> CreativeAgentState:
    """RAG 检索节点
    
    职责：
    1. 构建检索查询
    2. 调用 RAG Tool
    3. 组织检索结果
    
    Args:
        state: 当前状态
        
    Returns:
        更新后的状态
    """
    logger.info("Retrieving relevant knowledge...")
    
    # 检查是否需要 RAG
    if "rag_tool" not in state.get("tools_to_use", []):
        logger.info("RAG not required, skipping...")
        return {
            **state,
            "current_step": "generation",
            "reasoning": state["reasoning"] + ["跳过 RAG 检索"]
        }
    
    # 构建查询（从任务中提取关键词）
    query = state["task"]
    
    # 调用 RAG Tool
    rag_tool = state.get("_rag_tool")  # 从工作流上下文获取
    
    if rag_tool:
        result = await rag_tool.execute(
            params={
                "query": query,
                "project_id": state["project_id"],
                "content_types": ["character", "setting", "outline"],
                "top_k": 5,
                "enable_rerank": True
            },
            user_id=state["user_id"],
            project_id=state["project_id"]
        )
        
        if result.success:
            rag_results = result.data.get("results", [])
            
            # 组织检索结果为上下文
            context_parts = []
            for i, res in enumerate(rag_results, 1):
                context_parts.append(f"""
【参考资料 {i}】（类型：{res.get('content_type')}）
{res.get('content', '')}
""")
            
            retrieved_context = "\n".join(context_parts)
            
            return {
                **state,
                "rag_results": rag_results,
                "retrieved_context": retrieved_context,
                "current_step": "generation",
                "reasoning": state["reasoning"] + [
                    f"RAG 检索完成，找到 {len(rag_results)} 条相关资料"
                ]
            }
    
    # RAG 失败，继续执行
    return {
        **state,
        "current_step": "generation",
        "warnings": state.get("warnings", []) + ["RAG 检索失败"],
        "reasoning": state["reasoning"] + ["RAG 检索失败，继续执行"]
    }
```

### 2.3 Generation Node（生成节点）

```python
# src/core/agents/nodes/generation.py
from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


async def generation_node(state: CreativeAgentState) -> CreativeAgentState:
    """生成节点
    
    职责：
    1. 构建增强 Prompt
    2. 调用 LLM 生成内容
    3. 保存生成结果
    
    Args:
        state: 当前状态
        
    Returns:
        更新后的状态
    """
    logger.info("Generating content...")
    
    # 初始化 LLM
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7, max_tokens=2000)
    
    # 构建系统提示
    system_prompt = """
你是一位专业的网络小说作家，擅长创作引人入胜的故事。
请根据用户需求和参考资料，创作高质量的内容。

创作要求：
1. 内容要符合用户的具体要求
2. 保持角色性格一致
3. 情节合理连贯
4. 文笔流畅自然
"""
    
    # 构建用户提示
    user_prompt_parts = [f"创作任务：{state['task']}"]
    
    # 添加 RAG 检索的上下文
    if state.get("retrieved_context"):
        user_prompt_parts.append(f"\n参考资料：\n{state['retrieved_context']}")
    
    # 添加约束条件
    if state.get("constraints"):
        constraints_str = "\n".join([f"- {k}: {v}" for k, v in state["constraints"].items()])
        user_prompt_parts.append(f"\n创作约束：\n{constraints_str}")
    
    user_prompt = "\n".join(user_prompt_parts)
    
    # 调用 LLM
    messages = [
        SystemMessage(content=system_prompt),
        HumanMessage(content=user_prompt)
    ]
    
    response = await llm.ainvoke(messages)
    generated_content = response.content
    
    # 统计 Token 使用
    tokens_used = len(response.content) // 4  # 粗略估计
    
    return {
        **state,
        "messages": state["messages"] + messages + [response],
        "generated_content": generated_content,
        "content_draft": generated_content,
        "tokens_used": state.get("tokens_used", 0) + tokens_used,
        "current_step": "review",
        "reasoning": state["reasoning"] + [
            f"内容生成完成，字数约 {len(generated_content)}"
        ]
    }
```

### 2.4 Review Node（审核节点）

```python
# src/core/agents/nodes/review.py
from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


async def review_node(state: CreativeAgentState) -> CreativeAgentState:
    """审核节点
    
    职责：
    1. 检查生成内容质量
    2. 评估是否符合要求
    3. 提供改进建议
    
    Args:
        state: 当前状态
        
    Returns:
        更新后的状态
    """
    logger.info("Reviewing generated content...")
    
    # 初始化 LLM
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    # 构建审核 Prompt
    system_message = SystemMessage(content="""
你是一位专业的内容审核专家。请评估生成的内容质量。

评估标准：
1. 内容是否符合用户要求
2. 逻辑是否连贯
3. 角色性格是否一致
4. 文笔是否流畅
5. 是否有明显错误

输出格式：JSON
{
  "passed": true/false,
  "score": 85,
  "issues": ["问题1", "问题2"],
  "suggestions": ["建议1", "建议2"],
  "summary": "总体评价"
}
""")
    
    user_message = HumanMessage(content=f"""
原始任务：{state['task']}

生成内容：
{state['generated_content']}

请评估这个内容的质量。
""")
    
    # 调用 LLM
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析审核结果
    import json
    try:
        review_result = json.loads(response.content)
    except:
        # 解析失败，默认通过
        review_result = {
            "passed": True,
            "score": 75,
            "issues": [],
            "suggestions": [],
            "summary": "内容可接受"
        }
    
    passed = review_result.get("passed", False) or review_result.get("score", 0) >= 70
    
    return {
        **state,
        "messages": state["messages"] + [system_message, user_message, response],
        "review_result": review_result,
        "review_passed": passed,
        "current_step": "finalize" if passed else "regenerate",
        "reasoning": state["reasoning"] + [
            f"审核完成：{'通过' if passed else '不通过'}",
            f"评分：{review_result.get('score', 0)}",
            f"问题：{len(review_result.get('issues', []))}"
        ]
    }
```

### 2.5 Finalize Node（最终化节点）

```python
# src/core/agents/nodes/finalize.py
from typing import Dict, Any
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


async def finalize_node(state: CreativeAgentState) -> CreativeAgentState:
    """最终化节点
    
    职责：
    1. 整理最终输出
    2. 添加元数据
    3. 准备返回结果
    
    Args:
        state: 当前状态
        
    Returns:
        更新后的状态
    """
    logger.info("Finalizing output...")
    
    # 构建输出元数据
    output_metadata = {
        "tokens_used": state.get("tokens_used", 0),
        "retry_count": state.get("retry_count", 0),
        "review_score": state.get("review_result", {}).get("score", 0),
        "rag_sources_count": len(state.get("rag_results", [])),
        "tool_calls_count": len(state.get("tool_calls", [])),
        "reasoning_steps": len(state.get("reasoning", []))
    }
    
    return {
        **state,
        "final_output": state["generated_content"],
        "output_metadata": output_metadata,
        "current_step": "completed",
        "reasoning": state["reasoning"] + [
            "任务完成",
            f"总 Token 使用：{output_metadata['tokens_used']}"
        ]
    }
```

---

## 三、条件路由和循环控制

### 3.1 路由函数

```python
# src/core/agents/workflows/routers.py
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


def should_regenerate(state: CreativeAgentState) -> str:
    """决定是否重新生成
    
    Args:
        state: 当前状态
        
    Returns:
        下一个节点名称
    """
    # 如果审核通过，进入最终化
    if state.get("review_passed", False):
        logger.info("Review passed, proceeding to finalize")
        return "finalize"
    
    # 检查重试次数
    retry_count = state.get("retry_count", 0)
    max_retries = state.get("max_retries", 3)
    
    if retry_count >= max_retries:
        logger.warning(f"Max retries ({max_retries}) reached, forcing finalize")
        return "force_finalize"
    
    # 检查严重问题
    review_result = state.get("review_result", {})
    score = review_result.get("score", 0)
    
    if score < 40:
        # 分数太低，需要重新理解任务
        logger.info("Score too low, restarting from understanding")
        return "restart"
    
    # 普通重试，回到生成节点
    logger.info(f"Review failed (score: {score}), regenerating...")
    return "regenerate"


def should_continue_plan(state: CreativeAgentState) -> str:
    """决定是否继续执行计划
    
    Args:
        state: 当前状态
        
    Returns:
        下一个节点名称
    """
    plan = state.get("plan", [])
    current_index = state.get("current_plan_index", 0)
    
    if current_index >= len(plan):
        logger.info("Plan completed, proceeding to generation")
        return "generation"
    
    # 获取当前计划步骤
    current_step = plan[current_index]
    tool = current_step.get("tool", "")
    
    # 根据工具类型路由到不同节点
    if tool == "rag_tool":
        return "rag_retrieval"
    elif tool in ["character_tool", "outline_tool", "timeline_tool"]:
        return "tool_execution"
    else:
        return "generation"


def check_errors(state: CreativeAgentState) -> str:
    """检查是否有严重错误
    
    Args:
        state: 当前状态
        
    Returns:
        下一个节点名称
    """
    errors = state.get("errors", [])
    
    if errors:
        logger.error(f"Errors detected: {len(errors)}")
        return "error_handler"
    
    return "continue"
```

---

## 四、工作流构建

### 4.1 Creative Workflow

```python
# src/core/agents/workflows/creative.py
from langgraph.graph import StateGraph, END
from core.agents.states.creative_state import CreativeAgentState
from core.agents.nodes import (
    understand_task_node,
    rag_retrieval_node,
    generation_node,
    review_node,
    finalize_node
)
from core.agents.workflows.routers import should_regenerate
from utils.logging import get_logger

logger = get_logger(__name__)


def create_creative_workflow():
    """创建创作工作流
    
    Returns:
        编译后的工作流
    """
    logger.info("Creating creative workflow...")
    
    # 创建状态图
    workflow = StateGraph(CreativeAgentState)
    
    # 添加节点
    workflow.add_node("understand", understand_task_node)
    workflow.add_node("rag_retrieval", rag_retrieval_node)
    workflow.add_node("generation", generation_node)
    workflow.add_node("review", review_node)
    workflow.add_node("finalize", finalize_node)
    
    # 添加 regenerate 节点（增加重试计数）
    async def regenerate_node(state: CreativeAgentState) -> CreativeAgentState:
        return {
            **state,
            "retry_count": state.get("retry_count", 0) + 1,
            "reasoning": state["reasoning"] + ["重试生成"]
        }
    workflow.add_node("regenerate", regenerate_node)
    
    # 设置入口点
    workflow.set_entry_point("understand")
    
    # 添加边
    workflow.add_edge("understand", "rag_retrieval")
    workflow.add_edge("rag_retrieval", "generation")
    workflow.add_edge("generation", "review")
    
    # 条件边：审核后的路由
    workflow.add_conditional_edges(
        "review",
        should_regenerate,
        {
            "finalize": "finalize",
            "regenerate": "regenerate",
            "restart": "understand",
            "force_finalize": "finalize"
        }
    )
    
    # regenerate 回到 generation
    workflow.add_edge("regenerate", "generation")
    
    # 最终化后结束
    workflow.add_edge("finalize", END)
    
    # 编译
    app = workflow.compile()
    
    logger.info("Creative workflow created successfully")
    return app
```

### 4.2 工作流可视化

```python
# 生成工作流图
from IPython.display import Image, display

workflow = create_creative_workflow()

# 生成 Mermaid 图
mermaid_png = workflow.get_graph().draw_mermaid_png()

# 保存到文件
with open("creative_workflow.png", "wb") as f:
    f.write(mermaid_png)

# 或在 Jupyter 中显示
display(Image(mermaid_png))
```

生成的流程图：

```
┌──────────────┐
│ understand   │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│rag_retrieval │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ generation   │◄──────────┐
└──────┬───────┘           │
       │                   │
       ▼                   │
┌──────────────┐           │
│   review     │           │
└──────┬───────┘           │
       │                   │
       ├───(不通过)────────┤
       │              regenerate
       │
       ├───(通过)──────►┌──────────┐
                       │ finalize │
                       └────┬─────┘
                            │
                            ▼
                          [END]
```

---

## 五、并行执行

### 5.1 并行节点示例

```python
# src/core/agents/workflows/parallel_example.py
from langgraph.graph import StateGraph, END
from typing import TypedDict, Annotated, List
import operator


class ParallelState(TypedDict):
    """并行执行状态"""
    task: str
    character_info: str
    setting_info: str
    outline_info: str
    combined_context: str


async def fetch_character_node(state: ParallelState) -> ParallelState:
    """获取角色信息（并行）"""
    # 模拟并行获取
    character_info = "角色信息..."
    return {**state, "character_info": character_info}


async def fetch_setting_node(state: ParallelState) -> ParallelState:
    """获取设定信息（并行）"""
    setting_info = "设定信息..."
    return {**state, "setting_info": setting_info}


async def fetch_outline_node(state: ParallelState) -> ParallelState:
    """获取大纲信息（并行）"""
    outline_info = "大纲信息..."
    return {**state, "outline_info": outline_info}


async def combine_node(state: ParallelState) -> ParallelState:
    """汇聚节点"""
    combined = f"{state['character_info']}\n{state['setting_info']}\n{state['outline_info']}"
    return {**state, "combined_context": combined}


def create_parallel_workflow():
    """创建并行工作流"""
    workflow = StateGraph(ParallelState)
    
    # 添加并行节点
    workflow.add_node("fetch_character", fetch_character_node)
    workflow.add_node("fetch_setting", fetch_setting_node)
    workflow.add_node("fetch_outline", fetch_outline_node)
    workflow.add_node("combine", combine_node)
    
    # 设置入口（并行起点）
    workflow.set_entry_point("fetch_character")
    workflow.set_entry_point("fetch_setting")
    workflow.set_entry_point("fetch_outline")
    
    # 并行节点都指向汇聚点
    workflow.add_edge("fetch_character", "combine")
    workflow.add_edge("fetch_setting", "combine")
    workflow.add_edge("fetch_outline", "combine")
    
    # 汇聚后结束
    workflow.add_edge("combine", END)
    
    return workflow.compile()
```

---

## 六、错误恢复和降级

### 6.1 错误处理节点

```python
# src/core/agents/nodes/error_handler.py
from core.agents.states.creative_state import CreativeAgentState
from utils.logging import get_logger

logger = get_logger(__name__)


async def error_handler_node(state: CreativeAgentState) -> CreativeAgentState:
    """错误处理节点
    
    职责：
    1. 分析错误类型
    2. 尝试恢复
    3. 降级处理
    """
    errors = state.get("errors", [])
    
    logger.error(f"Handling errors: {len(errors)}")
    
    # 分析错误类型
    critical_errors = [e for e in errors if "critical" in e.lower()]
    
    if critical_errors:
        # 严重错误，无法恢复
        return {
            **state,
            "final_output": "抱歉，遇到严重错误，无法完成任务。",
            "output_metadata": {"error": True, "errors": errors},
            "current_step": "completed"
        }
    
    # 非严重错误，尝试降级处理
    # 使用更简单的策略重新生成
    return {
        **state,
        "retry_count": 0,
        "max_retries": 1,  # 降级：减少重试次数
        "tools_to_use": [],  # 降级：不使用工具
        "current_step": "generation",
        "reasoning": state["reasoning"] + [
            "遇到错误，尝试降级处理",
            "移除工具调用，直接生成"
        ]
    }
```

---

## 七、断点调试和状态检查

### 7.1 Human-in-the-Loop

```python
# src/core/agents/workflows/human_in_loop.py
from langgraph.graph import interrupt


async def human_review_node(state: CreativeAgentState) -> CreativeAgentState:
    """人工审核节点（中断等待）"""
    
    # 中断工作流，等待人工输入
    human_feedback = interrupt({
        "message": "请审核生成的内容",
        "content": state["generated_content"],
        "review_result": state.get("review_result")
    })
    
    # 根据人工反馈决定下一步
    if human_feedback.get("approved"):
        return {
            **state,
            "review_passed": True,
            "reasoning": state["reasoning"] + ["人工审核：通过"]
        }
    else:
        feedback = human_feedback.get("feedback", "")
        return {
            **state,
            "review_passed": False,
            "constraints": {
                **state.get("constraints", {}),
                "human_feedback": feedback
            },
            "reasoning": state["reasoning"] + [f"人工审核：不通过 - {feedback}"]
        }
```

### 7.2 Checkpointer（状态持久化）

```python
# src/core/agents/workflows/checkpointer_example.py
from langgraph.checkpoint.postgres import PostgresSaver

# 创建 Checkpointer
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/qingyu_db"
)

# 编译工作流时传入
app = workflow.compile(checkpointer=checkpointer)

# 执行时指定 thread_id
result = await app.ainvoke(
    initial_state,
    config={"configurable": {"thread_id": "user123_session001"}}
)

# 恢复工作流
continued_result = await app.ainvoke(
    None,  # 自动从 checkpoint 加载
    config={"configurable": {"thread_id": "user123_session001"}}
)
```

---

## 八、监控和调试

### 8.1 事件追踪

```python
# 使用 astream_events 追踪执行过程
async for event in app.astream_events(initial_state, version="v1"):
    print(f"Event: {event['event']}")
    print(f"Name: {event.get('name')}")
    print(f"Data: {event.get('data')}")
    print("---")
```

### 8.2 状态检查

```python
# 获取所有 checkpoint
history = checkpointer.list(
    config={"configurable": {"thread_id": "session001"}}
)

for checkpoint in history:
    print(f"Step: {checkpoint.step}")
    print(f"State: {checkpoint.state}")
    print(f"Current Step: {checkpoint.state.get('current_step')}")
```

---

## 九、总结

本文档详细设计了基于 LangGraph 的 Agent 工作流架构，包括：

- ✅ 清晰的 State Schema 设计（TypedDict）
- ✅ 完整的节点实现（理解、检索、生成、审核、最终化）
- ✅ 灵活的条件路由和循环控制
- ✅ 并行执行支持
- ✅ 完善的错误恢复和降级机制
- ✅ 人工介入和状态持久化
- ✅ 工作流可视化和调试

**关键特性**：
- 显式状态管理（TypedDict + Annotated）
- 声明式流程定义
- 支持条件分支、循环、并行
- 完整的可观测性
- 易于扩展和测试

**后续工作**：
- 实现具体的 A2A 创作流水线
- 完善错误处理和降级策略
- 性能优化和测试

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
