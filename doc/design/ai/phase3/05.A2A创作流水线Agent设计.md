# A2A 创作流水线 Agent 设计

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段
> **负责人**: AI架构组

---

## 📋 文档概述

本文档详细设计 A2A（Agent-to-Agent）创作流水线，包括四个专业 Agent（大纲 Agent、角色 Agent、情节 Agent、审核 Agent）的实现和流水线编排策略。

**适用范围**：
- A2A 创作流水线架构
- 四个专业 Agent 设计
- Agent 间协作机制
- 迭代优化循环
- 人工介入策略

---

## 🎯 设计目标

### 核心目标

1. **职责清晰**：每个 Agent 专注一个领域
2. **顺序协作**：大纲 → 角色 → 情节 → 审核
3. **迭代优化**：支持多轮优化循环
4. **可追溯性**：每个 Agent 的输入输出可追踪
5. **人工介入**：关键节点支持人工审核

### A2A 优势

- ✅ **专业化**：每个 Agent 专注一个任务，提高质量
- ✅ **可维护**：模块化设计，易于调试和优化
- ✅ **可扩展**：易于添加新 Agent（如风格 Agent）
- ✅ **可控**：显式流程，易于控制和监控

---

## 一、A2A 流水线架构

### 1.1 整体流程

```
┌─────────────┐
│ 用户需求    │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────┐
│            大纲 Agent                    │
│  - 分析需求                             │
│  - RAG 检索参考大纲                     │
│  - 生成章节结构                         │
│  - 输出：结构化大纲树                   │
└──────┬──────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│            角色 Agent                    │
│  - 基于大纲提取角色需求                 │
│  - RAG 检索现有角色                     │
│  - 生成新角色 / 更新现有角色            │
│  - 建立角色关系图                       │
│  - 输出：角色卡 + 关系图                │
└──────┬──────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│            情节 Agent                    │
│  - 基于大纲 + 角色生成情节节点          │
│  - 创建时间线事件                       │
│  - 安排关键场景                         │
│  - 输出：时间线 + 情节节点              │
└──────┬──────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│            审核 Agent                    │
│  - 检查大纲、角色、情节的一致性         │
│  - 评估质量                             │
│  - 提供改进建议                         │
│  - 决策：通过 / 重新生成 / 人工审核     │
└──────┬──────────────────────────────────┘
       │
       ├───[不通过]───► 重新生成（回到对应Agent）
       │
       ├───[需人工]───► 等待人工审核
       │
       ▼
   [完成输出]
```

### 1.2 Pipeline State Schema

```python
# src/core/agents/states/pipeline_state.py
from typing import TypedDict, Annotated, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator


class PipelineState(TypedDict):
    """A2A 流水线状态"""
    
    # ===== 输入 =====
    user_requirement: str                        # 用户需求
    user_id: str
    project_id: str
    
    # 流水线配置
    pipeline_config: Dict[str, Any]              # 流水线配置
    
    # ===== 大纲 Agent 输出 =====
    outline_nodes: List[Dict[str, Any]]          # 大纲节点列表
    outline_summary: str                         # 大纲总结
    outline_metadata: Dict[str, Any]             # 大纲元数据
    
    # ===== 角色 Agent 输出 =====
    characters: List[Dict[str, Any]]             # 角色列表
    character_relations: List[Dict[str, Any]]    # 角色关系列表
    character_summary: str                       # 角色总结
    
    # ===== 情节 Agent 输出 =====
    timeline_events: List[Dict[str, Any]]        # 时间线事件列表
    plot_nodes: List[Dict[str, Any]]             # 情节节点列表
    plot_summary: str                            # 情节总结
    
    # ===== 审核 Agent 输出 =====
    review_results: Dict[str, Any]               # 审核结果
    consistency_check: Dict[str, Any]            # 一致性检查
    quality_score: int                           # 质量评分（0-100）
    review_passed: bool                          # 是否通过
    improvement_suggestions: List[str]           # 改进建议
    
    # ===== 工作流控制 =====
    current_agent: str                           # 当前 Agent
    completed_agents: Annotated[List[str], operator.add]  # 已完成的 Agent
    
    # 迭代控制
    iteration_count: int                         # 迭代次数
    max_iterations: int                          # 最大迭代次数
    
    # 人工介入
    human_intervention_required: bool            # 是否需要人工介入
    human_feedback: Optional[str]                # 人工反馈
    
    # ===== 消息和推理 =====
    messages: Annotated[List[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]
    
    # ===== 错误处理 =====
    errors: Annotated[List[str], operator.add]
    warnings: Annotated[List[str], operator.add]
    
    # ===== 性能指标 =====
    start_time: float
    tokens_used: int
    tool_calls_count: int
```

---

## 二、专业 Agent 实现

### 2.1 大纲 Agent

```python
# src/core/agents/nodes/outline_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.outline_tool import OutlineTool
from core.tools.langchain.rag_tool import RAGTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def outline_agent_node(state: PipelineState) -> PipelineState:
    """大纲 Agent
    
    职责：
    1. 分析用户需求
    2. RAG 检索参考大纲
    3. 生成章节结构
    4. 创建大纲节点
    
    Args:
        state: 流水线状态
        
    Returns:
        更新后的状态
    """
    logger.info("Outline Agent: Starting outline generation...")
    
    user_requirement = state["user_requirement"]
    project_id = state["project_id"]
    
    # ===== Step 1: RAG 检索参考大纲 =====
    rag_tool = state.get("_rag_tool")
    reference_outlines = []
    
    if rag_tool:
        rag_result = await rag_tool.execute(
            params={
                "query": f"小说大纲 {user_requirement}",
                "project_id": project_id,
                "content_types": ["outline"],
                "top_k": 3
            },
            user_id=state["user_id"],
            project_id=project_id
        )
        
        if rag_result.success:
            reference_outlines = rag_result.data.get("results", [])
    
    # ===== Step 2: 生成大纲结构 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
你是一位专业的小说大纲策划师。你的任务是根据用户需求生成一个完整、合理的小说大纲。

大纲要求：
1. 章节结构清晰（卷 → 章 → 节）
2. 每个章节有明确的目标和冲突
3. 情节发展合理连贯
4. 节奏控制得当

输出格式：JSON 数组
[
  {
    "level": 1,
    "name": "第一卷：起始",
    "description": "故事开端，主角出场",
    "children": [
      {
        "level": 2,
        "name": "第一章：命运之门",
        "description": "主角发现神秘之门",
        "goals": ["引入主角", "设置悬念"],
        "conflicts": ["主角内心挣扎"],
        "children": []
      }
    ]
  }
]
""")
    
    # 构建参考资料
    reference_text = ""
    if reference_outlines:
        reference_text = "\n参考大纲：\n"
        for i, ref in enumerate(reference_outlines, 1):
            reference_text += f"\n【参考{i}】{ref.get('content', '')[:200]}\n"
    
    user_message = HumanMessage(content=f"""
用户需求：{user_requirement}

{reference_text}

请生成一个完整的小说大纲（JSON格式）。
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析大纲结构
    try:
        outline_structure = json.loads(response.content)
    except:
        # 解析失败，使用默认结构
        outline_structure = [
            {
                "level": 1,
                "name": "第一卷",
                "description": "开篇",
                "children": [
                    {
                        "level": 2,
                        "name": "第一章",
                        "description": "起始",
                        "children": []
                    }
                ]
            }
        ]
    
    # ===== Step 3: 调用 OutlineTool 创建节点 =====
    outline_tool = state.get("_outline_tool")
    created_nodes = []
    
    if outline_tool:
        created_nodes = await _create_outline_nodes_recursive(
            outline_tool,
            outline_structure,
            project_id,
            parent_id=None,
            user_id=state["user_id"]
        )
    
    # ===== Step 4: 生成大纲总结 =====
    outline_summary = f"生成大纲：共 {len(created_nodes)} 个节点"
    
    return {
        **state,
        "outline_nodes": created_nodes,
        "outline_summary": outline_summary,
        "outline_metadata": {
            "node_count": len(created_nodes),
            "reference_count": len(reference_outlines)
        },
        "current_agent": "character_agent",
        "completed_agents": state.get("completed_agents", []) + ["outline_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"大纲 Agent：分析用户需求",
            f"大纲 Agent：检索到 {len(reference_outlines)} 个参考大纲",
            f"大纲 Agent：生成 {len(created_nodes)} 个大纲节点"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_nodes)
    }


async def _create_outline_nodes_recursive(
    outline_tool: OutlineTool,
    nodes: List[Dict[str, Any]],
    project_id: str,
    parent_id: Optional[str],
    user_id: str
) -> List[Dict[str, Any]]:
    """递归创建大纲节点"""
    created = []
    
    for node in nodes:
        # 创建当前节点
        result = await outline_tool.execute(
            params={
                "action": "create_node",
                "project_id": project_id,
                "parent_id": parent_id or "",
                "name": node["name"],
                "description": node.get("description", ""),
                "metadata": {
                    "level": node.get("level", 1),
                    "goals": node.get("goals", []),
                    "conflicts": node.get("conflicts", [])
                }
            },
            user_id=user_id,
            project_id=project_id
        )
        
        if result.success:
            node_data = result.data
            created.append(node_data)
            
            # 递归创建子节点
            if node.get("children"):
                children = await _create_outline_nodes_recursive(
                    outline_tool,
                    node["children"],
                    project_id,
                    parent_id=node_data.get("id"),
                    user_id=user_id
                )
                created.extend(children)
    
    return created
```

### 2.2 角色 Agent

```python
# src/core/agents/nodes/character_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.character_tool import CharacterTool
from core.tools.langchain.relation_tool import RelationTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def character_agent_node(state: PipelineState) -> PipelineState:
    """角色 Agent
    
    职责：
    1. 基于大纲提取角色需求
    2. RAG 检索现有角色
    3. 生成新角色卡
    4. 建立角色关系
    
    Args:
        state: 流水线状态
        
    Returns:
        更新后的状态
    """
    logger.info("Character Agent: Starting character generation...")
    
    outline_summary = state.get("outline_summary", "")
    outline_nodes = state.get("outline_nodes", [])
    project_id = state["project_id"]
    
    # ===== Step 1: 分析大纲，提取角色需求 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
你是一位专业的角色设计师。你的任务是根据小说大纲设计角色。

角色设计要求：
1. 主角、配角、反派齐全
2. 性格鲜明，有独特标签
3. 背景合理，符合大纲设定
4. 角色间关系清晰

输出格式：JSON
{
  "characters": [
    {
      "name": "张三",
      "role_type": "protagonist",  // protagonist, supporting, antagonist
      "summary": "热血少年，正义感强",
      "traits": ["勇敢", "善良", "冲动"],
      "background": "平凡家庭出身...",
      "personality_prompt": "性格开朗，喜欢帮助他人",
      "speech_pattern": "说话直率，不拐弯抹角"
    }
  ],
  "relations": [
    {
      "from": "张三",
      "to": "李四",
      "type": "朋友",
      "strength": 80,
      "notes": "从小一起长大的好友"
    }
  ]
}
""")
    
    # 构建大纲摘要
    outline_text = f"大纲总结：{outline_summary}\n\n"
    outline_text += "大纲节点：\n"
    for node in outline_nodes[:5]:  # 只取前5个节点
        outline_text += f"- {node.get('name')}: {node.get('description', '')}\n"
    
    user_message = HumanMessage(content=f"""
{outline_text}

请根据大纲设计角色（JSON格式）。
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析角色数据
    try:
        character_data = json.loads(response.content)
        character_designs = character_data.get("characters", [])
        relation_designs = character_data.get("relations", [])
    except:
        character_designs = []
        relation_designs = []
    
    # ===== Step 2: 调用 CharacterTool 创建角色 =====
    character_tool = state.get("_character_tool")
    created_characters = []
    
    if character_tool:
        for char_design in character_designs:
            result = await character_tool.execute(
                params={
                    "action": "create",
                    "project_id": project_id,
                    "name": char_design["name"],
                    "summary": char_design.get("summary", ""),
                    "traits": char_design.get("traits", []),
                    "background": char_design.get("background", ""),
                    "personality_prompt": char_design.get("personality_prompt", ""),
                    "speech_pattern": char_design.get("speech_pattern", "")
                },
                user_id=state["user_id"],
                project_id=project_id
            )
            
            if result.success:
                created_characters.append(result.data)
    
    # ===== Step 3: 建立角色关系 =====
    relation_tool = state.get("_relation_tool")
    created_relations = []
    
    if relation_tool and len(created_characters) >= 2:
        # 构建角色名到 ID 的映射
        name_to_id = {char["name"]: char["id"] for char in created_characters}
        
        for relation_design in relation_designs:
            from_id = name_to_id.get(relation_design["from"])
            to_id = name_to_id.get(relation_design["to"])
            
            if from_id and to_id:
                result = await relation_tool.execute(
                    params={
                        "action": "create",
                        "project_id": project_id,
                        "from_id": from_id,
                        "to_id": to_id,
                        "relation_type": relation_design.get("type", "其他"),
                        "strength": relation_design.get("strength", 50),
                        "notes": relation_design.get("notes", "")
                    },
                    user_id=state["user_id"],
                    project_id=project_id
                )
                
                if result.success:
                    created_relations.append(result.data)
    
    # ===== Step 4: 生成角色总结 =====
    character_summary = f"创建 {len(created_characters)} 个角色，{len(created_relations)} 个关系"
    
    return {
        **state,
        "characters": created_characters,
        "character_relations": created_relations,
        "character_summary": character_summary,
        "current_agent": "plot_agent",
        "completed_agents": state.get("completed_agents", []) + ["character_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"角色 Agent：分析大纲",
            f"角色 Agent：设计 {len(character_designs)} 个角色",
            f"角色 Agent：创建 {len(created_characters)} 个角色卡",
            f"角色 Agent：建立 {len(created_relations)} 个关系"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_characters) + len(created_relations)
    }
```

### 2.3 情节 Agent

```python
# src/core/agents/nodes/plot_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.timeline_tool import TimelineTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def plot_agent_node(state: PipelineState) -> PipelineState:
    """情节 Agent
    
    职责：
    1. 基于大纲 + 角色生成情节
    2. 创建时间线事件
    3. 安排关键场景
    
    Args:
        state: 流水线状态
        
    Returns:
        更新后的状态
    """
    logger.info("Plot Agent: Starting plot generation...")
    
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    project_id = state["project_id"]
    
    # ===== Step 1: 生成时间线 =====
    timeline_tool = state.get("_timeline_tool")
    timeline_id = None
    
    if timeline_tool:
        result = await timeline_tool.execute(
            params={
                "action": "create_timeline",
                "project_id": project_id,
                "timeline_name": "主线时间线",
                "timeline_description": "小说主要情节时间线"
            },
            user_id=state["user_id"],
            project_id=project_id
        )
        
        if result.success:
            timeline_id = result.data.get("id")
    
    # ===== Step 2: 基于大纲和角色生成情节事件 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
你是一位专业的情节设计师。你的任务是根据大纲和角色设计情节事件。

情节设计要求：
1. 事件符合大纲章节目标
2. 角色行为符合性格
3. 冲突和高潮安排合理
4. 时间线清晰连贯

输出格式：JSON
{
  "events": [
    {
      "title": "主角觉醒",
      "description": "主角在危机中觉醒特殊能力",
      "event_type": "plot",  // plot, character, milestone
      "importance": 9,
      "participants": ["张三", "李四"],
      "chapter_ref": "第一章",
      "story_time": {"day": 1, "time": "清晨"}
    }
  ]
}
""")
    
    # 构建上下文
    context = f"大纲节点数：{len(outline_nodes)}\n"
    context += f"角色：{', '.join([c['name'] for c in characters])}\n\n"
    context += "大纲摘要：\n"
    for node in outline_nodes[:10]:
        context += f"- {node.get('name')}\n"
    
    user_message = HumanMessage(content=f"""
{context}

请根据大纲和角色设计情节事件（JSON格式）。
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析事件数据
    try:
        plot_data = json.loads(response.content)
        event_designs = plot_data.get("events", [])
    except:
        event_designs = []
    
    # ===== Step 3: 创建时间线事件 =====
    created_events = []
    
    if timeline_tool and timeline_id:
        # 构建角色名到 ID 的映射
        name_to_id = {char["name"]: char["id"] for char in characters}
        
        for event_design in event_designs:
            # 转换参与者名称为 ID
            participant_ids = [
                name_to_id[name]
                for name in event_design.get("participants", [])
                if name in name_to_id
            ]
            
            result = await timeline_tool.execute(
                params={
                    "action": "create_event",
                    "project_id": project_id,
                    "timeline_id": timeline_id,
                    "title": event_design["title"],
                    "description": event_design.get("description", ""),
                    "event_type": event_design.get("event_type", "plot"),
                    "importance": event_design.get("importance", 5),
                    "participants": participant_ids,
                    "story_time": event_design.get("story_time")
                },
                user_id=state["user_id"],
                project_id=project_id
            )
            
            if result.success:
                created_events.append(result.data)
    
    # ===== Step 4: 生成情节总结 =====
    plot_summary = f"创建 {len(created_events)} 个时间线事件"
    
    return {
        **state,
        "timeline_events": created_events,
        "plot_summary": plot_summary,
        "current_agent": "review_agent",
        "completed_agents": state.get("completed_agents", []) + ["plot_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"情节 Agent：分析大纲和角色",
            f"情节 Agent：设计 {len(event_designs)} 个情节事件",
            f"情节 Agent：创建时间线事件 {len(created_events)} 个"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_events) + 1  # +1 for timeline creation
    }
```

### 2.4 审核 Agent

```python
# src/core/agents/nodes/review_agent.py
from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def review_agent_node(state: PipelineState) -> PipelineState:
    """审核 Agent
    
    职责：
    1. 检查大纲、角色、情节的一致性
    2. 评估质量
    3. 提供改进建议
    4. 决策：通过 / 重新生成 / 人工审核
    
    Args:
        state: 流水线状态
        
    Returns:
        更新后的状态
    """
    logger.info("Review Agent: Starting review...")
    
    outline_summary = state.get("outline_summary", "")
    character_summary = state.get("character_summary", "")
    plot_summary = state.get("plot_summary", "")
    
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    timeline_events = state.get("timeline_events", [])
    
    # ===== Step 1: 一致性检查 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    system_message = SystemMessage(content="""
你是一位专业的内容审核专家。你的任务是评估小说创作内容的质量和一致性。

审核标准：
1. 一致性：大纲、角色、情节是否一致
2. 完整性：是否缺少关键元素
3. 合理性：设定是否合理
4. 质量：内容质量是否达标

输出格式：JSON
{
  "passed": true/false,
  "quality_score": 85,
  "consistency_check": {
    "outline_character_consistency": "good",  // good, fair, poor
    "character_plot_consistency": "good",
    "logical_consistency": "fair"
  },
  "issues": [
    {"severity": "high", "type": "consistency", "description": "角色A在大纲中未提及"},
    {"severity": "medium", "type": "quality", "description": "情节发展过于仓促"}
  ],
  "suggestions": [
    "建议在大纲中补充角色A的出场",
    "建议增加过渡情节"
  ],
  "decision": "pass",  // pass, regenerate, human_review
  "decision_reason": "整体质量良好，小问题可后期修正"
}
""")
    
    # 构建审核内容
    review_content = f"""
【大纲】
- 节点数：{len(outline_nodes)}
- 总结：{outline_summary}
- 前3个节点：{', '.join([n.get('name', '') for n in outline_nodes[:3]])}

【角色】
- 角色数：{len(characters)}
- 总结：{character_summary}
- 角色列表：{', '.join([c.get('name', '') for c in characters])}

【情节】
- 事件数：{len(timeline_events)}
- 总结：{plot_summary}
- 前3个事件：{', '.join([e.get('title', '') for e in timeline_events[:3]])}
"""
    
    user_message = HumanMessage(content=f"""
{review_content}

请审核以上内容（JSON格式）。
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析审核结果
    try:
        review_result = json.loads(response.content)
    except:
        # 解析失败，默认通过
        review_result = {
            "passed": True,
            "quality_score": 75,
            "consistency_check": {},
            "issues": [],
            "suggestions": [],
            "decision": "pass",
            "decision_reason": "审核通过"
        }
    
    passed = review_result.get("passed", False)
    quality_score = review_result.get("quality_score", 0)
    decision = review_result.get("decision", "pass")
    
    # 决定下一步
    if decision == "human_review":
        human_intervention_required = True
        current_agent = "human_review"
    elif decision == "regenerate" or quality_score < 60:
        human_intervention_required = False
        current_agent = "regenerate"
    else:
        human_intervention_required = False
        current_agent = "completed"
    
    return {
        **state,
        "review_results": review_result,
        "consistency_check": review_result.get("consistency_check", {}),
        "quality_score": quality_score,
        "review_passed": passed,
        "improvement_suggestions": review_result.get("suggestions", []),
        "human_intervention_required": human_intervention_required,
        "current_agent": current_agent,
        "completed_agents": state.get("completed_agents", []) + ["review_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"审核 Agent：质量评分 {quality_score}",
            f"审核 Agent：发现 {len(review_result.get('issues', []))} 个问题",
            f"审核 Agent：决策 - {decision}"
        ]
    }
```

---

## 三、流水线编排

### 3.1 A2A Workflow

```python
# src/core/agents/workflows/a2a_pipeline.py
from langgraph.graph import StateGraph, END
from core.agents.states.pipeline_state import PipelineState
from core.agents.nodes import (
    outline_agent_node,
    character_agent_node,
    plot_agent_node,
    review_agent_node
)
from utils.logging import get_logger

logger = get_logger(__name__)


def create_a2a_pipeline():
    """创建 A2A 创作流水线
    
    Returns:
        编译后的流水线
    """
    logger.info("Creating A2A pipeline...")
    
    # 创建状态图
    workflow = StateGraph(PipelineState)
    
    # 添加 Agent 节点
    workflow.add_node("outline_agent", outline_agent_node)
    workflow.add_node("character_agent", character_agent_node)
    workflow.add_node("plot_agent", plot_agent_node)
    workflow.add_node("review_agent", review_agent_node)
    
    # 添加重新生成节点
    async def regenerate_router_node(state: PipelineState) -> PipelineState:
        """重新生成路由节点"""
        issues = state.get("review_results", {}).get("issues", [])
        
        # 分析问题类型，决定从哪个 Agent 重新开始
        has_outline_issue = any("outline" in issue.get("description", "").lower() for issue in issues)
        has_character_issue = any("character" in issue.get("description", "").lower() or "角色" in issue.get("description", "") for issue in issues)
        has_plot_issue = any("plot" in issue.get("description", "").lower() or "情节" in issue.get("description", "") for issue in issues)
        
        if has_outline_issue:
            restart_agent = "outline_agent"
        elif has_character_issue:
            restart_agent = "character_agent"
        elif has_plot_issue:
            restart_agent = "plot_agent"
        else:
            restart_agent = "outline_agent"  # 默认从头开始
        
        return {
            **state,
            "iteration_count": state.get("iteration_count", 0) + 1,
            "current_agent": restart_agent,
            "reasoning": state.get("reasoning", []) + [
                f"重新生成：从 {restart_agent} 开始"
            ]
        }
    
    workflow.add_node("regenerate_router", regenerate_router_node)
    
    # 添加人工审核节点
    async def human_review_node(state: PipelineState) -> PipelineState:
        """人工审核节点（中断等待）"""
        from langgraph.graph import interrupt
        
        feedback = interrupt({
            "message": "请审核创作内容",
            "outline_summary": state.get("outline_summary"),
            "character_summary": state.get("character_summary"),
            "plot_summary": state.get("plot_summary"),
            "review_results": state.get("review_results")
        })
        
        if feedback.get("approved"):
            return {
                **state,
                "review_passed": True,
                "current_agent": "completed",
                "human_feedback": feedback.get("comment", ""),
                "reasoning": state.get("reasoning", []) + ["人工审核：通过"]
            }
        else:
            return {
                **state,
                "review_passed": False,
                "current_agent": "regenerate",
                "human_feedback": feedback.get("comment", ""),
                "reasoning": state.get("reasoning", []) + [
                    f"人工审核：不通过 - {feedback.get('comment', '')}"
                ]
            }
    
    workflow.add_node("human_review", human_review_node)
    
    # ===== 设置流程 =====
    workflow.set_entry_point("outline_agent")
    
    # 顺序边
    workflow.add_edge("outline_agent", "character_agent")
    workflow.add_edge("character_agent", "plot_agent")
    workflow.add_edge("plot_agent", "review_agent")
    
    # 条件边：审核后的路由
    def review_router(state: PipelineState) -> str:
        """审核路由"""
        current_agent = state.get("current_agent", "")
        
        if current_agent == "completed":
            return "end"
        elif current_agent == "human_review":
            return "human_review"
        elif current_agent == "regenerate":
            # 检查迭代次数
            iteration = state.get("iteration_count", 0)
            max_iterations = state.get("max_iterations", 3)
            
            if iteration >= max_iterations:
                logger.warning(f"Max iterations ({max_iterations}) reached")
                return "end"
            return "regenerate"
        else:
            return "end"
    
    workflow.add_conditional_edges(
        "review_agent",
        review_router,
        {
            "end": END,
            "human_review": "human_review",
            "regenerate": "regenerate_router"
        }
    )
    
    # 人工审核后的路由
    workflow.add_conditional_edges(
        "human_review",
        lambda state: "end" if state.get("review_passed") else "regenerate",
        {
            "end": END,
            "regenerate": "regenerate_router"
        }
    )
    
    # 重新生成路由
    def regenerate_router(state: PipelineState) -> str:
        """重新生成路由"""
        return state.get("current_agent", "outline_agent")
    
    workflow.add_conditional_edges(
        "regenerate_router",
        regenerate_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent"
        }
    )
    
    # 编译
    app = workflow.compile()
    
    logger.info("A2A pipeline created successfully")
    return app
```

---

## 四、使用示例

```python
# 创建流水线
from core.agents.workflows.a2a_pipeline import create_a2a_pipeline

pipeline = create_a2a_pipeline()

# 准备初始状态
initial_state = {
    "user_requirement": "创作一部修仙小说，主角从小镇出发，历经磨难成为仙帝",
    "user_id": "user-123",
    "project_id": "proj-456",
    "pipeline_config": {
        "enable_rag": True,
        "enable_human_review": False
    },
    "max_iterations": 3,
    "iteration_count": 0,
    "messages": [],
    "reasoning": [],
    "errors": [],
    "warnings": [],
    "completed_agents": [],
    "tool_calls_count": 0,
    "start_time": time.time(),
    "tokens_used": 0
}

# 执行流水线
result = await pipeline.ainvoke(initial_state)

# 查看结果
print(f"大纲节点数：{len(result['outline_nodes'])}")
print(f"角色数：{len(result['characters'])}")
print(f"时间线事件数：{len(result['timeline_events'])}")
print(f"质量评分：{result['quality_score']}")
print(f"审核是否通过：{result['review_passed']}")
```

---

## 五、总结

本文档详细设计了 A2A 创作流水线，包括：

- ✅ 四个专业 Agent（大纲、角色、情节、审核）
- ✅ 顺序协作流程
- ✅ 迭代优化循环
- ✅ 人工介入机制
- ✅ 完整的错误处理

**关键特性**：
- 专业化分工
- 显式流程控制
- 支持多轮迭代
- 支持人工审核
- 完整的可追溯性

**后续工作**：
- 性能优化（并行执行部分节点）
- 添加更多专业 Agent（风格 Agent、世界观 Agent）
- 完善质量评估标准

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
