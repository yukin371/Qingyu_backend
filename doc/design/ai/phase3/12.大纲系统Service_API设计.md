# 大纲系统 Service/API 设计

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段
> **负责人**: AI架构组

---

## 一、Service 接口定义

```go
// service/interfaces/outline_service.go
package interfaces

type OutlineService interface {
    // 节点 CRUD（基于 Node 模型）
    CreateNode(ctx context.Context, projectID string, req *CreateOutlineNodeRequest) (*writer.Node, error)
    GetNode(ctx context.Context, nodeID, projectID string) (*writer.Node, error)
    ListChildren(ctx context.Context, projectID, parentID string) ([]*writer.Node, error)
    GetTree(ctx context.Context, projectID string) (*OutlineTree, error)
    UpdateNode(ctx context.Context, nodeID, projectID string, req *UpdateOutlineNodeRequest) (*writer.Node, error)
    DeleteNode(ctx context.Context, nodeID, projectID string) error
    
    // 节点移动和排序
    MoveNode(ctx context.Context, nodeID, newParentID string, order int) error
    ReorderNodes(ctx context.Context, parentID string, nodeIDs []string) error
    
    // AI 生成
    GenerateOutline(ctx context.Context, projectID string, req *GenerateOutlineRequest) (*OutlineTree, error)
    ExpandNode(ctx context.Context, nodeID string, req *ExpandNodeRequest) ([]*writer.Node, error)
    GenerateSummary(ctx context.Context, nodeID string) (string, error)
    
    // 分析
    AnalyzeStructure(ctx context.Context, projectID string) (*OutlineAnalysis, error)
    GetSuggestions(ctx context.Context, nodeID string) ([]*OutlineSuggestion, error)
}

type CreateOutlineNodeRequest struct {
    ParentID    string                 `json:"parentId"`
    Name        string                 `json:"name" validate:"required"`
    Description string                 `json:"description"`
    Level       int                    `json:"level"`
    Order       int                    `json:"order"`
    Metadata    map[string]interface{} `json:"metadata"`
}

type UpdateOutlineNodeRequest struct {
    Name        *string                 `json:"name"`
    Description *string                 `json:"description"`
    Metadata    *map[string]interface{} `json:"metadata"`
}

type GenerateOutlineRequest struct {
    Prompt       string            `json:"prompt" validate:"required"`
    ChapterCount int               `json:"chapterCount"`
    Genre        string            `json:"genre"`
    Constraints  map[string]string `json:"constraints"`
}

type ExpandNodeRequest struct {
    SubNodeCount int    `json:"subNodeCount"`
    Depth        int    `json:"depth"`
    Strategy     string `json:"strategy"` // detailed, balanced, simple
}

type OutlineTree struct {
    Root     *OutlineTreeNode  `json:"root"`
    AllNodes []*OutlineTreeNode `json:"allNodes"`
    Metadata *OutlineMetadata  `json:"metadata"`
}

type OutlineTreeNode struct {
    Node     *writer.Node       `json:"node"`
    Children []*OutlineTreeNode `json:"children"`
    Depth    int                `json:"depth"`
}

type OutlineMetadata struct {
    TotalNodes   int     `json:"totalNodes"`
    MaxDepth     int     `json:"maxDepth"`
    ChapterCount int     `json:"chapterCount"`
    WordEstimate int     `json:"wordEstimate"`
    Completeness float32 `json:"completeness"` // 0-1
}

type OutlineAnalysis struct {
    Structure    *StructureAnalysis `json:"structure"`
    Balance      *BalanceAnalysis   `json:"balance"`
    Completeness *CompletenessAnalysis `json:"completeness"`
}

type StructureAnalysis struct {
    IsWellFormed bool     `json:"isWellFormed"`
    Issues       []string `json:"issues"`
    Depth        int      `json:"depth"`
    BranchFactor float32  `json:"branchFactor"`
}

type BalanceAnalysis struct {
    IsBalanced       bool    `json:"isBalanced"`
    ImbalancedNodes  []string `json:"imbalancedNodes"`
    AverageChildren  float32 `json:"averageChildren"`
}

type CompletenessAnalysis struct {
    Score            float32  `json:"score"` // 0-100
    MissingElements  []string `json:"missingElements"`
    Recommendations  []string `json:"recommendations"`
}

type OutlineSuggestion struct {
    Type        string `json:"type"` // expand, merge, reorder, split
    Description string `json:"description"`
    Confidence  float32 `json:"confidence"`
}
```

---

## 二、Service 实现

```go
// service/writer/outline_service_impl.go
package writer

type OutlineServiceImpl struct {
    nodeRepo interfaces.NodeRepository
    eventBus events.EventBus
    aiProxy  AIProxyService
}

func (s *OutlineServiceImpl) CreateNode(
    ctx context.Context,
    projectID string,
    req *CreateOutlineNodeRequest,
) (*writer.Node, error) {
    // 1. 如果有父节点，验证父节点存在
    if req.ParentID != "" {
        parent, err := s.nodeRepo.FindByID(ctx, req.ParentID)
        if err != nil {
            return nil, errors.NewNotFoundError("parent node not found", err)
        }
        
        if parent.ProjectID != projectID {
            return nil, errors.NewAuthError("no permission")
        }
    }
    
    // 2. 创建节点
    node := &writer.Node{
        ProjectID:   projectID,
        ParentID:    req.ParentID,
        Name:        req.Name,
        Type:        "outline",
        Description: req.Description,
        Order:       req.Order,
        Metadata:    req.Metadata,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    if err := s.nodeRepo.Create(ctx, node); err != nil {
        return nil, errors.NewDatabaseError("create node failed", err)
    }
    
    // 3. 发布事件
    s.eventBus.Publish(&events.OutlineNodeCreatedEvent{
        NodeID:    node.ID,
        ProjectID: projectID,
    })
    
    return node, nil
}

func (s *OutlineServiceImpl) GetTree(
    ctx context.Context,
    projectID string,
) (*OutlineTree, error) {
    // 1. 获取所有节点
    nodes, err := s.nodeRepo.FindByProjectID(ctx, projectID, "outline")
    if err != nil {
        return nil, err
    }
    
    // 2. 构建树结构
    nodeMap := make(map[string]*OutlineTreeNode)
    for _, node := range nodes {
        nodeMap[node.ID] = &OutlineTreeNode{
            Node:     node,
            Children: []*OutlineTreeNode{},
        }
    }
    
    // 3. 建立父子关系
    var root *OutlineTreeNode
    for _, treeNode := range nodeMap {
        if treeNode.Node.ParentID == "" {
            root = treeNode
        } else {
            if parent, ok := nodeMap[treeNode.Node.ParentID]; ok {
                parent.Children = append(parent.Children, treeNode)
            }
        }
    }
    
    // 4. 计算深度和元数据
    calculateDepth(root, 0)
    metadata := calculateOutlineMetadata(nodes, root)
    
    return &OutlineTree{
        Root:     root,
        AllNodes: getAllTreeNodes(root),
        Metadata: metadata,
    }, nil
}

func (s *OutlineServiceImpl) GenerateOutline(
    ctx context.Context,
    projectID string,
    req *GenerateOutlineRequest,
) (*OutlineTree, error) {
    // 1. 调用 AI 生成大纲
    aiReq := &AIAgentRequest{
        AgentType: "outline",
        Task:      req.Prompt,
        ProjectID: projectID,
        Parameters: map[string]string{
            "chapterCount": fmt.Sprintf("%d", req.ChapterCount),
            "genre":        req.Genre,
        },
    }
    
    aiResult, err := s.aiProxy.ExecuteAgent(ctx, aiReq)
    if err != nil {
        return nil, errors.NewExternalError("AI generation failed", err)
    }
    
    // 2. 解析 AI 结果
    outlineStructure := parseAIOutlineResult(aiResult)
    
    // 3. 递归创建节点
    createdNodes := s.createNodesRecursive(ctx, projectID, "", outlineStructure)
    
    // 4. 构建并返回树结构
    return s.GetTree(ctx, projectID)
}

func (s *OutlineServiceImpl) createNodesRecursive(
    ctx context.Context,
    projectID, parentID string,
    nodes []OutlineNodeData,
) []*writer.Node {
    var createdNodes []*writer.Node
    
    for i, nodeData := range nodes {
        req := &CreateOutlineNodeRequest{
            ParentID:    parentID,
            Name:        nodeData.Name,
            Description: nodeData.Description,
            Order:       i,
            Metadata: map[string]interface{}{
                "ai_generated": true,
                "level":        nodeData.Level,
            },
        }
        
        node, err := s.CreateNode(ctx, projectID, req)
        if err == nil {
            createdNodes = append(createdNodes, node)
            
            // 递归创建子节点
            if len(nodeData.Children) > 0 {
                children := s.createNodesRecursive(ctx, projectID, node.ID, nodeData.Children)
                createdNodes = append(createdNodes, children...)
            }
        }
    }
    
    return createdNodes
}

func (s *OutlineServiceImpl) MoveNode(
    ctx context.Context,
    nodeID, newParentID string,
    order int,
) error {
    // 1. 获取节点
    node, err := s.nodeRepo.FindByID(ctx, nodeID)
    if err != nil {
        return errors.NewNotFoundError("node not found", err)
    }
    
    // 2. 验证不能移动到自己的子节点
    if s.isDescendant(ctx, newParentID, nodeID) {
        return errors.NewBusinessError("cannot move node to its descendant")
    }
    
    // 3. 更新节点
    node.ParentID = newParentID
    node.Order = order
    node.UpdatedAt = time.Now()
    
    return s.nodeRepo.Update(ctx, node)
}

func (s *OutlineServiceImpl) AnalyzeStructure(
    ctx context.Context,
    projectID string,
) (*OutlineAnalysis, error) {
    // 获取大纲树
    tree, err := s.GetTree(ctx, projectID)
    if err != nil {
        return nil, err
    }
    
    // 分析结构
    structureAnalysis := analyzeTreeStructure(tree)
    balanceAnalysis := analyzeTreeBalance(tree)
    completenessAnalysis := analyzeCompleteness(tree)
    
    return &OutlineAnalysis{
        Structure:    structureAnalysis,
        Balance:      balanceAnalysis,
        Completeness: completenessAnalysis,
    }, nil
}

func (s *OutlineServiceImpl) GetSuggestions(
    ctx context.Context,
    nodeID string,
) ([]*OutlineSuggestion, error) {
    // 调用 AI 获取建议
    node, err := s.nodeRepo.FindByID(ctx, nodeID)
    if err != nil {
        return nil, err
    }
    
    // 构建上下文（同级节点、父节点）
    siblings, _ := s.ListChildren(ctx, node.ProjectID, node.ParentID)
    
    prompt := fmt.Sprintf("分析大纲节点：%s\n同级节点：%v\n提供改进建议",
        node.Name,
        getNodeNames(siblings),
    )
    
    aiResult, _ := s.aiProxy.GenerateText(ctx, &GenerateRequest{
        Prompt: prompt,
    })
    
    suggestions := parseAISuggestions(aiResult)
    
    // 保存建议到节点
    node.AISuggestions = suggestions
    s.nodeRepo.Update(ctx, node)
    
    return convertToOutlineSuggestions(suggestions), nil
}
```

---

## 三、辅助函数

```go
func calculateDepth(node *OutlineTreeNode, depth int) {
    if node == nil {
        return
    }
    node.Depth = depth
    for _, child := range node.Children {
        calculateDepth(child, depth+1)
    }
}

func calculateOutlineMetadata(nodes []*writer.Node, root *OutlineTreeNode) *OutlineMetadata {
    return &OutlineMetadata{
        TotalNodes:   len(nodes),
        MaxDepth:     getMaxDepth(root),
        ChapterCount: countChapters(nodes),
        WordEstimate: estimateWords(nodes),
        Completeness: calculateCompleteness(nodes),
    }
}

func analyzeTreeStructure(tree *OutlineTree) *StructureAnalysis {
    // 分析树结构是否合理
    return &StructureAnalysis{
        IsWellFormed: true,
        Issues:       []string{},
        Depth:        tree.Metadata.MaxDepth,
        BranchFactor: calculateBranchFactor(tree),
    }
}
```

---

## 四、总结

本文档设计了大纲系统的完整实现：

- ✅ OutlineService 接口定义
- ✅ 基于 Node 模型的树形结构管理
- ✅ AI 生成大纲
- ✅ 节点移动和排序
- ✅ 大纲结构分析
- ✅ AI 建议

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
