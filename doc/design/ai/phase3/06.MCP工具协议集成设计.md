# MCP 工具协议集成设计

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段（可选实现）
> **负责人**: AI架构组

---

## 📋 文档概述

本文档设计 MCP（Model Context Protocol）工具协议的集成方案，作为可选的标准化工具层与 LangChain Tools 并存。

**MCP 定位**：
- 作为可选的标准化工具接口层
- 与 LangChain Tools 并存（LangChain 包装 MCP）
- 便于未来集成第三方工具

---

## 一、MCP 协议概述

### 1.1 MCP 核心概念

```python
# MCP 协议由 Anthropic 提出，提供标准化的工具调用接口

# 核心组件：
# 1. Tool Server: 提供工具的服务端
# 2. Tool Client: 调用工具的客户端
# 3. Tool Schema: 工具描述格式（JSON Schema）
# 4. Transport: 传输协议（HTTP/SSE/stdio）
```

---

## 二、MCP Server 实现

### 2.1 MCP Tool Server

```python
# src/infrastructure/mcp/server.py
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import asyncio


@dataclass
class MCPTool:
    """MCP 工具定义"""
    name: str
    description: str
    input_schema: Dict[str, Any]
    handler: Callable


class MCPToolInvokeRequest(BaseModel):
    """MCP 工具调用请求"""
    name: str
    arguments: Dict[str, Any]


class MCPToolInvokeResponse(BaseModel):
    """MCP 工具调用响应"""
    content: List[Dict[str, Any]]
    is_error: bool = False


class MCPServer:
    """MCP 工具服务器"""
    
    def __init__(self):
        self.tools: Dict[str, MCPTool] = {}
        self.app = FastAPI()
        self._setup_routes()
    
    def register_tool(self, tool: MCPTool):
        """注册工具"""
        self.tools[tool.name] = tool
    
    def _setup_routes(self):
        """设置路由"""
        
        @self.app.get("/mcp/v1/tools/list")
        async def list_tools():
            """列出所有工具"""
            tools = []
            for tool in self.tools.values():
                tools.append({
                    "name": tool.name,
                    "description": tool.description,
                    "inputSchema": tool.input_schema
                })
            return {"tools": tools}
        
        @self.app.post("/mcp/v1/tools/call")
        async def call_tool(request: MCPToolInvokeRequest):
            """调用工具"""
            tool = self.tools.get(request.name)
            
            if not tool:
                raise HTTPException(status_code=404, detail=f"Tool not found: {request.name}")
            
            try:
                # 调用工具处理器
                result = await tool.handler(request.arguments)
                
                return MCPToolInvokeResponse(
                    content=[{
                        "type": "text",
                        "text": str(result)
                    }],
                    is_error=False
                )
            except Exception as e:
                return MCPToolInvokeResponse(
                    content=[{
                        "type": "text",
                        "text": f"Error: {str(e)}"
                    }],
                    is_error=True
                )
```

### 2.2 注册 LangChain Tools 到 MCP

```python
# src/infrastructure/mcp/langchain_adapter.py
from core.tools.base import BaseTool
from infrastructure.mcp.server import MCPServer, MCPTool


class LangChainToMCPAdapter:
    """LangChain Tools 到 MCP 的适配器"""
    
    @staticmethod
    def register_langchain_tool(mcp_server: MCPServer, langchain_tool: BaseTool):
        """将 LangChain Tool 注册到 MCP Server"""
        
        # 获取参数 Schema
        parameters_schema = langchain_tool.input_schema.schema()
        
        # 创建处理器
        async def handler(arguments: dict):
            result = await langchain_tool.execute(params=arguments)
            if result.success:
                return result.data
            else:
                raise Exception(result.error)
        
        # 创建 MCP Tool
        mcp_tool = MCPTool(
            name=langchain_tool.metadata.name,
            description=langchain_tool.metadata.description,
            input_schema={
                "type": "object",
                "properties": parameters_schema.get("properties", {}),
                "required": parameters_schema.get("required", [])
            },
            handler=handler
        )
        
        # 注册
        mcp_server.register_tool(mcp_tool)


# 使用示例
mcp_server = MCPServer()
adapter = LangChainToMCPAdapter()

# 注册所有 LangChain Tools
from core.tools.registry import ToolRegistry
tool_registry = ToolRegistry()

for tool in tool_registry._tools.values():
    adapter.register_langchain_tool(mcp_server, tool)
```

---

## 三、MCP Client 实现

### 3.1 MCP Tool Client

```python
# src/infrastructure/mcp/client.py
import aiohttp
from typing import List, Dict, Any


class MCPClient:
    """MCP 工具客户端"""
    
    def __init__(self, server_url: str):
        self.server_url = server_url.rstrip('/')
        self.session: aiohttp.ClientSession = None
    
    async def initialize(self):
        """初始化"""
        self.session = aiohttp.ClientSession()
    
    async def close(self):
        """关闭"""
        if self.session:
            await self.session.close()
    
    async def list_tools(self) -> List[Dict[str, Any]]:
        """列出所有工具"""
        async with self.session.get(f"{self.server_url}/mcp/v1/tools/list") as response:
            data = await response.json()
            return data.get("tools", [])
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """调用工具"""
        async with self.session.post(
            f"{self.server_url}/mcp/v1/tools/call",
            json={"name": tool_name, "arguments": arguments}
        ) as response:
            return await response.json()
```

---

## 四、MCP 与 LangChain 的协同

### 4.1 LangChain Tool 包装 MCP

```python
# src/core/tools/mcp/mcp_wrapper.py
from langchain.tools import BaseTool as LangChainBaseTool
from infrastructure.mcp.client import MCPClient


class MCPToolWrapper(LangChainBaseTool):
    """将 MCP Tool 包装为 LangChain Tool"""
    
    def __init__(self, mcp_client: MCPClient, tool_info: Dict[str, Any]):
        self.mcp_client = mcp_client
        self.tool_info = tool_info
        
        # 设置 LangChain Tool 属性
        self.name = tool_info["name"]
        self.description = tool_info["description"]
    
    async def _arun(self, **kwargs):
        """异步执行"""
        result = await self.mcp_client.call_tool(
            tool_name=self.name,
            arguments=kwargs
        )
        
        if result.get("is_error"):
            raise Exception(result["content"][0]["text"])
        
        return result["content"][0]["text"]
    
    def _run(self, **kwargs):
        """同步执行"""
        import asyncio
        return asyncio.run(self._arun(**kwargs))


# 动态加载 MCP Tools
async def load_mcp_tools(mcp_server_url: str) -> List[LangChainBaseTool]:
    """从 MCP Server 加载工具"""
    client = MCPClient(mcp_server_url)
    await client.initialize()
    
    tools = []
    mcp_tools = await client.list_tools()
    
    for tool_info in mcp_tools:
        wrapper = MCPToolWrapper(client, tool_info)
        tools.append(wrapper)
    
    return tools
```

---

## 五、部署架构

### 5.1 独立 MCP Server 部署

```yaml
# docker-compose.mcp.yml
version: '3.8'

services:
  mcp-server:
    build:
      context: .
      dockerfile: docker/Dockerfile.mcp
    ports:
      - "8081:8080"
    environment:
      - MCP_SERVER_PORT=8080
      - GO_API_URL=http://go-backend:8080
    depends_on:
      - go-backend
```

### 5.2 Python FastAPI 中集成 MCP

```python
# src/main.py FastAPI 应用中集成
from fastapi import FastAPI
from infrastructure.mcp.server import MCPServer
from infrastructure.mcp.langchain_adapter import LangChainToMCPAdapter

app = FastAPI()

# 创建 MCP Server
mcp_server = MCPServer()

# 注册所有 LangChain Tools
# ... 注册逻辑

# 挂载 MCP 路由
app.mount("/mcp", mcp_server.app)
```

---

## 六、使用场景

### 6.1 场景 1：LangGraph 使用 MCP Tools

```python
from langgraph.prebuilt import ToolNode

# 加载 MCP Tools
mcp_tools = await load_mcp_tools("http://localhost:8081")

# 创建 ToolNode
tool_node = ToolNode(mcp_tools)

# 添加到工作流
workflow.add_node("tools", tool_node)
```

### 6.2 场景 2：第三方 MCP Server

```python
# 集成外部 MCP Server（如未来的第三方工具）
external_mcp_tools = await load_mcp_tools("https://external-mcp-server.com")

# 混合使用
all_tools = langchain_native_tools + mcp_tools + external_mcp_tools
```

---

## 七、总结

本文档设计了 MCP 工具协议的集成方案：

- ✅ MCP Server 实现（FastAPI）
- ✅ MCP Client 实现
- ✅ LangChain Tools 到 MCP 的适配器
- ✅ MCP Tools 到 LangChain 的包装器
- ✅ 与 LangChain 的协同策略

**关键决策**：
- MCP 作为可选层
- 与 LangChain Tools 并存
- 优先使用 LangChain 原生工具
- MCP 用于标准化和第三方集成

**实施优先级**：中（可选实现）

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
