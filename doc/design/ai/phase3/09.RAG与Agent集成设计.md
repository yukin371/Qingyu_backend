# RAG 与 Agent 集成设计

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段
> **负责人**: AI架构组

---

## 📋 文档概述

本文档详细设计 RAG 系统与 Agent 的集成方案，包括 RAG Tool 封装、上下文构建、Prompt 增强、引用标注和缓存策略。

---

## 一、RAG Tool 增强封装

### 1.1 智能检索策略

```python
# src/core/rag/smart_retriever.py
from typing import List, Dict, Any, Optional
from core.rag.retriever import HybridSearchEngine
from core.rag.query_analyzer import QueryAnalyzer
from utils.logging import get_logger

logger = get_logger(__name__)


class SmartRetriever:
    """智能检索器（Agent 专用）"""
    
    def __init__(self, search_engine: HybridSearchEngine):
        self.search_engine = search_engine
        self.query_analyzer = QueryAnalyzer()
    
    async def retrieve_for_agent(
        self,
        query: str,
        context: Dict[str, Any],
        retrieval_mode: str = "auto"  # auto, semantic, keyword, hybrid
    ) -> Dict[str, Any]:
        """为 Agent 检索信息
        
        Args:
            query: 查询文本
            context: Agent 上下文（project_id, user_id 等）
            retrieval_mode: 检索模式
            
        Returns:
            检索结果 + 元数据
        """
        project_id = context.get("project_id")
        
        # 1. 分析查询意图
        query_info = self.query_analyzer.analyze(query)
        
        # 2. 确定检索模式
        if retrieval_mode == "auto":
            retrieval_mode = self._determine_retrieval_mode(query_info)
        
        # 3. 动态调整 top_k
        top_k = self._calculate_top_k(query_info)
        
        # 4. 确定内容类型过滤
        content_types = self._determine_content_types(query_info)
        
        # 5. 执行检索
        results = await self.search_engine.search(
            query=query,
            user_id=context.get("user_id"),
            project_id=project_id,
            top_k=top_k,
            content_types=content_types,
            enable_hybrid=(retrieval_mode == "hybrid")
        )
        
        # 6. 后处理
        processed_results = self._post_process_results(results, query_info)
        
        return {
            "results": processed_results,
            "retrieval_metadata": {
                "mode": retrieval_mode,
                "query_intent": query_info.get("intent"),
                "content_types": content_types,
                "top_k": top_k,
                "total_found": len(results)
            }
        }
    
    def _determine_retrieval_mode(self, query_info: Dict) -> str:
        """确定检索模式"""
        intent = query_info.get("intent", "general")
        
        # 精确查找 -> 关键词
        if intent in ["find_specific", "lookup"]:
            return "keyword"
        
        # 概念理解 -> 语义
        elif intent in ["understand", "explore"]:
            return "semantic"
        
        # 默认混合
        return "hybrid"
    
    def _calculate_top_k(self, query_info: Dict) -> int:
        """动态计算 top_k"""
        complexity = query_info.get("complexity", "medium")
        
        if complexity == "simple":
            return 3
        elif complexity == "complex":
            return 10
        else:
            return 5
    
    def _determine_content_types(self, query_info: Dict) -> Optional[List[str]]:
        """确定内容类型过滤"""
        entities = query_info.get("entities", [])
        
        # 如果提到角色 -> 只检索角色相关
        if any(e["type"] == "character" for e in entities):
            return ["character", "character_relation"]
        
        # 如果提到大纲、章节 -> 只检索大纲
        if any(e["type"] in ["outline", "chapter"] for e in entities):
            return ["outline"]
        
        # 否则不过滤
        return None
    
    def _post_process_results(self, results: List, query_info: Dict) -> List[Dict]:
        """后处理检索结果"""
        processed = []
        
        for result in results:
            processed.append({
                "content": result.chunk_text,
                "score": result.score,
                "content_type": result.metadata.get("content_type"),
                "document_id": result.document_id,
                "source": {
                    "type": result.metadata.get("content_type"),
                    "name": result.metadata.get("title", "未知"),
                    "id": result.document_id
                },
                "highlights": result.highlights
            })
        
        return processed
```

### 1.2 查询分析器

```python
# src/core/rag/query_analyzer.py
from typing import Dict, List, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
import json


class QueryAnalyzer:
    """查询分析器"""
    
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
    
    async def analyze(self, query: str) -> Dict[str, Any]:
        """分析查询
        
        Args:
            query: 查询文本
            
        Returns:
            查询分析结果
        """
        system_message = SystemMessage(content="""
分析用户查询，提取关键信息。

输出格式：JSON
{
  "intent": "find_specific",  // find_specific, understand, explore, compare
  "complexity": "simple",     // simple, medium, complex
  "entities": [
    {"type": "character", "value": "张三"},
    {"type": "chapter", "value": "第一章"}
  ],
  "keywords": ["关键词1", "关键词2"]
}
""")
        
        user_message = HumanMessage(content=f"查询：{query}")
        
        response = await self.llm.ainvoke([system_message, user_message])
        
        try:
            return json.loads(response.content)
        except:
            return {
                "intent": "general",
                "complexity": "medium",
                "entities": [],
                "keywords": []
            }
```

---

## 二、上下文构建策略

### 2.1 Context Builder

```python
# src/core/rag/context_builder.py
from typing import List, Dict, Any
from utils.logging import get_logger

logger = get_logger(__name__)


class ContextBuilder:
    """上下文构建器"""
    
    def __init__(self, max_context_length: int = 4000):
        self.max_context_length = max_context_length
    
    def build_context(
        self,
        query: str,
        rag_results: List[Dict[str, Any]],
        context_type: str = "standard"  # standard, detailed, summary
    ) -> str:
        """构建上下文
        
        Args:
            query: 查询
            rag_results: RAG 检索结果
            context_type: 上下文类型
            
        Returns:
            构建的上下文字符串
        """
        if context_type == "standard":
            return self._build_standard_context(rag_results)
        elif context_type == "detailed":
            return self._build_detailed_context(rag_results)
        elif context_type == "summary":
            return self._build_summary_context(rag_results)
        else:
            return self._build_standard_context(rag_results)
    
    def _build_standard_context(self, results: List[Dict]) -> str:
        """构建标准上下文"""
        if not results:
            return ""
        
        context_parts = ["【参考资料】\n"]
        
        for i, result in enumerate(results, 1):
            source = result.get("source", {})
            content = result.get("content", "")
            
            # 长度限制
            if len(content) > 500:
                content = content[:500] + "..."
            
            context_parts.append(f"""
{i}. 【{source.get('type', '未知')}】{source.get('name', '')}
{content}
---
""")
        
        full_context = "\n".join(context_parts)
        
        # 总长度限制
        if len(full_context) > self.max_context_length:
            full_context = full_context[:self.max_context_length] + "\n...(内容已截断)"
        
        return full_context
    
    def _build_detailed_context(self, results: List[Dict]) -> str:
        """构建详细上下文（包含元数据）"""
        if not results:
            return ""
        
        context_parts = ["【详细参考资料】\n"]
        
        for i, result in enumerate(results, 1):
            source = result.get("source", {})
            content = result.get("content", "")
            score = result.get("score", 0)
            
            context_parts.append(f"""
━━━ 资料 {i} ━━━
类型：{source.get('type', '未知')}
名称：{source.get('name', '')}
相关度：{score:.2f}

内容：
{content}

━━━━━━━━━━━━━
""")
        
        return "\n".join(context_parts)
    
    def _build_summary_context(self, results: List[Dict]) -> str:
        """构建摘要上下文"""
        if not results:
            return ""
        
        # 按内容类型分组
        by_type = {}
        for result in results:
            content_type = result.get("source", {}).get("type", "其他")
            if content_type not in by_type:
                by_type[content_type] = []
            by_type[content_type].append(result)
        
        context_parts = ["【参考资料摘要】\n"]
        
        for content_type, items in by_type.items():
            context_parts.append(f"\n【{content_type}】（{len(items)}条）")
            for item in items[:3]:  # 每类最多3条
                name = item.get("source", {}).get("name", "")
                content = item.get("content", "")[:100]
                context_parts.append(f"- {name}: {content}...")
        
        return "\n".join(context_parts)
```

---

## 三、Prompt 增强模板

### 3.1 Prompt Enhancer

```python
# src/core/rag/prompt_enhancer.py
from typing import Dict, Any, Optional


class PromptEnhancer:
    """Prompt 增强器"""
    
    @staticmethod
    def enhance_prompt(
        original_prompt: str,
        rag_context: str,
        enhancement_type: str = "standard"
    ) -> str:
        """增强 Prompt
        
        Args:
            original_prompt: 原始 Prompt
            rag_context: RAG 上下文
            enhancement_type: 增强类型
            
        Returns:
            增强后的 Prompt
        """
        if enhancement_type == "standard":
            return PromptEnhancer._standard_enhancement(original_prompt, rag_context)
        elif enhancement_type == "creative":
            return PromptEnhancer._creative_enhancement(original_prompt, rag_context)
        elif enhancement_type == "analytical":
            return PromptEnhancer._analytical_enhancement(original_prompt, rag_context)
        else:
            return original_prompt
    
    @staticmethod
    def _standard_enhancement(prompt: str, context: str) -> str:
        """标准增强"""
        if not context:
            return prompt
        
        return f"""
{context}

基于以上参考资料，{prompt}

要求：
1. 充分参考资料中的信息
2. 保持与已有设定一致
3. 如果资料中有相关内容，请优先使用
"""
    
    @staticmethod
    def _creative_enhancement(prompt: str, context: str) -> str:
        """创作增强"""
        if not context:
            return prompt
        
        return f"""
{context}

创作任务：{prompt}

创作指南：
1. 参考资料仅作参考，可以创新
2. 保持角色性格一致
3. 确保情节符合大纲
4. 保持世界观设定统一
"""
    
    @staticmethod
    def _analytical_enhancement(prompt: str, context: str) -> str:
        """分析增强"""
        if not context:
            return prompt
        
        return f"""
{context}

分析任务：{prompt}

分析要求：
1. 基于参考资料进行分析
2. 指出资料中的关键信息
3. 提供数据支持
4. 给出合理推理
"""
```

---

## 四、引用标注和溯源

### 4.1 Citation Manager

```python
# src/core/rag/citation_manager.py
from typing import List, Dict, Any
import re


class CitationManager:
    """引用标注管理器"""
    
    @staticmethod
    def add_citations(
        generated_text: str,
        rag_results: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """添加引用标注
        
        Args:
            generated_text: 生成的文本
            rag_results: RAG 检索结果
            
        Returns:
            包含引用的结果
        """
        citations = []
        
        # 尝试匹配生成文本中的内容与 RAG 结果
        for i, result in enumerate(rag_results, 1):
            source_content = result.get("content", "")
            
            # 简单匹配（实际应该用更复杂的算法）
            if CitationManager._is_content_used(generated_text, source_content):
                citation = {
                    "id": i,
                    "source": result.get("source"),
                    "relevance": result.get("score", 0)
                }
                citations.append(citation)
        
        return {
            "text": generated_text,
            "citations": citations,
            "citation_count": len(citations)
        }
    
    @staticmethod
    def _is_content_used(generated: str, source: str) -> bool:
        """检测内容是否被使用"""
        # 简化实现：检测是否有大段相似文本
        # 实际应该用语义相似度或 n-gram 匹配
        
        # 提取关键短语（3-gram）
        def get_ngrams(text: str, n: int = 3) -> set:
            words = text.split()
            return set(" ".join(words[i:i+n]) for i in range(len(words)-n+1))
        
        generated_ngrams = get_ngrams(generated)
        source_ngrams = get_ngrams(source)
        
        # 计算交集
        intersection = generated_ngrams & source_ngrams
        
        # 如果有超过 2 个相同的 3-gram，认为使用了该资料
        return len(intersection) >= 2
    
    @staticmethod
    def format_citations(citations: List[Dict]) -> str:
        """格式化引用
        
        Args:
            citations: 引用列表
            
        Returns:
            格式化的引用文本
        """
        if not citations:
            return ""
        
        formatted = ["\n\n【参考来源】"]
        
        for citation in citations:
            source = citation.get("source", {})
            formatted.append(
                f"[{citation['id']}] {source.get('type', '未知')} - {source.get('name', '未知')}"
            )
        
        return "\n".join(formatted)
```

---

## 五、检索结果缓存

### 5.1 RAG Cache

```python
# src/core/rag/cache.py
from typing import Optional, List, Dict, Any
import hashlib
import json
from datetime import datetime, timedelta
from utils.logging import get_logger

logger = get_logger(__name__)


class RAGCache:
    """RAG 检索缓存"""
    
    def __init__(self, redis_client, ttl_seconds: int = 3600):
        """初始化
        
        Args:
            redis_client: Redis 客户端
            ttl_seconds: 缓存过期时间（秒）
        """
        self.redis = redis_client
        self.ttl = ttl_seconds
    
    def _generate_cache_key(
        self,
        query: str,
        project_id: str,
        content_types: Optional[List[str]]
    ) -> str:
        """生成缓存键"""
        key_data = {
            "query": query,
            "project_id": project_id,
            "content_types": sorted(content_types) if content_types else []
        }
        
        key_str = json.dumps(key_data, sort_keys=True)
        hash_key = hashlib.md5(key_str.encode()).hexdigest()
        
        return f"rag_cache:{project_id}:{hash_key}"
    
    async def get(
        self,
        query: str,
        project_id: str,
        content_types: Optional[List[str]] = None
    ) -> Optional[List[Dict[str, Any]]]:
        """获取缓存
        
        Returns:
            缓存的检索结果，如果不存在返回 None
        """
        cache_key = self._generate_cache_key(query, project_id, content_types)
        
        try:
            cached_data = await self.redis.get(cache_key)
            
            if cached_data:
                logger.info(f"RAG cache hit: {cache_key}")
                return json.loads(cached_data)
            else:
                logger.info(f"RAG cache miss: {cache_key}")
                return None
                
        except Exception as e:
            logger.error(f"RAG cache get failed: {e}")
            return None
    
    async def set(
        self,
        query: str,
        project_id: str,
        content_types: Optional[List[str]],
        results: List[Dict[str, Any]]
    ):
        """设置缓存"""
        cache_key = self._generate_cache_key(query, project_id, content_types)
        
        try:
            await self.redis.setex(
                cache_key,
                self.ttl,
                json.dumps(results)
            )
            logger.info(f"RAG cache set: {cache_key}")
            
        except Exception as e:
            logger.error(f"RAG cache set failed: {e}")
    
    async def invalidate_project(self, project_id: str):
        """使项目的所有缓存失效"""
        pattern = f"rag_cache:{project_id}:*"
        
        try:
            keys = await self.redis.keys(pattern)
            if keys:
                await self.redis.delete(*keys)
                logger.info(f"Invalidated {len(keys)} RAG cache entries for project {project_id}")
                
        except Exception as e:
            logger.error(f"RAG cache invalidation failed: {e}")
```

---

## 六、与 Agent 集成

### 6.1 Agent RAG Mixin

```python
# src/core/agents/mixins/rag_mixin.py
from typing import Dict, Any, Optional
from core.rag.smart_retriever import SmartRetriever
from core.rag.context_builder import ContextBuilder
from core.rag.prompt_enhancer import PromptEnhancer


class RAGMixin:
    """Agent RAG 混入（为 Agent 添加 RAG 能力）"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.smart_retriever: Optional[SmartRetriever] = None
        self.context_builder = ContextBuilder()
        self.prompt_enhancer = PromptEnhancer()
    
    async def retrieve_context(
        self,
        query: str,
        state: Dict[str, Any],
        retrieval_mode: str = "auto",
        context_type: str = "standard"
    ) -> Dict[str, Any]:
        """检索并构建上下文
        
        Args:
            query: 查询
            state: Agent 状态
            retrieval_mode: 检索模式
            context_type: 上下文类型
            
        Returns:
            包含上下文和元数据的字典
        """
        if not self.smart_retriever:
            return {"context": "", "metadata": {}}
        
        # 检索
        retrieval_result = await self.smart_retriever.retrieve_for_agent(
            query=query,
            context={
                "project_id": state.get("project_id"),
                "user_id": state.get("user_id")
            },
            retrieval_mode=retrieval_mode
        )
        
        rag_results = retrieval_result.get("results", [])
        
        # 构建上下文
        context = self.context_builder.build_context(
            query=query,
            rag_results=rag_results,
            context_type=context_type
        )
        
        return {
            "context": context,
            "rag_results": rag_results,
            "metadata": retrieval_result.get("retrieval_metadata", {})
        }
    
    def enhance_prompt_with_rag(
        self,
        prompt: str,
        rag_context: str,
        enhancement_type: str = "standard"
    ) -> str:
        """使用 RAG 增强 Prompt"""
        return self.prompt_enhancer.enhance_prompt(
            original_prompt=prompt,
            rag_context=rag_context,
            enhancement_type=enhancement_type
        )
```

### 6.2 使用示例

```python
# 在 Agent 节点中使用 RAG
from core.agents.mixins.rag_mixin import RAGMixin

class EnhancedCreativeAgent(RAGMixin):
    """增强的创作 Agent（带 RAG）"""
    
    async def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
        task = state["task"]
        
        # 1. RAG 检索
        rag_data = await self.retrieve_context(
            query=task,
            state=state,
            retrieval_mode="auto",
            context_type="standard"
        )
        
        # 2. 增强 Prompt
        enhanced_prompt = self.enhance_prompt_with_rag(
            prompt=task,
            rag_context=rag_data["context"],
            enhancement_type="creative"
        )
        
        # 3. 调用 LLM 生成
        # ...
        
        return {
            **state,
            "rag_context": rag_data["context"],
            "rag_metadata": rag_data["metadata"]
        }
```

---

## 七、总结

本文档详细设计了 RAG 与 Agent 的集成方案，包括：

- ✅ 智能检索策略（查询分析、动态 top_k）
- ✅ 上下文构建（标准、详细、摘要）
- ✅ Prompt 增强（标准、创作、分析）
- ✅ 引用标注和溯源
- ✅ 检索结果缓存
- ✅ Agent RAG Mixin

**关键特性**：
- 查询意图分析
- 动态检索策略
- 多种上下文格式
- 完整的引用追踪
- 高效的缓存机制

**后续工作**：
- 优化检索算法
- 完善引用检测
- 性能优化

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
