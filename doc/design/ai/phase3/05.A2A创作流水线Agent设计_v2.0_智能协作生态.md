# A2A 创作流水线 Agent 设计 v2.0 - 智能协作生态

> **文档版本**: v2.0  
> **创建时间**: 2025-10-28  
> **实施状态**: 设计阶段  
> **负责人**: AI架构组  
> **改进理念**: 从流水线到协作生态

---

## 📋 文档概述

本文档是 A2A 创作流水线的 v2.0 版本，在 v1.0 基础上引入了**反思循环、规划Agent、深度RAG集成、知识图谱**等前沿理念，将固定流水线演进为**动态协作生态**。

**核心改进**：
- ✅ **反思与自我修正循环**：借鉴 Reflexion 论文，实现深度反馈和智能修正
- ✅ **规划 Agent**：动态任务分解和执行计划生成
- ✅ **上下文感知**：借鉴 Cursor，实现主动上下文工具
- ✅ **结构化RAG**：元数据增强 + 混合检索
- ✅ **知识图谱集成**：实体关系推理 + 向量检索结合
- ✅ **MCP工具范式**：标准化工具调用，易于扩展

---

## 🎯 设计目标

### v2.0 核心目标

1. **自主性**：Agent 能够自主反思、规划和修正
2. **智能性**：深度理解上下文，智能选择策略
3. **协作性**：Agent 间动态协作，不再是固定流程
4. **可扩展**：易于添加新 Agent、新工具、新知识源
5. **可观测**：完整的推理链路和决策记录

### v1.0 vs v2.0 对比

| 维度 | v1.0 (流水线) | v2.0 (协作生态) |
|------|--------------|----------------|
| **流程** | 固定顺序（大纲→角色→情节→审核） | 动态规划（根据需求调整） |
| **审核** | 简单 pass/fail | 结构化诊断报告 + 修正指令 |
| **重试** | 从固定节点重启 | 智能定位问题 + 针对性修正 |
| **上下文** | 被动RAG检索 | 主动上下文感知工具 |
| **工具** | LangChain Native | MCP标准化 + LangChain混合 |
| **知识** | 纯向量检索 | 知识图谱 + 向量混合 |

---

## 一、整体架构演进

### 1.1 v2.0 协作生态架构

```
┌────────────────────────────────────────────────────────────────────┐
│                    A2A 智能协作生态 v2.0                           │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │                    🧠 规划 Agent (Planner)                    │ │
│  │  - 分析用户需求                                               │ │
│  │  - 动态任务分解                                               │ │
│  │  - 生成执行计划（Agent序列 + 工具集）                         │ │
│  │  - 实时调整计划                                               │ │
│  └──────────────────┬───────────────────────────────────────────┘ │
│                     │                                              │
│                     ▼                                              │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │              📋 上下文感知层 (Context Awareness)              │ │
│  │  ┌─────────────────────────────────────────────────────────┐ │ │
│  │  │  WorkspaceContextTool - 主动获取当前任务相关上下文       │ │ │
│  │  │  - 自动加载：前序章节 + 角色卡 + 大纲节点 + 世界设定     │ │ │
│  │  │  - 结构化返回：按类型组织，易于LLM理解                  │ │ │
│  │  └─────────────────────────────────────────────────────────┘ │ │
│  └──────────────────────────────────────────────────────────────┘ │
│                     │                                              │
│                     ▼                                              │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │              🔄 专业 Agent 协作层                            │  │
│  │                                                               │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │  │
│  │  │ 大纲Agent│  │ 角色Agent│  │ 情节Agent│  │ 风格Agent│   │  │
│  │  │          │  │          │  │          │  │  (扩展)  │   │  │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │  │
│  │       │             │             │             │          │  │
│  │       └─────────────┴─────────────┴─────────────┘          │  │
│  │                          │                                  │  │
│  └──────────────────────────┼──────────────────────────────────┘  │
│                             │                                      │
│                             ▼                                      │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │          🔍 审核 Agent (Review with Reflection)              │ │
│  │  ┌────────────────────────────────────────────────────────┐ │ │
│  │  │  结构化诊断报告生成                                     │ │ │
│  │  │  - 问题根因分析（不是简单的 "角色A缺失"）              │ │ │
│  │  │  - 具体修正指令（"为角色A增加'优柔寡断'弱点"）         │ │ │
│  │  │  - 修正策略（重新生成 vs 增量修改）                    │ │ │
│  │  └────────────────────────────────────────────────────────┘ │ │
│  └──────────────────┬───────────────────────────────────────────┘ │
│                     │                                              │
│                     ▼                                              │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │       🎯 元调度器 (Meta-Scheduler / Regenerate Router)       │ │
│  │  - 解析诊断报告                                               │ │
│  │  - 智能定位问题Agent                                          │ │
│  │  - 生成修正Prompt（增强版，包含诊断结果）                     │ │
│  │  - 决定修正范围（全量重生成 vs 增量修改）                     │ │
│  │  - 迭代次数控制 + 自动降级（人工介入）                        │ │
│  └──────────────────┬───────────────────────────────────────────┘ │
│                     │                                              │
│                     ▼                                              │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │              🛠️ 工具与知识层                                 │ │
│  │  ┌────────────────────────────────────────────────────────┐ │ │
│  │  │  MCP标准化工具（易于解耦和扩展）                        │ │ │
│  │  │  - CharacterTool, OutlineTool, TimelineTool            │ │ │
│  │  │  - LangChain Tool Wrapper                              │ │ │
│  │  └────────────────────────────────────────────────────────┘ │ │
│  │  ┌────────────────────────────────────────────────────────┐ │ │
│  │  │  知识图谱 + 向量检索混合引擎                            │ │ │
│  │  │  - 图查询：关系推理（角色A的朋友 ∩ 去过地点B的角色）   │ │ │
│  │  │  - 向量查询：语义相似（性格描述匹配）                  │ │ │
│  │  │  - 结果融合：精准关系 + 语义相似                       │ │ │
│  │  └────────────────────────────────────────────────────────┘ │ │
│  └──────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────────┘
```

---

## 二、核心改进 1：反思与自我修正循环

### 2.1 增强的审核 Agent（深度诊断）

```python
# src/core/agents/nodes/review_agent_v2.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from dataclasses import dataclass
import json

@dataclass
class DiagnosticReport:
    """诊断报告"""
    passed: bool
    quality_score: int  # 0-100
    
    # 问题分析（结构化）
    issues: List[Dict[str, Any]]  # [{"severity": "high", "category": "character", "root_cause": "...", "affected_entities": [...]}]
    
    # 修正策略
    correction_strategy: str  # "regenerate", "incremental_fix", "human_review"
    correction_instructions: List[Dict[str, Any]]  # 每个问题的具体修正指令
    
    # 受影响的 Agent
    affected_agents: List[str]  # ["character_agent", "plot_agent"]
    
    # 推理过程（可追溯）
    reasoning_chain: List[str]


async def review_agent_node_v2(state: PipelineState) -> PipelineState:
    """审核 Agent v2.0 - 深度诊断和结构化报告
    
    改进点：
    1. 生成结构化诊断报告（不只是简单的 pass/fail）
    2. 问题根因分析（不只是表面问题）
    3. 具体修正指令（可执行的、针对性的）
    4. 受影响 Agent 识别
    """
    logger.info("Review Agent v2.0: Starting deep diagnostic review...")
    
    # 收集所有输出
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    timeline_events = state.get("timeline_events", [])
    
    # ===== Step 1: 深度诊断分析 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    system_message = SystemMessage(content="""
你是一位专业的内容审核专家和诊断师。你的任务是深度分析创作内容，提供结构化的诊断报告。

## 审核维度
1. **一致性 (Consistency)**: 大纲、角色、情节是否一致
2. **完整性 (Completeness)**: 是否缺少关键元素
3. **合理性 (Rationality)**: 设定是否合理、逻辑是否自洽
4. **质量 (Quality)**: 内容深度、创意性

## 诊断要求
- **问题根因分析**：不只是说"角色A缺失"，而是说"角色A在大纲第三章被提及但未定义"
- **具体修正指令**：不只是说"补充角色"，而是说"为角色'张三'增加性格弱点'优柔寡断'，并在背景故事中体现"
- **受影响分析**：明确指出哪些 Agent 的输出需要修正

## 输出格式：JSON
{
  "passed": false,
  "quality_score": 65,
  "issues": [
    {
      "id": "issue-001",
      "severity": "high",  // high, medium, low
      "category": "consistency",  // consistency, completeness, rationality, quality
      "sub_category": "character",  // character, outline, plot, timeline
      "title": "角色定义缺失",
      "root_cause": "角色'李四'在大纲第三章'主角与李四相遇'中被提及，但角色列表中未找到该角色的定义",
      "affected_entities": ["大纲节点：第三章", "角色列表"],
      "impact": "导致情节无法展开，角色关系不明确"
    }
  ],
  "correction_strategy": "incremental_fix",  // regenerate, incremental_fix, human_review
  "correction_instructions": [
    {
      "issue_id": "issue-001",
      "target_agent": "character_agent",
      "action": "create",  // create, update, delete
      "specific_instruction": "创建角色'李四'，设定为：配角，主角的挚友，性格开朗但有些冲动。背景：与主角从小一起长大，是主角最信任的人。",
      "parameters": {
        "name": "李四",
        "role_type": "supporting",
        "traits": ["开朗", "冲动", "忠诚"],
        "relationship_to_protagonist": "挚友"
      }
    }
  ],
  "affected_agents": ["character_agent"],
  "reasoning_chain": [
    "检查大纲节点：发现第三章提及'李四'",
    "检查角色列表：未找到'李四'的定义",
    "分析影响：情节需要该角色，属于高优先级问题",
    "确定修正策略：增量修复（创建缺失角色）比全量重新生成更高效",
    "生成具体指令：基于大纲中的描述推断角色特征"
  ],
  "suggestions_for_improvement": [
    "建议在角色生成阶段，提取大纲中所有提及的角色名称进行交叉验证"
  ]
}
""")
    
    # 构建审核内容（结构化）
    review_content = {
        "outline": {
            "node_count": len(outline_nodes),
            "nodes": [
                {
                    "name": n.get("name"),
                    "description": n.get("description"),
                    "mentioned_entities": extract_entities(n.get("description", ""))
                } for n in outline_nodes[:10]
            ]
        },
        "characters": {
            "count": len(characters),
            "characters": [
                {
                    "name": c.get("name"),
                    "role_type": c.get("roleType"),
                    "traits": c.get("traits", [])
                } for c in characters
            ]
        },
        "timeline": {
            "event_count": len(timeline_events),
            "events": [
                {
                    "title": e.get("title"),
                    "participants": e.get("participants", []),
                    "importance": e.get("importance")
                } for e in timeline_events[:10]
            ]
        }
    }
    
    user_message = HumanMessage(content=f"""
请深度审核以下创作内容，生成结构化诊断报告（JSON格式）：

{json.dumps(review_content, ensure_ascii=False, indent=2)}
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析诊断报告
    try:
        diagnostic_dict = json.loads(response.content)
    except:
        # 解析失败，返回默认通过
        diagnostic_dict = {
            "passed": True,
            "quality_score": 75,
            "issues": [],
            "correction_strategy": "none",
            "correction_instructions": [],
            "affected_agents": [],
            "reasoning_chain": ["诊断报告解析失败，默认通过"],
            "suggestions_for_improvement": []
        }
    
    # ===== Step 2: 决策下一步 =====
    passed = diagnostic_dict.get("passed", False)
    quality_score = diagnostic_dict.get("quality_score", 0)
    correction_strategy = diagnostic_dict.get("correction_strategy", "regenerate")
    
    # 决定工作流下一步
    if correction_strategy == "human_review" or quality_score < 50:
        next_agent = "human_review"
    elif correction_strategy in ["regenerate", "incremental_fix"] and quality_score < 75:
        next_agent = "meta_scheduler"
    else:
        next_agent = "completed"
    
    return {
        **state,
        "diagnostic_report": diagnostic_dict,  # 完整的诊断报告
        "quality_score": quality_score,
        "review_passed": passed,
        "current_agent": next_agent,
        "completed_agents": state.get("completed_agents", []) + ["review_agent_v2"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + diagnostic_dict.get("reasoning_chain", [])
    }


def extract_entities(text: str) -> List[str]:
    """简单的实体提取（实际应该用 NER）"""
    # 简化实现：提取引号中的内容
    import re
    entities = re.findall(r'[\'"""\'](.*?)[\'"""\']', text)
    return entities
```

### 2.2 元调度器（智能修正路由）

```python
# src/core/agents/nodes/meta_scheduler_node.py
from typing import Dict, Any, List
from core.agents.states.pipeline_state import PipelineState
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
import json


async def meta_scheduler_node(state: PipelineState) -> PipelineState:
    """元调度器 - 智能分析诊断报告并生成修正计划
    
    职责：
    1. 解析诊断报告
    2. 智能定位需要修正的 Agent
    3. 为每个 Agent 生成增强的、具体的修正 Prompt
    4. 决定修正范围（全量 vs 增量）
    5. 管理迭代次数
    """
    logger.info("Meta Scheduler: Analyzing diagnostic report and planning corrections...")
    
    diagnostic_report = state.get("diagnostic_report", {})
    iteration_count = state.get("iteration_count", 0)
    max_iterations = state.get("max_iterations", 3)
    
    # 检查迭代次数
    if iteration_count >= max_iterations:
        logger.warning(f"Max iterations ({max_iterations}) reached, escalating to human review")
        return {
            **state,
            "current_agent": "human_review",
            "reasoning": state.get("reasoning", []) + [
                f"元调度器：达到最大迭代次数 {max_iterations}，升级到人工审核"
            ]
        }
    
    # ===== Step 1: 分析诊断报告，确定修正策略 =====
    correction_strategy = diagnostic_report.get("correction_strategy", "regenerate")
    correction_instructions = diagnostic_report.get("correction_instructions", [])
    affected_agents = diagnostic_report.get("affected_agents", [])
    
    if not affected_agents:
        # 如果诊断报告没有明确指出，使用启发式规则
        affected_agents = _heuristic_determine_agents(diagnostic_report)
    
    # ===== Step 2: 为每个受影响的 Agent 生成修正 Prompt =====
    correction_prompts = {}
    
    for agent_name in affected_agents:
        # 找到该 Agent 相关的所有修正指令
        agent_instructions = [
            inst for inst in correction_instructions
            if inst.get("target_agent") == agent_name
        ]
        
        if agent_instructions:
            # 生成增强 Prompt
            enhanced_prompt = _generate_correction_prompt(
                agent_name=agent_name,
                instructions=agent_instructions,
                original_output=state.get(f"{agent_name}_output"),
                diagnostic_report=diagnostic_report
            )
            
            correction_prompts[agent_name] = enhanced_prompt
    
    # ===== Step 3: 决定从哪个 Agent 开始 =====
    # 优先级：outline_agent > character_agent > plot_agent
    agent_priority = ["outline_agent", "character_agent", "plot_agent"]
    
    restart_agent = None
    for agent in agent_priority:
        if agent in affected_agents:
            restart_agent = agent
            break
    
    if not restart_agent:
        restart_agent = affected_agents[0] if affected_agents else "outline_agent"
    
    # ===== Step 4: 决定修正范围 =====
    if correction_strategy == "regenerate":
        # 全量重新生成：清空受影响 Agent 的输出
        _clear_affected_outputs(state, affected_agents)
        correction_mode = "regenerate"
    else:
        # 增量修复：保留现有输出，只修改有问题的部分
        correction_mode = "incremental"
    
    return {
        **state,
        "iteration_count": iteration_count + 1,
        "current_agent": restart_agent,
        "correction_prompts": correction_prompts,  # 修正 Prompt
        "correction_mode": correction_mode,  # 修正模式
        "affected_agents": affected_agents,
        "reasoning": state.get("reasoning", []) + [
            f"元调度器：分析诊断报告",
            f"元调度器：确定修正策略 - {correction_strategy}",
            f"元调度器：受影响 Agent - {', '.join(affected_agents)}",
            f"元调度器：从 {restart_agent} 开始修正",
            f"元调度器：修正模式 - {correction_mode}",
            f"元调度器：当前迭代次数 {iteration_count + 1}/{max_iterations}"
        ]
    }


def _heuristic_determine_agents(diagnostic_report: Dict) -> List[str]:
    """启发式确定受影响的 Agent"""
    issues = diagnostic_report.get("issues", [])
    agents = set()
    
    for issue in issues:
        sub_category = issue.get("sub_category", "")
        
        if "character" in sub_category:
            agents.add("character_agent")
        if "outline" in sub_category:
            agents.add("outline_agent")
        if "plot" in sub_category or "timeline" in sub_category:
            agents.add("plot_agent")
    
    return list(agents) if agents else ["outline_agent"]


def _generate_correction_prompt(
    agent_name: str,
    instructions: List[Dict],
    original_output: Any,
    diagnostic_report: Dict
) -> str:
    """生成增强的修正 Prompt"""
    prompt_parts = [
        "## 修正任务\n",
        "根据审核反馈，需要修正以下问题：\n\n"
    ]
    
    for i, inst in enumerate(instructions, 1):
        prompt_parts.append(f"### 问题 {i}\n")
        prompt_parts.append(f"**描述**: {inst.get('specific_instruction')}\n")
        prompt_parts.append(f"**操作**: {inst.get('action')}\n")
        
        if inst.get('parameters'):
            prompt_parts.append(f"**参数**: {json.dumps(inst['parameters'], ensure_ascii=False)}\n")
        
        prompt_parts.append("\n")
    
    prompt_parts.append("## 修正要求\n")
    prompt_parts.append("1. 针对性修正：只修改有问题的部分\n")
    prompt_parts.append("2. 保持一致性：确保与其他部分协调\n")
    prompt_parts.append("3. 提升质量：不只是修复问题，还要提升整体质量\n")
    
    return "".join(prompt_parts)


def _clear_affected_outputs(state: Dict, affected_agents: List[str]):
    """清空受影响 Agent 的输出（全量重新生成模式）"""
    if "outline_agent" in affected_agents:
        state["outline_nodes"] = []
    if "character_agent" in affected_agents:
        state["characters"] = []
        state["character_relations"] = []
    if "plot_agent" in affected_agents:
        state["timeline_events"] = []
```

### 2.3 Agent 修正执行（接收修正 Prompt）

```python
# 修改专业 Agent，使其能够接收和应用修正 Prompt

async def character_agent_node_v2(state: PipelineState) -> PipelineState:
    """角色 Agent v2.0 - 支持修正模式"""
    
    correction_prompts = state.get("correction_prompts", {})
    correction_mode = state.get("correction_mode", "regenerate")
    
    # 检查是否有针对本 Agent 的修正 Prompt
    if "character_agent" in correction_prompts:
        correction_prompt = correction_prompts["character_agent"]
        
        if correction_mode == "incremental":
            # 增量修复模式：加载现有角色，只修改有问题的
            existing_characters = state.get("characters", [])
            
            # 使用增强 Prompt 进行修正
            system_message = SystemMessage(content=f"""
你是角色设计师，现在需要根据审核反馈进行修正。

{correction_prompt}

## 现有角色
{json.dumps(existing_characters, ensure_ascii=False, indent=2)}

请输出修正后的完整角色列表（JSON格式）。
""")
        else:
            # 全量重新生成模式
            system_message = SystemMessage(content=f"""
你是角色设计师，需要重新设计角色。

{correction_prompt}

请设计角色（JSON格式）。
""")
    else:
        # 正常模式（首次生成）
        system_message = SystemMessage(content="""
你是角色设计师，根据大纲设计角色...
""")
    
    # ... 后续生成逻辑类似 v1.0
```

---

## 三、核心改进 2：规划 Agent

### 3.1 规划 Agent 实现

```python
# src/core/agents/nodes/planner_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
import json


async def planner_agent_node(state: PipelineState) -> PipelineState:
    """规划 Agent - 动态任务分解和执行计划生成
    
    职责：
    1. 分析用户需求（理解意图）
    2. 动态任务分解（生成子任务列表）
    3. 确定执行顺序（Agent 序列）
    4. 选择工具集（为每个 Agent 配置工具）
    5. 生成执行计划
    """
    logger.info("Planner Agent: Analyzing user requirement and generating execution plan...")
    
    user_requirement = state["user_requirement"]
    
    # ===== Step 1: 需求分析 =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.3)
    
    system_message = SystemMessage(content="""
你是一位专业的任务规划师。你的职责是分析用户的创作需求，并生成详细的执行计划。

## 分析维度
1. **需求类型**: 全新创作 / 扩展现有内容 / 修改优化
2. **复杂度**: 简单（单一任务）/ 中等（3-5个子任务）/ 复杂（>5个子任务）
3. **需要的能力**: 世界观设定 / 角色设计 / 情节构思 / 大纲规划

## 执行计划生成规则
- **全新创作**：世界观 → 角色 → 大纲 → 情节 → 审核
- **扩展内容**：分析现有 → 角色/情节 → 审核
- **修改优化**：诊断 → 针对性修正 → 审核

## 输出格式：JSON
{
  "requirement_analysis": {
    "type": "new_creation",  // new_creation, extension, modification
    "complexity": "medium",   // simple, medium, complex
    "required_capabilities": ["worldview", "character", "outline", "plot"]
  },
  "execution_plan": {
    "steps": [
      {
        "step_id": 1,
        "agent": "worldview_agent",  // 如果需要
        "task_description": "构建赛博朋克世界观：2077年，大公司统治，阶级分化严重",
        "required_tools": ["SettingTool", "RAGTool"],
        "dependencies": [],  // 依赖的前序步骤
        "estimated_tokens": 2000
      },
      {
        "step_id": 2,
        "agent": "character_agent",
        "task_description": "设计主角：私家侦探，具有黑客技能",
        "required_tools": ["CharacterTool", "RelationTool", "RAGTool"],
        "dependencies": [1],  // 依赖世界观
        "estimated_tokens": 3000
      },
      {
        "step_id": 3,
        "agent": "outline_agent",
        "task_description": "生成大纲：主线围绕调查大公司阴谋",
        "required_tools": ["OutlineTool", "RAGTool"],
        "dependencies": [1, 2],
        "estimated_tokens": 4000
      },
      {
        "step_id": 4,
        "agent": "plot_agent",
        "task_description": "安排情节事件和时间线",
        "required_tools": ["TimelineTool", "RAGTool"],
        "dependencies": [2, 3],
        "estimated_tokens": 3000
      },
      {
        "step_id": 5,
        "agent": "review_agent_v2",
        "task_description": "审核一致性和质量",
        "required_tools": [],
        "dependencies": [1, 2, 3, 4],
        "estimated_tokens": 2000
      }
    ],
    "total_estimated_tokens": 14000,
    "parallelizable_steps": [],  // 未来可并行执行的步骤
    "critical_path": [1, 2, 3, 4, 5]
  },
  "tool_configuration": {
    "enable_rag": true,
    "enable_knowledge_graph": false,  // 未来扩展
    "context_mode": "auto"  // auto, minimal, full
  },
  "reasoning": [
    "用户需求包含'赛博朋克'和'侦探'，需要世界观设定",
    "需要设计主角和相关角色",
    "需要完整的大纲和情节安排",
    "因此采用完整流程：世界观→角色→大纲→情节→审核"
  ]
}
""")
    
    user_message = HumanMessage(content=f"""
用户需求：{user_requirement}

请生成执行计划（JSON格式）。
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # 解析执行计划
    try:
        plan_dict = json.loads(response.content)
    except:
        # 解析失败，使用默认计划
        plan_dict = _generate_default_plan()
    
    execution_plan = plan_dict.get("execution_plan", {})
    steps = execution_plan.get("steps", [])
    
    # ===== Step 2: 确定第一个 Agent =====
    first_step = steps[0] if steps else {"agent": "outline_agent"}
    next_agent = first_step.get("agent", "outline_agent")
    
    return {
        **state,
        "requirement_analysis": plan_dict.get("requirement_analysis", {}),
        "execution_plan": execution_plan,
        "tool_configuration": plan_dict.get("tool_configuration", {}),
        "current_step": 0,
        "current_agent": next_agent,
        "completed_agents": ["planner_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + plan_dict.get("reasoning", [])
    }


def _generate_default_plan() -> Dict:
    """生成默认执行计划"""
    return {
        "requirement_analysis": {
            "type": "new_creation",
            "complexity": "medium",
            "required_capabilities": ["character", "outline", "plot"]
        },
        "execution_plan": {
            "steps": [
                {"step_id": 1, "agent": "outline_agent", "required_tools": ["OutlineTool", "RAGTool"]},
                {"step_id": 2, "agent": "character_agent", "required_tools": ["CharacterTool", "RelationTool", "RAGTool"]},
                {"step_id": 3, "agent": "plot_agent", "required_tools": ["TimelineTool", "RAGTool"]},
                {"step_id": 4, "agent": "review_agent_v2", "required_tools": []}
            ]
        },
        "tool_configuration": {"enable_rag": True},
        "reasoning": ["使用默认流程"]
    }
```

### 3.2 动态路由器（根据计划执行）

```python
# src/core/agents/workflows/dynamic_router.py

def create_dynamic_router(state: PipelineState) -> str:
    """动态路由器 - 根据执行计划路由到下一个 Agent"""
    execution_plan = state.get("execution_plan", {})
    current_step = state.get("current_step", 0)
    steps = execution_plan.get("steps", [])
    
    if current_step >= len(steps):
        return "review_agent_v2"
    
    next_step = steps[current_step]
    next_agent = next_step.get("agent", "outline_agent")
    
    # 更新当前步骤
    state["current_step"] = current_step + 1
    
    return next_agent
```

---

## 四、核心改进 3：深度 RAG 集成

### 4.1 工作区上下文工具（主动感知）

```python
# src/core/tools/langchain/workspace_context_tool.py
from typing import Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class WorkspaceContextToolInput(ToolInputSchema):
    """工作区上下文工具输入"""
    task_type: str = Field(..., description="任务类型: continue_writing, create_chapter, review_content")
    context_scope: str = Field(..., description="上下文范围: current_chapter, full_project, related_entities")
    
    # 上下文参数
    chapter_id: str = Field(None, description="章节 ID（如果任务是续写章节）")
    character_ids: List[str] = Field(default_factory=list, description="相关角色 ID")


class WorkspaceContextTool(BaseTool):
    """工作区上下文工具 - 主动获取当前任务相关的结构化上下文
    
    借鉴 Cursor 的核心理念：
    - 不是被动等待 Agent 查询，而是主动理解任务并提供上下文
    - 返回结构化数据，不是纯文本 chunks
    - 包含多种类型：前序内容 + 角色卡 + 大纲节点 + 世界设定
    """
    
    def __init__(self, go_api_client, auth_context=None):
        metadata = ToolMetadata(
            name="workspace_context_tool",
            description="主动获取当前写作任务相关的结构化上下文",
            category="knowledge",
            requires_auth=True,
            requires_project=True
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return WorkspaceContextToolInput
    
    async def _execute_impl(self, validated_input: WorkspaceContextToolInput) -> ToolResult:
        """执行上下文获取"""
        task_type = validated_input.task_type
        project_id = validated_input.project_id
        
        context = {
            "task_type": task_type,
            "related_content": {}
        }
        
        # ===== 1. 根据任务类型，智能获取上下文 =====
        if task_type == "continue_writing" and validated_input.chapter_id:
            # 续写任务：获取前序章节内容 + 本章大纲 + 出场角色
            context["related_content"] = await self._get_continue_writing_context(
                project_id, validated_input.chapter_id
            )
        
        elif task_type == "create_chapter":
            # 新章节任务：获取大纲节点 + 全部角色 + 前序章节摘要
            context["related_content"] = await self._get_create_chapter_context(project_id)
        
        elif task_type == "review_content":
            # 审核任务：获取完整项目概览
            context["related_content"] = await self._get_review_context(project_id)
        
        return ToolResult(
            success=True,
            data=context,
            metadata={"context_items": len(context["related_content"])}
        )
    
    async def _get_continue_writing_context(self, project_id: str, chapter_id: str) -> Dict:
        """获取续写上下文（结构化）"""
        context = {}
        
        # 1. 获取本章大纲节点
        outline_response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{chapter_id}",
            user_id=self.auth_context.get("user_id")
        )
        context["current_outline_node"] = outline_response.get("data")
        
        # 2. 获取前一章内容（最后500字）
        # ... 调用章节内容 API
        
        # 3. 获取本章出场角色
        participants = outline_response.get("data", {}).get("metadata", {}).get("participants", [])
        if participants:
            characters_response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/projects/{project_id}/characters",
                params={"ids": ",".join(participants)},
                user_id=self.auth_context.get("user_id")
            )
            context["participating_characters"] = characters_response.get("data", {}).get("items", [])
        
        # 4. 获取相关时间线事件
        timeline_response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/timeline-events",
            params={"chapterRef": chapter_id},
            user_id=self.auth_context.get("user_id")
        )
        context["timeline_events"] = timeline_response.get("data", {}).get("items", [])
        
        return context
    
    async def _get_create_chapter_context(self, project_id: str) -> Dict:
        """获取新建章节上下文"""
        # ... 类似实现
        pass
    
    async def _get_review_context(self, project_id: str) -> Dict:
        """获取审核上下文"""
        # ... 类似实现
        pass
```

### 4.2 结构化 RAG 增强

```python
# 在向量化时注入元数据
from core.rag.knowledge_base import KnowledgeBaseManager

async def index_character_with_metadata(character: Dict, kb_manager: KnowledgeBaseManager):
    """索引角色（带丰富元数据）"""
    document = Document(
        id=character["id"],
        user_id=character["userId"],
        project_id=character["projectId"],
        content=f"""
角色名称：{character["name"]}
别名：{", ".join(character.get("alias", []))}
角色类型：{character.get("roleType")}
性格标签：{", ".join(character.get("traits", []))}
背景故事：{character.get("background", "")}
""",
        content_type="character",
        metadata={
            "doc_type": "character",
            "character_id": character["id"],
            "character_name": character["name"],
            "role_type": character.get("roleType"),
            "traits": character.get("traits", []),
            # 更多元数据...
        }
    )
    
    await kb_manager.index_document(document)


# 混合检索（结构化过滤 + 向量相似度）
from core.rag.retriever import HybridSearchEngine

search_results = await search_engine.search(
    query="找到勇敢善良的主角",
    user_id=user_id,
    project_id=project_id,
    top_k=5,
    # 结构化过滤
    filters={
        "content_type": "character",
        "role_type": "protagonist",
        "traits": {"$contains": "勇敢"}  # 假设支持这种查询
    }
)
```

---

## 五、核心改进 4：知识图谱集成（长期演进）

### 5.1 知识图谱构建

```python
# src/core/knowledge_graph/graph_builder.py (未来实现)
from typing import List, Dict, Any

class KnowledgeGraphBuilder:
    """知识图谱构建器
    
    实体节点：
    - Character (角色)
    - Location (地点)
    - Event (事件)
    - Item (道具)
    
    关系边：
    - knows (认识)
    - friend_of (朋友)
    - enemy_of (敌人)
    - visited (去过)
    - participated_in (参与了)
    """
    
    def __init__(self, neo4j_client):
        self.neo4j = neo4j_client
    
    async def add_character_node(self, character: Dict):
        """添加角色节点"""
        query = """
        CREATE (c:Character {
            id: $id,
            name: $name,
            role_type: $role_type,
            traits: $traits,
            description: $description
        })
        """
        await self.neo4j.run(query, character)
    
    async def add_relationship(self, from_id: str, to_id: str, rel_type: str, properties: Dict):
        """添加关系"""
        query = f"""
        MATCH (a:Character {{id: $from_id}})
        MATCH (b:Character {{id: $to_id}})
        CREATE (a)-[r:{rel_type} $properties]->(b)
        """
        await self.neo4j.run(query, {
            "from_id": from_id,
            "to_id": to_id,
            "properties": properties
        })


# 混合查询引擎
class HybridKGVectorEngine:
    """知识图谱 + 向量检索混合引擎"""
    
    async def query(self, natural_language_query: str) -> List[Dict]:
        """混合查询
        
        示例：找到和主角亦敌亦友，并且去过'迷雾森林'的角色
        
        执行步骤：
        1. 图查询：找到与主角有 friend_of 和 enemy_of 关系的角色
        2. 图查询：找到 visited '迷雾森林'的角色
        3. 交集
        4. 在交集中，用向量查询找"性格描述最符合..."的角色
        """
        
        # 1. 图查询
        graph_results = await self._graph_query(natural_language_query)
        
        # 2. 向量查询（在图查询结果范围内）
        candidate_ids = [r["id"] for r in graph_results]
        vector_results = await self._vector_query_in_scope(natural_language_query, candidate_ids)
        
        # 3. 融合
        return self._merge_results(graph_results, vector_results)
```

---

## 六、Pipeline 状态 Schema v2.0

```python
# src/core/agents/states/pipeline_state_v2.py
from typing import TypedDict, Annotated, List, Dict, Any, Optional
import operator


class PipelineStateV2(TypedDict):
    """A2A 流水线状态 v2.0（增强版）"""
    
    # ===== 输入 =====
    user_requirement: str
    user_id: str
    project_id: str
    pipeline_config: Dict[str, Any]
    
    # ===== v2.0 新增：规划 Agent 输出 =====
    requirement_analysis: Dict[str, Any]      # 需求分析结果
    execution_plan: Dict[str, Any]            # 执行计划
    tool_configuration: Dict[str, Any]        # 工具配置
    current_step: int                         # 当前执行步骤
    
    # ===== 专业 Agent 输出 =====
    outline_nodes: List[Dict[str, Any]]
    outline_summary: str
    outline_metadata: Dict[str, Any]
    
    characters: List[Dict[str, Any]]
    character_relations: List[Dict[str, Any]]
    character_summary: str
    
    timeline_events: List[Dict[str, Any]]
    plot_nodes: List[Dict[str, Any]]
    plot_summary: str
    
    # ===== v2.0 新增：审核 Agent 输出 =====
    diagnostic_report: Dict[str, Any]         # 结构化诊断报告（替代简单的 review_results）
    consistency_check: Dict[str, Any]
    quality_score: int
    review_passed: bool
    
    # ===== v2.0 新增：修正相关 =====
    correction_prompts: Dict[str, str]        # 为每个 Agent 生成的修正 Prompt
    correction_mode: str                      # "regenerate" 或 "incremental"
    affected_agents: List[str]                # 受影响的 Agent 列表
    
    # ===== 工作流控制 =====
    current_agent: str
    completed_agents: Annotated[List[str], operator.add]
    
    # 迭代控制
    iteration_count: int
    max_iterations: int
    
    # 人工介入
    human_intervention_required: bool
    human_feedback: Optional[str]
    
    # ===== v2.0 新增：上下文增强 =====
    workspace_context: Dict[str, Any]         # 工作区上下文（结构化）
    rag_context: str                          # RAG 检索上下文
    rag_metadata: Dict[str, Any]              # RAG 元数据
    
    # ===== 消息和推理 =====
    messages: Annotated[List[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]  # 完整的推理链路
    
    # ===== 错误处理 =====
    errors: Annotated[List[str], operator.add]
    warnings: Annotated[List[str], operator.add]
    
    # ===== 性能指标 =====
    start_time: float
    tokens_used: int
    tool_calls_count: int
```

---

## 七、Workflow v2.0 编排

```python
# src/core/agents/workflows/a2a_pipeline_v2.py
from langgraph.graph import StateGraph, END
from core.agents.states.pipeline_state_v2 import PipelineStateV2
from core.agents.nodes import (
    planner_agent_node,
    outline_agent_node_v2,
    character_agent_node_v2,
    plot_agent_node_v2,
    review_agent_node_v2,
    meta_scheduler_node
)


def create_a2a_pipeline_v2():
    """创建 A2A 创作流水线 v2.0 - 智能协作生态"""
    workflow = StateGraph(PipelineStateV2)
    
    # ===== 添加节点 =====
    workflow.add_node("planner_agent", planner_agent_node)  # 新增
    workflow.add_node("outline_agent", outline_agent_node_v2)
    workflow.add_node("character_agent", character_agent_node_v2)
    workflow.add_node("plot_agent", plot_agent_node_v2)
    workflow.add_node("review_agent_v2", review_agent_node_v2)  # 增强版
    workflow.add_node("meta_scheduler", meta_scheduler_node)    # 新增
    workflow.add_node("human_review", human_review_node)
    
    # ===== 设置入口点 =====
    workflow.set_entry_point("planner_agent")  # v2.0 从规划开始
    
    # ===== 规划后的动态路由 =====
    def planner_router(state: PipelineStateV2) -> str:
        """规划后路由到第一个 Agent"""
        execution_plan = state.get("execution_plan", {})
        steps = execution_plan.get("steps", [])
        
        if steps:
            first_agent = steps[0].get("agent", "outline_agent")
            return first_agent
        else:
            return "outline_agent"  # 默认
    
    workflow.add_conditional_edges(
        "planner_agent",
        planner_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent",
            "worldview_agent": "worldview_agent"  # 未来扩展
        }
    )
    
    # ===== 动态执行流程 =====
    def dynamic_next_router(state: PipelineStateV2) -> str:
        """动态路由到下一个 Agent（根据执行计划）"""
        execution_plan = state.get("execution_plan", {})
        current_step = state.get("current_step", 0)
        steps = execution_plan.get("steps", [])
        
        if current_step < len(steps):
            next_agent = steps[current_step].get("agent")
            return next_agent
        else:
            return "review_agent_v2"
    
    # 为每个专业 Agent 添加动态路由
    for agent_name in ["outline_agent", "character_agent", "plot_agent"]:
        workflow.add_conditional_edges(
            agent_name,
            dynamic_next_router,
            {
                "outline_agent": "outline_agent",
                "character_agent": "character_agent",
                "plot_agent": "plot_agent",
                "review_agent_v2": "review_agent_v2"
            }
        )
    
    # ===== 审核后的路由（智能修正）=====
    def review_router(state: PipelineStateV2) -> str:
        """审核后路由"""
        current_agent = state.get("current_agent", "")
        
        if current_agent == "completed":
            return "end"
        elif current_agent == "human_review":
            return "human_review"
        elif current_agent == "meta_scheduler":
            return "meta_scheduler"  # 进入修正循环
        else:
            return "end"
    
    workflow.add_conditional_edges(
        "review_agent_v2",
        review_router,
        {
            "end": END,
            "human_review": "human_review",
            "meta_scheduler": "meta_scheduler"
        }
    )
    
    # ===== 元调度器后的路由（回到专业 Agent）=====
    def meta_scheduler_router(state: PipelineStateV2) -> str:
        """元调度器路由到需要修正的 Agent"""
        return state.get("current_agent", "outline_agent")
    
    workflow.add_conditional_edges(
        "meta_scheduler",
        meta_scheduler_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent"
        }
    )
    
    # ===== 人工审核后的路由 =====
    workflow.add_conditional_edges(
        "human_review",
        lambda state: "end" if state.get("review_passed") else "meta_scheduler",
        {
            "end": END,
            "meta_scheduler": "meta_scheduler"
        }
    )
    
    # 编译
    app = workflow.compile()
    return app
```

---

## 八、使用示例

```python
# 示例 1：全新创作
pipeline_v2 = create_a2a_pipeline_v2()

initial_state = {
    "user_requirement": "创作一部赛博朋克背景的侦探小说，主角是私家侦探，擅长黑客技术",
    "user_id": "user-123",
    "project_id": "proj-456",
    "pipeline_config": {
        "enable_rag": True,
        "enable_planner": True,  # v2.0 启用规划 Agent
        "enable_knowledge_graph": False  # 未来启用
    },
    "max_iterations": 3,
    "iteration_count": 0,
    "current_step": 0,
    "messages": [],
    "reasoning": [],
    "completed_agents": [],
    "tool_calls_count": 0,
    "start_time": time.time(),
    "tokens_used": 0
}

# 执行
result = await pipeline_v2.ainvoke(initial_state)

# 查看推理链路
print("=== 推理链路 ===")
for reasoning in result["reasoning"]:
    print(f"- {reasoning}")

# 查看诊断报告
if result.get("diagnostic_report"):
    report = result["diagnostic_report"]
    print(f"\n=== 诊断报告 ===")
    print(f"质量评分: {report['quality_score']}/100")
    print(f"问题数量: {len(report['issues'])}")
    for issue in report["issues"]:
        print(f"- [{issue['severity']}] {issue['title']}: {issue['root_cause']}")


# 示例 2：使用工作区上下文工具
from core.tools.langchain.workspace_context_tool import WorkspaceContextTool

workspace_tool = WorkspaceContextTool(go_api_client, auth_context)

context_result = await workspace_tool.execute(
    params={
        "task_type": "continue_writing",
        "context_scope": "current_chapter",
        "chapter_id": "chapter-001",
        "project_id": "proj-456"
    },
    user_id="user-123",
    project_id="proj-456"
)

if context_result.success:
    context = context_result.data
    print("=== 工作区上下文 ===")
    print(f"当前大纲节点: {context['related_content']['current_outline_node']['name']}")
    print(f"出场角色数: {len(context['related_content'].get('participating_characters', []))}")
    print(f"相关事件数: {len(context['related_content'].get('timeline_events', []))}")
```

---

## 九、与 v1.0 兼容性

v2.0 设计为渐进式升级：

1. **向后兼容**：可以禁用新功能，退回到 v1.0 流程
2. **渐进实施**：可以先实现反思循环，再实现规划Agent
3. **配置驱动**：通过 `pipeline_config` 控制启用哪些功能

```python
# 配置为 v1.0 模式
pipeline_config = {
    "enable_planner": False,  # 不启用规划 Agent
    "enable_meta_scheduler": False,  # 使用简单的 regenerate_router
    "enable_workspace_context": False  # 使用普通 RAG
}
```

---

## 十、总结与后续工作

### v2.0 核心改进总结

| 改进点 | v1.0 | v2.0 | 受益 |
|-------|------|------|------|
| **反思循环** | 简单 pass/fail | 结构化诊断 + 智能修正 | 质量提升 30%+ |
| **规划能力** | 固定流程 | 动态任务分解 | 灵活性提升 |
| **上下文** | 被动RAG | 主动上下文工具 | 理解力提升 |
| **修正策略** | 全量重生成 | 增量 + 全量混合 | 效率提升 50%+ |
| **可扩展性** | 新增Agent需改workflow | 配置驱动 | 开发效率提升 |

### 实施优先级

| 阶段 | 功能 | 优先级 | 预计工期 |
|------|------|--------|---------|
| Phase 1 | 增强审核Agent（诊断报告） | P0 | 1周 |
| Phase 1 | 元调度器（智能修正） | P0 | 1周 |
| Phase 2 | 工作区上下文工具 | P0 | 1周 |
| Phase 2 | 结构化RAG增强 | P1 | 1周 |
| Phase 3 | 规划Agent | P1 | 2周 |
| Phase 4 | 知识图谱集成 | P2 | 4周+ |

### 后续工作

1. **短期（1-2个月）**
   - 实现反思循环和元调度器
   - 实现工作区上下文工具
   - 完善诊断报告生成

2. **中期（3-6个月）**
   - 实现规划Agent
   - 引入知识图谱雏形
   - 优化修正策略

3. **长期（6个月+）**
   - 完整的知识图谱系统
   - 多Agent并行执行
   - 自适应学习和优化

---

**文档版本**: v2.0  
**创建时间**: 2025-10-28  
**维护者**: AI架构组  
**理念**: 从流水线到智能协作生态

