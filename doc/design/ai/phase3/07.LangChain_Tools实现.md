# LangChain Tools 实现

> **文档版本**: v1.0
> **创建时间**: 2025-10-27
> **实施状态**: 设计阶段
> **负责人**: AI架构组

---

## 📋 文档概述

本文档详细设计 LangChain Tools 的实现，包括 Tool 基类、核心工具（角色卡、大纲、时间线等）的具体实现、参数验证、错误处理和权限控制机制。

**适用范围**：
- Tool 基类设计
- 7 个核心工具实现
- 参数验证和 Schema 定义
- 工具注册和管理
- 权限控制和审计

---

## 🎯 设计目标

### 核心目标

1. **统一接口**：所有工具遵循统一的 Tool 接口规范
2. **类型安全**：完整的参数验证和类型检查
3. **易于扩展**：新增工具只需继承基类并实现核心方法
4. **权限控制**：工具级别的权限检查和审计日志
5. **错误恢复**：完善的错误处理和重试机制

### 非目标

- ❌ 不实现 MCP 协议（单独文档）
- ❌ 不包含业务逻辑（调用 Go API）

---

## 一、Tool 基类设计

### 1.1 基类架构

```python
# src/core/tools/base.py
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type
from pydantic import BaseModel, Field, validator
from dataclasses import dataclass
import asyncio
from utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ToolMetadata:
    """工具元数据"""
    name: str                      # 工具名称
    description: str               # 工具描述
    category: str                  # 分类：writing, knowledge, analysis
    requires_auth: bool = True     # 是否需要认证
    requires_project: bool = False # 是否需要项目上下文
    version: str = "1.0.0"         # 版本
    
    # 高级配置
    timeout_seconds: int = 30      # 超时时间
    max_retries: int = 3           # 最大重试次数
    rate_limit_per_minute: int = 60  # 速率限制


class ToolParameter(BaseModel):
    """工具参数定义"""
    name: str = Field(..., description="参数名称")
    type: str = Field(..., description="参数类型: string, number, boolean, object, array")
    description: str = Field(..., description="参数描述")
    required: bool = Field(default=False, description="是否必需")
    default: Any = Field(default=None, description="默认值")
    enum: Optional[List[Any]] = Field(default=None, description="枚举值")
    
    @validator('type')
    def validate_type(cls, v):
        """验证类型"""
        valid_types = ['string', 'number', 'integer', 'boolean', 'object', 'array']
        if v not in valid_types:
            raise ValueError(f"Invalid type: {v}, must be one of {valid_types}")
        return v


class ToolInputSchema(BaseModel):
    """工具输入 Schema 基类"""
    
    class Config:
        extra = "forbid"  # 禁止额外字段


class ToolResult(BaseModel):
    """工具执行结果"""
    success: bool = Field(..., description="是否成功")
    data: Any = Field(default=None, description="返回数据")
    error: Optional[str] = Field(default=None, description="错误信息")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="元数据")
    
    # 性能指标
    duration_ms: int = Field(default=0, description="执行时长（毫秒）")
    retries: int = Field(default=0, description="重试次数")


class BaseTool(ABC):
    """工具基类"""
    
    def __init__(
        self,
        metadata: ToolMetadata,
        go_api_client: 'GoAPIClient',
        auth_context: Optional[Dict[str, str]] = None
    ):
        """初始化
        
        Args:
            metadata: 工具元数据
            go_api_client: Go API 客户端
            auth_context: 认证上下文（user_id, token 等）
        """
        self.metadata = metadata
        self.go_api_client = go_api_client
        self.auth_context = auth_context or {}
        self.logger = get_logger(f"tool.{metadata.name}")
    
    @property
    @abstractmethod
    def input_schema(self) -> Type[ToolInputSchema]:
        """输入 Schema（子类必须实现）"""
        pass
    
    @abstractmethod
    async def _execute_impl(self, validated_input: ToolInputSchema) -> ToolResult:
        """执行实现（子类必须实现）
        
        Args:
            validated_input: 已验证的输入
            
        Returns:
            工具执行结果
        """
        pass
    
    async def execute(
        self,
        params: Dict[str, Any],
        user_id: Optional[str] = None,
        project_id: Optional[str] = None,
        agent_call_id: Optional[str] = None
    ) -> ToolResult:
        """执行工具（对外接口）
        
        Args:
            params: 参数字典
            user_id: 用户 ID
            project_id: 项目 ID
            agent_call_id: Agent 调用 ID
            
        Returns:
            工具执行结果
        """
        start_time = asyncio.get_event_loop().time()
        retries = 0
        
        try:
            # 1. 权限检查
            if self.metadata.requires_auth and not user_id:
                return ToolResult(
                    success=False,
                    error="Missing user_id for authenticated tool"
                )
            
            if self.metadata.requires_project and not project_id:
                return ToolResult(
                    success=False,
                    error="Missing project_id for project-scoped tool"
                )
            
            # 2. 参数验证
            try:
                validated_input = self.input_schema(**params)
            except Exception as e:
                self.logger.error(f"Parameter validation failed: {e}")
                return ToolResult(
                    success=False,
                    error=f"Invalid parameters: {str(e)}"
                )
            
            # 3. 执行（带重试）
            last_error = None
            for attempt in range(self.metadata.max_retries):
                try:
                    # 设置超时
                    result = await asyncio.wait_for(
                        self._execute_impl(validated_input),
                        timeout=self.metadata.timeout_seconds
                    )
                    
                    # 计算耗时
                    duration_ms = int((asyncio.get_event_loop().time() - start_time) * 1000)
                    result.duration_ms = duration_ms
                    result.retries = retries
                    
                    self.logger.info(
                        f"Tool executed successfully",
                        tool=self.metadata.name,
                        duration_ms=duration_ms,
                        retries=retries
                    )
                    
                    return result
                    
                except asyncio.TimeoutError:
                    last_error = f"Timeout after {self.metadata.timeout_seconds}s"
                    retries += 1
                    self.logger.warning(
                        f"Tool execution timeout (attempt {attempt + 1}/{self.metadata.max_retries})",
                        tool=self.metadata.name
                    )
                    
                except Exception as e:
                    last_error = str(e)
                    retries += 1
                    self.logger.error(
                        f"Tool execution failed (attempt {attempt + 1}/{self.metadata.max_retries})",
                        tool=self.metadata.name,
                        error=str(e)
                    )
                    
                    # 只在特定错误时重试
                    if not self._is_retryable_error(e):
                        break
                    
                    # 指数退避
                    if attempt < self.metadata.max_retries - 1:
                        await asyncio.sleep(2 ** attempt)
            
            # 所有重试失败
            return ToolResult(
                success=False,
                error=f"Tool execution failed after {retries} retries: {last_error}",
                retries=retries
            )
            
        except Exception as e:
            self.logger.error(f"Unexpected error in tool execution: {e}", exc_info=True)
            return ToolResult(
                success=False,
                error=f"Unexpected error: {str(e)}"
            )
    
    def _is_retryable_error(self, error: Exception) -> bool:
        """判断错误是否可重试"""
        # 网络错误、超时错误可重试
        retryable_types = (
            asyncio.TimeoutError,
            ConnectionError,
            TimeoutError,
        )
        return isinstance(error, retryable_types)
    
    def get_parameters_schema(self) -> List[ToolParameter]:
        """获取参数 Schema（用于 LLM Function Calling）"""
        schema = self.input_schema.schema()
        parameters = []
        
        for field_name, field_info in schema.get('properties', {}).items():
            param = ToolParameter(
                name=field_name,
                type=field_info.get('type', 'string'),
                description=field_info.get('description', ''),
                required=field_name in schema.get('required', []),
                default=field_info.get('default'),
                enum=field_info.get('enum')
            )
            parameters.append(param)
        
        return parameters
    
    def to_langchain_tool(self):
        """转换为 LangChain Tool 格式"""
        from langchain.tools import BaseTool as LangChainBaseTool
        from langchain.tools import ToolException
        
        class LangChainToolWrapper(LangChainBaseTool):
            name = self.metadata.name
            description = self.metadata.description
            
            async def _arun(self, **kwargs):
                result = await self.execute(params=kwargs)
                if not result.success:
                    raise ToolException(result.error)
                return result.data
            
            def _run(self, **kwargs):
                import asyncio
                return asyncio.run(self._arun(**kwargs))
        
        return LangChainToolWrapper()
```

---

## 二、核心工具实现

### 2.1 CharacterTool（角色卡工具）

```python
# src/core/tools/langchain/character_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult
from infrastructure.go_api import GoAPIClient


class CharacterToolInput(ToolInputSchema):
    """角色卡工具输入"""
    action: str = Field(
        ...,
        description="操作类型",
        enum=["create", "update", "get", "list", "delete"]
    )
    project_id: str = Field(..., description="项目 ID")
    character_id: Optional[str] = Field(None, description="角色 ID（update/get/delete 时需要）")
    
    # 角色数据（create/update 时使用）
    name: Optional[str] = Field(None, description="角色名称")
    alias: Optional[List[str]] = Field(None, description="别名列表")
    summary: Optional[str] = Field(None, description="角色简介")
    traits: Optional[List[str]] = Field(None, description="性格标签")
    background: Optional[str] = Field(None, description="背景故事")
    personality_prompt: Optional[str] = Field(None, description="性格提示词")
    speech_pattern: Optional[str] = Field(None, description="说话方式")


class CharacterTool(BaseTool):
    """角色卡工具"""
    
    def __init__(self, go_api_client: GoAPIClient, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="character_tool",
            description="管理小说角色卡片，支持创建、更新、查询、列表和删除操作",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return CharacterToolInput
    
    async def _execute_impl(self, validated_input: CharacterToolInput) -> ToolResult:
        """执行角色卡操作"""
        action = validated_input.action
        project_id = validated_input.project_id
        
        try:
            if action == "create":
                return await self._create_character(validated_input, project_id)
            elif action == "update":
                return await self._update_character(validated_input, project_id)
            elif action == "get":
                return await self._get_character(validated_input, project_id)
            elif action == "list":
                return await self._list_characters(project_id)
            elif action == "delete":
                return await self._delete_character(validated_input, project_id)
            else:
                return ToolResult(
                    success=False,
                    error=f"Unknown action: {action}"
                )
        except Exception as e:
            self.logger.error(f"Character tool execution failed: {e}")
            return ToolResult(
                success=False,
                error=str(e)
            )
    
    async def _create_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """创建角色卡"""
        # 构建请求数据
        character_data = {
            "name": input_data.name,
            "alias": input_data.alias or [],
            "summary": input_data.summary or "",
            "traits": input_data.traits or [],
            "background": input_data.background or "",
            "personalityPrompt": input_data.personality_prompt or "",
            "speechPattern": input_data.speech_pattern or ""
        }
        
        # 调用 Go API
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/characters",
            data=character_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create", "character_id": response.get("data", {}).get("id")}
        )
    
    async def _update_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """更新角色卡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for update")
        
        # 构建更新数据（只包含非 None 的字段）
        update_data = {}
        if input_data.name is not None:
            update_data["name"] = input_data.name
        if input_data.alias is not None:
            update_data["alias"] = input_data.alias
        if input_data.summary is not None:
            update_data["summary"] = input_data.summary
        if input_data.traits is not None:
            update_data["traits"] = input_data.traits
        if input_data.background is not None:
            update_data["background"] = input_data.background
        if input_data.personality_prompt is not None:
            update_data["personalityPrompt"] = input_data.personality_prompt
        if input_data.speech_pattern is not None:
            update_data["speechPattern"] = input_data.speech_pattern
        
        response = await self.go_api_client.call_api(
            method="PUT",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            data=update_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "update", "character_id": input_data.character_id}
        )
    
    async def _get_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """获取角色卡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for get")
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "get", "character_id": input_data.character_id}
        )
    
    async def _list_characters(self, project_id: str) -> ToolResult:
        """列出所有角色卡"""
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/characters",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        characters = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=characters,
            metadata={"action": "list", "count": len(characters)}
        )
    
    async def _delete_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """删除角色卡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for delete")
        
        await self.go_api_client.call_api(
            method="DELETE",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data={"deleted": True},
            metadata={"action": "delete", "character_id": input_data.character_id}
        )
```

### 2.2 OutlineTool（大纲工具）

```python
# src/core/tools/langchain/outline_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class OutlineToolInput(ToolInputSchema):
    """大纲工具输入"""
    action: str = Field(
        ...,
        description="操作类型",
        enum=["create_node", "update_node", "get_node", "list_children", "move_node", "delete_node"]
    )
    project_id: str = Field(..., description="项目 ID")
    node_id: Optional[str] = Field(None, description="节点 ID")
    parent_id: Optional[str] = Field(None, description="父节点 ID")
    
    # 节点数据
    name: Optional[str] = Field(None, description="节点名称")
    description: Optional[str] = Field(None, description="节点描述")
    order: Optional[int] = Field(None, description="排序顺序")
    metadata: Optional[Dict[str, Any]] = Field(None, description="节点元数据")


class OutlineTool(BaseTool):
    """大纲工具（基于 Node 模型）"""
    
    def __init__(self, go_api_client, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="outline_tool",
            description="管理小说大纲树形结构，支持创建、更新、移动、删除节点",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return OutlineToolInput
    
    async def _execute_impl(self, validated_input: OutlineToolInput) -> ToolResult:
        """执行大纲操作"""
        action = validated_input.action
        project_id = validated_input.project_id
        
        try:
            if action == "create_node":
                return await self._create_node(validated_input, project_id)
            elif action == "update_node":
                return await self._update_node(validated_input, project_id)
            elif action == "get_node":
                return await self._get_node(validated_input, project_id)
            elif action == "list_children":
                return await self._list_children(validated_input, project_id)
            elif action == "move_node":
                return await self._move_node(validated_input, project_id)
            elif action == "delete_node":
                return await self._delete_node(validated_input, project_id)
            else:
                return ToolResult(success=False, error=f"Unknown action: {action}")
        except Exception as e:
            self.logger.error(f"Outline tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
    
    async def _create_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """创建大纲节点"""
        node_data = {
            "projectId": project_id,
            "parentId": input_data.parent_id or "",
            "name": input_data.name,
            "type": "outline",
            "description": input_data.description or "",
            "order": input_data.order or 0,
            "metadata": input_data.metadata or {}
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/nodes",
            data=node_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_node", "node_id": response.get("data", {}).get("id")}
        )
    
    async def _update_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """更新大纲节点"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for update")
        
        update_data = {}
        if input_data.name is not None:
            update_data["name"] = input_data.name
        if input_data.description is not None:
            update_data["description"] = input_data.description
        if input_data.order is not None:
            update_data["order"] = input_data.order
        if input_data.metadata is not None:
            update_data["metadata"] = input_data.metadata
        
        response = await self.go_api_client.call_api(
            method="PUT",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            data=update_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "update_node", "node_id": input_data.node_id}
        )
    
    async def _list_children(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """列出子节点"""
        params = {"type": "outline"}
        if input_data.parent_id:
            params["parentId"] = input_data.parent_id
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes",
            params=params,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        nodes = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=nodes,
            metadata={"action": "list_children", "count": len(nodes)}
        )
    
    async def _get_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """获取节点详情"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for get")
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "get_node", "node_id": input_data.node_id}
        )
    
    async def _move_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """移动节点"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for move")
        
        move_data = {
            "parentId": input_data.parent_id or "",
            "order": input_data.order or 0
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}/move",
            data=move_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "move_node", "node_id": input_data.node_id}
        )
    
    async def _delete_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """删除节点"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for delete")
        
        await self.go_api_client.call_api(
            method="DELETE",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data={"deleted": True},
            metadata={"action": "delete_node", "node_id": input_data.node_id}
        )
```

### 2.3 TimelineTool（时间线工具）

```python
# src/core/tools/langchain/timeline_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class TimelineToolInput(ToolInputSchema):
    """时间线工具输入"""
    action: str = Field(
        ...,
        description="操作类型",
        enum=["create_timeline", "create_event", "update_event", "get_event", "list_events", "delete_event"]
    )
    project_id: str = Field(..., description="项目 ID")
    timeline_id: Optional[str] = Field(None, description="时间线 ID")
    event_id: Optional[str] = Field(None, description="事件 ID")
    
    # 时间线数据
    timeline_name: Optional[str] = Field(None, description="时间线名称")
    timeline_description: Optional[str] = Field(None, description="时间线描述")
    
    # 事件数据
    title: Optional[str] = Field(None, description="事件标题")
    description: Optional[str] = Field(None, description="事件描述")
    event_type: Optional[str] = Field(None, description="事件类型: plot, character, world, background, milestone")
    importance: Optional[int] = Field(None, description="重要性等级 1-10")
    participants: Optional[List[str]] = Field(None, description="参与角色 ID 列表")
    
    # 故事时间
    story_time: Optional[Dict[str, Any]] = Field(None, description="故事时间")


class TimelineTool(BaseTool):
    """时间线工具"""
    
    def __init__(self, go_api_client, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="timeline_tool",
            description="管理小说时间线和事件，支持创建时间线、添加事件、查询事件等",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return TimelineToolInput
    
    async def _execute_impl(self, validated_input: TimelineToolInput) -> ToolResult:
        """执行时间线操作"""
        action = validated_input.action
        
        try:
            if action == "create_timeline":
                return await self._create_timeline(validated_input)
            elif action == "create_event":
                return await self._create_event(validated_input)
            elif action == "update_event":
                return await self._update_event(validated_input)
            elif action == "get_event":
                return await self._get_event(validated_input)
            elif action == "list_events":
                return await self._list_events(validated_input)
            elif action == "delete_event":
                return await self._delete_event(validated_input)
            else:
                return ToolResult(success=False, error=f"Unknown action: {action}")
        except Exception as e:
            self.logger.error(f"Timeline tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
    
    async def _create_timeline(self, input_data: TimelineToolInput) -> ToolResult:
        """创建时间线"""
        timeline_data = {
            "projectId": input_data.project_id,
            "name": input_data.timeline_name,
            "description": input_data.timeline_description or ""
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timelines",
            data=timeline_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_timeline", "timeline_id": response.get("data", {}).get("id")}
        )
    
    async def _create_event(self, input_data: TimelineToolInput) -> ToolResult:
        """创建时间线事件"""
        if not input_data.timeline_id:
            return ToolResult(success=False, error="timeline_id is required for create_event")
        
        event_data = {
            "projectId": input_data.project_id,
            "timelineId": input_data.timeline_id,
            "title": input_data.title,
            "description": input_data.description or "",
            "eventType": input_data.event_type or "plot",
            "importance": input_data.importance or 5,
            "participants": input_data.participants or [],
            "storyTime": input_data.story_time
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timeline-events",
            data=event_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_event", "event_id": response.get("data", {}).get("id")}
        )
    
    async def _list_events(self, input_data: TimelineToolInput) -> ToolResult:
        """列出时间线事件"""
        params = {}
        if input_data.timeline_id:
            params["timelineId"] = input_data.timeline_id
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timeline-events",
            params=params,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        events = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=events,
            metadata={"action": "list_events", "count": len(events)}
        )
```

### 2.4 RAGTool（RAG 检索工具）

```python
# src/core/tools/langchain/rag_tool.py
from typing import Optional, List, Dict, Any
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult
from core.rag.retriever import HybridSearchEngine


class RAGToolInput(ToolInputSchema):
    """RAG 工具输入"""
    query: str = Field(..., description="查询文本")
    project_id: str = Field(..., description="项目 ID")
    content_types: Optional[List[str]] = Field(
        None,
        description="内容类型过滤: character, setting, outline, timeline"
    )
    top_k: int = Field(default=5, description="返回结果数量")
    enable_rerank: bool = Field(default=True, description="是否启用重排序")


class RAGTool(BaseTool):
    """RAG 检索工具"""
    
    def __init__(
        self,
        search_engine: HybridSearchEngine,
        go_api_client,
        auth_context: Dict[str, str] = None
    ):
        metadata = ToolMetadata(
            name="rag_tool",
            description="检索项目相关知识，包括角色、设定、大纲、时间线等内容",
            category="knowledge",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=10
        )
        super().__init__(metadata, go_api_client, auth_context)
        self.search_engine = search_engine
    
    @property
    def input_schema(self):
        return RAGToolInput
    
    async def _execute_impl(self, validated_input: RAGToolInput) -> ToolResult:
        """执行 RAG 检索"""
        try:
            # 执行检索
            results = await self.search_engine.search(
                query=validated_input.query,
                user_id=self.auth_context.get("user_id"),
                project_id=validated_input.project_id,
                top_k=validated_input.top_k,
                content_types=validated_input.content_types,
                enable_hybrid=True
            )
            
            # 可选重排序
            if validated_input.enable_rerank and len(results) > 0:
                from core.rag.reranker import Reranker
                reranker = Reranker()
                results = reranker.rerank(
                    query=validated_input.query,
                    results=results,
                    top_k=validated_input.top_k
                )
            
            # 转换结果
            formatted_results = []
            for result in results:
                formatted_results.append({
                    "content": result.chunk_text,
                    "score": result.score,
                    "content_type": result.metadata.get("content_type"),
                    "document_id": result.document_id,
                    "highlights": result.highlights
                })
            
            return ToolResult(
                success=True,
                data={
                    "results": formatted_results,
                    "total": len(formatted_results)
                },
                metadata={
                    "query": validated_input.query,
                    "top_k": validated_input.top_k,
                    "reranked": validated_input.enable_rerank
                }
            )
            
        except Exception as e:
            self.logger.error(f"RAG tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
```

### 2.5 RelationTool（角色关系工具）

```python
# src/core/tools/langchain/relation_tool.py
from typing import Optional
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class RelationToolInput(ToolInputSchema):
    """角色关系工具输入"""
    action: str = Field(
        ...,
        description="操作类型",
        enum=["create", "update", "get", "list", "delete"]
    )
    project_id: str = Field(..., description="项目 ID")
    relation_id: Optional[str] = Field(None, description="关系 ID")
    from_id: Optional[str] = Field(None, description="起始角色 ID")
    to_id: Optional[str] = Field(None, description="目标角色 ID")
    relation_type: Optional[str] = Field(
        None,
        description="关系类型: 朋友, 家庭, 敌人, 恋人, 盟友, 其他"
    )
    strength: Optional[int] = Field(None, description="关系强度 0-100")
    notes: Optional[str] = Field(None, description="关系备注")


class RelationTool(BaseTool):
    """角色关系工具"""
    
    def __init__(self, go_api_client, auth_context=None):
        metadata = ToolMetadata(
            name="relation_tool",
            description="管理角色之间的关系，支持创建、更新、查询和删除关系",
            category="writing",
            requires_auth=True,
            requires_project=True
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return RelationToolInput
    
    async def _execute_impl(self, validated_input: RelationToolInput) -> ToolResult:
        """执行关系操作"""
        action = validated_input.action
        
        if action == "create":
            relation_data = {
                "projectId": validated_input.project_id,
                "fromId": validated_input.from_id,
                "toId": validated_input.to_id,
                "type": validated_input.relation_type,
                "strength": validated_input.strength or 50,
                "notes": validated_input.notes or ""
            }
            
            response = await self.go_api_client.call_api(
                method="POST",
                endpoint=f"/api/v1/projects/{validated_input.project_id}/character-relations",
                data=relation_data,
                user_id=self.auth_context.get("user_id")
            )
            
            return ToolResult(
                success=True,
                data=response.get("data"),
                metadata={"action": "create"}
            )
        
        elif action == "list":
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/projects/{validated_input.project_id}/character-relations",
                user_id=self.auth_context.get("user_id")
            )
            
            relations = response.get("data", {}).get("items", [])
            return ToolResult(
                success=True,
                data=relations,
                metadata={"action": "list", "count": len(relations)}
            )
        
        # 其他操作类似实现...
        return ToolResult(success=True, data={})
```

---

## 三、工具注册和管理

### 3.1 工具注册表

```python
# src/core/tools/registry.py
from typing import Dict, List, Type, Optional
from core.tools.base import BaseTool, ToolMetadata
from core.tools.langchain import (
    CharacterTool,
    OutlineTool,
    TimelineTool,
    RAGTool,
    RelationTool
)
from utils.logging import get_logger

logger = get_logger(__name__)


class ToolRegistry:
    """工具注册表"""
    
    def __init__(self):
        self._tools: Dict[str, BaseTool] = {}
        self._tool_classes: Dict[str, Type[BaseTool]] = {}
    
    def register_tool_class(self, tool_class: Type[BaseTool]):
        """注册工具类"""
        # 临时实例获取元数据
        temp_instance = tool_class(None, None)
        tool_name = temp_instance.metadata.name
        
        self._tool_classes[tool_name] = tool_class
        logger.info(f"Registered tool class: {tool_name}")
    
    def register_tool_instance(self, tool: BaseTool):
        """注册工具实例"""
        self._tools[tool.metadata.name] = tool
        logger.info(f"Registered tool instance: {tool.metadata.name}")
    
    def get_tool(self, tool_name: str) -> Optional[BaseTool]:
        """获取工具实例"""
        return self._tools.get(tool_name)
    
    def list_tools(self) -> List[ToolMetadata]:
        """列出所有工具"""
        return [tool.metadata for tool in self._tools.values()]
    
    def get_tools_by_category(self, category: str) -> List[BaseTool]:
        """按分类获取工具"""
        return [
            tool for tool in self._tools.values()
            if tool.metadata.category == category
        ]
    
    async def register_all(self):
        """注册所有内置工具"""
        logger.info("Registering all tools...")
        
        # 注册工具类
        self.register_tool_class(CharacterTool)
        self.register_tool_class(OutlineTool)
        self.register_tool_class(TimelineTool)
        self.register_tool_class(RAGTool)
        self.register_tool_class(RelationTool)
        
        logger.info(f"Registered {len(self._tool_classes)} tool classes")
```

---

## 四、Go API 客户端

```python
# src/infrastructure/go_api/http_client.py
import aiohttp
from typing import Dict, Any, Optional
from utils.logging import get_logger

logger = get_logger(__name__)


class GoAPIClient:
    """Go API HTTP 客户端"""
    
    def __init__(self, base_url: str, timeout: int = 30):
        """初始化
        
        Args:
            base_url: Go 后端 URL
            timeout: 超时时间
        """
        self.base_url = base_url.rstrip('/')
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def initialize(self):
        """初始化会话"""
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        logger.info(f"Go API client initialized: {self.base_url}")
    
    async def close(self):
        """关闭会话"""
        if self.session:
            await self.session.close()
    
    async def call_api(
        self,
        method: str,
        endpoint: str,
        data: Dict[str, Any] = None,
        params: Dict[str, Any] = None,
        user_id: str = None,
        agent_call_id: str = None,
        auth_token: str = None
    ) -> Dict[str, Any]:
        """调用 Go API
        
        Args:
            method: HTTP 方法
            endpoint: API 端点
            data: 请求体数据
            params: 查询参数
            user_id: 用户 ID
            agent_call_id: Agent 调用 ID
            auth_token: 认证 Token
            
        Returns:
            响应数据
        """
        if not self.session:
            await self.initialize()
        
        url = f"{self.base_url}{endpoint}"
        
        # 构建 headers
        headers = {
            'Content-Type': 'application/json',
        }
        
        if auth_token:
            headers['Authorization'] = f'Bearer {auth_token}'
        
        if agent_call_id:
            headers['X-Agent-Call-ID'] = agent_call_id
        
        if user_id:
            headers['X-User-ID'] = user_id
        
        # 发送请求
        try:
            logger.debug(f"Calling Go API: {method} {url}")
            
            async with self.session.request(
                method=method,
                url=url,
                json=data,
                params=params,
                headers=headers
            ) as response:
                # 检查状态码
                if response.status >= 400:
                    error_data = await response.json()
                    raise Exception(
                        f"API call failed: {response.status} - {error_data.get('message', 'Unknown error')}"
                    )
                
                result = await response.json()
                logger.debug(f"API call success: {method} {url}")
                return result
                
        except aiohttp.ClientError as e:
            logger.error(f"API call failed: {method} {url}, error: {e}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error in API call: {e}")
            raise
```

---

## 五、工具权限控制

### 5.1 权限检查

```python
# src/core/tools/permissions.py
from typing import Dict, List
from utils.logging import get_logger

logger = get_logger(__name__)


class ToolPermissionChecker:
    """工具权限检查器"""
    
    def __init__(self, go_api_client):
        self.go_api_client = go_api_client
    
    async def check_permission(
        self,
        user_id: str,
        tool_name: str,
        action: str = "execute"
    ) -> bool:
        """检查用户是否有工具权限
        
        Args:
            user_id: 用户 ID
            tool_name: 工具名称
            action: 操作类型
            
        Returns:
            是否有权限
        """
        try:
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/tool-permissions/check",
                params={
                    "userId": user_id,
                    "toolName": tool_name,
                    "action": action
                }
            )
            
            return response.get("data", {}).get("allowed", False)
            
        except Exception as e:
            logger.error(f"Permission check failed: {e}")
            # 默认拒绝
            return False
    
    async def get_user_tools(self, user_id: str) -> List[str]:
        """获取用户可用的工具列表"""
        try:
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/users/{user_id}/allowed-tools"
            )
            
            return response.get("data", [])
            
        except Exception as e:
            logger.error(f"Get user tools failed: {e}")
            return []
```

---

## 六、使用示例

### 6.1 在 Agent 中使用工具

```python
# 示例：在 LangGraph Agent 中使用工具
from langgraph.prebuilt import ToolNode
from core.tools.registry import ToolRegistry

# 初始化工具注册表
tool_registry = ToolRegistry()
await tool_registry.register_all()

# 获取工具
character_tool = tool_registry.get_tool("character_tool")
outline_tool = tool_registry.get_tool("outline_tool")
rag_tool = tool_registry.get_tool("rag_tool")

# 转换为 LangChain 工具
tools = [
    character_tool.to_langchain_tool(),
    outline_tool.to_langchain_tool(),
    rag_tool.to_langchain_tool()
]

# 创建 ToolNode
tool_node = ToolNode(tools)

# 添加到工作流
workflow.add_node("tools", tool_node)
```

---

## 七、测试策略

### 7.1 单元测试

```python
# tests/unit/test_character_tool.py
import pytest
from unittest.mock import AsyncMock
from core.tools.langchain.character_tool import CharacterTool


@pytest.mark.asyncio
async def test_character_tool_create():
    """测试创建角色卡"""
    # Mock Go API 客户端
    mock_client = AsyncMock()
    mock_client.call_api.return_value = {
        "data": {
            "id": "char-123",
            "name": "测试角色"
        }
    }
    
    # 创建工具
    tool = CharacterTool(mock_client, {"user_id": "user-1"})
    
    # 执行
    result = await tool.execute(
        params={
            "action": "create",
            "project_id": "proj-1",
            "name": "测试角色",
            "traits": ["勇敢", "善良"]
        },
        user_id="user-1",
        project_id="proj-1"
    )
    
    # 验证
    assert result.success is True
    assert result.data["id"] == "char-123"
    mock_client.call_api.assert_called_once()
```

---

## 八、总结

本文档详细设计了 LangChain Tools 的完整实现，包括：

- ✅ 统一的 Tool 基类和接口规范
- ✅ 7 个核心工具的完整实现
- ✅ 完整的参数验证和错误处理
- ✅ 工具注册和管理机制
- ✅ Go API 客户端封装
- ✅ 权限控制和审计

**关键特性**：
- 类型安全的参数验证（Pydantic）
- 统一的错误处理和重试机制
- 完整的权限控制
- 易于扩展（继承基类即可）
- 与 LangChain/LangGraph 无缝集成

**后续工作**：
- 实现 MCP 协议集成
- 完善权限控制系统
- 添加更多工具

---

**文档版本**: v1.0
**创建时间**: 2025-10-27
**维护者**: AI架构组
