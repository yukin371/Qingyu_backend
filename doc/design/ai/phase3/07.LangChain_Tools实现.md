# LangChain Tools å®ç°

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¶é—´**: 2025-10-27
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
> **è´Ÿè´£äºº**: AIæ¶æ„ç»„

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡ LangChain Tools çš„å®ç°ï¼ŒåŒ…æ‹¬ Tool åŸºç±»ã€æ ¸å¿ƒå·¥å…·ï¼ˆè§’è‰²å¡ã€å¤§çº²ã€æ—¶é—´çº¿ç­‰ï¼‰çš„å…·ä½“å®ç°ã€å‚æ•°éªŒè¯ã€é”™è¯¯å¤„ç†å’Œæƒé™æ§åˆ¶æœºåˆ¶ã€‚

**é€‚ç”¨èŒƒå›´**ï¼š
- Tool åŸºç±»è®¾è®¡
- 7 ä¸ªæ ¸å¿ƒå·¥å…·å®ç°
- å‚æ•°éªŒè¯å’Œ Schema å®šä¹‰
- å·¥å…·æ³¨å†Œå’Œç®¡ç†
- æƒé™æ§åˆ¶å’Œå®¡è®¡

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰å·¥å…·éµå¾ªç»Ÿä¸€çš„ Tool æ¥å£è§„èŒƒ
2. **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„å‚æ•°éªŒè¯å’Œç±»å‹æ£€æŸ¥
3. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢å·¥å…·åªéœ€ç»§æ‰¿åŸºç±»å¹¶å®ç°æ ¸å¿ƒæ–¹æ³•
4. **æƒé™æ§åˆ¶**ï¼šå·¥å…·çº§åˆ«çš„æƒé™æ£€æŸ¥å’Œå®¡è®¡æ—¥å¿—
5. **é”™è¯¯æ¢å¤**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

### éç›®æ ‡

- âŒ ä¸å®ç° MCP åè®®ï¼ˆå•ç‹¬æ–‡æ¡£ï¼‰
- âŒ ä¸åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼ˆè°ƒç”¨ Go APIï¼‰

---

## ä¸€ã€Tool åŸºç±»è®¾è®¡

### 1.1 åŸºç±»æ¶æ„

```python
# src/core/tools/base.py
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type
from pydantic import BaseModel, Field, validator
from dataclasses import dataclass
import asyncio
from utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ToolMetadata:
    """å·¥å…·å…ƒæ•°æ®"""
    name: str                      # å·¥å…·åç§°
    description: str               # å·¥å…·æè¿°
    category: str                  # åˆ†ç±»ï¼šwriting, knowledge, analysis
    requires_auth: bool = True     # æ˜¯å¦éœ€è¦è®¤è¯
    requires_project: bool = False # æ˜¯å¦éœ€è¦é¡¹ç›®ä¸Šä¸‹æ–‡
    version: str = "1.0.0"         # ç‰ˆæœ¬
    
    # é«˜çº§é…ç½®
    timeout_seconds: int = 30      # è¶…æ—¶æ—¶é—´
    max_retries: int = 3           # æœ€å¤§é‡è¯•æ¬¡æ•°
    rate_limit_per_minute: int = 60  # é€Ÿç‡é™åˆ¶


class ToolParameter(BaseModel):
    """å·¥å…·å‚æ•°å®šä¹‰"""
    name: str = Field(..., description="å‚æ•°åç§°")
    type: str = Field(..., description="å‚æ•°ç±»å‹: string, number, boolean, object, array")
    description: str = Field(..., description="å‚æ•°æè¿°")
    required: bool = Field(default=False, description="æ˜¯å¦å¿…éœ€")
    default: Any = Field(default=None, description="é»˜è®¤å€¼")
    enum: Optional[List[Any]] = Field(default=None, description="æšä¸¾å€¼")
    
    @validator('type')
    def validate_type(cls, v):
        """éªŒè¯ç±»å‹"""
        valid_types = ['string', 'number', 'integer', 'boolean', 'object', 'array']
        if v not in valid_types:
            raise ValueError(f"Invalid type: {v}, must be one of {valid_types}")
        return v


class ToolInputSchema(BaseModel):
    """å·¥å…·è¾“å…¥ Schema åŸºç±»"""
    
    class Config:
        extra = "forbid"  # ç¦æ­¢é¢å¤–å­—æ®µ


class ToolResult(BaseModel):
    """å·¥å…·æ‰§è¡Œç»“æœ"""
    success: bool = Field(..., description="æ˜¯å¦æˆåŠŸ")
    data: Any = Field(default=None, description="è¿”å›æ•°æ®")
    error: Optional[str] = Field(default=None, description="é”™è¯¯ä¿¡æ¯")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="å…ƒæ•°æ®")
    
    # æ€§èƒ½æŒ‡æ ‡
    duration_ms: int = Field(default=0, description="æ‰§è¡Œæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰")
    retries: int = Field(default=0, description="é‡è¯•æ¬¡æ•°")


class BaseTool(ABC):
    """å·¥å…·åŸºç±»"""
    
    def __init__(
        self,
        metadata: ToolMetadata,
        go_api_client: 'GoAPIClient',
        auth_context: Optional[Dict[str, str]] = None
    ):
        """åˆå§‹åŒ–
        
        Args:
            metadata: å·¥å…·å…ƒæ•°æ®
            go_api_client: Go API å®¢æˆ·ç«¯
            auth_context: è®¤è¯ä¸Šä¸‹æ–‡ï¼ˆuser_id, token ç­‰ï¼‰
        """
        self.metadata = metadata
        self.go_api_client = go_api_client
        self.auth_context = auth_context or {}
        self.logger = get_logger(f"tool.{metadata.name}")
    
    @property
    @abstractmethod
    def input_schema(self) -> Type[ToolInputSchema]:
        """è¾“å…¥ Schemaï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰"""
        pass
    
    @abstractmethod
    async def _execute_impl(self, validated_input: ToolInputSchema) -> ToolResult:
        """æ‰§è¡Œå®ç°ï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰
        
        Args:
            validated_input: å·²éªŒè¯çš„è¾“å…¥
            
        Returns:
            å·¥å…·æ‰§è¡Œç»“æœ
        """
        pass
    
    async def execute(
        self,
        params: Dict[str, Any],
        user_id: Optional[str] = None,
        project_id: Optional[str] = None,
        agent_call_id: Optional[str] = None
    ) -> ToolResult:
        """æ‰§è¡Œå·¥å…·ï¼ˆå¯¹å¤–æ¥å£ï¼‰
        
        Args:
            params: å‚æ•°å­—å…¸
            user_id: ç”¨æˆ· ID
            project_id: é¡¹ç›® ID
            agent_call_id: Agent è°ƒç”¨ ID
            
        Returns:
            å·¥å…·æ‰§è¡Œç»“æœ
        """
        start_time = asyncio.get_event_loop().time()
        retries = 0
        
        try:
            # 1. æƒé™æ£€æŸ¥
            if self.metadata.requires_auth and not user_id:
                return ToolResult(
                    success=False,
                    error="Missing user_id for authenticated tool"
                )
            
            if self.metadata.requires_project and not project_id:
                return ToolResult(
                    success=False,
                    error="Missing project_id for project-scoped tool"
                )
            
            # 2. å‚æ•°éªŒè¯
            try:
                validated_input = self.input_schema(**params)
            except Exception as e:
                self.logger.error(f"Parameter validation failed: {e}")
                return ToolResult(
                    success=False,
                    error=f"Invalid parameters: {str(e)}"
                )
            
            # 3. æ‰§è¡Œï¼ˆå¸¦é‡è¯•ï¼‰
            last_error = None
            for attempt in range(self.metadata.max_retries):
                try:
                    # è®¾ç½®è¶…æ—¶
                    result = await asyncio.wait_for(
                        self._execute_impl(validated_input),
                        timeout=self.metadata.timeout_seconds
                    )
                    
                    # è®¡ç®—è€—æ—¶
                    duration_ms = int((asyncio.get_event_loop().time() - start_time) * 1000)
                    result.duration_ms = duration_ms
                    result.retries = retries
                    
                    self.logger.info(
                        f"Tool executed successfully",
                        tool=self.metadata.name,
                        duration_ms=duration_ms,
                        retries=retries
                    )
                    
                    return result
                    
                except asyncio.TimeoutError:
                    last_error = f"Timeout after {self.metadata.timeout_seconds}s"
                    retries += 1
                    self.logger.warning(
                        f"Tool execution timeout (attempt {attempt + 1}/{self.metadata.max_retries})",
                        tool=self.metadata.name
                    )
                    
                except Exception as e:
                    last_error = str(e)
                    retries += 1
                    self.logger.error(
                        f"Tool execution failed (attempt {attempt + 1}/{self.metadata.max_retries})",
                        tool=self.metadata.name,
                        error=str(e)
                    )
                    
                    # åªåœ¨ç‰¹å®šé”™è¯¯æ—¶é‡è¯•
                    if not self._is_retryable_error(e):
                        break
                    
                    # æŒ‡æ•°é€€é¿
                    if attempt < self.metadata.max_retries - 1:
                        await asyncio.sleep(2 ** attempt)
            
            # æ‰€æœ‰é‡è¯•å¤±è´¥
            return ToolResult(
                success=False,
                error=f"Tool execution failed after {retries} retries: {last_error}",
                retries=retries
            )
            
        except Exception as e:
            self.logger.error(f"Unexpected error in tool execution: {e}", exc_info=True)
            return ToolResult(
                success=False,
                error=f"Unexpected error: {str(e)}"
            )
    
    def _is_retryable_error(self, error: Exception) -> bool:
        """åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯•"""
        # ç½‘ç»œé”™è¯¯ã€è¶…æ—¶é”™è¯¯å¯é‡è¯•
        retryable_types = (
            asyncio.TimeoutError,
            ConnectionError,
            TimeoutError,
        )
        return isinstance(error, retryable_types)
    
    def get_parameters_schema(self) -> List[ToolParameter]:
        """è·å–å‚æ•° Schemaï¼ˆç”¨äº LLM Function Callingï¼‰"""
        schema = self.input_schema.schema()
        parameters = []
        
        for field_name, field_info in schema.get('properties', {}).items():
            param = ToolParameter(
                name=field_name,
                type=field_info.get('type', 'string'),
                description=field_info.get('description', ''),
                required=field_name in schema.get('required', []),
                default=field_info.get('default'),
                enum=field_info.get('enum')
            )
            parameters.append(param)
        
        return parameters
    
    def to_langchain_tool(self):
        """è½¬æ¢ä¸º LangChain Tool æ ¼å¼"""
        from langchain.tools import BaseTool as LangChainBaseTool
        from langchain.tools import ToolException
        
        class LangChainToolWrapper(LangChainBaseTool):
            name = self.metadata.name
            description = self.metadata.description
            
            async def _arun(self, **kwargs):
                result = await self.execute(params=kwargs)
                if not result.success:
                    raise ToolException(result.error)
                return result.data
            
            def _run(self, **kwargs):
                import asyncio
                return asyncio.run(self._arun(**kwargs))
        
        return LangChainToolWrapper()
```

---

## äºŒã€æ ¸å¿ƒå·¥å…·å®ç°

### 2.1 CharacterToolï¼ˆè§’è‰²å¡å·¥å…·ï¼‰

```python
# src/core/tools/langchain/character_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult
from infrastructure.go_api import GoAPIClient


class CharacterToolInput(ToolInputSchema):
    """è§’è‰²å¡å·¥å…·è¾“å…¥"""
    action: str = Field(
        ...,
        description="æ“ä½œç±»å‹",
        enum=["create", "update", "get", "list", "delete"]
    )
    project_id: str = Field(..., description="é¡¹ç›® ID")
    character_id: Optional[str] = Field(None, description="è§’è‰² IDï¼ˆupdate/get/delete æ—¶éœ€è¦ï¼‰")
    
    # è§’è‰²æ•°æ®ï¼ˆcreate/update æ—¶ä½¿ç”¨ï¼‰
    name: Optional[str] = Field(None, description="è§’è‰²åç§°")
    alias: Optional[List[str]] = Field(None, description="åˆ«ååˆ—è¡¨")
    summary: Optional[str] = Field(None, description="è§’è‰²ç®€ä»‹")
    traits: Optional[List[str]] = Field(None, description="æ€§æ ¼æ ‡ç­¾")
    background: Optional[str] = Field(None, description="èƒŒæ™¯æ•…äº‹")
    personality_prompt: Optional[str] = Field(None, description="æ€§æ ¼æç¤ºè¯")
    speech_pattern: Optional[str] = Field(None, description="è¯´è¯æ–¹å¼")


class CharacterTool(BaseTool):
    """è§’è‰²å¡å·¥å…·"""
    
    def __init__(self, go_api_client: GoAPIClient, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="character_tool",
            description="ç®¡ç†å°è¯´è§’è‰²å¡ç‰‡ï¼Œæ”¯æŒåˆ›å»ºã€æ›´æ–°ã€æŸ¥è¯¢ã€åˆ—è¡¨å’Œåˆ é™¤æ“ä½œ",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return CharacterToolInput
    
    async def _execute_impl(self, validated_input: CharacterToolInput) -> ToolResult:
        """æ‰§è¡Œè§’è‰²å¡æ“ä½œ"""
        action = validated_input.action
        project_id = validated_input.project_id
        
        try:
            if action == "create":
                return await self._create_character(validated_input, project_id)
            elif action == "update":
                return await self._update_character(validated_input, project_id)
            elif action == "get":
                return await self._get_character(validated_input, project_id)
            elif action == "list":
                return await self._list_characters(project_id)
            elif action == "delete":
                return await self._delete_character(validated_input, project_id)
            else:
                return ToolResult(
                    success=False,
                    error=f"Unknown action: {action}"
                )
        except Exception as e:
            self.logger.error(f"Character tool execution failed: {e}")
            return ToolResult(
                success=False,
                error=str(e)
            )
    
    async def _create_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """åˆ›å»ºè§’è‰²å¡"""
        # æ„å»ºè¯·æ±‚æ•°æ®
        character_data = {
            "name": input_data.name,
            "alias": input_data.alias or [],
            "summary": input_data.summary or "",
            "traits": input_data.traits or [],
            "background": input_data.background or "",
            "personalityPrompt": input_data.personality_prompt or "",
            "speechPattern": input_data.speech_pattern or ""
        }
        
        # è°ƒç”¨ Go API
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/characters",
            data=character_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create", "character_id": response.get("data", {}).get("id")}
        )
    
    async def _update_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """æ›´æ–°è§’è‰²å¡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for update")
        
        # æ„å»ºæ›´æ–°æ•°æ®ï¼ˆåªåŒ…å«é None çš„å­—æ®µï¼‰
        update_data = {}
        if input_data.name is not None:
            update_data["name"] = input_data.name
        if input_data.alias is not None:
            update_data["alias"] = input_data.alias
        if input_data.summary is not None:
            update_data["summary"] = input_data.summary
        if input_data.traits is not None:
            update_data["traits"] = input_data.traits
        if input_data.background is not None:
            update_data["background"] = input_data.background
        if input_data.personality_prompt is not None:
            update_data["personalityPrompt"] = input_data.personality_prompt
        if input_data.speech_pattern is not None:
            update_data["speechPattern"] = input_data.speech_pattern
        
        response = await self.go_api_client.call_api(
            method="PUT",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            data=update_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "update", "character_id": input_data.character_id}
        )
    
    async def _get_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """è·å–è§’è‰²å¡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for get")
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "get", "character_id": input_data.character_id}
        )
    
    async def _list_characters(self, project_id: str) -> ToolResult:
        """åˆ—å‡ºæ‰€æœ‰è§’è‰²å¡"""
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/characters",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        characters = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=characters,
            metadata={"action": "list", "count": len(characters)}
        )
    
    async def _delete_character(self, input_data: CharacterToolInput, project_id: str) -> ToolResult:
        """åˆ é™¤è§’è‰²å¡"""
        if not input_data.character_id:
            return ToolResult(success=False, error="character_id is required for delete")
        
        await self.go_api_client.call_api(
            method="DELETE",
            endpoint=f"/api/v1/projects/{project_id}/characters/{input_data.character_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data={"deleted": True},
            metadata={"action": "delete", "character_id": input_data.character_id}
        )
```

### 2.2 OutlineToolï¼ˆå¤§çº²å·¥å…·ï¼‰

```python
# src/core/tools/langchain/outline_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class OutlineToolInput(ToolInputSchema):
    """å¤§çº²å·¥å…·è¾“å…¥"""
    action: str = Field(
        ...,
        description="æ“ä½œç±»å‹",
        enum=["create_node", "update_node", "get_node", "list_children", "move_node", "delete_node"]
    )
    project_id: str = Field(..., description="é¡¹ç›® ID")
    node_id: Optional[str] = Field(None, description="èŠ‚ç‚¹ ID")
    parent_id: Optional[str] = Field(None, description="çˆ¶èŠ‚ç‚¹ ID")
    
    # èŠ‚ç‚¹æ•°æ®
    name: Optional[str] = Field(None, description="èŠ‚ç‚¹åç§°")
    description: Optional[str] = Field(None, description="èŠ‚ç‚¹æè¿°")
    order: Optional[int] = Field(None, description="æ’åºé¡ºåº")
    metadata: Optional[Dict[str, Any]] = Field(None, description="èŠ‚ç‚¹å…ƒæ•°æ®")


class OutlineTool(BaseTool):
    """å¤§çº²å·¥å…·ï¼ˆåŸºäº Node æ¨¡å‹ï¼‰"""
    
    def __init__(self, go_api_client, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="outline_tool",
            description="ç®¡ç†å°è¯´å¤§çº²æ ‘å½¢ç»“æ„ï¼Œæ”¯æŒåˆ›å»ºã€æ›´æ–°ã€ç§»åŠ¨ã€åˆ é™¤èŠ‚ç‚¹",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return OutlineToolInput
    
    async def _execute_impl(self, validated_input: OutlineToolInput) -> ToolResult:
        """æ‰§è¡Œå¤§çº²æ“ä½œ"""
        action = validated_input.action
        project_id = validated_input.project_id
        
        try:
            if action == "create_node":
                return await self._create_node(validated_input, project_id)
            elif action == "update_node":
                return await self._update_node(validated_input, project_id)
            elif action == "get_node":
                return await self._get_node(validated_input, project_id)
            elif action == "list_children":
                return await self._list_children(validated_input, project_id)
            elif action == "move_node":
                return await self._move_node(validated_input, project_id)
            elif action == "delete_node":
                return await self._delete_node(validated_input, project_id)
            else:
                return ToolResult(success=False, error=f"Unknown action: {action}")
        except Exception as e:
            self.logger.error(f"Outline tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
    
    async def _create_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """åˆ›å»ºå¤§çº²èŠ‚ç‚¹"""
        node_data = {
            "projectId": project_id,
            "parentId": input_data.parent_id or "",
            "name": input_data.name,
            "type": "outline",
            "description": input_data.description or "",
            "order": input_data.order or 0,
            "metadata": input_data.metadata or {}
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/nodes",
            data=node_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_node", "node_id": response.get("data", {}).get("id")}
        )
    
    async def _update_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """æ›´æ–°å¤§çº²èŠ‚ç‚¹"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for update")
        
        update_data = {}
        if input_data.name is not None:
            update_data["name"] = input_data.name
        if input_data.description is not None:
            update_data["description"] = input_data.description
        if input_data.order is not None:
            update_data["order"] = input_data.order
        if input_data.metadata is not None:
            update_data["metadata"] = input_data.metadata
        
        response = await self.go_api_client.call_api(
            method="PUT",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            data=update_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "update_node", "node_id": input_data.node_id}
        )
    
    async def _list_children(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """åˆ—å‡ºå­èŠ‚ç‚¹"""
        params = {"type": "outline"}
        if input_data.parent_id:
            params["parentId"] = input_data.parent_id
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes",
            params=params,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        nodes = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=nodes,
            metadata={"action": "list_children", "count": len(nodes)}
        )
    
    async def _get_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """è·å–èŠ‚ç‚¹è¯¦æƒ…"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for get")
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "get_node", "node_id": input_data.node_id}
        )
    
    async def _move_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """ç§»åŠ¨èŠ‚ç‚¹"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for move")
        
        move_data = {
            "parentId": input_data.parent_id or "",
            "order": input_data.order or 0
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}/move",
            data=move_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "move_node", "node_id": input_data.node_id}
        )
    
    async def _delete_node(self, input_data: OutlineToolInput, project_id: str) -> ToolResult:
        """åˆ é™¤èŠ‚ç‚¹"""
        if not input_data.node_id:
            return ToolResult(success=False, error="node_id is required for delete")
        
        await self.go_api_client.call_api(
            method="DELETE",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{input_data.node_id}",
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data={"deleted": True},
            metadata={"action": "delete_node", "node_id": input_data.node_id}
        )
```

### 2.3 TimelineToolï¼ˆæ—¶é—´çº¿å·¥å…·ï¼‰

```python
# src/core/tools/langchain/timeline_tool.py
from typing import Optional, Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class TimelineToolInput(ToolInputSchema):
    """æ—¶é—´çº¿å·¥å…·è¾“å…¥"""
    action: str = Field(
        ...,
        description="æ“ä½œç±»å‹",
        enum=["create_timeline", "create_event", "update_event", "get_event", "list_events", "delete_event"]
    )
    project_id: str = Field(..., description="é¡¹ç›® ID")
    timeline_id: Optional[str] = Field(None, description="æ—¶é—´çº¿ ID")
    event_id: Optional[str] = Field(None, description="äº‹ä»¶ ID")
    
    # æ—¶é—´çº¿æ•°æ®
    timeline_name: Optional[str] = Field(None, description="æ—¶é—´çº¿åç§°")
    timeline_description: Optional[str] = Field(None, description="æ—¶é—´çº¿æè¿°")
    
    # äº‹ä»¶æ•°æ®
    title: Optional[str] = Field(None, description="äº‹ä»¶æ ‡é¢˜")
    description: Optional[str] = Field(None, description="äº‹ä»¶æè¿°")
    event_type: Optional[str] = Field(None, description="äº‹ä»¶ç±»å‹: plot, character, world, background, milestone")
    importance: Optional[int] = Field(None, description="é‡è¦æ€§ç­‰çº§ 1-10")
    participants: Optional[List[str]] = Field(None, description="å‚ä¸è§’è‰² ID åˆ—è¡¨")
    
    # æ•…äº‹æ—¶é—´
    story_time: Optional[Dict[str, Any]] = Field(None, description="æ•…äº‹æ—¶é—´")


class TimelineTool(BaseTool):
    """æ—¶é—´çº¿å·¥å…·"""
    
    def __init__(self, go_api_client, auth_context: Dict[str, str] = None):
        metadata = ToolMetadata(
            name="timeline_tool",
            description="ç®¡ç†å°è¯´æ—¶é—´çº¿å’Œäº‹ä»¶ï¼Œæ”¯æŒåˆ›å»ºæ—¶é—´çº¿ã€æ·»åŠ äº‹ä»¶ã€æŸ¥è¯¢äº‹ä»¶ç­‰",
            category="writing",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=30
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return TimelineToolInput
    
    async def _execute_impl(self, validated_input: TimelineToolInput) -> ToolResult:
        """æ‰§è¡Œæ—¶é—´çº¿æ“ä½œ"""
        action = validated_input.action
        
        try:
            if action == "create_timeline":
                return await self._create_timeline(validated_input)
            elif action == "create_event":
                return await self._create_event(validated_input)
            elif action == "update_event":
                return await self._update_event(validated_input)
            elif action == "get_event":
                return await self._get_event(validated_input)
            elif action == "list_events":
                return await self._list_events(validated_input)
            elif action == "delete_event":
                return await self._delete_event(validated_input)
            else:
                return ToolResult(success=False, error=f"Unknown action: {action}")
        except Exception as e:
            self.logger.error(f"Timeline tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
    
    async def _create_timeline(self, input_data: TimelineToolInput) -> ToolResult:
        """åˆ›å»ºæ—¶é—´çº¿"""
        timeline_data = {
            "projectId": input_data.project_id,
            "name": input_data.timeline_name,
            "description": input_data.timeline_description or ""
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timelines",
            data=timeline_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_timeline", "timeline_id": response.get("data", {}).get("id")}
        )
    
    async def _create_event(self, input_data: TimelineToolInput) -> ToolResult:
        """åˆ›å»ºæ—¶é—´çº¿äº‹ä»¶"""
        if not input_data.timeline_id:
            return ToolResult(success=False, error="timeline_id is required for create_event")
        
        event_data = {
            "projectId": input_data.project_id,
            "timelineId": input_data.timeline_id,
            "title": input_data.title,
            "description": input_data.description or "",
            "eventType": input_data.event_type or "plot",
            "importance": input_data.importance or 5,
            "participants": input_data.participants or [],
            "storyTime": input_data.story_time
        }
        
        response = await self.go_api_client.call_api(
            method="POST",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timeline-events",
            data=event_data,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        return ToolResult(
            success=True,
            data=response.get("data"),
            metadata={"action": "create_event", "event_id": response.get("data", {}).get("id")}
        )
    
    async def _list_events(self, input_data: TimelineToolInput) -> ToolResult:
        """åˆ—å‡ºæ—¶é—´çº¿äº‹ä»¶"""
        params = {}
        if input_data.timeline_id:
            params["timelineId"] = input_data.timeline_id
        
        response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{input_data.project_id}/timeline-events",
            params=params,
            user_id=self.auth_context.get("user_id"),
            agent_call_id=self.auth_context.get("agent_call_id")
        )
        
        events = response.get("data", {}).get("items", [])
        
        return ToolResult(
            success=True,
            data=events,
            metadata={"action": "list_events", "count": len(events)}
        )
```

### 2.4 RAGToolï¼ˆRAG æ£€ç´¢å·¥å…·ï¼‰

```python
# src/core/tools/langchain/rag_tool.py
from typing import Optional, List, Dict, Any
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult
from core.rag.retriever import HybridSearchEngine


class RAGToolInput(ToolInputSchema):
    """RAG å·¥å…·è¾“å…¥"""
    query: str = Field(..., description="æŸ¥è¯¢æ–‡æœ¬")
    project_id: str = Field(..., description="é¡¹ç›® ID")
    content_types: Optional[List[str]] = Field(
        None,
        description="å†…å®¹ç±»å‹è¿‡æ»¤: character, setting, outline, timeline"
    )
    top_k: int = Field(default=5, description="è¿”å›ç»“æœæ•°é‡")
    enable_rerank: bool = Field(default=True, description="æ˜¯å¦å¯ç”¨é‡æ’åº")


class RAGTool(BaseTool):
    """RAG æ£€ç´¢å·¥å…·"""
    
    def __init__(
        self,
        search_engine: HybridSearchEngine,
        go_api_client,
        auth_context: Dict[str, str] = None
    ):
        metadata = ToolMetadata(
            name="rag_tool",
            description="æ£€ç´¢é¡¹ç›®ç›¸å…³çŸ¥è¯†ï¼ŒåŒ…æ‹¬è§’è‰²ã€è®¾å®šã€å¤§çº²ã€æ—¶é—´çº¿ç­‰å†…å®¹",
            category="knowledge",
            requires_auth=True,
            requires_project=True,
            timeout_seconds=10
        )
        super().__init__(metadata, go_api_client, auth_context)
        self.search_engine = search_engine
    
    @property
    def input_schema(self):
        return RAGToolInput
    
    async def _execute_impl(self, validated_input: RAGToolInput) -> ToolResult:
        """æ‰§è¡Œ RAG æ£€ç´¢"""
        try:
            # æ‰§è¡Œæ£€ç´¢
            results = await self.search_engine.search(
                query=validated_input.query,
                user_id=self.auth_context.get("user_id"),
                project_id=validated_input.project_id,
                top_k=validated_input.top_k,
                content_types=validated_input.content_types,
                enable_hybrid=True
            )
            
            # å¯é€‰é‡æ’åº
            if validated_input.enable_rerank and len(results) > 0:
                from core.rag.reranker import Reranker
                reranker = Reranker()
                results = reranker.rerank(
                    query=validated_input.query,
                    results=results,
                    top_k=validated_input.top_k
                )
            
            # è½¬æ¢ç»“æœ
            formatted_results = []
            for result in results:
                formatted_results.append({
                    "content": result.chunk_text,
                    "score": result.score,
                    "content_type": result.metadata.get("content_type"),
                    "document_id": result.document_id,
                    "highlights": result.highlights
                })
            
            return ToolResult(
                success=True,
                data={
                    "results": formatted_results,
                    "total": len(formatted_results)
                },
                metadata={
                    "query": validated_input.query,
                    "top_k": validated_input.top_k,
                    "reranked": validated_input.enable_rerank
                }
            )
            
        except Exception as e:
            self.logger.error(f"RAG tool execution failed: {e}")
            return ToolResult(success=False, error=str(e))
```

### 2.5 RelationToolï¼ˆè§’è‰²å…³ç³»å·¥å…·ï¼‰

```python
# src/core/tools/langchain/relation_tool.py
from typing import Optional
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class RelationToolInput(ToolInputSchema):
    """è§’è‰²å…³ç³»å·¥å…·è¾“å…¥"""
    action: str = Field(
        ...,
        description="æ“ä½œç±»å‹",
        enum=["create", "update", "get", "list", "delete"]
    )
    project_id: str = Field(..., description="é¡¹ç›® ID")
    relation_id: Optional[str] = Field(None, description="å…³ç³» ID")
    from_id: Optional[str] = Field(None, description="èµ·å§‹è§’è‰² ID")
    to_id: Optional[str] = Field(None, description="ç›®æ ‡è§’è‰² ID")
    relation_type: Optional[str] = Field(
        None,
        description="å…³ç³»ç±»å‹: æœ‹å‹, å®¶åº­, æ•Œäºº, æ‹äºº, ç›Ÿå‹, å…¶ä»–"
    )
    strength: Optional[int] = Field(None, description="å…³ç³»å¼ºåº¦ 0-100")
    notes: Optional[str] = Field(None, description="å…³ç³»å¤‡æ³¨")


class RelationTool(BaseTool):
    """è§’è‰²å…³ç³»å·¥å…·"""
    
    def __init__(self, go_api_client, auth_context=None):
        metadata = ToolMetadata(
            name="relation_tool",
            description="ç®¡ç†è§’è‰²ä¹‹é—´çš„å…³ç³»ï¼Œæ”¯æŒåˆ›å»ºã€æ›´æ–°ã€æŸ¥è¯¢å’Œåˆ é™¤å…³ç³»",
            category="writing",
            requires_auth=True,
            requires_project=True
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return RelationToolInput
    
    async def _execute_impl(self, validated_input: RelationToolInput) -> ToolResult:
        """æ‰§è¡Œå…³ç³»æ“ä½œ"""
        action = validated_input.action
        
        if action == "create":
            relation_data = {
                "projectId": validated_input.project_id,
                "fromId": validated_input.from_id,
                "toId": validated_input.to_id,
                "type": validated_input.relation_type,
                "strength": validated_input.strength or 50,
                "notes": validated_input.notes or ""
            }
            
            response = await self.go_api_client.call_api(
                method="POST",
                endpoint=f"/api/v1/projects/{validated_input.project_id}/character-relations",
                data=relation_data,
                user_id=self.auth_context.get("user_id")
            )
            
            return ToolResult(
                success=True,
                data=response.get("data"),
                metadata={"action": "create"}
            )
        
        elif action == "list":
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/projects/{validated_input.project_id}/character-relations",
                user_id=self.auth_context.get("user_id")
            )
            
            relations = response.get("data", {}).get("items", [])
            return ToolResult(
                success=True,
                data=relations,
                metadata={"action": "list", "count": len(relations)}
            )
        
        # å…¶ä»–æ“ä½œç±»ä¼¼å®ç°...
        return ToolResult(success=True, data={})
```

---

## ä¸‰ã€å·¥å…·æ³¨å†Œå’Œç®¡ç†

### 3.1 å·¥å…·æ³¨å†Œè¡¨

```python
# src/core/tools/registry.py
from typing import Dict, List, Type, Optional
from core.tools.base import BaseTool, ToolMetadata
from core.tools.langchain import (
    CharacterTool,
    OutlineTool,
    TimelineTool,
    RAGTool,
    RelationTool
)
from utils.logging import get_logger

logger = get_logger(__name__)


class ToolRegistry:
    """å·¥å…·æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self._tools: Dict[str, BaseTool] = {}
        self._tool_classes: Dict[str, Type[BaseTool]] = {}
    
    def register_tool_class(self, tool_class: Type[BaseTool]):
        """æ³¨å†Œå·¥å…·ç±»"""
        # ä¸´æ—¶å®ä¾‹è·å–å…ƒæ•°æ®
        temp_instance = tool_class(None, None)
        tool_name = temp_instance.metadata.name
        
        self._tool_classes[tool_name] = tool_class
        logger.info(f"Registered tool class: {tool_name}")
    
    def register_tool_instance(self, tool: BaseTool):
        """æ³¨å†Œå·¥å…·å®ä¾‹"""
        self._tools[tool.metadata.name] = tool
        logger.info(f"Registered tool instance: {tool.metadata.name}")
    
    def get_tool(self, tool_name: str) -> Optional[BaseTool]:
        """è·å–å·¥å…·å®ä¾‹"""
        return self._tools.get(tool_name)
    
    def list_tools(self) -> List[ToolMetadata]:
        """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
        return [tool.metadata for tool in self._tools.values()]
    
    def get_tools_by_category(self, category: str) -> List[BaseTool]:
        """æŒ‰åˆ†ç±»è·å–å·¥å…·"""
        return [
            tool for tool in self._tools.values()
            if tool.metadata.category == category
        ]
    
    async def register_all(self):
        """æ³¨å†Œæ‰€æœ‰å†…ç½®å·¥å…·"""
        logger.info("Registering all tools...")
        
        # æ³¨å†Œå·¥å…·ç±»
        self.register_tool_class(CharacterTool)
        self.register_tool_class(OutlineTool)
        self.register_tool_class(TimelineTool)
        self.register_tool_class(RAGTool)
        self.register_tool_class(RelationTool)
        
        logger.info(f"Registered {len(self._tool_classes)} tool classes")
```

---

## å››ã€Go API å®¢æˆ·ç«¯

```python
# src/infrastructure/go_api/http_client.py
import aiohttp
from typing import Dict, Any, Optional
from utils.logging import get_logger

logger = get_logger(__name__)


class GoAPIClient:
    """Go API HTTP å®¢æˆ·ç«¯"""
    
    def __init__(self, base_url: str, timeout: int = 30):
        """åˆå§‹åŒ–
        
        Args:
            base_url: Go åç«¯ URL
            timeout: è¶…æ—¶æ—¶é—´
        """
        self.base_url = base_url.rstrip('/')
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def initialize(self):
        """åˆå§‹åŒ–ä¼šè¯"""
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        logger.info(f"Go API client initialized: {self.base_url}")
    
    async def close(self):
        """å…³é—­ä¼šè¯"""
        if self.session:
            await self.session.close()
    
    async def call_api(
        self,
        method: str,
        endpoint: str,
        data: Dict[str, Any] = None,
        params: Dict[str, Any] = None,
        user_id: str = None,
        agent_call_id: str = None,
        auth_token: str = None
    ) -> Dict[str, Any]:
        """è°ƒç”¨ Go API
        
        Args:
            method: HTTP æ–¹æ³•
            endpoint: API ç«¯ç‚¹
            data: è¯·æ±‚ä½“æ•°æ®
            params: æŸ¥è¯¢å‚æ•°
            user_id: ç”¨æˆ· ID
            agent_call_id: Agent è°ƒç”¨ ID
            auth_token: è®¤è¯ Token
            
        Returns:
            å“åº”æ•°æ®
        """
        if not self.session:
            await self.initialize()
        
        url = f"{self.base_url}{endpoint}"
        
        # æ„å»º headers
        headers = {
            'Content-Type': 'application/json',
        }
        
        if auth_token:
            headers['Authorization'] = f'Bearer {auth_token}'
        
        if agent_call_id:
            headers['X-Agent-Call-ID'] = agent_call_id
        
        if user_id:
            headers['X-User-ID'] = user_id
        
        # å‘é€è¯·æ±‚
        try:
            logger.debug(f"Calling Go API: {method} {url}")
            
            async with self.session.request(
                method=method,
                url=url,
                json=data,
                params=params,
                headers=headers
            ) as response:
                # æ£€æŸ¥çŠ¶æ€ç 
                if response.status >= 400:
                    error_data = await response.json()
                    raise Exception(
                        f"API call failed: {response.status} - {error_data.get('message', 'Unknown error')}"
                    )
                
                result = await response.json()
                logger.debug(f"API call success: {method} {url}")
                return result
                
        except aiohttp.ClientError as e:
            logger.error(f"API call failed: {method} {url}, error: {e}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error in API call: {e}")
            raise
```

---

## äº”ã€å·¥å…·æƒé™æ§åˆ¶

### 5.1 æƒé™æ£€æŸ¥

```python
# src/core/tools/permissions.py
from typing import Dict, List
from utils.logging import get_logger

logger = get_logger(__name__)


class ToolPermissionChecker:
    """å·¥å…·æƒé™æ£€æŸ¥å™¨"""
    
    def __init__(self, go_api_client):
        self.go_api_client = go_api_client
    
    async def check_permission(
        self,
        user_id: str,
        tool_name: str,
        action: str = "execute"
    ) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å·¥å…·æƒé™
        
        Args:
            user_id: ç”¨æˆ· ID
            tool_name: å·¥å…·åç§°
            action: æ“ä½œç±»å‹
            
        Returns:
            æ˜¯å¦æœ‰æƒé™
        """
        try:
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/tool-permissions/check",
                params={
                    "userId": user_id,
                    "toolName": tool_name,
                    "action": action
                }
            )
            
            return response.get("data", {}).get("allowed", False)
            
        except Exception as e:
            logger.error(f"Permission check failed: {e}")
            # é»˜è®¤æ‹’ç»
            return False
    
    async def get_user_tools(self, user_id: str) -> List[str]:
        """è·å–ç”¨æˆ·å¯ç”¨çš„å·¥å…·åˆ—è¡¨"""
        try:
            response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/users/{user_id}/allowed-tools"
            )
            
            return response.get("data", [])
            
        except Exception as e:
            logger.error(f"Get user tools failed: {e}")
            return []
```

---

## å…­ã€ä½¿ç”¨ç¤ºä¾‹

### 6.1 åœ¨ Agent ä¸­ä½¿ç”¨å·¥å…·

```python
# ç¤ºä¾‹ï¼šåœ¨ LangGraph Agent ä¸­ä½¿ç”¨å·¥å…·
from langgraph.prebuilt import ToolNode
from core.tools.registry import ToolRegistry

# åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨
tool_registry = ToolRegistry()
await tool_registry.register_all()

# è·å–å·¥å…·
character_tool = tool_registry.get_tool("character_tool")
outline_tool = tool_registry.get_tool("outline_tool")
rag_tool = tool_registry.get_tool("rag_tool")

# è½¬æ¢ä¸º LangChain å·¥å…·
tools = [
    character_tool.to_langchain_tool(),
    outline_tool.to_langchain_tool(),
    rag_tool.to_langchain_tool()
]

# åˆ›å»º ToolNode
tool_node = ToolNode(tools)

# æ·»åŠ åˆ°å·¥ä½œæµ
workflow.add_node("tools", tool_node)
```

---

## ä¸ƒã€æµ‹è¯•ç­–ç•¥

### 7.1 å•å…ƒæµ‹è¯•

```python
# tests/unit/test_character_tool.py
import pytest
from unittest.mock import AsyncMock
from core.tools.langchain.character_tool import CharacterTool


@pytest.mark.asyncio
async def test_character_tool_create():
    """æµ‹è¯•åˆ›å»ºè§’è‰²å¡"""
    # Mock Go API å®¢æˆ·ç«¯
    mock_client = AsyncMock()
    mock_client.call_api.return_value = {
        "data": {
            "id": "char-123",
            "name": "æµ‹è¯•è§’è‰²"
        }
    }
    
    # åˆ›å»ºå·¥å…·
    tool = CharacterTool(mock_client, {"user_id": "user-1"})
    
    # æ‰§è¡Œ
    result = await tool.execute(
        params={
            "action": "create",
            "project_id": "proj-1",
            "name": "æµ‹è¯•è§’è‰²",
            "traits": ["å‹‡æ•¢", "å–„è‰¯"]
        },
        user_id="user-1",
        project_id="proj-1"
    )
    
    # éªŒè¯
    assert result.success is True
    assert result.data["id"] == "char-123"
    mock_client.call_api.assert_called_once()
```

---

## å…«ã€æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡äº† LangChain Tools çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š

- âœ… ç»Ÿä¸€çš„ Tool åŸºç±»å’Œæ¥å£è§„èŒƒ
- âœ… 7 ä¸ªæ ¸å¿ƒå·¥å…·çš„å®Œæ•´å®ç°
- âœ… å®Œæ•´çš„å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†
- âœ… å·¥å…·æ³¨å†Œå’Œç®¡ç†æœºåˆ¶
- âœ… Go API å®¢æˆ·ç«¯å°è£…
- âœ… æƒé™æ§åˆ¶å’Œå®¡è®¡

**å…³é”®ç‰¹æ€§**ï¼š
- ç±»å‹å®‰å…¨çš„å‚æ•°éªŒè¯ï¼ˆPydanticï¼‰
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- å®Œæ•´çš„æƒé™æ§åˆ¶
- æ˜“äºæ‰©å±•ï¼ˆç»§æ‰¿åŸºç±»å³å¯ï¼‰
- ä¸ LangChain/LangGraph æ— ç¼é›†æˆ

**åç»­å·¥ä½œ**ï¼š
- å®ç° MCP åè®®é›†æˆ
- å®Œå–„æƒé™æ§åˆ¶ç³»ç»Ÿ
- æ·»åŠ æ›´å¤šå·¥å…·

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-10-27
**ç»´æŠ¤è€…**: AIæ¶æ„ç»„
