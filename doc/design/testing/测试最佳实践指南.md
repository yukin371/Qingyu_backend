# 测试最佳实践指南

> 青羽平台Go测试编写规范和最佳实践
> 
> **创建时间**: 2025-10-17  
> **最后更新**: 2025-10-17  
> **适用范围**: 单元测试、集成测试、性能测试

---

## 📋 目录

- [1. 测试金字塔原则](#1-测试金字塔原则)
- [2. Table-Driven测试模式](#2-table-driven测试模式)
- [3. Mock使用最佳实践](#3-mock使用最佳实践)
- [4. 测试数据工厂模式](#4-测试数据工厂模式)
- [5. AAA测试模式](#5-aaa测试模式)
- [6. 测试命名规范](#6-测试命名规范)
- [7. 常见测试场景](#7-常见测试场景)
- [8. 性能测试指南](#8-性能测试指南)
- [9. 测试代码审查清单](#9-测试代码审查清单)

---

## 1. 测试金字塔原则

### 1.1 测试层级分布

```
      ┌─────────┐
      │  E2E    │ 5%  - 关键业务流程
      ├─────────┤
      │ 集成测试 │ 25% - API和数据库集成
      ├─────────┤
      │ 单元测试 │ 70% - Service和Repository层
      └─────────┘
```

### 1.2 各层级测试重点

**单元测试 (70%)**
- ✅ Service层业务逻辑
- ✅ Repository层数据操作
- ✅ 工具函数和辅助方法
- ✅ 使用Mock隔离依赖
- ✅ 快速执行（< 100ms/用例）

**集成测试 (25%)**
- ✅ API端到端流程
- ✅ 数据库真实操作
- ✅ 多模块协作
- ✅ 中间件功能验证

**E2E测试 (5%)**
- ✅ 关键业务流程
- ✅ 用户核心场景
- ✅ 跨系统集成

---

## 2. Table-Driven测试模式

### 2.1 基本结构

```go
func TestUserService_CreateUser(t *testing.T) {
    // 定义测试用例表
    tests := []struct {
        name    string          // 测试用例名称
        input   *CreateUserRequest
        mock    func(*MockRepo) // Mock设置函数
        wantErr bool            // 是否期望错误
        errMsg  string          // 错误消息（可选）
    }{
        {
            name: "成功创建用户",
            input: &CreateUserRequest{
                Username: "testuser",
                Email: "test@example.com",
            },
            mock: func(m *MockRepo) {
                m.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "用户名已存在_返回错误",
            input: &CreateUserRequest{
                Username: "existing",
                Email: "test@example.com",
            },
            mock: func(m *MockRepo) {
                m.On("Create", mock.Anything, mock.Anything).
                    Return(errors.New("duplicate username"))
            },
            wantErr: true,
            errMsg: "duplicate username",
        },
    }

    // 遍历测试用例
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Arrange
            mockRepo := new(MockRepo)
            tt.mock(mockRepo)
            service := NewUserService(mockRepo)

            // Act
            err := service.CreateUser(context.Background(), tt.input)

            // Assert
            if tt.wantErr {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.errMsg)
            } else {
                assert.NoError(t, err)
            }
            
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### 2.2 优点

✅ **代码复用**: 测试结构只写一次，适用多个场景  
✅ **易于维护**: 新增场景只需添加测试用例  
✅ **可读性强**: 测试意图清晰，场景一目了然  
✅ **全面覆盖**: 容易涵盖正常和异常场景

### 2.3 使用时机

✅ 多个输入需要测试相同逻辑  
✅ 需要覆盖大量边界条件  
✅ 测试逻辑复杂但结构相同  
❌ 单一简单场景（使用普通测试即可）

---

## 3. Mock使用最佳实践

### 3.1 何时使用Mock

✅ **使用Mock**
- 外部服务调用（HTTP API、RPC）
- 数据库操作（单元测试时）
- 文件系统操作
- 第三方SDK
- 耗时操作

❌ **不使用Mock**
- 简单的数据结构
- 纯函数计算
- 工具函数
- 集成测试（使用真实依赖）

### 3.2 Mock精确匹配

```go
// ✅ Good: 精确匹配
mockRepo.On("GetByEmail", mock.Anything, "test@example.com").
    Return(&User{ID: "123"}, nil)

// ❌ Bad: 过度宽松
mockRepo.On("GetByEmail", mock.Anything, mock.Anything).
    Return(mock.Anything, mock.Anything)
```

### 3.3 Mock复杂参数

```go
// 使用mock.MatchedBy进行复杂匹配
mockRepo.On("Create", mock.Anything, mock.MatchedBy(func(user *User) bool {
    return user.Username == "testuser" && user.Email != ""
})).Return(nil)

// 匹配特定类型
mockRepo.On("Update", mock.Anything, mock.AnythingOfType("*models.User")).
    Return(nil)
```

### 3.4 Mock调用次数验证

```go
// 验证调用次数
mockRepo.On("GetByID", mock.Anything, "123").Return(user, nil).Once()
mockRepo.On("Delete", mock.Anything, "123").Return(nil).Times(3)

// 验证所有预期都被调用
mockRepo.AssertExpectations(t)

// 验证特定方法被调用
mockRepo.AssertCalled(t, "GetByID", mock.Anything, "123")
```

---

## 4. 测试数据工厂模式

### 4.1 工厂模式的优势

✅ **减少重复代码**: 测试数据创建集中管理  
✅ **数据一致性**: 确保测试数据格式统一  
✅ **易于修改**: 模型变更时只需修改工厂  
✅ **支持自定义**: 提供选项函数定制字段

### 4.2 基本使用

```go
// 创建工厂
userFactory := fixtures.NewUserFactory()

// 创建默认用户
user1 := userFactory.Create()

// 创建自定义用户
user2 := userFactory.Create(func(u *User) {
    u.Username = "custom"
    u.Role = "admin"
})

// 批量创建
users := userFactory.CreateBatch(10)

// 创建特定类型
admin := userFactory.CreateAdmin()
author := userFactory.CreateAuthor()
```

### 4.3 工厂设计模式

```go
type UserFactory struct {
    counter int
}

func NewUserFactory() *UserFactory {
    return &UserFactory{counter: 0}
}

func (f *UserFactory) Create(opts ...func(*User)) *User {
    f.counter++
    user := &User{
        ID: primitive.NewObjectID().Hex(),
        Username: fmt.Sprintf("user%d", f.counter),
        Email: fmt.Sprintf("user%d@test.com", f.counter),
        Status: "active",
        CreatedAt: time.Now(),
    }
    
    for _, opt := range opts {
        opt(user)
    }
    
    return user
}
```

---

## 5. AAA测试模式

### 5.1 Arrange-Act-Assert

```go
func TestUserService_CreateUser(t *testing.T) {
    // ===== Arrange: 准备测试数据和依赖 =====
    mockRepo := new(MockUserRepository)
    mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
    
    service := NewUserService(mockRepo)
    user := testutil.CreateTestUser()
    ctx := context.Background()

    // ===== Act: 执行被测试的操作 =====
    err := service.CreateUser(ctx, user)

    // ===== Assert: 验证结果 =====
    assert.NoError(t, err)
    assert.NotEmpty(t, user.ID)
    mockRepo.AssertExpectations(t)
}
```

### 5.2 代码清晰性

✅ **明确的三段式结构**
- Arrange: 所有准备工作
- Act: 单一的操作调用
- Assert: 所有验证逻辑

✅ **一个测试一个断言**
- 测试失败时容易定位问题
- 避免"一失皆失"

---

## 6. 测试命名规范

### 6.1 命名格式

```
Test[FunctionName]_[Scenario]_[ExpectedResult]
```

### 6.2 示例

```go
// ✅ Good: 命名清晰
func TestUserService_CreateUser_Success(t *testing.T)
func TestUserService_CreateUser_DuplicateEmail_ReturnsError(t *testing.T)
func TestUserService_GetUser_UserNotFound_ReturnsNil(t *testing.T)

// ❌ Bad: 命名模糊
func TestCreateUser(t *testing.T)
func TestError(t *testing.T)
func TestUserService(t *testing.T)
```

### 6.3 文件命名

```
xxx_test.go
```

- 与被测试文件同名，加`_test`后缀
- 例如: `user_service.go` → `user_service_test.go`

---

## 7. 常见测试场景

### 7.1 测试错误场景

```go
t.Run("邮箱格式错误_返回验证错误", func(t *testing.T) {
    user := &User{Email: "invalid-email"}
    err := service.CreateUser(ctx, user)
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "invalid email")
})
```

### 7.2 测试边界条件

```go
t.Run("空字符串输入", func(t *testing.T) {
    err := service.CreateUser(ctx, &User{Username: ""})
    assert.Error(t, err)
})

t.Run("超长字符串输入", func(t *testing.T) {
    longString := strings.Repeat("a", 1000)
    err := service.CreateUser(ctx, &User{Username: longString})
    assert.Error(t, err)
})

t.Run("nil输入", func(t *testing.T) {
    err := service.CreateUser(ctx, nil)
    assert.Error(t, err)
})
```

### 7.3 测试并发场景

```go
func TestUserService_Concurrent(t *testing.T) {
    service := NewUserService(repo)
    
    var wg sync.WaitGroup
    errCh := make(chan error, 10)
    
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            user := testutil.CreateTestUser()
            errCh <- service.CreateUser(ctx, user)
        }(i)
    }
    
    wg.Wait()
    close(errCh)
    
    for err := range errCh {
        assert.NoError(t, err)
    }
}
```

### 7.4 测试超时场景

```go
func TestUserService_Timeout(t *testing.T) {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    // 模拟耗时操作
    mockRepo.On("Create", mock.Anything, mock.Anything).
        Run(func(args mock.Arguments) {
            time.Sleep(2 * time.Second) // 超过超时时间
        }).
        Return(nil)
    
    err := service.CreateUser(ctx, user)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "context deadline exceeded")
}
```

---

## 8. 性能测试指南

### 8.1 基准测试

```go
func BenchmarkUserService_CreateUser(b *testing.B) {
    mockRepo := new(MockUserRepository)
    mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
    
    service := NewUserService(mockRepo)
    user := testutil.CreateTestUser()
    ctx := context.Background()

    b.ResetTimer() // 重置计时器
    for i := 0; i < b.N; i++ {
        _ = service.CreateUser(ctx, user)
    }
}
```

### 8.2 内存分析

```go
func BenchmarkUserService_CreateUser_Memory(b *testing.B) {
    // ... setup ...
    
    b.ReportAllocs() // 报告内存分配
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        _ = service.CreateUser(ctx, user)
    }
}
```

### 8.3 并行基准测试

```go
func BenchmarkUserService_CreateUser_Parallel(b *testing.B) {
    // ... setup ...
    
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _ = service.CreateUser(ctx, user)
        }
    })
}
```

---

## 9. 测试代码审查清单

### 9.1 测试质量

- [ ] 测试名称清晰描述了场景和预期结果
- [ ] 使用AAA模式(Arrange-Act-Assert)
- [ ] 每个测试只验证一个功能点
- [ ] 测试独立，不依赖其他测试
- [ ] 测试可重复运行，结果一致

### 9.2 测试覆盖

- [ ] 覆盖正常流程
- [ ] 覆盖异常流程
- [ ] 覆盖边界条件
- [ ] 覆盖并发场景（如适用）
- [ ] 核心业务逻辑覆盖率 > 90%

### 9.3 Mock使用

- [ ] Mock设置精确，不过度宽松
- [ ] 验证Mock调用（AssertExpectations）
- [ ] Mock只用于外部依赖，不Mock被测对象
- [ ] 避免过度Mock导致测试脆弱

### 9.4 测试数据

- [ ] 使用工厂模式创建测试数据
- [ ] 测试数据有代表性
- [ ] 避免硬编码魔法值
- [ ] 测试后清理数据

### 9.5 代码质量

- [ ] 没有重复代码
- [ ] 测试代码易于理解
- [ ] 没有被注释掉的测试
- [ ] 测试执行快速（< 5秒）

---

## 10. 常见反模式

### ❌ 反模式1: 测试依赖其他测试

```go
// ❌ Bad
var globalUser *User

func TestCreateUser(t *testing.T) {
    globalUser = &User{...}
    // ...
}

func TestUpdateUser(t *testing.T) {
    // 依赖TestCreateUser
    user := globalUser
    // ...
}
```

✅ **正确做法**: 每个测试独立准备数据

### ❌ 反模式2: 测试过多细节

```go
// ❌ Bad: 测试实现细节
func TestUserService_CreateUser(t *testing.T) {
    // 测试内部变量状态
    assert.Equal(t, 3, service.internalCounter)
}
```

✅ **正确做法**: 测试公共行为和输出

### ❌ 反模式3: 一个测试验证多个场景

```go
// ❌ Bad
func TestUserService(t *testing.T) {
    // 测试创建
    err := service.Create(user)
    assert.NoError(t, err)
    
    // 测试查询
    user, err = service.Get(id)
    assert.NoError(t, err)
    
    // 测试更新
    // ...
}
```

✅ **正确做法**: 拆分为多个独立测试

---

## 11. 快速参考

### 11.1 常用命令

```bash
# 运行所有测试
go test ./...

# 运行特定测试
go test -run TestUserService_CreateUser

# 生成覆盖率报告
go test -cover -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 运行基准测试
go test -bench=. ./...

# 并发测试（竞态检测）
go test -race ./...

# 短测试（跳过耗时测试）
go test -short ./...
```

### 11.2 testify常用断言

```go
// 相等性断言
assert.Equal(t, expected, actual)
assert.NotEqual(t, expected, actual)

// 错误断言
assert.NoError(t, err)
assert.Error(t, err)
assert.EqualError(t, err, "expected error message")
assert.Contains(t, err.Error(), "substring")

// nil断言
assert.Nil(t, obj)
assert.NotNil(t, obj)

// 布尔断言
assert.True(t, condition)
assert.False(t, condition)

// 集合断言
assert.Empty(t, collection)
assert.NotEmpty(t, collection)
assert.Len(t, collection, length)
assert.Contains(t, collection, element)
```

---

## 12. 相关文档

- [自动化测试总体方案](./自动化测试总体方案.md)
- [Service测试示例](../../test/examples/service_test_example.go)
- [Repository测试示例](../../test/examples/repository_test_example.go)
- [测试工具使用说明](../../test/README.md)

---

**文档维护**: 青羽后端团队  
**最后更新**: 2025-10-17

