# 推荐缓存策略设计

> **版本**: v1.0  
> **创建日期**: 2025-10-21  
> **状态**: ⚠️ 待完善实现

---

## 1. 设计概述

推荐缓存用于提升推荐系统性能，减少实时计算负担。

---

## 2. 缓存策略

### 2.1 用户推荐列表缓存

**缓存Key**：`recommendation:user:{userId}`

**TTL**: 30分钟

**缓存内容**：
```go
type CachedRecommendation struct {
    UserID      string
    Books       []RecommendedBook
    Algorithm   string  // collaborative/content/hybrid
    GeneratedAt time.Time
}
```

### 2.2 热门推荐缓存

**缓存Key**：`recommendation:hot:{category}`

**TTL**: 1小时

**更新策略**：
- 定时更新（每小时）
- 主动刷新（新书上架时）

---

## 3. 协同过滤缓存

### 3.1 用户相似度矩阵缓存

**问题**：计算用户相似度耗时

**解决方案**：缓存预计算的相似度矩阵

```go
// 缓存用户的Top-N相似用户
type UserSimilarity struct {
    UserID        string
    SimilarUsers  []SimilarUser  // Top 50相似用户
    UpdatedAt     time.Time
}

type SimilarUser struct {
    UserID     string
    Similarity float64  // 相似度分数
}

// 缓存Key: similarity:user:{userId}
// TTL: 24小时
```

### 3.2 物品相似度缓存

```go
// 缓存书籍的相似书籍
type ItemSimilarity struct {
    BookID       string
    SimilarBooks []SimilarBook  // Top 20相似书籍
    UpdatedAt    time.Time
}

// 缓存Key: similarity:book:{bookId}
// TTL: 12小时
```

---

## 4. 推荐算法缓存优化

### 4.1 用户画像缓存

```go
type UserProfile struct {
    UserID        string
    Preferences   map[string]float64  // 类别偏好
    ReadHistory   []string            // 最近阅读
    FavoriteGenres []string           // 喜爱类型
    UpdatedAt     time.Time
}

// 缓存Key: profile:user:{userId}
// TTL: 1小时
```

### 4.2 推荐结果预计算

```go
// 离线批量计算推荐结果
func PrecomputeRecommendations() {
    // 1. 获取活跃用户列表
    activeUsers := getActiveUsers(7*24*time.Hour)
    
    // 2. 批量计算推荐
    for _, userID := range activeUsers {
        recommendations := computeRecommendations(userID)
        
        // 3. 缓存结果
        cacheKey := "recommendation:user:" + userID
        cache.Set(cacheKey, recommendations, 30*time.Minute)
    }
}

// 定时任务：每30分钟执行一次
cron.Every(30*time.Minute).Do(PrecomputeRecommendations)
```

---

## 5. 冷启动处理

### 5.1 新用户推荐缓存

```go
// 新用户使用热门推荐
func GetNewUserRecommendations() []RecommendedBook {
    cacheKey := "recommendation:newuser:hot"
    
    cached := cache.Get(cacheKey)
    if cached != nil {
        return cached.([]RecommendedBook)
    }
    
    // 获取热门书籍
    hotBooks := getHotBooks(20)
    
    // 缓存1小时
    cache.Set(cacheKey, hotBooks, 1*time.Hour)
    
    return hotBooks
}
```

---

## 6. 缓存更新策略

### 6.1 增量更新

```go
// 用户行为触发增量更新
func OnUserBehavior(userID string, action string, bookID string) {
    // 1. 清除用户推荐缓存
    cache.Delete("recommendation:user:" + userID)
    
    // 2. 异步更新用户画像
    go updateUserProfile(userID, action, bookID)
    
    // 3. 异步更新相似度
    if action == "favorite" || action == "rate" {
        go updateUserSimilarity(userID)
    }
}
```

### 6.2 全量更新

```go
// 每日凌晨全量更新推荐缓存
cron.At("02:00").Do(func() {
    // 1. 重新计算所有相似度矩阵
    recomputeAllSimilarities()
    
    // 2. 清理过期缓存
    cleanExpiredCache()
    
    // 3. 预计算活跃用户推荐
    PrecomputeRecommendations()
})
```

---

## 7. 性能优化

### 7.1 批量加载

```go
// 批量加载多个用户的推荐
func BatchGetRecommendations(userIDs []string) map[string][]RecommendedBook {
    result := make(map[string][]RecommendedBook)
    
    // 使用Pipeline批量获取
    pipe := redis.Pipeline()
    for _, userID := range userIDs {
        key := "recommendation:user:" + userID
        pipe.Get(key)
    }
    
    results, _ := pipe.Exec()
    
    // 处理结果
    for i, userID := range userIDs {
        if results[i] != nil {
            result[userID] = parseRecommendations(results[i])
        }
    }
    
    return result
}
```

---

## 8. 与v2.1架构的关系

```
Recommendation Module
  └─ CacheService
      ├─ UserRecommendationCache (用户推荐缓存)
      ├─ SimilarityCache (相似度缓存)
      ├─ UserProfileCache (用户画像缓存)
      └─ HotRecommendationCache (热门推荐缓存)
```

---

## 9. 实现参考

**代码文件**：
- `service/recommendation/cache_service.go`（待创建）
- `service/recommendation/recommendation_service.go`（已有）

---

**文档状态**: ✅ 已完成  
**优先级**: P1

