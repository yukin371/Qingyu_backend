# 用户登录状态检查修复

**日期**: 2025-10-17  
**类型**: 安全漏洞修复  
**优先级**: 🔴 高  
**影响范围**: 用户认证模块

---

## 📋 问题描述

### 发现的安全漏洞

在用户登录逻辑中，**缺少用户状态检查**，导致以下严重问题：

1. ❌ **已封禁用户仍可登录** - `banned` 状态用户可以通过认证
2. ❌ **已删除用户仍可登录** - `deleted` 状态用户可以继续使用系统
3. ❌ **未激活用户可以登录** - `inactive` 状态未验证邮箱的用户也能访问

### 原始代码（有漏洞）

```go
// service/user/user_service.go:282-320
func (s *UserServiceImpl) LoginUser(ctx context.Context, req *serviceInterfaces.LoginUserRequest) (*serviceInterfaces.LoginUserResponse, error) {
    // 1. 验证请求数据
    if req.Username == "" || req.Password == "" {
        return nil, serviceInterfaces.NewServiceError(s.name, serviceInterfaces.ErrorTypeValidation, "用户名和密码不能为空", nil)
    }

    // 2. 获取用户
    user, err := s.userRepo.GetByUsername(ctx, req.Username)
    if err != nil {
        // ...
    }

    // 3. 验证密码
    if !user.ValidatePassword(req.Password) {
        return nil, serviceInterfaces.NewServiceError(s.name, serviceInterfaces.ErrorTypeUnauthorized, "密码错误", nil)
    }

    // ❌ 问题：这里缺少状态检查，直接生成 token
    
    // 4. 更新最后登录时间
    // 5. 生成JWT令牌
    token, err := s.generateToken(user.ID, user.Role)
    
    return &serviceInterfaces.LoginUserResponse{
        User:  user,
        Token: token,
    }, nil
}
```

---

## 🔧 修复方案

### 修复内容

在密码验证通过后，生成 token 之前，**添加用户状态检查**：

```go
// 4. 检查用户状态
switch user.Status {
case usersModel.UserStatusInactive:
    return nil, serviceInterfaces.NewServiceError(
        s.name,
        serviceInterfaces.ErrorTypeUnauthorized,
        "账号未激活，请先验证邮箱",
        nil,
    )
case usersModel.UserStatusBanned:
    return nil, serviceInterfaces.NewServiceError(
        s.name,
        serviceInterfaces.ErrorTypeUnauthorized,
        "账号已被封禁，请联系管理员",
        nil,
    )
case usersModel.UserStatusDeleted:
    return nil, serviceInterfaces.NewServiceError(
        s.name,
        serviceInterfaces.ErrorTypeUnauthorized,
        "账号已删除",
        nil,
    )
case usersModel.UserStatusActive:
    // 允许登录，继续执行
default:
    return nil, serviceInterfaces.NewServiceError(
        s.name,
        serviceInterfaces.ErrorTypeInternal,
        "未知的用户状态",
        nil,
    )
}
```

### 修复后的完整流程

```
用户登录请求
    ↓
[1] 验证请求参数
    ↓
[2] 获取用户信息
    ↓
[3] 验证密码
    ↓
[4] ✅ 检查用户状态（新增）
    ├─ inactive  → ❌ 拒绝登录（账号未激活）
    ├─ banned    → ❌ 拒绝登录（账号已封禁）
    ├─ deleted   → ❌ 拒绝登录（账号已删除）
    ├─ active    → ✅ 允许继续
    └─ unknown   → ❌ 拒绝登录（未知状态）
    ↓
[5] 更新最后登录时间
    ↓
[6] 生成 JWT Token
    ↓
返回登录成功响应
```

---

## 📊 用户状态说明

| 状态 | 含义 | 登录权限 | 使用场景 |
|------|------|---------|---------|
| `active` | 活跃用户 | ✅ 允许 | 正常用户 |
| `inactive` | 未激活 | ❌ 拒绝 | 注册后未验证邮箱 |
| `banned` | 已封禁 | ❌ 拒绝 | 被管理员封禁 |
| `deleted` | 已删除 | ❌ 拒绝 | 软删除的用户 |

### 状态转换流程

```
注册
 ↓
inactive（未激活）
 ↓ [验证邮箱]
active（活跃）
 ↓ [违规操作]
banned（封禁）
 ↓ [用户删除账号]
deleted（软删除）
```

---

## 🔍 代码变更详情

### 修改文件

- **文件**: `service/user/user_service.go`
- **函数**: `LoginUser`
- **行数**: 第 302-334 行

### 变更对比

```diff
  // 3. 验证密码
  if !user.ValidatePassword(req.Password) {
      return nil, serviceInterfaces.NewServiceError(s.name, serviceInterfaces.ErrorTypeUnauthorized, "密码错误", nil)
  }

+ // 4. 检查用户状态
+ switch user.Status {
+ case usersModel.UserStatusInactive:
+     return nil, serviceInterfaces.NewServiceError(
+         s.name,
+         serviceInterfaces.ErrorTypeUnauthorized,
+         "账号未激活，请先验证邮箱",
+         nil,
+     )
+ case usersModel.UserStatusBanned:
+     return nil, serviceInterfaces.NewServiceError(
+         s.name,
+         serviceInterfaces.ErrorTypeUnauthorized,
+         "账号已被封禁，请联系管理员",
+         nil,
+     )
+ case usersModel.UserStatusDeleted:
+     return nil, serviceInterfaces.NewServiceError(
+         s.name,
+         serviceInterfaces.ErrorTypeUnauthorized,
+         "账号已删除",
+         nil,
+     )
+ case usersModel.UserStatusActive:
+     // 允许登录，继续执行
+ default:
+     return nil, serviceInterfaces.NewServiceError(
+         s.name,
+         serviceInterfaces.ErrorTypeInternal,
+         "未知的用户状态",
+         nil,
+     )
+ }
+
- // 4. 更新最后登录时间
+ // 5. 更新最后登录时间
  // IP 地址应该从 context 中获取，这里暂时使用默认值
  ip := "unknown" // TODO: 从 context 中获取客户端 IP
  
- // 5. 生成JWT令牌
+ // 6. 生成JWT令牌
  token, err := s.generateToken(user.ID, user.Role)
```

---

## ✅ 测试验证

### 测试场景

#### 场景 1: 正常用户登录
```
输入: active 状态用户 + 正确密码
预期: ✅ 登录成功，返回 token
```

#### 场景 2: 未激活用户登录
```
输入: inactive 状态用户 + 正确密码
预期: ❌ 登录失败
错误: "账号未激活，请先验证邮箱"
HTTP状态码: 401
```

#### 场景 3: 已封禁用户登录
```
输入: banned 状态用户 + 正确密码
预期: ❌ 登录失败
错误: "账号已被封禁，请联系管理员"
HTTP状态码: 401
```

#### 场景 4: 已删除用户登录
```
输入: deleted 状态用户 + 正确密码
预期: ❌ 登录失败
错误: "账号已删除"
HTTP状态码: 401
```

### 单元测试（建议添加）

```go
// service/user/user_service_test.go
func TestUserService_LoginUser_WithInactiveStatus(t *testing.T) {
    // Arrange
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)
    
    inactiveUser := &usersModel.User{
        ID:       "user-123",
        Username: "testuser",
        Password: "$2a$10$...", // hashed password
        Status:   usersModel.UserStatusInactive,
    }
    
    mockRepo.On("GetByUsername", mock.Anything, "testuser").Return(inactiveUser, nil)
    
    // Act
    resp, err := service.LoginUser(context.Background(), &serviceInterfaces.LoginUserRequest{
        Username: "testuser",
        Password: "password123",
    })
    
    // Assert
    assert.Error(t, err)
    assert.Nil(t, resp)
    assert.Contains(t, err.Error(), "账号未激活")
}

func TestUserService_LoginUser_WithBannedStatus(t *testing.T) {
    // ... 类似测试
}

func TestUserService_LoginUser_WithDeletedStatus(t *testing.T) {
    // ... 类似测试
}

func TestUserService_LoginUser_WithActiveStatus_Success(t *testing.T) {
    // ... 测试正常登录
}
```

---

## 📝 相关改进建议

### 1. 邮箱验证激活流程

当前注册时直接设置为 `active`，建议改为：

```go
// service/user/user_service.go - RegisterUser
user := &usersModel.User{
    Username: req.Username,
    Email:    req.Email,
    Password: req.Password,
    Role:     "user",
    Status:   usersModel.UserStatusInactive, // ✅ 改为未激活
}

// 创建用户后发送激活邮件
s.sendActivationEmail(user.Email, activationToken)
```

添加激活接口：
```go
// ActivateUser 激活用户账号
func (s *UserServiceImpl) ActivateUser(ctx context.Context, token string) error {
    // 1. 验证激活 token
    userID, err := s.validateActivationToken(token)
    if err != nil {
        return serviceInterfaces.NewServiceError(s.name, serviceInterfaces.ErrorTypeValidation, "激活链接无效或已过期", err)
    }
    
    // 2. 更新用户状态
    err = s.userRepo.Update(ctx, userID, map[string]interface{}{
        "status":         usersModel.UserStatusActive,
        "email_verified": true,
        "updated_at":     time.Now(),
    })
    
    if err != nil {
        return serviceInterfaces.NewServiceError(s.name, serviceInterfaces.ErrorTypeInternal, "激活账号失败", err)
    }
    
    return nil
}
```

### 2. 中间件层状态检查

除了登录时检查，建议在 JWT 中间件也添加状态检查：

```go
// middleware/jwt.go
func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ... 验证 token ...
        
        // ✅ 获取用户并检查状态
        user, err := userRepo.GetByID(c.Request.Context(), userID)
        if err != nil || user.Status != usersModel.UserStatusActive {
            c.JSON(401, gin.H{"error": "用户状态异常"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

### 3. 审计日志

记录被拒绝的登录尝试：

```go
// 在状态检查失败时记录日志
log.WithFields(logrus.Fields{
    "username": req.Username,
    "status":   user.Status,
    "ip":       getClientIP(ctx),
    "time":     time.Now(),
}).Warn("登录被拒绝：用户状态异常")
```

---

## 🎯 影响评估

### 安全性提升

- ✅ 防止已封禁用户继续访问系统
- ✅ 防止已删除用户登录
- ✅ 支持邮箱验证激活流程
- ✅ 增强账号管理能力

### 向后兼容性

- ✅ 对现有 `active` 用户无影响
- ⚠️ 如果数据库中存在 `inactive/banned/deleted` 状态的用户，他们将无法登录（符合预期）

### 性能影响

- ✅ 几乎无性能影响（仅增加一个 switch 语句）
- ✅ 不增加数据库查询

---

## 📋 后续任务清单

- [x] 修复登录逻辑，添加状态检查
- [ ] 添加单元测试覆盖所有状态场景
- [ ] 实现邮箱验证激活流程
- [ ] 在 JWT 中间件添加状态检查
- [ ] 添加登录失败审计日志
- [ ] 更新 API 文档，说明新的错误码
- [ ] 前端适配新的错误提示

---

## 📚 相关文档

- [用户模型定义](../../models/users/user.go)
- [用户服务实现](../../service/user/user_service.go)
- [软删除事务管理](../../service/user/transaction_manager.go)
- [API错误处理规范](../architecture/架构设计规范.md)

---

**修复完成时间**: 2025-10-17  
**修复人员**: AI Assistant  
**代码审查**: 待审查  
**测试状态**: 待测试

