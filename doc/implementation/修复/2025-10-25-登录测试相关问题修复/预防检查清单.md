# ✅ 防止类似问题再次发生 - 检查清单

## 🎯 核心原则

**记住这一点**：**Repository 层的查询条件必须基于 Model 层实际存在的字段！**

---

## 📋 开发检查清单

### 修改 Model 时

- [ ] **同步更新 Repository**：检查所有查询该 Model 的 Repository 方法
- [ ] **更新相关测试**：确保集成测试覆盖新字段或字段变更
- [ ] **更新 API 文档**：如果字段在 API 中暴露，更新 API 文档
- [ ] **数据迁移脚本**：如果是生产环境，创建数据迁移脚本
- [ ] **通知团队**：在团队会议中分享 Model 变更

### 修改 Repository 查询时

- [ ] **验证字段存在**：确认查询的字段在 Model 中定义
- [ ] **测试验证**：编写或更新集成测试验证查询逻辑
- [ ] **考虑索引**：查询条件是否需要数据库索引？
- [ ] **性能测试**：复杂查询是否需要性能测试？

### Code Review 时

- [ ] **字段一致性**：Repository 查询字段是否在 Model 中存在？
- [ ] **软删除处理**：软删除逻辑是否正确？
- [ ] **测试覆盖**：是否有测试覆盖新代码？
- [ ] **错误处理**：错误处理是否完善？
- [ ] **日志记录**：关键操作是否有日志？

### 提交代码前

- [ ] **运行所有测试**：`go test ./...`
- [ ] **检查 Linter**：`golangci-lint run`
- [ ] **本地集成测试**：运行集成测试套件
- [ ] **检查 Git Diff**：review 自己的代码变更

---

## 🔧 技术实践

### 1. 编写集成测试

**必须测试的场景**：

```go
// ✅ 好的测试
func TestUserRepository_GetByUsername_Success(t *testing.T) {
    // 1. 准备：创建测试用户
    user := createTestUser()
    err := repo.Create(ctx, user)
    require.NoError(t, err)
    
    // 2. 执行：查询用户
    found, err := repo.GetByUsername(ctx, user.Username)
    
    // 3. 验证：确认结果正确
    assert.NoError(t, err)
    assert.Equal(t, user.Username, found.Username)
    assert.Equal(t, user.Email, found.Email)
}

func TestUserRepository_GetByUsername_Deleted(t *testing.T) {
    // 1. 准备：创建并软删除用户
    user := createTestUser()
    user.Status = "deleted"
    err := repo.Create(ctx, user)
    
    // 2. 执行：查询已删除用户
    found, err := repo.GetByUsername(ctx, user.Username)
    
    // 3. 验证：根据业务逻辑验证
    // 如果业务层处理软删除，Repository 应该能找到
    assert.NoError(t, err)
    assert.Equal(t, "deleted", string(found.Status))
}
```

### 2. 使用类型安全的查询构建器

**避免硬编码字段名**：

```go
// ❌ 不好 - 硬编码字段名，容易出错
filter := bson.M{
    "username": username,
    "deleted_at": bson.M{"$exists": false},
}

// ✅ 更好 - 使用常量
const (
    FieldUsername = "username"
    FieldStatus   = "status"
)

filter := bson.M{
    FieldUsername: username,
    FieldStatus:   bson.M{"$ne": "deleted"},
}

// ✅ 最好 - 使用结构体标签
type User struct {
    Username string `bson:"username"`
    Status   string `bson:"status"`
}

// 然后使用反射或代码生成获取字段名
```

### 3. 添加运行时验证

```go
// 在 Repository 初始化时验证
func NewMongoUserRepository(db *mongo.Database) (*MongoUserRepository, error) {
    repo := &MongoUserRepository{
        collection: db.Collection("users"),
    }
    
    // 验证关键字段是否存在
    if err := repo.validateSchema(); err != nil {
        return nil, fmt.Errorf("schema validation failed: %w", err)
    }
    
    return repo, nil
}

func (r *MongoUserRepository) validateSchema() error {
    // 检查索引或字段
    // 可以查询一条记录并验证字段
    return nil
}
```

---

## 📚 文档要求

### 1. Model 定义文档

在 `models/users/README.md` 中记录：

```markdown
## User 模型

### 字段说明

| 字段 | 类型 | BSON 标签 | 说明 | 默认值 |
|------|------|-----------|------|--------|
| Status | UserStatus | `status` | 用户状态 | "active" |

### 软删除策略

本模型使用 `status` 字段实现软删除：
- 删除用户时，将 `status` 设为 "deleted"
- 查询时，Repository 层不过滤 deleted 用户
- 业务层负责检查 `status` 字段

**注意**：本模型没有 `deleted_at` 字段！
```

### 2. Repository 设计文档

在 `doc/architecture/repository层设计规范.md` 中添加：

```markdown
## 软删除策略

### 规范

1. **Repository 层职责**：
   - Repository 不应该过滤软删除的记录
   - Repository 只负责数据访问，不包含业务逻辑
   
2. **Service 层职责**：
   - Service 层检查记录的删除状态
   - Service 层决定是否返回已删除的记录

### 示例

```go
// ✅ 正确的 Repository 实现
func (r *UserRepository) GetByUsername(ctx, username) (*User, error) {
    filter := bson.M{"username": username}
    // 不检查 deleted 状态
    return r.findOne(ctx, filter)
}

// ✅ 正确的 Service 实现
func (s *UserService) LoginUser(ctx, req) (*LoginResponse, error) {
    user, err := s.userRepo.GetByUsername(ctx, req.Username)
    if err != nil {
        return nil, err
    }
    
    // 在 Service 层检查状态
    if user.Status == "deleted" {
        return nil, errors.New("账号已删除")
    }
    
    // ...
}
```
```

---

## 🔄 定期审计

### 每月检查

- [ ] 审计所有 Repository 查询方法
- [ ] 检查是否有使用不存在的字段
- [ ] 验证软删除逻辑是否一致
- [ ] 更新测试覆盖率报告

### 每季度检查

- [ ] Review 架构文档
- [ ] 更新开发规范
- [ ] 团队培训和知识分享
- [ ] 评估是否需要新的工具或流程

---

## 🛠️ 推荐工具

### 静态分析

```bash
# 安装 golangci-lint
brew install golangci-lint  # macOS
# 或
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 运行检查
golangci-lint run
```

### 测试覆盖率

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率
go tool cover -html=coverage.out

# 设置最低覆盖率要求
# 在 CI/CD 中强制要求 >80% 覆盖率
```

### 数据库 Schema 验证

考虑使用：
- MongoDB Schema Validation
- 自定义验证脚本
- 集成测试验证

---

## 📖 学习资源

### 内部文档

- `doc/architecture/架构设计规范.md`
- `doc/architecture/repository层设计规范.md`
- `doc/engineering/软件工程规范_v2.0.md`

### 外部资源

- [MongoDB Best Practices](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/)
- [Go Testing Best Practices](https://go.dev/doc/tutorial/add-a-test)
- [Repository Pattern in Go](https://threedots.tech/post/repository-pattern-in-go/)

---

## 🎯 关键记忆点

### 三个"必须"

1. **必须保持一致**：Model 和 Repository 的字段必须一致
2. **必须有测试**：每个 Repository 方法必须有集成测试
3. **必须有文档**：软删除策略必须在文档中明确

### 三个"不要"

1. **不要硬编码字段名**：使用常量或结构体标签
2. **不要跳过测试**：即使是简单的 CRUD 操作也要测试
3. **不要假设字段存在**：在使用前验证字段是否在 Model 中定义

---

## ✅ 快速检查命令

```bash
# 1. 查找所有使用 deleted_at 的地方
grep -r "deleted_at" repository/

# 2. 运行所有测试
go test ./...

# 3. 检查测试覆盖率
go test -cover ./...

# 4. Lint 检查
golangci-lint run

# 5. 集成测试
python scripts/testing/run_tests.py
```

---

**记住**：预防胜于修复！花时间在代码审查和测试上，可以避免生产环境的严重问题。

---

**文档版本**：1.0  
**创建时间**：2025-10-25  
**适用范围**：所有开发人员

