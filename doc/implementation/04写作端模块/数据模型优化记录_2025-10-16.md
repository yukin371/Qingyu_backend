# 数据模型优化记录

> **优化日期**: 2025-10-16  
> **优化类型**: 关联关系简化  
> **影响范围**: Document、DocumentContent、Version模型

## 优化原因

用户发现了数据模型设计中的改进点：
1. **VersionNum的必要性** - ID是否能替代版本号？
2. **ContentID的必要性** - Document是否需要ContentID字段？
3. **关联关系** - Document-DocumentContent-Version三者关联是否最优？

## 优化决策

经过讨论，确定最佳方案：

### 1. 移除Document.ContentID ✅

**优化前**:
```go
type Document struct {
    ContentID string  // 指向DocumentContent
}
```

**优化后**:
```go
type Document struct {
    // 移除ContentID，通过DocumentID反向查询
}
```

**理由**:
- ✅ 避免双向关联，减少数据同步问题
- ✅ 单向关联更简洁，易于维护
- ✅ 反向查询性能相同（document_id有索引）
- ✅ 符合MongoDB推荐模式

### 2. 保留VersionNum ✅

**决策**:
```go
type Version struct {
    VersionNum int  // 保留版本号
}
```

**理由**:
- ✅ 语义清晰：用户可以说"恢复到版本5"
- ✅ 便于排序：ORDER BY version_num DESC
- ✅ 便于查询：WHERE version_num = 3
- ✅ 用户友好：显示"v1, v2, v3..."

**对比ID方案**:
- ❌ ID是随机生成，无序
- ❌ 需要用created_at排序，语义不清
- ❌ 用户无法直接引用"版本3"

### 3. Version存储完整快照 ✅

**决策**:
```go
type Version struct {
    Content string  // 完整内容快照
}
```

**理由**:
- ✅ 支持独立回滚，无需依赖其他版本
- ✅ 版本对比简单，直接比较两个快照
- ✅ 磁盘便宜，空间不是问题
- ✅ 可靠性高，不会因为中间版本损坏导致无法恢复

**对比diff方案**:
- ❌ 恢复时需要逐版本应用diff
- ❌ 中间版本损坏会导致后续版本无法恢复
- ❌ 实现复杂，容易出错

---

## 优化后的关联关系

### 关联图

```
Document (文档结构)
  ↑
  │ document_id (单向关联)
  │
  ├── DocumentContent (当前内容) 0..1
  │     字段：
  │     - document_id: 关联到Document
  │     - content: 实际内容
  │     - version: 乐观锁（并发控制）
  │     - gridfs_id: 大文件支持
  │
  └── Version (历史版本) 0..N
        字段：
        - document_id: 关联到Document
        - version_num: 版本号（v1, v2, v3...）
        - content: 完整快照
        - gridfs_id: 大文件版本支持
        - is_auto_save: 区分自动/手动保存
```

### 查询方式

```go
// Document → DocumentContent (反向查询)
content, _ := documentContentRepo.GetByDocumentID(documentID)

// Document → Versions (反向查询)
versions, _ := versionRepo.GetByDocumentID(documentID)

// 获取特定版本
version, _ := versionRepo.GetByDocumentIDAndVersion(documentID, 5)
```

---

## 具体改动

### 改动1: Document模型

**文件**: `models/document/document.go`

**移除字段**:
```diff
- // 内容引用
- ContentID string `bson:"content_id,omitempty" json:"contentId,omitempty"` // 关联DocumentContent
```

**保留字段**:
```go
WordCount int  // 冗余字段，从DocumentContent同步，方便查询
```

### 改动2: DocumentContent模型（无需改动）

**文件**: `models/document/document_content.go`

**保持现状**:
```go
type DocumentContent struct {
    DocumentID string  // 关联到Document
    Content string     // 实际内容
    Version int        // 乐观锁
    GridFSID string    // 大文件支持
}
```

### 改动3: Version模型（无需改动）

**文件**: `models/document/version.go`

**保持现状**:
```go
type Version struct {
    DocumentID string  // 关联到Document
    VersionNum int     // 版本号（语义清晰）
    Content string     // 完整快照（独立回滚）
    GridFSID string    // 大文件版本
}
```

### 改动4: 更新设计文档

**文件**: `doc/design/writer/数据模型设计说明.md`

**更新内容**:
- 关联关系图
- 集合结构示例
- 查询方式说明

---

## 优化效果

### 数据一致性 ⬆️

**优化前（双向关联）**:
```
Document.ContentID ←→ DocumentContent.ID
问题：需要同步两个字段，可能不一致
```

**优化后（单向关联）**:
```
DocumentContent.DocumentID → Document.ID
优势：只需维护一个字段，不会不一致
```

### 代码简洁性 ⬆️

**优化前**:
```go
// 创建DocumentContent时需要更新两处
content := &DocumentContent{DocumentID: docID}
contentRepo.Create(content)
documentRepo.Update(docID, {"content_id": content.ID}) // 额外更新
```

**优化后**:
```go
// 创建DocumentContent时只需一步
content := &DocumentContent{DocumentID: docID}
contentRepo.Create(content)  // 完成
```

### 查询性能 →

**性能相同**:
```go
// 优化前
content := contentRepo.GetByID(document.ContentID)

// 优化后
content := contentRepo.GetByDocumentID(document.ID)

// 性能一样（都是索引查询）
```

---

## 索引设计

### document_contents索引

```javascript
// 必须创建的索引
db.document_contents.createIndex({
  "document_id": 1  // 支持反向查询
}, {
  unique: true        // 一个Document只有一个当前内容
})
```

### versions索引

```javascript
// 支持版本查询
db.versions.createIndex({
  "document_id": 1,
  "version_num": -1   // 降序，最新版本在前
})

// 支持按文档和版本号查询
db.versions.createIndex({
  "document_id": 1,
  "version_num": 1
}, {
  unique: true        // document_id + version_num 组合唯一
})
```

---

## API使用示例

### 查询文档树

```http
GET /api/v1/projects/123/documents/tree

返回：
{
  "documents": [
    {
      "id": "doc123",
      "title": "第一章",
      "wordCount": 5000,
      // 不包含content和contentId
    }
  ]
}
```

### 获取文档内容

```http
GET /api/v1/documents/doc123/content

后端实现：
content := documentContentRepo.GetByDocumentID("doc123")

返回：
{
  "documentId": "doc123",
  "content": "实际文档内容...",
  "version": 3,
  "wordCount": 5000
}
```

### 获取版本历史

```http
GET /api/v1/documents/doc123/versions

后端实现：
versions := versionRepo.GetByDocumentID("doc123")

返回：
[
  {
    "versionNum": 3,
    "content": "第三版完整内容...",
    "comment": "修改结尾",
    "createdAt": "..."
  },
  {
    "versionNum": 2,
    "content": "第二版完整内容...",
    ...
  }
]
```

### 恢复版本

```http
POST /api/v1/documents/doc123/restore/v2

后端实现：
1. version := versionRepo.GetByDocumentIDAndVersion("doc123", 2)
2. documentContent := DocumentContent{
     Content: version.Content,  // 使用完整快照
     Version: currentVersion + 1
   }
3. documentContentRepo.Update(documentContent)
```

---

## 总结

### 优化要点

1. ✅ **移除Document.ContentID** - 单向关联更清晰
2. ✅ **保留Version.VersionNum** - 语义清晰，用户友好
3. ✅ **Version存储完整快照** - 独立回滚，可靠性高

### 优化效果

- ✅ 数据一致性提升
- ✅ 代码简洁性提升
- ✅ 维护性提升
- → 性能保持不变

### 符合最佳实践

- ✅ 单向关联（避免循环依赖）
- ✅ 语义版本号（用户友好）
- ✅ 完整快照（数据可靠）
- ✅ MongoDB推荐模式

---

**优化完成日期**: 2025-10-16  
**优化状态**: ✅ 已完成  
**影响评估**: 低（只是移除冗余字段）  
**建议**: 采纳此优化方案

