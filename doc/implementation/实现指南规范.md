# 实现指南规范

## 1. 概述

### 1.1 目的
本规范旨在为青羽项目的功能实现提供统一的指导原则和最佳实践，确保代码质量、开发效率和系统可维护性。

### 1.2 适用范围
- 功能开发实现指南
- 代码编写规范
- 测试实现指南
- 部署实现指南
- 性能优化指南
- 安全实现指南

### 1.3 指导原则
- **代码质量**：编写高质量、可读性强的代码
- **标准化**：遵循统一的编码和实现标准
- **可测试性**：代码应易于测试和验证
- **可维护性**：便于后续维护和扩展
- **性能优先**：考虑性能影响和优化
- **安全第一**：确保实现的安全性

## 2. 实现指南分类

### 2.1 开发实现指南
**用途**：指导具体功能的开发实现

**包含内容**：
- 开发环境搭建
- 代码结构组织
- 编码规范和风格
- 依赖管理
- 版本控制使用

### 2.2 测试实现指南
**用途**：指导测试的设计和实现

**包含内容**：
- 测试策略和方法
- 单元测试编写
- 集成测试实现
- 端到端测试设计
- 性能测试执行

### 2.3 部署实现指南
**用途**：指导系统的部署和发布

**包含内容**：
- 环境配置管理
- 构建和打包流程
- 部署自动化
- 监控和日志配置
- 故障排查方法

### 2.4 性能优化指南
**用途**：指导系统性能的优化实现

**包含内容**：
- 性能分析方法
- 代码优化技巧
- 数据库优化策略
- 缓存使用指南
- 并发处理优化

### 2.5 安全实现指南
**用途**：指导安全功能的实现

**包含内容**：
- 安全编码规范
- 身份认证实现
- 数据加密处理
- 输入验证和过滤
- 安全测试方法

## 3. 开发实现指南

### 3.1 开发环境搭建

#### 3.1.1 基础环境要求
```markdown
## 开发环境配置

### 必需软件
- **Node.js**: v18.x 或更高版本
- **Go**: v1.19 或更高版本
- **Docker**: v20.x 或更高版本
- **Git**: v2.30 或更高版本

### 开发工具
- **IDE**: VS Code 或 GoLand
- **数据库工具**: DBeaver 或 Navicat
- **API测试**: Postman 或 Insomnia
- **版本控制**: Git + GitHub Desktop

### 环境变量配置
```bash
# 数据库配置
DB_HOST=localhost
DB_PORT=5432
DB_NAME=qingyu_dev
DB_USER=developer
DB_PASSWORD=dev_password

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# JWT配置
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRE=24h

# 服务配置
SERVER_PORT=8080
SERVER_MODE=debug
```

### 项目初始化
```bash
# 克隆项目
git clone https://github.com/your-org/qingyu-backend.git
cd qingyu-backend

# 安装依赖
go mod download

# 初始化数据库
make db-migrate

# 启动开发服务
make dev
```
```

#### 3.1.2 开发工具配置
- **VS Code插件推荐**：Go、GitLens、Docker、REST Client
- **代码格式化**：使用gofmt和golint
- **调试配置**：配置launch.json用于调试
- **代码片段**：创建常用代码模板

### 3.2 代码结构组织

#### 3.2.1 项目目录结构
```
qingyu-backend/
├── cmd/                    # 应用程序入口
│   └── server/
│       └── main.go
├── internal/               # 私有应用程序代码
│   ├── api/               # API处理器
│   ├── service/           # 业务逻辑服务
│   ├── repository/        # 数据访问层
│   ├── model/             # 数据模型
│   ├── middleware/        # 中间件
│   └── config/            # 配置管理
├── pkg/                   # 公共库代码
│   ├── utils/             # 工具函数
│   ├── logger/            # 日志组件
│   └── database/          # 数据库连接
├── scripts/               # 构建和部署脚本
├── docs/                  # 文档
├── tests/                 # 测试文件
└── deployments/           # 部署配置
```

#### 3.2.2 代码分层架构
```go
// Router层 - 路由定义
func SetupRoutes(r *gin.Engine) {
    api := r.Group("/api/v1")
    {
        api.POST("/users", userHandler.CreateUser)
        api.GET("/users/:id", userHandler.GetUser)
    }
}

// Handler层 - HTTP请求处理
type UserHandler struct {
    userService service.UserService
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    user, err := h.userService.CreateUser(req.ToUser())
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(201, UserResponse{}.FromUser(user))
}

// Service层 - 业务逻辑
type UserService interface {
    CreateUser(user *model.User) (*model.User, error)
    GetUser(id uint) (*model.User, error)
}

type userService struct {
    userRepo repository.UserRepository
}

func (s *userService) CreateUser(user *model.User) (*model.User, error) {
    // 业务逻辑验证
    if err := s.validateUser(user); err != nil {
        return nil, err
    }
    
    // 调用数据访问层
    return s.userRepo.Create(user)
}

// Repository层 - 数据访问
type UserRepository interface {
    Create(user *model.User) (*model.User, error)
    GetByID(id uint) (*model.User, error)
}

type userRepository struct {
    db *gorm.DB
}

func (r *userRepository) Create(user *model.User) (*model.User, error) {
    if err := r.db.Create(user).Error; err != nil {
        return nil, err
    }
    return user, nil
}
```

### 3.3 编码规范

#### 3.3.1 Go编码规范
```go
// 包命名：使用小写字母，简洁明了
package userservice

// 常量命名：使用驼峰命名法
const (
    DefaultPageSize = 20
    MaxPageSize     = 100
)

// 变量命名：使用驼峰命名法
var (
    ErrUserNotFound = errors.New("user not found")
    ErrInvalidEmail = errors.New("invalid email format")
)

// 结构体命名：使用帕斯卡命名法
type UserService struct {
    repo   UserRepository
    logger *zap.Logger
}

// 方法命名：使用帕斯卡命名法，动词开头
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    // 参数验证
    if user == nil {
        return ErrInvalidUser
    }
    
    // 业务逻辑
    if err := s.validateUser(user); err != nil {
        return fmt.Errorf("validate user: %w", err)
    }
    
    // 数据操作
    return s.repo.Create(ctx, user)
}

// 私有方法：使用小写字母开头
func (s *UserService) validateUser(user *User) error {
    if user.Email == "" {
        return ErrInvalidEmail
    }
    return nil
}
```

#### 3.3.2 错误处理规范
```go
// 定义错误类型
var (
    ErrUserNotFound     = errors.New("user not found")
    ErrInvalidParameter = errors.New("invalid parameter")
    ErrDatabaseError    = errors.New("database error")
)

// 错误包装
func (s *UserService) GetUser(id uint) (*User, error) {
    user, err := s.repo.GetByID(id)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("%w: id=%d", ErrUserNotFound, id)
        }
        return nil, fmt.Errorf("get user from database: %w", err)
    }
    return user, nil
}

// 错误处理
func (h *UserHandler) GetUser(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(400, gin.H{"error": "invalid user id"})
        return
    }
    
    user, err := h.userService.GetUser(uint(id))
    if err != nil {
        if errors.Is(err, ErrUserNotFound) {
            c.JSON(404, gin.H{"error": "user not found"})
            return
        }
        c.JSON(500, gin.H{"error": "internal server error"})
        return
    }
    
    c.JSON(200, user)
}
```

#### 3.3.3 日志记录规范
```go
// 日志级别使用
logger.Debug("debug information", zap.String("user_id", userID))
logger.Info("user created successfully", zap.Uint("user_id", user.ID))
logger.Warn("deprecated API used", zap.String("endpoint", "/old-api"))
logger.Error("failed to create user", zap.Error(err), zap.String("email", user.Email))

// 结构化日志
logger.Info("user operation",
    zap.String("operation", "create"),
    zap.String("user_id", user.ID),
    zap.String("email", user.Email),
    zap.Duration("duration", time.Since(start)),
)

// 上下文日志
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    logger := s.logger.With(
        zap.String("operation", "create_user"),
        zap.String("email", user.Email),
    )
    
    logger.Info("starting user creation")
    
    if err := s.repo.Create(ctx, user); err != nil {
        logger.Error("failed to create user", zap.Error(err))
        return err
    }
    
    logger.Info("user created successfully", zap.Uint("user_id", user.ID))
    return nil
}
```

## 4. 测试实现指南

### 4.1 测试策略

#### 4.1.1 测试金字塔
```
    /\
   /  \     E2E Tests (少量)
  /____\    
 /      \   Integration Tests (适量)
/________\  Unit Tests (大量)
```

#### 4.1.2 测试覆盖率要求
- **单元测试覆盖率**：≥ 80%
- **集成测试覆盖率**：≥ 60%
- **关键路径覆盖率**：100%

### 4.2 单元测试

#### 4.2.1 测试文件组织
```
internal/
├── service/
│   ├── user_service.go
│   └── user_service_test.go
├── repository/
│   ├── user_repository.go
│   └── user_repository_test.go
└── api/
    ├── user_handler.go
    └── user_handler_test.go
```

#### 4.2.2 单元测试示例
```go
// user_service_test.go
package service

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock Repository
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

func (m *MockUserRepository) GetByID(ctx context.Context, id uint) (*User, error) {
    args := m.Called(ctx, id)
    return args.Get(0).(*User), args.Error(1)
}

// 测试用例
func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name    string
        user    *User
        mockFn  func(*MockUserRepository)
        wantErr bool
    }{
        {
            name: "successful creation",
            user: &User{
                Email: "test@example.com",
                Name:  "Test User",
            },
            mockFn: func(repo *MockUserRepository) {
                repo.On("Create", mock.Anything, mock.AnythingOfType("*User")).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "invalid email",
            user: &User{
                Email: "invalid-email",
                Name:  "Test User",
            },
            mockFn:  func(repo *MockUserRepository) {},
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            repo := new(MockUserRepository)
            tt.mockFn(repo)
            
            service := NewUserService(repo, nil)
            err := service.CreateUser(context.Background(), tt.user)
            
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
            }
            
            repo.AssertExpectations(t)
        })
    }
}
```

### 4.3 集成测试

#### 4.3.1 数据库集成测试
```go
// integration_test.go
package integration

import (
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
)

func TestUserRepository_Integration(t *testing.T) {
    // 启动测试数据库容器
    ctx := context.Background()
    pgContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:13"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("testuser"),
        postgres.WithPassword("testpass"),
    )
    require.NoError(t, err)
    defer pgContainer.Terminate(ctx)

    // 获取数据库连接
    connStr, err := pgContainer.ConnectionString(ctx)
    require.NoError(t, err)
    
    db, err := gorm.Open(postgres.Open(connStr), &gorm.Config{})
    require.NoError(t, err)
    
    // 运行迁移
    err = db.AutoMigrate(&User{})
    require.NoError(t, err)
    
    // 创建repository
    repo := NewUserRepository(db)
    
    // 测试用例
    t.Run("create and get user", func(t *testing.T) {
        user := &User{
            Email: "test@example.com",
            Name:  "Test User",
        }
        
        err := repo.Create(ctx, user)
        assert.NoError(t, err)
        assert.NotZero(t, user.ID)
        
        retrieved, err := repo.GetByID(ctx, user.ID)
        assert.NoError(t, err)
        assert.Equal(t, user.Email, retrieved.Email)
        assert.Equal(t, user.Name, retrieved.Name)
    })
}
```

### 4.4 API测试

#### 4.4.1 HTTP API测试
```go
// api_test.go
package api

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
)

func TestUserHandler_CreateUser(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    tests := []struct {
        name           string
        requestBody    interface{}
        expectedStatus int
        expectedBody   string
    }{
        {
            name: "valid request",
            requestBody: CreateUserRequest{
                Email: "test@example.com",
                Name:  "Test User",
            },
            expectedStatus: 201,
        },
        {
            name: "invalid email",
            requestBody: CreateUserRequest{
                Email: "invalid-email",
                Name:  "Test User",
            },
            expectedStatus: 400,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建mock service
            mockService := new(MockUserService)
            handler := NewUserHandler(mockService)
            
            // 设置路由
            router := gin.New()
            router.POST("/users", handler.CreateUser)
            
            // 准备请求
            body, _ := json.Marshal(tt.requestBody)
            req := httptest.NewRequest("POST", "/users", bytes.NewBuffer(body))
            req.Header.Set("Content-Type", "application/json")
            
            // 执行请求
            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
            
            // 验证结果
            assert.Equal(t, tt.expectedStatus, w.Code)
        })
    }
}
```

## 5. 部署实现指南

### 5.1 容器化部署

#### 5.1.1 Dockerfile
```dockerfile
# 多阶段构建
FROM golang:1.19-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main cmd/server/main.go

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/configs ./configs

EXPOSE 8080
CMD ["./main"]
```

#### 5.1.2 Docker Compose
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    networks:
      - qingyu-network

  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: qingyu
      POSTGRES_USER: qingyu
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - qingyu-network

  redis:
    image: redis:6-alpine
    networks:
      - qingyu-network

volumes:
  postgres_data:

networks:
  qingyu-network:
    driver: bridge
```

### 5.2 CI/CD流程

#### 5.2.1 GitHub Actions
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Install dependencies
      run: go mod download
    
    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: docker build -t qingyu-backend:${{ github.sha }} .
    
    - name: Push to registry
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push qingyu-backend:${{ github.sha }}
```

## 6. 性能优化指南

### 6.1 数据库优化

#### 6.1.1 查询优化
```go
// 使用索引
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Email string `gorm:"uniqueIndex"`
    Name  string `gorm:"index"`
}

// 批量查询
func (r *userRepository) GetUsersByIDs(ids []uint) ([]*User, error) {
    var users []*User
    err := r.db.Where("id IN ?", ids).Find(&users).Error
    return users, err
}

// 预加载关联数据
func (r *userRepository) GetUserWithProjects(id uint) (*User, error) {
    var user User
    err := r.db.Preload("Projects").First(&user, id).Error
    return &user, err
}

// 分页查询
func (r *userRepository) GetUsers(page, pageSize int) ([]*User, int64, error) {
    var users []*User
    var total int64
    
    offset := (page - 1) * pageSize
    
    err := r.db.Model(&User{}).Count(&total).Error
    if err != nil {
        return nil, 0, err
    }
    
    err = r.db.Offset(offset).Limit(pageSize).Find(&users).Error
    return users, total, err
}
```

#### 6.1.2 缓存策略
```go
// Redis缓存
type CacheUserRepository struct {
    db    *gorm.DB
    cache *redis.Client
}

func (r *CacheUserRepository) GetByID(id uint) (*User, error) {
    // 先从缓存获取
    cacheKey := fmt.Sprintf("user:%d", id)
    cached, err := r.cache.Get(context.Background(), cacheKey).Result()
    if err == nil {
        var user User
        if err := json.Unmarshal([]byte(cached), &user); err == nil {
            return &user, nil
        }
    }
    
    // 缓存未命中，从数据库获取
    var user User
    if err := r.db.First(&user, id).Error; err != nil {
        return nil, err
    }
    
    // 写入缓存
    userJSON, _ := json.Marshal(user)
    r.cache.Set(context.Background(), cacheKey, userJSON, time.Hour)
    
    return &user, nil
}
```

### 6.2 并发处理

#### 6.2.1 Goroutine池
```go
// 工作池模式
type WorkerPool struct {
    workerCount int
    jobQueue    chan Job
    quit        chan bool
}

type Job struct {
    ID   int
    Data interface{}
}

func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        workerCount: workerCount,
        jobQueue:    make(chan Job, 100),
        quit:        make(chan bool),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    for {
        select {
        case job := <-wp.jobQueue:
            wp.processJob(job)
        case <-wp.quit:
            return
        }
    }
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobQueue <- job
}
```

#### 6.2.2 上下文超时控制
```go
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    // 设置超时
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    // 使用channel进行异步处理
    errChan := make(chan error, 1)
    
    go func() {
        errChan <- s.repo.Create(ctx, user)
    }()
    
    select {
    case err := <-errChan:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

## 7. 安全实现指南

### 7.1 身份认证

#### 7.1.1 JWT实现
```go
// JWT工具
type JWTManager struct {
    secretKey string
    expire    time.Duration
}

func NewJWTManager(secretKey string, expire time.Duration) *JWTManager {
    return &JWTManager{secretKey, expire}
}

func (j *JWTManager) GenerateToken(userID uint) (string, error) {
    claims := jwt.MapClaims{
        "user_id": userID,
        "exp":     time.Now().Add(j.expire).Unix(),
        "iat":     time.Now().Unix(),
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.secretKey))
}

func (j *JWTManager) ValidateToken(tokenString string) (uint, error) {
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        return []byte(j.secretKey), nil
    })
    
    if err != nil {
        return 0, err
    }
    
    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
        userID := uint(claims["user_id"].(float64))
        return userID, nil
    }
    
    return 0, errors.New("invalid token")
}

// 认证中间件
func AuthMiddleware(jwtManager *JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "authorization header required"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        userID, err := jwtManager.ValidateToken(tokenString)
        if err != nil {
            c.JSON(401, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        c.Set("user_id", userID)
        c.Next()
    }
}
```

### 7.2 输入验证

#### 7.2.1 参数验证
```go
// 验证结构体
type CreateUserRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Name     string `json:"name" binding:"required,min=2,max=50"`
    Password string `json:"password" binding:"required,min=8"`
}

// 自定义验证器
func ValidatePassword(fl validator.FieldLevel) bool {
    password := fl.Field().String()
    
    // 至少包含一个数字、一个小写字母、一个大写字母
    hasNumber := regexp.MustCompile(`[0-9]`).MatchString(password)
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    
    return hasNumber && hasLower && hasUpper
}

// 注册自定义验证器
func RegisterValidators() {
    if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
        v.RegisterValidation("password", ValidatePassword)
    }
}
```

### 7.3 数据加密

#### 7.3.1 密码加密
```go
// 密码哈希
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// 敏感数据加密
func EncryptSensitiveData(data, key string) (string, error) {
    block, err := aes.NewCipher([]byte(key))
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, []byte(data), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}
```

## 8. 监控和日志

### 8.1 应用监控

#### 8.1.1 Prometheus指标
```go
// 定义指标
var (
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP request duration in seconds",
        },
        []string{"method", "endpoint"},
    )
)

// 注册指标
func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
}

// 监控中间件
func PrometheusMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start).Seconds()
        status := strconv.Itoa(c.Writer.Status())
        
        httpRequestsTotal.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()
        httpRequestDuration.WithLabelValues(c.Request.Method, c.FullPath()).Observe(duration)
    }
}
```

### 8.2 结构化日志

#### 8.2.1 Zap日志配置
```go
// 日志配置
func NewLogger() *zap.Logger {
    config := zap.NewProductionConfig()
    config.OutputPaths = []string{"stdout", "logs/app.log"}
    config.ErrorOutputPaths = []string{"stderr", "logs/error.log"}
    
    logger, _ := config.Build()
    return logger
}

// 请求日志中间件
func LoggerMiddleware(logger *zap.Logger) gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        logger.Info("HTTP Request",
            zap.String("method", param.Method),
            zap.String("path", param.Path),
            zap.Int("status", param.StatusCode),
            zap.Duration("latency", param.Latency),
            zap.String("client_ip", param.ClientIP),
            zap.String("user_agent", param.Request.UserAgent()),
        )
        return ""
    })
}
```

## 9. 最佳实践总结

### 9.1 代码质量
- 遵循SOLID原则
- 使用依赖注入
- 编写可测试的代码
- 保持函数简洁
- 使用有意义的命名

### 9.2 性能优化
- 合理使用缓存
- 优化数据库查询
- 控制并发数量
- 避免内存泄漏
- 使用连接池

### 9.3 安全防护
- 输入验证和过滤
- 使用HTTPS传输
- 实施访问控制
- 定期安全审计
- 敏感数据加密

### 9.4 运维监控
- 完善的日志记录
- 关键指标监控
- 健康检查接口
- 优雅关闭处理
- 错误告警机制

## 10. 工具和资源

### 10.1 开发工具
- **代码质量**：golangci-lint, SonarQube
- **测试工具**：testify, gomock, testcontainers
- **性能分析**：pprof, go-torch
- **依赖管理**：go mod, govulncheck

### 10.2 监控工具
- **指标监控**：Prometheus, Grafana
- **日志管理**：ELK Stack, Fluentd
- **链路追踪**：Jaeger, Zipkin
- **错误追踪**：Sentry

### 10.3 部署工具
- **容器化**：Docker, Podman
- **编排工具**：Kubernetes, Docker Compose
- **CI/CD**：GitHub Actions, GitLab CI
- **基础设施**：Terraform, Ansible