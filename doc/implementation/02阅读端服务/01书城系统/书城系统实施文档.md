# ä¹¦åŸç³»ç»Ÿå®æ–½æ–‡æ¡£

> **æ¨¡å—åç§°**: ä¹¦åŸç³»ç»Ÿ (Bookstore System)  
> **å®æ–½çŠ¶æ€**: âœ… å·²å®Œæˆ  
> **å®Œæˆåº¦**: 70%
> **å®æ–½æ—¥æœŸ**: 2025-10-08
> **è´Ÿè´£äºº**: é’ç¾½åç«¯å›¢é˜Ÿ

## ğŸ“‹ ç›®å½•

1. [å®æ–½æ¦‚è¿°](#1-å®æ–½æ¦‚è¿°)
2. [æ¶æ„å®ç°](#2-æ¶æ„å®ç°)
3. [Modelå±‚å®ç°](#3-modelå±‚å®ç°)
4. [Repositoryå±‚å®ç°](#4-repositoryå±‚å®ç°)
5. [Serviceå±‚å®ç°](#5-serviceå±‚å®ç°)
6. [APIå±‚å®ç°](#6-apiå±‚å®ç°)
7. [Routerå±‚å®ç°](#7-routerå±‚å®ç°)
8. [ç¼“å­˜ç­–ç•¥å®ç°](#8-ç¼“å­˜ç­–ç•¥å®ç°)
9. [æµ‹è¯•æŒ‡å—](#9-æµ‹è¯•æŒ‡å—)
10. [éƒ¨ç½²è¯´æ˜](#10-éƒ¨ç½²è¯´æ˜)

## 1. å®æ–½æ¦‚è¿°

### 1.1 åŠŸèƒ½èŒƒå›´

ä¹¦åŸç³»ç»Ÿæ˜¯é˜…è¯»ç«¯çš„æ ¸å¿ƒæ¨¡å—ï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š

âœ… **å·²å®ç°åŠŸèƒ½**:
- ä¹¦ç±ç®¡ç†ï¼ˆCRUDï¼‰
- åˆ†ç±»ç®¡ç†ï¼ˆå±‚çº§ç»“æ„ï¼‰
- Bannerç®¡ç†ï¼ˆè½®æ’­å›¾ï¼‰
- é¦–é¡µæ•°æ®èšåˆ
- ä¹¦ç±æœç´¢å’Œç­›é€‰
- æ¦œå•ç®¡ç†ï¼ˆå®æ—¶/å‘¨/æœˆæ¦œï¼‰
- ç»Ÿè®¡åŠŸèƒ½ï¼ˆæµè§ˆé‡ã€ç‚¹èµç­‰ï¼‰
- Redisç¼“å­˜é›†æˆ
- å®šæ—¶ä»»åŠ¡è°ƒåº¦

â¸ï¸ **æš‚æ—¶ç¦ç”¨åŠŸèƒ½**:
- ä¹¦ç±è¯„åˆ†API
- ä¹¦ç±ç»Ÿè®¡API

### 1.2 æŠ€æœ¯æ ˆ

- **ç¼–ç¨‹è¯­è¨€**: Go 1.21+
- **Webæ¡†æ¶**: Gin
- **æ•°æ®åº“**: MongoDB 5.0+
- **ç¼“å­˜**: Redis 6.0+
- **ä¾èµ–æ³¨å…¥**: è‡ªå®šä¹‰ServiceContainer
- **æ—¥å¿—**: Zap

### 1.3 ç›®å½•ç»“æ„

```
ä¹¦åŸç³»ç»Ÿç›®å½•ç»“æ„
â”œâ”€â”€ models/reading/bookstore/          # æ•°æ®æ¨¡å‹å±‚
â”‚   â”œâ”€â”€ book.go                        # ä¹¦ç±æ¨¡å‹
â”‚   â”œâ”€â”€ category.go                    # åˆ†ç±»æ¨¡å‹
â”‚   â”œâ”€â”€ banner.go                      # Banneræ¨¡å‹
â”‚   â”œâ”€â”€ chapter.go                     # ç« èŠ‚æ¨¡å‹
â”‚   â”œâ”€â”€ ranking.go                     # æ¦œå•æ¨¡å‹
â”‚   â”œâ”€â”€ book_detail.go                 # ä¹¦ç±è¯¦æƒ…
â”‚   â”œâ”€â”€ book_rating.go                 # ä¹¦ç±è¯„åˆ†
â”‚   â””â”€â”€ book_statistics.go             # ä¹¦ç±ç»Ÿè®¡
â”‚
â”œâ”€â”€ repository/                        # ä»“å‚¨å±‚
â”‚   â”œâ”€â”€ interfaces/bookstore/          # ä»“å‚¨æ¥å£
â”‚   â”‚   â”œâ”€â”€ book_repository.go
â”‚   â”‚   â”œâ”€â”€ category_repository.go
â”‚   â”‚   â”œâ”€â”€ banner_repository.go
â”‚   â”‚   â”œâ”€â”€ chapter_repository.go
â”‚   â”‚   â”œâ”€â”€ ranking_repository.go
â”‚   â”‚   â”œâ”€â”€ book_detail_repository.go
â”‚   â”‚   â””â”€â”€ book_rating_repository.go
â”‚   â”‚
â”‚   â””â”€â”€ mongodb/bookstore/             # MongoDBå®ç°
â”‚       â”œâ”€â”€ book_repository_mongo.go
â”‚       â”œâ”€â”€ category_repository_mongo.go
â”‚       â”œâ”€â”€ banner_repository_mongo.go
â”‚       â”œâ”€â”€ chapter_repository_mongo.go
â”‚       â”œâ”€â”€ ranking_repository_mongo.go
â”‚       â”œâ”€â”€ book_detail_repository_mongo.go
â”‚       â””â”€â”€ book_rating_repository_mongo.go
â”‚
â”œâ”€â”€ service/bookstore/                 # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ bookstore_service.go           # æ ¸å¿ƒä¹¦åŸæœåŠ¡
â”‚   â”œâ”€â”€ cache_service.go               # ç¼“å­˜æœåŠ¡
â”‚   â”œâ”€â”€ cached_bookstore_service.go    # å¸¦ç¼“å­˜çš„æœåŠ¡åŒ…è£…
â”‚   â”œâ”€â”€ ranking_scheduler.go           # æ¦œå•è°ƒåº¦å™¨
â”‚   â”œâ”€â”€ chapter_service.go             # ç« èŠ‚æœåŠ¡
â”‚   â”œâ”€â”€ book_detail_service.go         # ä¹¦ç±è¯¦æƒ…æœåŠ¡
â”‚   â”œâ”€â”€ book_rating_service.go         # è¯„åˆ†æœåŠ¡
â”‚   â””â”€â”€ book_statistics_service.go     # ç»Ÿè®¡æœåŠ¡
â”‚
â”œâ”€â”€ api/v1/reading/                    # APIæ¥å£å±‚
â”‚   â”œâ”€â”€ bookstore_api.go               # ä¹¦åŸä¸»API
â”‚   â”œâ”€â”€ chapter_api.go                 # ç« èŠ‚API
â”‚   â”œâ”€â”€ book_detail_api.go             # è¯¦æƒ…API
â”‚   â”œâ”€â”€ book_rating_api.go.disabled    # è¯„åˆ†APIï¼ˆç¦ç”¨ï¼‰
â”‚   â””â”€â”€ book_statistics_api.go.disabled # ç»Ÿè®¡APIï¼ˆç¦ç”¨ï¼‰
â”‚
â””â”€â”€ router/bookstore/                  # è·¯ç”±å±‚
    â””â”€â”€ bookstore_router.go            # è·¯ç”±é…ç½®
```

## 2. æ¶æ„å®ç°

### 2.1 åˆ†å±‚æ¶æ„

ä¹¦åŸç³»ç»Ÿä¸¥æ ¼éµå¾ªäº”å±‚æ¶æ„è®¾è®¡ï¼š

```
è¯·æ±‚æµç¨‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client Request                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Router Layer (è·¯ç”±å±‚)                            â”‚
â”‚ - è·¯ç”±åˆ†å‘                                       â”‚
â”‚ - ä¸­é—´ä»¶å¤„ç†                                     â”‚
â”‚ - å‚æ•°éªŒè¯                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ API Layer (æ¥å£å±‚)                               â”‚
â”‚ - HTTPè¯·æ±‚å¤„ç†                                   â”‚
â”‚ - å‚æ•°ç»‘å®š                                       â”‚
â”‚ - å“åº”æ ¼å¼åŒ–                                     â”‚
â”‚ - é”™è¯¯è½¬æ¢                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Layer (ä¸šåŠ¡é€»è¾‘å±‚)                       â”‚
â”‚ - ä¸šåŠ¡è§„åˆ™å¤„ç†                                   â”‚
â”‚ - æ•°æ®èšåˆ                                       â”‚
â”‚ - ç¼“å­˜ç®¡ç†                                       â”‚
â”‚ - äº‹ä»¶å‘å¸ƒ                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Repository Layer (ä»“å‚¨å±‚)                        â”‚
â”‚ - æ•°æ®è®¿é—®                                       â”‚
â”‚ - æŸ¥è¯¢å°è£…                                       â”‚
â”‚ - äº‹åŠ¡ç®¡ç†                                       â”‚
â”‚ - ç¼“å­˜ç­–ç•¥                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Layer (æ¨¡å‹å±‚)                             â”‚
â”‚ - æ•°æ®ç»“æ„å®šä¹‰                                   â”‚
â”‚ - å­—æ®µéªŒè¯                                       â”‚
â”‚ - ä¸šåŠ¡è§„åˆ™                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ä¾èµ–å…³ç³»

```go
// ä¾èµ–æ³¨å…¥ç¤ºä¾‹
type BookstoreService struct {
    bookRepo     bookstore.BookRepository      // Repositoryæ¥å£
    categoryRepo bookstore.CategoryRepository
    bannerRepo   bookstore.BannerRepository
    eventBus     base.EventBus                 // äº‹ä»¶æ€»çº¿
}

// æ„é€ å‡½æ•°æ³¨å…¥
func NewBookstoreService(
    bookRepo bookstore.BookRepository,
    categoryRepo bookstore.CategoryRepository,
    bannerRepo bookstore.BannerRepository,
    eventBus base.EventBus,
) *BookstoreService {
    return &BookstoreService{
        bookRepo:     bookRepo,
        categoryRepo: categoryRepo,
        bannerRepo:   bannerRepo,
        eventBus:     eventBus,
    }
}
```

### 2.3 è®¾è®¡æ¨¡å¼åº”ç”¨

#### 2.3.1 è£…é¥°å™¨æ¨¡å¼ - ç¼“å­˜æœåŠ¡

```go
// CachedBookstoreService åŒ…è£…åŸå§‹æœåŠ¡æ·»åŠ ç¼“å­˜åŠŸèƒ½
type CachedBookstoreService struct {
    bookstoreService *BookstoreService
    cacheService     *CacheService
}

func (s *CachedBookstoreService) GetBook(ctx context.Context, id string) (*models.Book, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    if book := s.cacheService.GetBook(id); book != nil {
        return book, nil
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼Œä»åŸå§‹æœåŠ¡è·å–
    book, err := s.bookstoreService.GetBook(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    s.cacheService.SetBook(id, book)
    
    return book, nil
}
```

#### 2.3.2 å·¥å‚æ¨¡å¼ - Repositoryåˆ›å»º

```go
// MongoDB Repositoryå·¥å‚
type MongoRepositoryFactory struct {
    db *mongo.Database
}

func (f *MongoRepositoryFactory) CreateBookRepository() BookRepository {
    return mongodb.NewMongoBookRepository(f.db)
}

func (f *MongoRepositoryFactory) CreateCategoryRepository() CategoryRepository {
    return mongodb.NewMongoCategoryRepository(f.db)
}
```

#### 2.3.3 ç­–ç•¥æ¨¡å¼ - æ¦œå•è®¡ç®—

```go
// æ¦œå•è®¡ç®—ç­–ç•¥æ¥å£
type RankingStrategy interface {
    Calculate(books []*models.Book) []*models.Book
}

// çƒ­åº¦æ¦œç­–ç•¥
type HotRankingStrategy struct{}

func (s *HotRankingStrategy) Calculate(books []*models.Book) []*models.Book {
    // æŒ‰æµè§ˆé‡å’Œç‚¹èµæ•°æ’åº
    sort.Slice(books, func(i, j int) bool {
        return books[i].ViewCount > books[j].ViewCount
    })
    return books
}
```

## 3. Modelå±‚å®ç°

### 3.1 Bookæ¨¡å‹

**æ–‡ä»¶ä½ç½®**: `models/reading/bookstore/book.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Book ä¹¦ç±æ¨¡å‹
type Book struct {
    ID           primitive.ObjectID   `bson:"_id,omitempty" json:"id"`
    Title        string              `bson:"title" json:"title" validate:"required,min=1,max=200"`
    Author       string              `bson:"author" json:"author" validate:"required"`
    AuthorID     primitive.ObjectID   `bson:"author_id,omitempty" json:"authorId,omitempty"`
    Introduction string              `bson:"introduction" json:"introduction"`
    Cover        string              `bson:"cover" json:"cover"`
    CategoryIDs  []primitive.ObjectID `bson:"category_ids" json:"categoryIds"`
    Tags         []string            `bson:"tags" json:"tags"`
    Status       string              `bson:"status" json:"status" validate:"required,oneof=draft published"`
    WordCount    int64               `bson:"word_count" json:"wordCount"`
    ChapterCount int                 `bson:"chapter_count" json:"chapterCount"`
    ViewCount    int64               `bson:"view_count" json:"viewCount"`
    LikeCount    int64               `bson:"like_count" json:"likeCount"`
    CommentCount int64               `bson:"comment_count" json:"commentCount"`
    Rating       float64             `bson:"rating" json:"rating"`
    RatingCount  int64               `bson:"rating_count" json:"ratingCount"`
    IsRecommended bool               `bson:"is_recommended" json:"isRecommended"`
    IsFeatured   bool                `bson:"is_featured" json:"isFeatured"`
    PublishedAt  *time.Time          `bson:"published_at,omitempty" json:"publishedAt,omitempty"`
    CreatedAt    time.Time           `bson:"created_at" json:"createdAt"`
    UpdatedAt    time.Time           `bson:"updated_at" json:"updatedAt"`
}

// ä¸šåŠ¡æ–¹æ³•
func (b *Book) IsPublished() bool {
    return b.Status == "published"
}

func (b *Book) HasCategories() bool {
    return len(b.CategoryIDs) > 0
}
```

**å…³é”®å­—æ®µè¯´æ˜**:

| å­—æ®µ | ç±»å‹ | è¯´æ˜ | éªŒè¯è§„åˆ™ |
|-----|------|------|---------|
| ID | ObjectID | MongoDBä¸»é”® | - |
| Title | string | ä¹¦å | required, 1-200å­—ç¬¦ |
| Author | string | ä½œè€…å | required |
| Status | string | çŠ¶æ€ | draft/published |
| CategoryIDs | []ObjectID | åˆ†ç±»IDåˆ—è¡¨ | - |
| Tags | []string | æ ‡ç­¾ | - |
| ViewCount | int64 | æµè§ˆé‡ | - |
| LikeCount | int64 | ç‚¹èµæ•° | - |
| Rating | float64 | è¯„åˆ†(0-5) | - |
| IsRecommended | bool | æ˜¯å¦æ¨è | - |
| IsFeatured | bool | æ˜¯å¦ç²¾é€‰ | - |

### 3.2 Categoryæ¨¡å‹

**æ–‡ä»¶ä½ç½®**: `models/reading/bookstore/category.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Category åˆ†ç±»æ¨¡å‹
type Category struct {
    ID          primitive.ObjectID  `bson:"_id,omitempty" json:"id"`
    Name        string             `bson:"name" json:"name" validate:"required,min=1,max=50"`
    Description string             `bson:"description" json:"description"`
    Icon        string             `bson:"icon" json:"icon"`
    ParentID    *primitive.ObjectID `bson:"parent_id,omitempty" json:"parentId,omitempty"`
    Level       int                `bson:"level" json:"level"`
    SortOrder   int                `bson:"sort_order" json:"sortOrder"`
    BookCount   int64              `bson:"book_count" json:"bookCount"`
    IsActive    bool               `bson:"is_active" json:"isActive"`
    CreatedAt   time.Time          `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time          `bson:"updated_at" json:"updatedAt"`
}

// ä¸šåŠ¡æ–¹æ³•
func (c *Category) IsTopLevel() bool {
    return c.ParentID == nil || c.Level == 0
}

func (c *Category) HasParent() bool {
    return c.ParentID != nil
}
```

**å±‚çº§ç»“æ„è¯´æ˜**:
- Level 0: é¡¶çº§åˆ†ç±»ï¼ˆå¦‚ï¼šç„å¹»ã€éƒ½å¸‚ã€å†å²ï¼‰
- Level 1: äºŒçº§åˆ†ç±»ï¼ˆå¦‚ï¼šç„å¹»ä¸‹çš„ä¸œæ–¹ç„å¹»ã€å¼‚ä¸–å¤§é™†ï¼‰
- ParentID: æŒ‡å‘çˆ¶åˆ†ç±»çš„ID

### 3.3 Banneræ¨¡å‹

**æ–‡ä»¶ä½ç½®**: `models/reading/bookstore/banner.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Banner è½®æ’­å›¾æ¨¡å‹
type Banner struct {
    ID          primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Title       string            `bson:"title" json:"title" validate:"required"`
    Description string            `bson:"description" json:"description"`
    Image       string            `bson:"image" json:"image" validate:"required,url"`
    Target      string            `bson:"target" json:"target"`
    TargetType  string            `bson:"target_type" json:"targetType" validate:"oneof=book category url"`
    SortOrder   int               `bson:"sort_order" json:"sortOrder"`
    IsActive    bool              `bson:"is_active" json:"isActive"`
    StartTime   *time.Time        `bson:"start_time,omitempty" json:"startTime,omitempty"`
    EndTime     *time.Time        `bson:"end_time,omitempty" json:"endTime,omitempty"`
    ClickCount  int64             `bson:"click_count" json:"clickCount"`
    CreatedAt   time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time         `bson:"updated_at" json:"updatedAt"`
}

// ä¸šåŠ¡æ–¹æ³•
func (b *Banner) IsInTimeRange() bool {
    now := time.Now()
    if b.StartTime != nil && now.Before(*b.StartTime) {
        return false
    }
    if b.EndTime != nil && now.After(*b.EndTime) {
        return false
    }
    return true
}

func (b *Banner) CanDisplay() bool {
    return b.IsActive && b.IsInTimeRange()
}
```

**TargetTypeè¯´æ˜**:
- `book`: è·³è½¬åˆ°ä¹¦ç±è¯¦æƒ…é¡µ
- `category`: è·³è½¬åˆ°åˆ†ç±»é¡µ
- `url`: è·³è½¬åˆ°å¤–éƒ¨é“¾æ¥

## 4. Repositoryå±‚å®ç°

### 4.1 BookRepositoryæ¥å£

**æ–‡ä»¶ä½ç½®**: `repository/interfaces/bookstore/book_repository.go`

```go
package bookstore

import (
    "context"
    "Qingyu_backend/models/reading/bookstore"
    "Qingyu_backend/repository/interfaces/infrastructure"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// BookRepository ä¹¦ç±ä»“å‚¨æ¥å£
type BookRepository interface {
    // åŸºç¡€CRUDæ“ä½œ
    Create(ctx context.Context, book *bookstore.Book) error
    GetByID(ctx context.Context, id primitive.ObjectID) (*bookstore.Book, error)
    Update(ctx context.Context, id primitive.ObjectID, updates map[string]interface{}) error
    Delete(ctx context.Context, id primitive.ObjectID) error
    
    // åˆ—è¡¨æŸ¥è¯¢
    List(ctx context.Context, filter infrastructure.Filter) ([]*bookstore.Book, error)
    GetByCategory(ctx context.Context, categoryID primitive.ObjectID, limit, offset int64) ([]*bookstore.Book, error)
    GetByAuthor(ctx context.Context, author string, limit, offset int64) ([]*bookstore.Book, error)
    GetByAuthorID(ctx context.Context, authorID primitive.ObjectID, limit, offset int64) ([]*bookstore.Book, error)
    GetByStatus(ctx context.Context, status string, limit, offset int64) ([]*bookstore.Book, error)
    
    // ç‰¹æ®ŠæŸ¥è¯¢
    GetRecommended(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetFeatured(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetHotBooks(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetNewReleases(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetFreeBooks(ctx context.Context, limit, offset int64) ([]*bookstore.Book, error)
    GetByPriceRange(ctx context.Context, minPrice, maxPrice int64, limit, offset int64) ([]*bookstore.Book, error)
    
    // æœç´¢
    Search(ctx context.Context, keyword string, limit, offset int64) ([]*bookstore.Book, error)
    SearchWithFilter(ctx context.Context, filter *bookstore.BookSearchFilter) ([]*bookstore.Book, error)
    
    // ç»Ÿè®¡
    Count(ctx context.Context, filter infrastructure.Filter) (int64, error)
    CountByCategory(ctx context.Context, categoryID primitive.ObjectID) (int64, error)
    CountByAuthor(ctx context.Context, author string) (int64, error)
    CountByStatus(ctx context.Context, status string) (int64, error)
    
    // æ‰¹é‡æ“ä½œ
    BatchUpdateStatus(ctx context.Context, ids []primitive.ObjectID, status string) error
    BatchUpdateCategory(ctx context.Context, ids []primitive.ObjectID, categoryID primitive.ObjectID) error
    BatchUpdateRecommended(ctx context.Context, ids []primitive.ObjectID, isRecommended bool) error
    BatchUpdateFeatured(ctx context.Context, ids []primitive.ObjectID, isFeatured bool) error
    
    // ç»Ÿè®¡æ›´æ–°
    IncrementViewCount(ctx context.Context, id primitive.ObjectID) error
    IncrementLikeCount(ctx context.Context, id primitive.ObjectID) error
    IncrementCommentCount(ctx context.Context, id primitive.ObjectID) error
    UpdateRating(ctx context.Context, id primitive.ObjectID, rating float64, count int64) error
    
    // äº‹åŠ¡æ”¯æŒ
    Transaction(ctx context.Context, fn func(ctx context.Context) error) error
    
    // å¥åº·æ£€æŸ¥
    Health(ctx context.Context) error
}
```

### 4.2 MongoDBå®ç°

**æ–‡ä»¶ä½ç½®**: `repository/mongodb/bookstore/book_repository_mongo.go`

```go
package bookstore

import (
    "context"
    "fmt"
    "time"
    
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    
    "Qingyu_backend/models/reading/bookstore"
    "Qingyu_backend/repository/interfaces/infrastructure"
)

type MongoBookRepository struct {
    collection *mongo.Collection
    db         *mongo.Database
}

func NewMongoBookRepository(db *mongo.Database) *MongoBookRepository {
    return &MongoBookRepository{
        collection: db.Collection("books"),
        db:         db,
    }
}

// Create åˆ›å»ºä¹¦ç±
func (r *MongoBookRepository) Create(ctx context.Context, book *bookstore.Book) error {
    if book.ID.IsZero() {
        book.ID = primitive.NewObjectID()
    }
    book.CreatedAt = time.Now()
    book.UpdatedAt = time.Now()
    
    _, err := r.collection.InsertOne(ctx, book)
    if err != nil {
        if mongo.IsDuplicateKeyError(err) {
            return fmt.Errorf("ä¹¦ç±å·²å­˜åœ¨")
        }
        return fmt.Errorf("åˆ›å»ºä¹¦ç±å¤±è´¥: %w", err)
    }
    
    return nil
}

// GetByID æ ¹æ®IDè·å–ä¹¦ç±
func (r *MongoBookRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*bookstore.Book, error) {
    var book bookstore.Book
    err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&book)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return nil, fmt.Errorf("ä¹¦ç±ä¸å­˜åœ¨")
        }
        return nil, fmt.Errorf("æŸ¥è¯¢ä¹¦ç±å¤±è´¥: %w", err)
    }
    
    return &book, nil
}

// GetRecommended è·å–æ¨èä¹¦ç±
func (r *MongoBookRepository) GetRecommended(ctx context.Context, limit int64) ([]*bookstore.Book, error) {
    filter := bson.M{
        "is_recommended": true,
        "status":         "published",
    }
    
    opts := options.Find().
        SetLimit(limit).
        SetSort(bson.D{
            {Key: "rating", Value: -1},
            {Key: "view_count", Value: -1},
        })
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢æ¨èä¹¦ç±å¤±è´¥: %w", err)
    }
    defer cursor.Close(ctx)
    
    var books []*bookstore.Book
    if err = cursor.All(ctx, &books); err != nil {
        return nil, fmt.Errorf("è§£æä¹¦ç±æ•°æ®å¤±è´¥: %w", err)
    }
    
    return books, nil
}

// Search æœç´¢ä¹¦ç±
func (r *MongoBookRepository) Search(ctx context.Context, keyword string, limit, offset int64) ([]*bookstore.Book, error) {
    filter := bson.M{
        "$or": []bson.M{
            {"title": bson.M{"$regex": keyword, "$options": "i"}},
            {"author": bson.M{"$regex": keyword, "$options": "i"}},
            {"tags": bson.M{"$in": []string{keyword}}},
        },
        "status": "published",
    }
    
    opts := options.Find().
        SetSkip(offset).
        SetLimit(limit).
        SetSort(bson.D{{Key: "view_count", Value: -1}})
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("æœç´¢ä¹¦ç±å¤±è´¥: %w", err)
    }
    defer cursor.Close(ctx)
    
    var books []*bookstore.Book
    if err = cursor.All(ctx, &books); err != nil {
        return nil, fmt.Errorf("è§£ææœç´¢ç»“æœå¤±è´¥: %w", err)
    }
    
    return books, nil
}

// IncrementViewCount å¢åŠ æµè§ˆé‡
func (r *MongoBookRepository) IncrementViewCount(ctx context.Context, id primitive.ObjectID) error {
    update := bson.M{
        "$inc": bson.M{"view_count": 1},
        "$set": bson.M{"updated_at": time.Now()},
    }
    
    _, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
    if err != nil {
        return fmt.Errorf("æ›´æ–°æµè§ˆé‡å¤±è´¥: %w", err)
    }
    
    return nil
}

// Transaction æ‰§è¡Œäº‹åŠ¡
func (r *MongoBookRepository) Transaction(ctx context.Context, fn func(ctx context.Context) error) error {
    session, err := r.db.Client().StartSession()
    if err != nil {
        return fmt.Errorf("å¯åŠ¨ä¼šè¯å¤±è´¥: %w", err)
    }
    defer session.EndSession(ctx)
    
    _, err = session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) {
        return nil, fn(sessCtx)
    })
    
    return err
}

// Health å¥åº·æ£€æŸ¥
func (r *MongoBookRepository) Health(ctx context.Context) error {
    return r.db.Client().Ping(ctx, nil)
}
```

**å®ç°è¦ç‚¹**:
1. âœ… æ‰€æœ‰æ–¹æ³•è¿”å›é”™è¯¯ä¿¡æ¯
2. âœ… ä½¿ç”¨contextè¿›è¡Œè¶…æ—¶æ§åˆ¶
3. âœ… è‡ªåŠ¨è®¾ç½®CreatedAtå’ŒUpdatedAt
4. âœ… æ”¯æŒåˆ†é¡µæŸ¥è¯¢
5. âœ… æ”¯æŒæ’åº
6. âœ… æ”¯æŒäº‹åŠ¡æ“ä½œ

### 4.3 ç´¢å¼•ç­–ç•¥

**MongoDBç´¢å¼•é…ç½®**:

```javascript
// booksé›†åˆç´¢å¼•
db.books.createIndex({ "title": "text", "author": "text" })  // å…¨æ–‡æœç´¢
db.books.createIndex({ "author": 1 })                         // ä½œè€…æŸ¥è¯¢
db.books.createIndex({ "category_ids": 1 })                   // åˆ†ç±»æŸ¥è¯¢
db.books.createIndex({ "status": 1 })                         // çŠ¶æ€æŸ¥è¯¢
db.books.createIndex({ "is_recommended": 1 })                 // æ¨èä¹¦ç±
db.books.createIndex({ "is_featured": 1 })                    // ç²¾é€‰ä¹¦ç±
db.books.createIndex({ "rating": -1, "view_count": -1 })      // æ’åºå¤åˆç´¢å¼•
db.books.createIndex({ "created_at": -1 })                    // æ—¶é—´æ’åº
db.books.createIndex({ "published_at": -1 })                  // å‘å¸ƒæ—¶é—´

// categoriesé›†åˆç´¢å¼•
db.categories.createIndex({ "parent_id": 1 })                 // çˆ¶åˆ†ç±»æŸ¥è¯¢
db.categories.createIndex({ "level": 1 })                     // å±‚çº§æŸ¥è¯¢
db.categories.createIndex({ "sort_order": 1 })                // æ’åº
db.categories.createIndex({ "is_active": 1 })                 // çŠ¶æ€æŸ¥è¯¢

// bannersé›†åˆç´¢å¼•
db.banners.createIndex({ "is_active": 1 })                    // çŠ¶æ€æŸ¥è¯¢
db.banners.createIndex({ "sort_order": 1 })                   // æ’åº
db.banners.createIndex({ "start_time": 1, "end_time": 1 })    // æ—¶é—´èŒƒå›´
```

## 5. Serviceå±‚å®ç°

### 5.1 BookstoreServiceæ ¸å¿ƒæœåŠ¡

**æ–‡ä»¶ä½ç½®**: `service/bookstore/bookstore_service.go`

```go
package bookstore

import (
    "context"
    "fmt"
    
    "go.mongodb.org/mongo-driver/bson/primitive"
    
    "Qingyu_backend/models/reading/bookstore"
    bookstoreRepo "Qingyu_backend/repository/interfaces/bookstore"
    "Qingyu_backend/service/base"
)

type BookstoreService struct {
    bookRepo     bookstoreRepo.BookRepository
    categoryRepo bookstoreRepo.CategoryRepository
    bannerRepo   bookstoreRepo.BannerRepository
    eventBus     base.EventBus
}

func NewBookstoreService(
    bookRepo bookstoreRepo.BookRepository,
    categoryRepo bookstoreRepo.CategoryRepository,
    bannerRepo bookstoreRepo.BannerRepository,
    eventBus base.EventBus,
) *BookstoreService {
    return &BookstoreService{
        bookRepo:     bookRepo,
        categoryRepo: categoryRepo,
        bannerRepo:   bannerRepo,
        eventBus:     eventBus,
    }
}

// GetHomepage è·å–é¦–é¡µæ•°æ®
func (s *BookstoreService) GetHomepage(ctx context.Context) (*HomepageResponse, error) {
    // 1. è·å–æ´»åŠ¨Banner
    banners, err := s.bannerRepo.GetActive(ctx, 5)
    if err != nil {
        return nil, fmt.Errorf("è·å–Bannerå¤±è´¥: %w", err)
    }
    
    // 2. è·å–æ¨èä¹¦ç±
    recommendedBooks, err := s.bookRepo.GetRecommended(ctx, 20)
    if err != nil {
        return nil, fmt.Errorf("è·å–æ¨èä¹¦ç±å¤±è´¥: %w", err)
    }
    
    // 3. è·å–ç²¾é€‰ä¹¦ç±
    featuredBooks, err := s.bookRepo.GetFeatured(ctx, 10)
    if err != nil {
        return nil, fmt.Errorf("è·å–ç²¾é€‰ä¹¦ç±å¤±è´¥: %w", err)
    }
    
    // 4. è·å–çƒ­é—¨ä¹¦ç±
    hotBooks, err := s.bookRepo.GetHotBooks(ctx, 10)
    if err != nil {
        return nil, fmt.Errorf("è·å–çƒ­é—¨ä¹¦ç±å¤±è´¥: %w", err)
    }
    
    // 5. è·å–åˆ†ç±»åˆ—è¡¨
    categories, err := s.categoryRepo.GetTopLevel(ctx)
    if err != nil {
        return nil, fmt.Errorf("è·å–åˆ†ç±»åˆ—è¡¨å¤±è´¥: %w", err)
    }
    
    // 6. ç»Ÿè®¡æ•°æ®
    totalBooks, _ := s.bookRepo.CountByStatus(ctx, "published")
    
    return &HomepageResponse{
        Banners:          banners,
        RecommendedBooks: recommendedBooks,
        FeaturedBooks:    featuredBooks,
        HotBooks:         hotBooks,
        Categories:       categories,
        Stats: Stats{
            TotalBooks: totalBooks,
        },
    }, nil
}

// SearchBooks æœç´¢ä¹¦ç±
func (s *BookstoreService) SearchBooks(ctx context.Context, req *SearchBooksRequest) (*SearchBooksResponse, error) {
    // å‚æ•°éªŒè¯
    if req.Keyword == "" && len(req.CategoryIDs) == 0 && len(req.Tags) == 0 {
        return nil, fmt.Errorf("æœç´¢æ¡ä»¶ä¸èƒ½ä¸ºç©º")
    }
    
    // æ„å»ºæœç´¢è¿‡æ»¤å™¨
    filter := &bookstore.BookSearchFilter{
        Keyword:     req.Keyword,
        CategoryIDs: req.CategoryIDs,
        Author:      req.Author,
        Tags:        req.Tags,
        MinRating:   req.MinRating,
        SortBy:      req.SortBy,
        SortOrder:   req.SortOrder,
    }
    
    // æ‰§è¡Œæœç´¢
    books, err := s.bookRepo.SearchWithFilter(ctx, filter)
    if err != nil {
        return nil, fmt.Errorf("æœç´¢å¤±è´¥: %w", err)
    }
    
    // åˆ†é¡µå¤„ç†
    offset := (req.Page - 1) * req.PageSize
    limit := req.PageSize
    
    paginatedBooks := paginateBooks(books, offset, limit)
    
    return &SearchBooksResponse{
        Books: paginatedBooks,
        Total: int64(len(books)),
        Page:  req.Page,
        Size:  req.PageSize,
    }, nil
}

// IncrementViewCount å¢åŠ æµè§ˆé‡
func (s *BookstoreService) IncrementViewCount(ctx context.Context, bookID string) error {
    id, err := primitive.ObjectIDFromHex(bookID)
    if err != nil {
        return fmt.Errorf("æ— æ•ˆçš„ä¹¦ç±ID: %w", err)
    }
    
    // æ›´æ–°æµè§ˆé‡
    if err := s.bookRepo.IncrementViewCount(ctx, id); err != nil {
        return fmt.Errorf("æ›´æ–°æµè§ˆé‡å¤±è´¥: %w", err)
    }
    
    // å‘å¸ƒæµè§ˆäº‹ä»¶
    event := &base.BaseEvent{
        EventType: "book.viewed",
        EventData: map[string]interface{}{
            "book_id": bookID,
        },
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}
```

**HomepageResponseç»“æ„**:

```go
type HomepageResponse struct {
    Banners          []*bookstore.Banner   `json:"banners"`
    RecommendedBooks []*bookstore.Book     `json:"recommendedBooks"`
    FeaturedBooks    []*bookstore.Book     `json:"featuredBooks"`
    HotBooks         []*bookstore.Book     `json:"hotBooks"`
    Categories       []*bookstore.Category `json:"categories"`
    Stats            Stats                 `json:"stats"`
}

type Stats struct {
    TotalBooks      int64 `json:"totalBooks"`
    PublishedBooks  int64 `json:"publishedBooks"`
}
```

### 5.2 ç¼“å­˜æœåŠ¡

**æ–‡ä»¶ä½ç½®**: `service/bookstore/cache_service.go`

```go
package bookstore

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
    
    "Qingyu_backend/models/reading/bookstore"
)

type CacheService struct {
    client *redis.Client
}

func NewCacheService(client *redis.Client) *CacheService {
    return &CacheService{
        client: client,
    }
}

// GetBook ä»ç¼“å­˜è·å–ä¹¦ç±
func (s *CacheService) GetBook(bookID string) (*bookstore.Book, error) {
    key := fmt.Sprintf("book:detail:%s", bookID)
    
    data, err := s.client.Get(context.Background(), key).Result()
    if err == redis.Nil {
        return nil, nil // ç¼“å­˜æœªå‘½ä¸­
    }
    if err != nil {
        return nil, err
    }
    
    var book bookstore.Book
    if err := json.Unmarshal([]byte(data), &book); err != nil {
        return nil, err
    }
    
    return &book, nil
}

// SetBook è®¾ç½®ä¹¦ç±ç¼“å­˜
func (s *CacheService) SetBook(bookID string, book *bookstore.Book) error {
    key := fmt.Sprintf("book:detail:%s", bookID)
    
    data, err := json.Marshal(book)
    if err != nil {
        return err
    }
    
    // ç¼“å­˜1å¤©
    return s.client.Set(context.Background(), key, data, 24*time.Hour).Err()
}

// GetHotBooks è·å–çƒ­é—¨ä¹¦ç±ç¼“å­˜
func (s *CacheService) GetHotBooks() ([]*bookstore.Book, error) {
    key := "book:hot:list"
    
    data, err := s.client.Get(context.Background(), key).Result()
    if err == redis.Nil {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    var books []*bookstore.Book
    if err := json.Unmarshal([]byte(data), &books); err != nil {
        return nil, err
    }
    
    return books, nil
}

// SetHotBooks è®¾ç½®çƒ­é—¨ä¹¦ç±ç¼“å­˜
func (s *CacheService) SetHotBooks(books []*bookstore.Book) error {
    key := "book:hot:list"
    
    data, err := json.Marshal(books)
    if err != nil {
        return err
    }
    
    // ç¼“å­˜1å°æ—¶
    return s.client.Set(context.Background(), key, data, 1*time.Hour).Err()
}

// InvalidateBook ä½¿ä¹¦ç±ç¼“å­˜å¤±æ•ˆ
func (s *CacheService) InvalidateBook(bookID string) error {
    key := fmt.Sprintf("book:detail:%s", bookID)
    return s.client.Del(context.Background(), key).Err()
}
```

### 5.3 æ¦œå•è°ƒåº¦å™¨

**æ–‡ä»¶ä½ç½®**: `service/bookstore/ranking_scheduler.go`

```go
package bookstore

import (
    "context"
    "log"
    "time"
    
    "Qingyu_backend/models/reading/bookstore"
    bookstoreRepo "Qingyu_backend/repository/interfaces/bookstore"
)

type RankingScheduler struct {
    bookRepo    bookstoreRepo.BookRepository
    rankingRepo bookstoreRepo.RankingRepository
    cacheService *CacheService
    ticker      *time.Ticker
    stopChan    chan bool
}

func NewRankingScheduler(
    bookRepo bookstoreRepo.BookRepository,
    rankingRepo bookstoreRepo.RankingRepository,
    cacheService *CacheService,
) *RankingScheduler {
    return &RankingScheduler{
        bookRepo:     bookRepo,
        rankingRepo:  rankingRepo,
        cacheService: cacheService,
        stopChan:     make(chan bool),
    }
}

// Start å¯åŠ¨è°ƒåº¦å™¨
func (s *RankingScheduler) Start() {
    // æ¯å°æ—¶æ›´æ–°ä¸€æ¬¡æ¦œå•
    s.ticker = time.NewTicker(1 * time.Hour)
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    s.updateRankings()
    
    go func() {
        for {
            select {
            case <-s.ticker.C:
                s.updateRankings()
            case <-s.stopChan:
                return
            }
        }
    }()
    
    log.Println("æ¦œå•è°ƒåº¦å™¨å·²å¯åŠ¨")
}

// Stop åœæ­¢è°ƒåº¦å™¨
func (s *RankingScheduler) Stop() {
    s.ticker.Stop()
    s.stopChan <- true
    log.Println("æ¦œå•è°ƒåº¦å™¨å·²åœæ­¢")
}

// updateRankings æ›´æ–°æ‰€æœ‰æ¦œå•
func (s *RankingScheduler) updateRankings() {
    ctx := context.Background()
    
    log.Println("å¼€å§‹æ›´æ–°æ¦œå•...")
    
    // 1. æ›´æ–°å®æ—¶çƒ­åº¦æ¦œ
    if err := s.updateHotRanking(ctx); err != nil {
        log.Printf("æ›´æ–°çƒ­åº¦æ¦œå¤±è´¥: %v", err)
    }
    
    // 2. æ›´æ–°å‘¨æ¦œ
    if err := s.updateWeeklyRanking(ctx); err != nil {
        log.Printf("æ›´æ–°å‘¨æ¦œå¤±è´¥: %v", err)
    }
    
    // 3. æ›´æ–°æœˆæ¦œ
    if err := s.updateMonthlyRanking(ctx); err != nil {
        log.Printf("æ›´æ–°æœˆæ¦œå¤±è´¥: %v", err)
    }
    
    // 4. æ›´æ–°æ–°ä¹¦æ¦œ
    if err := s.updateNewReleaseRanking(ctx); err != nil {
        log.Printf("æ›´æ–°æ–°ä¹¦æ¦œå¤±è´¥: %v", err)
    }
    
    log.Println("æ¦œå•æ›´æ–°å®Œæˆ")
}

// updateHotRanking æ›´æ–°çƒ­åº¦æ¦œ
func (s *RankingScheduler) updateHotRanking(ctx context.Context) error {
    // è·å–çƒ­é—¨ä¹¦ç±ï¼ˆæŒ‰æµè§ˆé‡å’Œç‚¹èµæ•°æ’åºï¼‰
    books, err := s.bookRepo.GetHotBooks(ctx, 100)
    if err != nil {
        return err
    }
    
    // ä¿å­˜åˆ°æ¦œå•è¡¨
    ranking := &bookstore.Ranking{
        Type:      "hot",
        BookIDs:   extractBookIDs(books),
        UpdatedAt: time.Now(),
    }
    
    if err := s.rankingRepo.Update(ctx, ranking); err != nil {
        return err
    }
    
    // æ›´æ–°ç¼“å­˜
    return s.cacheService.SetHotBooks(books[:min(20, len(books))])
}

// extractBookIDs æå–ä¹¦ç±IDåˆ—è¡¨
func extractBookIDs(books []*bookstore.Book) []primitive.ObjectID {
    ids := make([]primitive.ObjectID, len(books))
    for i, book := range books {
        ids[i] = book.ID
    }
    return ids
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**(å¾…ç»­...æ–‡æ¡£å¤ªé•¿ï¼Œæˆ‘å°†åˆ†éƒ¨åˆ†åˆ›å»º)**

è®©æˆ‘ç»§ç»­åˆ›å»ºåç»­éƒ¨åˆ†ï¼š
