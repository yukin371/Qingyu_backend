# 阶段 2.2：结构化RAG实现 - 实施计划

**日期**: 2025-10-28  
**状态**: 🚧 进行中  
**预计时间**: Week 3（3-4小时）

---

## 🎯 目标

在阶段2.1向量化引擎的基础上，实现完整的RAG（Retrieval Augmented Generation）系统，包括检索、重排序、上下文组装和引用标注。

---

## 📋 核心任务

### 任务 1: RAGPipeline 核心类（60分钟）

#### 1.1 创建RAGPipeline
**文件**: `python_ai_service/src/rag/rag_pipeline.py`（新建）

**核心职责**:
- 端到端RAG流程编排
- 统一的检索接口
- 上下文组装
- 引用标注

**核心方法**:
```python
class RAGPipeline:
    def __init__(
        self,
        embedding_manager: EmbeddingManager,
        milvus_client: MilvusClient,
        reranker: Optional[Reranker] = None
    ):
        """初始化RAG Pipeline"""
        
    async def retrieve(
        self,
        query: str,
        top_k: int = 5,
        filters: Optional[Dict] = None
    ) -> List[RetrievalResult]:
        """检索相关文档"""
        
    async def retrieve_and_rerank(
        self,
        query: str,
        top_k: int = 5,
        rerank_top_k: int = 3
    ) -> List[RetrievalResult]:
        """检索并重排序"""
        
    async def build_context(
        self,
        results: List[RetrievalResult],
        max_tokens: int = 2000
    ) -> str:
        """构建RAG上下文"""
        
    async def retrieve_with_context(
        self,
        query: str,
        top_k: int = 5,
        max_tokens: int = 2000
    ) -> RAGContext:
        """完整RAG流程（检索+上下文）"""
```

#### 1.2 数据结构定义
**文件**: `python_ai_service/src/rag/schemas.py`（新建）

```python
@dataclass
class RetrievalResult:
    """检索结果"""
    id: str
    text: str
    score: float
    source: str
    document_id: str
    chunk_id: int
    metadata: Dict[str, Any]
    
@dataclass
class RAGContext:
    """RAG上下文"""
    query: str
    context: str
    sources: List[RetrievalResult]
    total_tokens: int
    metadata: Dict[str, Any]
```

---

### 任务 2: Reranker 重排序（45分钟）

#### 2.1 创建Reranker接口
**文件**: `python_ai_service/src/rag/reranker.py`（新建）

**实现策略**:
- **Cross-Encoder Reranker** - 使用交叉编码器模型
- **BM25 Reranker** - 基于关键词的重排序（可选）
- **Reciprocal Rank Fusion** - 融合多种排序结果

**核心方法**:
```python
class CrossEncoderReranker:
    def __init__(self, model_name: str = "BAAI/bge-reranker-large"):
        """初始化重排序模型"""
        
    async def rerank(
        self,
        query: str,
        documents: List[str],
        top_k: int = 5
    ) -> List[Tuple[int, float]]:
        """
        重排序文档
        
        Returns:
            [(doc_index, score), ...]
        """
        
    def get_scores(
        self,
        query: str,
        documents: List[str]
    ) -> List[float]:
        """获取相关性分数"""
```

#### 2.2 实现RRF融合
**文件**: `python_ai_service/src/rag/fusion.py`（新建）

```python
class ReciprocalRankFusion:
    """倒数排名融合（RRF）"""
    
    def fuse(
        self,
        rankings: List[List[Tuple[str, float]]],
        k: int = 60
    ) -> List[Tuple[str, float]]:
        """
        融合多个排序结果
        
        RRF Score = sum(1 / (k + rank_i))
        """
```

---

### 任务 3: 混合检索（40分钟）

#### 3.1 实现BM25检索
**文件**: `python_ai_service/src/rag/bm25_retriever.py`（新建）

```python
from rank_bm25 import BM25Okapi

class BM25Retriever:
    """BM25关键词检索"""
    
    def __init__(self):
        self.corpus: List[str] = []
        self.bm25: Optional[BM25Okapi] = None
        self.doc_ids: List[str] = []
        
    def index_documents(
        self,
        documents: List[Dict[str, Any]]
    ):
        """索引文档"""
        
    def search(
        self,
        query: str,
        top_k: int = 10
    ) -> List[Tuple[str, float]]:
        """BM25检索"""
```

#### 3.2 实现混合检索器
**文件**: `python_ai_service/src/rag/hybrid_retriever.py`（新建）

```python
class HybridRetriever:
    """混合检索器（向量 + BM25）"""
    
    def __init__(
        self,
        vector_retriever: MilvusClient,
        bm25_retriever: BM25Retriever,
        fusion_method: str = "rrf"  # rrf, weighted
    ):
        """初始化混合检索器"""
        
    async def search(
        self,
        query: str,
        top_k: int = 5,
        vector_weight: float = 0.7,
        bm25_weight: float = 0.3
    ) -> List[RetrievalResult]:
        """混合检索"""
```

---

### 任务 4: 上下文组装（30分钟）

#### 4.1 实现上下文构建器
**文件**: `python_ai_service/src/rag/context_builder.py`（新建）

**核心功能**:
- Token计数（使用tiktoken）
- 智能截断（保留完整句子）
- 上下文模板
- 引用标注

```python
class ContextBuilder:
    """上下文构建器"""
    
    def __init__(self, model: str = "gpt-3.5-turbo"):
        self.encoding = tiktoken.encoding_for_model(model)
        
    def count_tokens(self, text: str) -> int:
        """计算token数量"""
        
    def build_context(
        self,
        query: str,
        results: List[RetrievalResult],
        max_tokens: int = 2000,
        template: Optional[str] = None
    ) -> str:
        """构建上下文"""
        
    def add_citations(
        self,
        context: str,
        results: List[RetrievalResult]
    ) -> str:
        """添加引用标注"""
```

#### 4.2 上下文模板

**默认模板**:
```
基于以下参考资料回答问题：

[资料1] 来源：{source}
{text}

[资料2] 来源：{source}
{text}

...

问题：{query}

请基于上述资料回答，并在回答中标注引用来源（如[1]、[2]）。
```

---

### 任务 5: 引用标注（25分钟）

#### 5.1 实现Citation管理
**文件**: `python_ai_service/src/rag/citation.py`（新建）

```python
@dataclass
class Citation:
    """引用信息"""
    index: int
    source: str
    document_id: str
    chunk_id: int
    text_snippet: str
    
class CitationManager:
    """引用管理器"""
    
    def extract_citations(
        self,
        response: str
    ) -> List[int]:
        """从回复中提取引用标记 [1], [2]..."""
        
    def format_citations(
        self,
        results: List[RetrievalResult]
    ) -> str:
        """格式化引用列表"""
        
    def validate_citations(
        self,
        response: str,
        num_sources: int
    ) -> bool:
        """验证引用是否有效"""
```

---

### 任务 6: 配置管理（10分钟）

#### 6.1 更新配置
**文件**: `python_ai_service/src/core/config.py`

**新增配置项**:
```python
class Settings(BaseSettings):
    # RAG配置
    rag_top_k: int = 5
    rag_rerank_top_k: int = 3
    rag_max_context_tokens: int = 2000
    rag_use_reranker: bool = True
    rag_use_hybrid_search: bool = False
    
    # Reranker配置
    reranker_model: str = "BAAI/bge-reranker-large"
    reranker_batch_size: int = 32
    
    # 混合检索配置
    hybrid_vector_weight: float = 0.7
    hybrid_bm25_weight: float = 0.3
    hybrid_fusion_method: str = "rrf"  # rrf, weighted
```

---

### 任务 7: 测试与文档（40分钟）

#### 7.1 单元测试
**文件**: `python_ai_service/tests/test_rag_pipeline.py`（新建）

**测试用例**:
- 测试基础检索
- 测试重排序
- 测试上下文构建
- 测试引用标注
- 测试完整RAG流程

#### 7.2 集成测试
**文件**: `python_ai_service/tests/test_hybrid_retrieval.py`（新建）

**测试场景**:
- 向量检索vs BM25检索
- 混合检索准确性
- RRF融合效果

#### 7.3 性能测试
**测试指标**:
- 检索延迟（P50, P95, P99）
- 重排序延迟
- 端到端RAG延迟
- 内存占用

#### 7.4 中文文档
**文件**: `doc/implementation/00进度指导/阶段2.2_结构化RAG实现_实施报告.md`（新建）

**文档结构**:
```markdown
# 阶段 2.2：结构化RAG实现实施报告

## 实施概览
## RAGPipeline设计
## Reranker集成
## 混合检索
## 上下文组装
## 引用标注
## 使用指南
## 性能测试结果
## 后续规划
```

---

## 🗂️ 文件清单

### 新建文件（9个）
1. `python_ai_service/src/rag/rag_pipeline.py` - RAG Pipeline
2. `python_ai_service/src/rag/schemas.py` - 数据结构
3. `python_ai_service/src/rag/reranker.py` - 重排序器
4. `python_ai_service/src/rag/fusion.py` - 排序融合
5. `python_ai_service/src/rag/bm25_retriever.py` - BM25检索
6. `python_ai_service/src/rag/hybrid_retriever.py` - 混合检索
7. `python_ai_service/src/rag/context_builder.py` - 上下文构建
8. `python_ai_service/src/rag/citation.py` - 引用管理
9. `python_ai_service/tests/test_rag_pipeline.py` - RAG测试

### 更新文件（1个）
10. `python_ai_service/src/core/config.py` - 配置更新

### 文档文件（1个）
11. `doc/implementation/00进度指导/阶段2.2_结构化RAG实现_实施报告.md`

---

## ⏱️ 时间分配

| 任务 | 预计时间 | 优先级 |
|------|---------|-------|
| 1. RAGPipeline核心类 | 60分钟 | P0 |
| 2. Reranker重排序 | 45分钟 | P1 |
| 3. 混合检索 | 40分钟 | P1 |
| 4. 上下文组装 | 30分钟 | P0 |
| 5. 引用标注 | 25分钟 | P1 |
| 6. 配置管理 | 10分钟 | P0 |
| 7. 测试与文档 | 40分钟 | P0 |
| **总计** | **3.5小时** | |

---

## ✅ 验收标准

- [ ] RAGPipeline支持完整的检索流程
- [ ] Reranker正确提升检索准确率
- [ ] 混合检索结合向量和关键词
- [ ] 上下文构建符合token限制
- [ ] 引用标注格式正确
- [ ] 所有单元测试通过
- [ ] 检索准确率提升20%+（对比纯向量检索）
- [ ] P95延迟<500ms
- [ ] 中文文档完整清晰

---

## 🔧 技术要点

### RAG流程

```
用户查询
   ↓
1. 向量化查询
   ↓
2. 向量检索（top_k=10）
   ↓
3. [可选] BM25检索 + 融合
   ↓
4. [可选] Reranker重排序（top_k=5）
   ↓
5. 构建上下文（添加引用）
   ↓
6. 返回RAGContext
```

### Reranker原理

Cross-Encoder直接对(query, doc)对打分，比Bi-Encoder更准确：

```python
# Bi-Encoder (向量检索)
query_vec = encode(query)
doc_vec = encode(doc)
score = cosine(query_vec, doc_vec)

# Cross-Encoder (重排序)
score = cross_encode([query, doc])  # 更准确但更慢
```

### 混合检索

RRF（Reciprocal Rank Fusion）:

```python
RRF_score(d) = sum(1 / (k + rank_i(d)))

# 示例
# 向量检索: [doc1, doc3, doc2]  ranks=[1,2,3]
# BM25检索: [doc2, doc1, doc4]  ranks=[1,2,3]
# 
# RRF分数:
# doc1: 1/(60+1) + 1/(60+2) = 0.0328
# doc2: 1/(60+3) + 1/(60+1) = 0.0322
# doc3: 1/(60+2) + 0         = 0.0161
# doc4: 0       + 1/(60+3)   = 0.0159
#
# 最终排序: [doc1, doc2, doc3, doc4]
```

---

## 📊 预期成果

**代码量**: ~1500行
- RAGPipeline: ~300行
- Reranker: ~200行
- 混合检索: ~300行
- 上下文构建: ~200行
- 引用管理: ~150行
- 测试: ~350行

**性能提升**:
- 检索准确率：+20%（使用Reranker）
- 召回率：+15%（使用混合检索）
- 用户满意度：显著提升（有引用来源）

**功能完善度**:
- 检索策略：3种（向量、BM25、混合）
- 重排序：Cross-Encoder
- 上下文：智能截断、引用标注
- 融合方法：RRF

---

## 🚀 下一步

完成阶段2.2后，将进入：

**阶段 2.3：事件驱动索引更新**（Week 4）
- EventBus集成
- 监听文档变更事件
- 自动增量索引
- 索引版本控制

---

**创建日期**: 2025-10-28  
**预计完成**: 2025-10-28  
**维护者**: 青羽后端架构团队

