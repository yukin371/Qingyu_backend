# Phase 0~2 P0遗漏项补充实施计划

**启动日期**: 2025-10-29  
**优先级**: 🔴 P0（阻塞性）  
**目标**: 消除MVP阻塞项，系统立即可用  
**预计工期**: 7.5天（约1.5周）

---

## 📋 执行摘要

暂停Phase 3工作，优先处理5个MVP阻塞项。

### P0任务清单

| # | 任务 | 优先级 | 工期 | 状态 |
|---|------|--------|------|------|
| 1 | SessionService Bug修复 | 🔴 紧急 | 1天 | ⏳ 待开始 |
| 2 | 数据统计实际Repository查询 | 🔴 高 | 2天 | ⏳ 待开始 |
| 3 | MongoDB聚合查询实现 | 🔴 高 | 2天 | ⏳ 待开始 |
| 4 | 自动保存功能 | 🔴 中高 | 1.5天 | ⏳ 待开始 |
| 5 | 多端登录限制 | 🔴 中 | 1天 | ⏳ 待开始 |

**总工期**: 7.5天

---

## 一、任务优先级排序

### 优先级原则

1. **影响范围** - 影响用户数量
2. **阻塞程度** - 是否阻塞其他功能
3. **实现难度** - 预估实现复杂度
4. **依赖关系** - 是否被其他任务依赖

### 推荐执行顺序

```
Day 1: SessionService Bug修复（紧急，影响所有用户）
  ↓
Day 2-3: 数据统计实际查询 + MongoDB聚合（高优先级，可并行）
  ↓
Day 4-5: 自动保存功能（中高优先级）
  ↓
Day 6: 多端登录限制（中优先级）
  ↓
Day 7: 集成测试和修复
```

---

## 二、详细实施计划

### 任务1：SessionService Bug修复 🔴

**优先级**: 最高（影响所有用户登录体验）  
**预计工期**: 1天  
**状态**: ⏳ 待开始

#### 问题描述

当前SessionService存在已知Bug：
1. Session过期时间计算不准确
2. Session刷新逻辑有问题
3. 过期Session未及时清理
4. Session并发访问可能有竞争条件

#### 实施步骤

**Phase 1: 问题诊断（2小时）**
- [ ] 阅读现有SessionService代码
- [ ] 定位过期时间计算逻辑
- [ ] 分析刷新逻辑问题
- [ ] 检查清理机制

**Phase 2: Bug修复（4小时）**
- [ ] 修复过期时间计算Bug
  - 使用统一的时间处理（time.Now() + duration）
  - 确保时区处理正确
- [ ] 修复Session刷新逻辑
  - 实现滑动过期窗口
  - 更新Redis TTL
- [ ] 实现Session定时清理
  - 使用Redis的过期机制
  - 添加定时清理任务（兜底）
- [ ] Session并发访问保护
  - 使用Redis SETNX保证原子性
  - 添加分布式锁

**Phase 3: 测试（2小时）**
- [ ] 编写单元测试
  - 测试过期时间计算
  - 测试刷新逻辑
  - 测试清理机制
  - 测试并发场景
- [ ] 集成测试
  - 模拟真实登录场景
  - 验证Token过期和刷新
- [ ] 压力测试
  - 并发登录测试
  - Session大量创建和销毁

#### 关键文件

- `service/shared/auth/session_service.go` - Session服务主逻辑
- `test/service/shared/session_service_test.go` - 单元测试
- `test/integration/auth_integration_test.go` - 集成测试

#### 验收标准

- [ ] 所有已知Bug修复
- [ ] 单元测试100%通过
- [ ] 集成测试通过
- [ ] 无新增lint错误
- [ ] Session管理功能正常

---

### 任务2：数据统计实际Repository查询 🔴

**优先级**: 高（当前全是Mock数据）  
**预计工期**: 2天  
**状态**: ⏳ 待开始

#### 问题描述

当前所有统计API返回的都是Mock数据，需要实现实际的Repository查询。

涉及的统计API：
1. 平台用户统计
2. 平台内容统计
3. 用户活跃度统计
4. 收益统计
5. 作品统计
6. 阅读热力图

#### 实施步骤

**Phase 1: 设计查询方案（4小时）**
- [ ] 分析各统计API的数据需求
- [ ] 设计Repository查询方法
- [ ] 确定聚合策略（实时 vs 预聚合）
- [ ] 设计缓存策略

**Phase 2: 实现平台统计（6小时）**
- [ ] 实现平台用户统计查询
  - 总用户数
  - 新增用户数（按时间范围）
  - 活跃用户数（DAU/WAU/MAU）
  - 用户增长趋势
- [ ] 实现平台内容统计查询
  - 总作品数
  - 总章节数
  - 总字数
  - 新增内容数
- [ ] 实现用户活跃度统计
  - 活跃用户分布
  - 用户行为统计
  - 留存率计算

**Phase 3: 实现用户级统计（6小时）**
- [ ] 实现我的统计查询
  - 我的作品数
  - 总字数
  - 总阅读数
  - 总收藏数
- [ ] 实现作品统计查询
  - 作品详细数据
  - 章节统计
  - 阅读趋势
- [ ] 实现收益统计查询
  - 总收益
  - 收益趋势
  - 收益来源分析

**Phase 4: 测试和优化（4小时）**
- [ ] 编写单元测试
- [ ] 性能测试
- [ ] 添加查询索引（如需要）
- [ ] 替换所有Mock返回

#### 关键文件

- `service/shared/stats/platform_stats_service.go` - 平台统计服务
- `service/reading/stats/reading_stats_service.go` - 阅读统计服务
- `repository/mongodb/stats/` - 统计Repository（可能需要新建）
- `test/service/shared/stats_service_test.go` - 单元测试

#### 验收标准

- [ ] 所有Mock数据替换为实际查询
- [ ] 查询响应时间<2s（大部分<500ms）
- [ ] 单元测试通过
- [ ] 统计数据准确
- [ ] 无性能问题

---

### 任务3：MongoDB聚合查询实现 🔴

**优先级**: 高（支撑任务2）  
**预计工期**: 2天  
**状态**: ⏳ 待开始  
**依赖**: 可与任务2并行

#### 问题描述

需要实现MongoDB聚合查询来支持复杂的统计需求。

#### 实施步骤

**Phase 1: 聚合Pipeline设计（4小时）**
- [ ] 用户维度聚合
  - 按日期聚合用户注册数
  - 按活跃度聚合用户
  - 按VIP等级聚合
- [ ] 内容维度聚合
  - 按分类聚合作品
  - 按作者聚合作品
  - 按时间聚合内容
- [ ] 阅读维度聚合
  - 按作品聚合阅读数
  - 按章节聚合阅读数
  - 按时间聚合阅读行为

**Phase 2: Repository方法实现（8小时）**
- [ ] 实现用户聚合方法
  ```go
  func (r *MongoStatsRepository) AggregateUsersByDate(
      startDate, endDate time.Time
  ) ([]UserDailyStats, error)
  
  func (r *MongoStatsRepository) AggregateActiveUsers(
      period string
  ) (int64, error)
  ```

- [ ] 实现内容聚合方法
  ```go
  func (r *MongoStatsRepository) AggregateContentByCategory() 
      ([]CategoryStats, error)
  
  func (r *MongoStatsRepository) AggregateContentByAuthor(
      authorID string
  ) (*AuthorStats, error)
  ```

- [ ] 实现阅读聚合方法
  ```go
  func (r *MongoStatsRepository) AggregateReadingByBook(
      bookID string
  ) (*BookReadingStats, error)
  
  func (r *MongoStatsRepository) AggregateReadingHeatmap(
      bookID string, period string
  ) ([]HeatmapPoint, error)
  ```

**Phase 3: 性能优化（4小时）**
- [ ] 添加必要的索引
  - 用户表：created_at, last_active_at
  - 作品表：author_id, category_id, created_at
  - 阅读记录表：book_id, user_id, read_at
- [ ] 优化聚合Pipeline
  - 使用$match提前过滤
  - 合理使用$project减少数据量
  - 避免$lookup（尽量）
- [ ] 添加查询缓存
  - 使用Redis缓存热点统计
  - 设置合理的TTL（如5分钟）

**Phase 4: 测试（4小时）**
- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能测试
- [ ] 数据准确性验证

#### 关键文件

- `repository/interfaces/stats/stats_repository_interface.go` - 接口定义（新建）
- `repository/mongodb/stats/stats_repository_mongo.go` - MongoDB实现（新建）
- `repository/mongodb/factory.go` - 工厂方法更新
- `test/repository/stats_repository_test.go` - 单元测试

#### 验收标准

- [ ] 所有聚合方法实现完成
- [ ] 查询性能达标（<2s）
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 必要的索引已创建

---

### 任务4：自动保存功能 🔴

**优先级**: 中高（防止用户数据丢失）  
**预计工期**: 1.5天  
**状态**: ⏳ 待开始

#### 问题描述

当前缺少自动保存功能，用户在编辑文档时如果忘记保存会丢失数据。

#### 实施步骤

**Phase 1: 设计方案（2小时）**
- [ ] 设计自动保存触发机制
  - 定时触发（如每30秒）
  - 内容变化触发（防抖）
  - 失去焦点触发
- [ ] 设计版本管理
  - 自动保存版本与手动保存版本区分
  - 保留历史版本数量（如最近10个）
  - 版本清理策略
- [ ] 设计恢复机制
  - 自动恢复未保存内容
  - 版本对比和选择
  - 冲突处理

**Phase 2: 后端实现（6小时）**
- [ ] 创建AutoSaveService
  ```go
  type AutoSaveService struct {
      documentRepo interfaces.DocumentRepository
      versionRepo  interfaces.VersionRepository
      redis        *redis.Client
  }
  
  func (s *AutoSaveService) AutoSave(
      ctx context.Context, 
      userID, documentID string, 
      content string
  ) error
  
  func (s *AutoSaveService) GetLatestAutoSave(
      ctx context.Context,
      userID, documentID string
  ) (*models.AutoSaveVersion, error)
  
  func (s *AutoSaveService) ListVersions(
      ctx context.Context,
      documentID string,
      limit int
  ) ([]models.Version, error)
  ```

- [ ] 实现内容变化检测
  - 计算内容Hash
  - 对比上次保存的Hash
  - 只有变化时才保存

- [ ] 实现版本管理
  - 保存到独立的auto_save_versions集合
  - 标记版本类型（auto vs manual）
  - 保留最近N个版本
  - 定时清理旧版本

**Phase 3: API实现（4小时）**
- [ ] 自动保存API
  ```
  POST /api/v1/documents/:id/autosave
  Body: { "content": "...", "hash": "..." }
  ```

- [ ] 获取最新自动保存
  ```
  GET /api/v1/documents/:id/autosave/latest
  ```

- [ ] 版本列表API
  ```
  GET /api/v1/documents/:id/versions
  ```

- [ ] 恢复版本API
  ```
  POST /api/v1/documents/:id/restore/:versionId
  ```

**Phase 4: 测试（2小时）**
- [ ] 单元测试（4个TDD测试用例）
  - 测试定时触发
  - 测试变化检测
  - 测试版本管理
  - 测试恢复机制
- [ ] 集成测试
- [ ] 性能测试

#### 关键文件

- `service/document/autosave_service.go` - 自动保存服务（新建）
- `models/writer/autosave_version.go` - 自动保存版本模型（新建）
- `api/v1/writer/autosave_api.go` - 自动保存API（新建）
- `test/service/document/autosave_service_test.go` - 单元测试

#### 验收标准

- [ ] 自动保存功能完整实现
- [ ] 版本管理正常
- [ ] 恢复功能正常
- [ ] TDD测试4个用例全部通过
- [ ] 性能影响<100ms

---

### 任务5：多端登录限制 🔴

**优先级**: 中（安全性增强）  
**预计工期**: 1天  
**状态**: ⏳ 待开始

#### 问题描述

当前没有多端登录限制，用户可以无限制地在多个设备登录，存在安全隐患。

#### 实施步骤

**Phase 1: 设计方案（2小时）**
- [ ] 设计设备管理机制
  - 设备标识（deviceID）
  - 设备信息（操作系统、浏览器、IP等）
  - 登录时间和最后活跃时间
- [ ] 设计限制策略
  - 最大登录设备数（如5个）
  - 超额时的处理（踢出最早登录）
  - VIP用户额外设备数
- [ ] 设计数据存储
  - Redis存储在线设备
  - MongoDB存储设备历史

**Phase 2: 后端实现（4小时）**
- [ ] 扩展SessionService
  ```go
  func (s *SessionService) LoginWithDevice(
      ctx context.Context,
      userID string,
      device *models.DeviceInfo
  ) (*models.Session, error)
  
  func (s *SessionService) GetUserDevices(
      ctx context.Context,
      userID string
  ) ([]models.DeviceSession, error)
  
  func (s *SessionService) KickoutDevice(
      ctx context.Context,
      userID, deviceID string
  ) error
  
  func (s *SessionService) CheckDeviceLimit(
      ctx context.Context,
      userID string
  ) error
  ```

- [ ] 实现设备管理
  - 登录时记录设备信息
  - 检查设备数量限制
  - 超额时踢出最早设备
  - 更新设备活跃时间

- [ ] 实现设备存储
  - Redis: `user_devices:{userID}` -> Set of deviceID
  - Redis: `device_session:{deviceID}` -> Session info
  - MongoDB: devices集合存储历史

**Phase 3: API实现（2小时）**
- [ ] 修改登录API（添加设备信息）
  ```
  POST /api/v1/user/login
  Body: { 
    "username": "...", 
    "password": "...",
    "device": {
      "deviceId": "...",
      "platform": "...",
      "browser": "...",
      "os": "..."
    }
  }
  ```

- [ ] 设备列表API
  ```
  GET /api/v1/user/devices
  ```

- [ ] 踢出设备API
  ```
  DELETE /api/v1/user/devices/:deviceId
  ```

**Phase 4: 测试（2小时）**
- [ ] 单元测试（2个TDD测试用例）
  - 测试设备限制
  - 测试超额踢出
- [ ] 集成测试
  - 模拟多设备登录
  - 验证踢出机制

#### 关键文件

- `service/shared/auth/session_service.go` - Session服务扩展
- `models/shared/auth/device.go` - 设备模型（新建）
- `api/v1/user/device_api.go` - 设备管理API（新建）
- `test/service/shared/session_device_test.go` - 单元测试

#### 验收标准

- [ ] 多端登录限制功能完整
- [ ] 设备管理正常
- [ ] 踢出机制正常
- [ ] TDD测试2个用例全部通过
- [ ] 不影响正常登录流程

---

## 三、实施时间表

### Week 1: Day 1-3（重点周）

**Day 1 (2025-10-29)**:
- [ ] 上午: SessionService Bug修复（问题诊断 + 部分修复）
- [ ] 下午: SessionService Bug修复完成 + 测试
- [ ] 晚上: Review代码，确保质量

**Day 2 (2025-10-30)**:
- [ ] 上午: 数据统计查询方案设计 + 开始实现平台统计
- [ ] 下午: 完成平台统计实现
- [ ] 晚上: 开始用户级统计

**Day 3 (2025-10-31)**:
- [ ] 上午: 完成用户级统计 + 测试
- [ ] 下午: MongoDB聚合Pipeline设计 + 开始实现
- [ ] 晚上: 继续聚合方法实现

---

### Week 2: Day 4-7（完成周）

**Day 4 (2025-11-01)**:
- [ ] 上午: 完成MongoDB聚合实现 + 性能优化
- [ ] 下午: 聚合查询测试 + 数据验证
- [ ] 晚上: 自动保存方案设计

**Day 5 (2025-11-02)**:
- [ ] 上午: 自动保存后端实现
- [ ] 下午: 自动保存API实现
- [ ] 晚上: 自动保存测试

**Day 6 (2025-11-03)**:
- [ ] 上午: 多端登录限制方案设计 + 开始实现
- [ ] 下午: 完成多端登录实现 + API
- [ ] 晚上: 多端登录测试

**Day 7 (2025-11-04)**:
- [ ] 上午: 集成测试（所有P0功能）
- [ ] 下午: Bug修复 + 性能优化
- [ ] 晚上: 文档更新 + 代码Review

---

## 四、风险管理

### 风险识别

| 风险 | 概率 | 影响 | 应对措施 |
|-----|------|------|---------|
| SessionService改动影响现有功能 | 中 | 高 | 充分测试，保留回滚方案 |
| MongoDB聚合性能不达标 | 中 | 中 | 添加索引，使用缓存 |
| 自动保存频繁导致性能问题 | 低 | 中 | 防抖处理，异步保存 |
| 多端登录改动影响登录流程 | 低 | 高 | 向后兼容，渐进式rollout |
| 时间估算偏差 | 中 | 中 | 每日Review进度，及时调整 |

### 应急预案

1. **如果SessionService修复遇到困难**
   - 快速回滚，保持现状
   - 改为修复最严重的Bug（过期时间）
   - 其他Bug延后处理

2. **如果聚合查询性能不佳**
   - 先实现功能，标记性能TODO
   - 后续专门优化（添加索引、缓存等）
   - 考虑使用预聚合表

3. **如果时间不足**
   - 优先完成任务1、2、3（最高优先级）
   - 任务4、5可以延后1-2天

---

## 五、质量保证

### 代码质量标准

- [ ] 符合Go编码规范
- [ ] 0编译错误
- [ ] 0 Lint错误
- [ ] 单元测试覆盖率>70%
- [ ] 所有测试通过
- [ ] 代码Review通过

### 测试标准

- [ ] 单元测试：每个功能都有测试
- [ ] 集成测试：关键流程端到端测试
- [ ] 性能测试：响应时间<2s
- [ ] 安全测试：无安全漏洞
- [ ] 兼容性测试：不影响现有功能

### 文档标准

- [ ] 代码注释完整
- [ ] API文档更新
- [ ] 实施报告完整
- [ ] 变更日志更新

---

## 六、验收标准

### 功能验收

- [ ] SessionService Bug全部修复
- [ ] 数据统计返回实际数据（非Mock）
- [ ] MongoDB聚合查询性能达标
- [ ] 自动保存功能完整可用
- [ ] 多端登录限制正常工作

### 性能验收

- [ ] Session操作响应时间<100ms
- [ ] 统计查询响应时间<2s（大部分<500ms）
- [ ] 自动保存不影响编辑体验（<100ms）
- [ ] 登录流程不变慢（<500ms）

### 质量验收

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 0编译错误
- [ ] 0 Lint错误
- [ ] 代码Review通过

---

## 七、交付物清单

### 代码交付

1. **SessionService Bug修复**
   - `service/shared/auth/session_service.go`（修改）
   - `test/service/shared/session_service_test.go`（新增/修改）

2. **数据统计实际查询**
   - `service/shared/stats/platform_stats_service.go`（修改）
   - `service/reading/stats/reading_stats_service.go`（修改）
   - `test/service/shared/stats_service_test.go`（修改）

3. **MongoDB聚合查询**
   - `repository/interfaces/stats/stats_repository_interface.go`（新建）
   - `repository/mongodb/stats/stats_repository_mongo.go`（新建）
   - `test/repository/stats_repository_test.go`（新建）

4. **自动保存功能**
   - `service/document/autosave_service.go`（新建）
   - `models/writer/autosave_version.go`（新建）
   - `api/v1/writer/autosave_api.go`（新建）
   - `test/service/document/autosave_service_test.go`（新建）

5. **多端登录限制**
   - `service/shared/auth/session_service.go`（修改）
   - `models/shared/auth/device.go`（新建）
   - `api/v1/user/device_api.go`（新建）
   - `test/service/shared/session_device_test.go`（新建）

### 文档交付

- [ ] P0补充实施报告
- [ ] API文档更新
- [ ] 变更日志
- [ ] 测试报告

---

## 八、后续计划

### P0完成后

1. **短期（1-2天）**
   - 监控P0功能运行情况
   - 修复发现的Bug
   - 性能优化

2. **中期（Phase 3.5，1周）**
   - 补充P1基础设施（4项）
   - 补充P1高级功能核心（2项）

3. **长期（Phase 4，3-4天）**
   - RAG性能优化
   - 文件存储高级功能
   - 完整测试覆盖

---

**计划制定时间**: 2025-10-29  
**计划制定人**: AI Assistant  
**审核状态**: 待用户确认

**下一步**: 开始执行任务1（SessionService Bug修复）

---

## ✅ 准备就绪检查清单

- [x] P0任务清单明确
- [x] 实施计划详细
- [x] 时间表合理
- [x] 风险识别完整
- [x] 验收标准清晰
- [ ] 用户确认开始执行

**状态**: ✅ 准备就绪，等待开始执行

