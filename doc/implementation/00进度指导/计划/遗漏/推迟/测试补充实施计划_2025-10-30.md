# 测试补充实施计划

**日期**: 2025-10-30 凌晨  
**状态**: 🔄 开始实施  
**预计工期**: 1天（8小时）

---

## 📊 测试补充总览

### 待补充测试清单

| 类别 | 测试内容 | 文件数 | 预计时间 |
|------|---------|--------|---------|
| **单元测试** | DocumentService测试更新 | 3个 | 2h |
| **单元测试** | SessionService新功能测试 | 2个 | 2h |
| **单元测试** | StatsService测试 | 1个 | 1h |
| **集成测试** | P0任务集成测试 | 4个 | 3h |
| **总计** | - | **10个** | **8h** |

---

## 📋 详细实施计划

### Phase 1: DocumentService测试更新（2小时）

#### 待更新文件

1. **test/service/document/document_service_test.go**
   - 添加MockDocumentContentRepository
   - 更新NewDocumentService调用
   - 测试AutoSaveDocument
   - 测试GetDocumentContent
   - 测试UpdateDocumentContent

2. **test/repository/writing/document_content_repository_test.go**
   - 验证现有测试是否完整
   - 补充版本控制测试

3. **test/api/document_api_test.go**
   - 更新API测试（如果需要）

#### 实施步骤

**Step 1: 创建MockDocumentContentRepository** (30分钟)
```go
// 在test/service/document/document_service_test.go中添加

type MockDocumentContentRepository struct {
    contents map[string]*models.DocumentContent
    mu       sync.RWMutex
}

func NewMockDocumentContentRepository() *MockDocumentContentRepository {
    return &MockDocumentContentRepository{
        contents: make(map[string]*models.DocumentContent),
    }
}

func (m *MockDocumentContentRepository) Create(ctx context.Context, content *models.DocumentContent) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    content.Version = 1
    m.contents[content.DocumentID] = content
    return nil
}

func (m *MockDocumentContentRepository) GetByDocumentID(ctx context.Context, docID string) (*models.DocumentContent, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    content, ok := m.contents[docID]
    if !ok {
        return nil, fmt.Errorf("content not found")
    }
    return content, nil
}

func (m *MockDocumentContentRepository) Update(ctx context.Context, content *models.DocumentContent) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    existing, ok := m.contents[content.DocumentID]
    if !ok {
        return fmt.Errorf("content not found")
    }
    if content.Version != existing.Version {
        return fmt.Errorf("version conflict")
    }
    content.Version++
    m.contents[content.DocumentID] = content
    return nil
}
```

**Step 2: 更新测试Setup** (15分钟)
```go
func setupDocumentServiceTest() (*documentService.DocumentService, *MockDocumentRepository, *MockDocumentContentRepository) {
    mockDocRepo := NewMockDocumentRepository()
    mockContentRepo := NewMockDocumentContentRepository()
    service := documentService.NewDocumentService(mockDocRepo, mockContentRepo)
    return service, mockDocRepo, mockContentRepo
}
```

**Step 3: 添加AutoSaveDocument测试** (30分钟)
```go
func TestAutoSaveDocument(t *testing.T) {
    service, _, mockContentRepo := setupDocumentServiceTest()
    
    // Test Case 1: 首次保存（Create）
    t.Run("FirstSave_Create", func(t *testing.T) {
        err := service.AutoSaveDocument(ctx, "doc1", "user1", "content1")
        assert.NoError(t, err)
        
        // 验证内容已保存
        content, err := mockContentRepo.GetByDocumentID(ctx, "doc1")
        assert.NoError(t, err)
        assert.Equal(t, "content1", content.Content)
        assert.Equal(t, int64(1), content.Version)
    })
    
    // Test Case 2: 再次保存（Update）
    t.Run("SecondSave_Update", func(t *testing.T) {
        err := service.AutoSaveDocument(ctx, "doc1", "user1", "content2")
        assert.NoError(t, err)
        
        content, err := mockContentRepo.GetByDocumentID(ctx, "doc1")
        assert.NoError(t, err)
        assert.Equal(t, "content2", content.Content)
        assert.Equal(t, int64(2), content.Version)
    })
    
    // Test Case 3: 空内容保存
    t.Run("EmptyContent", func(t *testing.T) {
        err := service.AutoSaveDocument(ctx, "doc2", "user1", "")
        assert.NoError(t, err)
    })
}
```

**Step 4: 添加版本冲突测试** (30分钟)
```go
func TestUpdateDocumentContent_VersionConflict(t *testing.T) {
    service, _, mockContentRepo := setupDocumentServiceTest()
    
    // 1. 创建初始内容
    err := service.AutoSaveDocument(ctx, "doc1", "user1", "v1")
    assert.NoError(t, err)
    
    // 2. 模拟版本1成功
    content, _ := mockContentRepo.GetByDocumentID(ctx, "doc1")
    assert.Equal(t, int64(1), content.Version)
    
    // 3. 并发更新模拟
    err = service.UpdateDocumentContent(ctx, "doc1", "user1", "v2", 1)
    assert.NoError(t, err)  // 版本匹配，成功
    
    // 4. 使用旧版本号更新（冲突）
    err = service.UpdateDocumentContent(ctx, "doc1", "user1", "v3", 1)
    assert.Error(t, err)  // 版本冲突
    assert.Contains(t, err.Error(), "version conflict")
}
```

**Step 5: 运行测试验证** (15分钟)
```bash
go test ./test/service/document/... -v
```

---

### Phase 2: SessionService新功能测试（2小时）

#### 新增测试文件

**test/service/shared/auth/session_service_enhanced_test.go**

#### 测试内容

**1. 定时清理测试** (45分钟)
```go
func TestSessionCleanupTask(t *testing.T) {
    // Test Case 1: 清理任务启动
    t.Run("CleanupTaskStart", func(t *testing.T) {
        cacheClient := NewMockCacheClient()
        service := auth.NewSessionService(cacheClient)
        
        // 验证定时器已启动
        assert.NotNil(t, service.cleanupTicker)
    })
    
    // Test Case 2: 优雅关闭
    t.Run("GracefulShutdown", func(t *testing.T) {
        cacheClient := NewMockCacheClient()
        service := auth.NewSessionService(cacheClient)
        
        err := service.StopCleanupTask()
        assert.NoError(t, err)
    })
}
```

**2. EnforceDeviceLimit测试** (45分钟)
```go
func TestEnforceDeviceLimit(t *testing.T) {
    cacheClient := NewMockCacheClient()
    service := auth.NewSessionService(cacheClient)
    
    // Test Case 1: 未超限
    t.Run("BelowLimit", func(t *testing.T) {
        // 创建3个会话
        for i := 0; i < 3; i++ {
            service.CreateSession(ctx, "user1")
        }
        
        // 限制5台，不应踢出
        err := service.EnforceDeviceLimit(ctx, "user1", 5)
        assert.NoError(t, err)
        
        sessions, _ := service.GetUserSessions(ctx, "user1")
        assert.Equal(t, 3, len(sessions))
    })
    
    // Test Case 2: 超限踢出（FIFO）
    t.Run("ExceedLimit_KickOldest", func(t *testing.T) {
        // 创建6个会话
        sessionIDs := make([]string, 6)
        for i := 0; i < 6; i++ {
            session, _ := service.CreateSession(ctx, "user2")
            sessionIDs[i] = session.ID
            time.Sleep(10 * time.Millisecond)  // 确保时间差异
        }
        
        // 限制5台，应踢出最老的1台
        err := service.EnforceDeviceLimit(ctx, "user2", 5)
        assert.NoError(t, err)
        
        // 验证：最老的会话应被踢出
        _, err = service.GetSession(ctx, sessionIDs[0])
        assert.Error(t, err)  // 第一个应被踢出
        
        // 其他会话应存在
        for i := 1; i < 6; i++ {
            _, err = service.GetSession(ctx, sessionIDs[i])
            assert.NoError(t, err)
        }
    })
    
    // Test Case 3: 超限多台
    t.Run("ExceedLimit_KickMultiple", func(t *testing.T) {
        // 创建8个会话
        sessionIDs := make([]string, 8)
        for i := 0; i < 8; i++ {
            session, _ := service.CreateSession(ctx, "user3")
            sessionIDs[i] = session.ID
            time.Sleep(10 * time.Millisecond)
        }
        
        // 限制5台，应踢出最老的3台（8-5=3）
        err := service.EnforceDeviceLimit(ctx, "user3", 5)
        assert.NoError(t, err)
        
        // 验证前3台被踢出
        for i := 0; i < 3; i++ {
            _, err = service.GetSession(ctx, sessionIDs[i])
            assert.Error(t, err)
        }
        
        // 后5台仍存在
        for i := 3; i < 8; i++ {
            _, err = service.GetSession(ctx, sessionIDs[i])
            assert.NoError(t, err)
        }
    })
}
```

**3. 分布式锁测试** (30分钟)
```go
func TestUserSessionLock(t *testing.T) {
    cacheClient := NewMockCacheClient()
    service := auth.NewSessionService(cacheClient)
    
    t.Run("ConcurrentSessionCreation", func(t *testing.T) {
        // 模拟并发创建会话
        var wg sync.WaitGroup
        for i := 0; i < 10; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                service.CreateSession(ctx, "user1")
            }()
        }
        wg.Wait()
        
        // 验证会话列表一致性
        sessions, err := service.GetUserSessions(ctx, "user1")
        assert.NoError(t, err)
        assert.Equal(t, 10, len(sessions))
    })
}
```

---

### Phase 3: StatsService测试（1小时）

#### 新增测试文件

**test/service/shared/stats/stats_service_test.go**

#### 测试内容

```go
func TestGetUserStats(t *testing.T) {
    // Setup
    mockUserRepo := NewMockUserRepository()
    mockBookRepo := NewMockBookRepository()
    mockProjectRepo := NewMockProjectRepository()
    mockChapterRepo := NewMockChapterRepository()
    
    service := stats.NewPlatformStatsService(
        mockUserRepo,
        mockBookRepo,
        mockProjectRepo,
        mockChapterRepo,
    )
    
    // Test Case 1: 正常查询
    t.Run("NormalQuery", func(t *testing.T) {
        // 准备测试数据
        mockUserRepo.users["user1"] = &models.User{
            ID: "user1",
            Username: "testuser",
            Role: "writer",
            CreatedAt: time.Now().Add(-30 * 24 * time.Hour),
        }
        mockProjectRepo.SetProjectCount("user1", 5)
        
        // 执行查询
        stats, err := service.GetUserStats(ctx, "user1")
        assert.NoError(t, err)
        assert.Equal(t, "testuser", stats.Username)
        assert.Equal(t, int64(5), stats.TotalProjects)
    })
    
    // Test Case 2: 用户不存在
    t.Run("UserNotFound", func(t *testing.T) {
        _, err := service.GetUserStats(ctx, "nonexistent")
        assert.Error(t, err)
    })
}

func TestGetContentStats(t *testing.T) {
    // 类似GetUserStats的测试结构
}
```

---

### Phase 4: 集成测试（3小时）

#### 新增测试文件

**test/integration/p0_tasks_integration_test.go**

#### 测试场景

**1. SessionService集成测试** (1小时)
```go
func TestSessionServiceIntegration(t *testing.T) {
    // 需要真实Redis连接
    if testing.Short() {
        t.Skip("Skipping integration test")
    }
    
    // 1. 创建真实SessionService
    // 2. 测试完整会话生命周期
    // 3. 测试多端登录和踢出
    // 4. 测试定时清理（模拟时间流逝）
}
```

**2. DocumentService集成测试** (1小时)
```go
func TestDocumentAutoSaveIntegration(t *testing.T) {
    // 需要真实MongoDB连接
    if testing.Short() {
        t.Skip("Skipping integration test")
    }
    
    // 1. 测试完整自动保存流程
    // 2. 测试版本冲突场景
    // 3. 测试并发保存
}
```

**3. StatsService集成测试** (1小时)
```go
func TestStatsServiceIntegration(t *testing.T) {
    // 需要真实MongoDB连接
    if testing.Short() {
        t.Skip("Skipping integration test")
    }
    
    // 1. 准备测试数据（用户、项目、书籍）
    // 2. 测试实际Repository查询
    // 3. 验证统计准确性
}
```

---

## ⏱️ 时间分配

| Phase | 任务 | 预计时间 | 说明 |
|-------|------|---------|------|
| Phase 1 | DocumentService测试更新 | 2h | Mock+单元测试 |
| Phase 2 | SessionService新功能测试 | 2h | 定时清理+FIFO |
| Phase 3 | StatsService测试 | 1h | Repository查询 |
| Phase 4 | 集成测试 | 3h | 真实环境测试 |
| **总计** | - | **8h** | **1天** |

---

## ✅ 验收标准

### 代码质量
- [ ] 所有测试文件0 lint错误
- [ ] 所有测试文件0编译错误
- [ ] 测试命名规范清晰

### 测试覆盖
- [ ] DocumentService核心方法测试覆盖
- [ ] SessionService新功能测试覆盖
- [ ] StatsService查询测试覆盖
- [ ] P0任务集成测试覆盖

### 测试通过率
- [ ] 单元测试100%通过
- [ ] 集成测试100%通过（需要环境）
- [ ] Mock测试逻辑正确

---

## 🚀 实施顺序

### 第1步: DocumentService测试（2小时）
- 创建MockDocumentContentRepository
- 更新测试Setup
- 添加AutoSaveDocument测试
- 添加版本冲突测试
- 运行测试验证

### 第2步: SessionService测试（2小时）
- 创建session_service_enhanced_test.go
- 测试定时清理任务
- 测试EnforceDeviceLimit（FIFO）
- 测试分布式锁
- 运行测试验证

### 第3步: StatsService测试（1小时）
- 创建stats_service_test.go
- 创建Mock Repositories
- 测试GetUserStats
- 测试GetContentStats
- 运行测试验证

### 第4步: 集成测试（3小时）
- 创建p0_tasks_integration_test.go
- SessionService集成测试
- DocumentService集成测试
- StatsService集成测试
- 运行集成测试（需环境）

---

## 📝 测试文件清单

### 新增文件（7个）

1. **test/service/shared/auth/session_service_enhanced_test.go**
   - 定时清理测试
   - EnforceDeviceLimit测试
   - 分布式锁测试

2. **test/service/shared/stats/stats_service_test.go**
   - GetUserStats测试
   - GetContentStats测试
   - Mock Repository

3. **test/integration/p0_tasks_integration_test.go**
   - SessionService集成测试
   - DocumentService集成测试
   - StatsService集成测试

### 修改文件（3个）

4. **test/service/document/document_service_test.go**
   - 添加MockDocumentContentRepository
   - 更新Setup
   - 添加AutoSave测试

5. **test/repository/writing/document_content_repository_test.go**
   - 验证现有测试
   - 补充版本控制测试

6. **test/api/document_api_test.go**
   - 更新API测试（如需）

---

## 💡 实施要点

### Mock设计原则

1. **简单Mock优先**
   - 使用map存储数据
   - 使用sync.RWMutex保证并发安全
   - 实现接口最小方法集

2. **模拟真实行为**
   - 版本控制逻辑
   - 并发冲突检测
   - 错误场景模拟

### 测试用例设计

1. **正常场景**
   - Happy Path测试
   - 边界值测试

2. **异常场景**
   - 错误处理测试
   - 冲突场景测试
   - 并发安全测试

3. **性能场景**（可选）
   - 大数据量测试
   - 并发压力测试

---

## 📊 预期成果

### 代码贡献
- 新增测试代码: ~1500行
- 修改测试代码: ~300行
- 总计: ~1800行

### 测试覆盖
- DocumentService: 85%+
- SessionService: 80%+
- StatsService: 75%+
- 总体: 80%+

### 质量指标
- 0 lint错误
- 0编译错误
- 100%测试通过率

---

**计划创建时间**: 2025-10-30 凌晨  
**计划执行人**: AI Assistant  
**预计开始**: 立即开始  
**预计完成**: 2025-10-30 晚

**下一步**: 开始Phase 1 - DocumentService测试更新

