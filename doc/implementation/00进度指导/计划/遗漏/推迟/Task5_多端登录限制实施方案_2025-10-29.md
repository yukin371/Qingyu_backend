# Task 5: 多端登录限制实施方案

**日期**: 2025-10-29 深夜  
**状态**: 🔄 进行中  
**预计工期**: 1天（压缩到3小时）

---

## 📊 现状分析

### 已有基础

✅ **SessionService基础功能**（完整）:
- `CreateSession()` - 创建会话
- `GetSession()` - 获取会话
- `DestroySession()` - 销毁会话
- `GetUserSessions()` - 获取用户所有会话
- `addSessionToUserList()` - 添加会话到用户列表（带并发控制）
- `removeSessionFromUserList()` - 从用户列表移除会话（带并发控制）

✅ **已有设备限制检查**（287-306行）:
- `CheckDeviceLimit()` - 检查设备数量
- 当前策略：超过限制直接拒绝登录 ❌
- 缺少：自动踢出最老设备的逻辑

✅ **分布式并发控制**（已在Task 1完成）:
- `withUserSessionLock()` - 分布式锁保护
- 保证多端并发登录安全

### 待实现的功能

❌ **自动踢出最老设备**:
- 当设备数超限时，踢出最老的会话
- 使用FIFO（First In First Out）策略

❌ **设备管理API**:
- 查看设备列表
- 手动踢出指定设备
- 设备信息（登录时间、IP等）

❌ **可配置的设备限制**:
- 不同用户等级不同限制
- VIP用户更多设备
- 普通用户默认限制

---

## 🎯 实施策略

采用**MVP优先**策略：

**Phase 1（核心）**: 自动踢出最老设备（2小时）
- 修改`CheckDeviceLimit`为`EnforceDeviceLimit`
- 实现FIFO踢出逻辑
- 在`CreateSession`调用时自动执行

**Phase 2（可选）**: 设备管理API（延后到Phase 4）
- 设备列表API
- 手动踢出API
- 设备信息增强

**Phase 3（可选）**: 高级功能（延后到Phase 5）
- 不同等级不同限制
- 设备信任机制
- 异常登录检测

---

## 📋 详细实施步骤

### Step 1: 修改CheckDeviceLimit为EnforceDeviceLimit（1小时）

**当前问题**（287-306行）:
```go
func (s *SessionServiceImpl) CheckDeviceLimit(ctx context.Context, userID string, maxDevices int) error {
    sessions, err := s.GetUserSessions(ctx, userID)
    if len(sessions) >= maxDevices {
        return fmt.Errorf("登录设备数量已达上限...") // 直接拒绝 ❌
    }
    return nil
}
```

**修改为**:
```go
// EnforceDeviceLimit 强制执行设备数量限制（FIFO策略）
// 如果设备数超限，自动踢出最老的设备，允许新设备登录
func (s *SessionServiceImpl) EnforceDeviceLimit(ctx context.Context, userID string, maxDevices int) error {
    if maxDevices <= 0 {
        maxDevices = 5 // 默认最多5台设备
    }

    // 1. 获取当前用户的所有活跃会话
    sessions, err := s.GetUserSessions(ctx, userID)
    if err != nil {
        // 查询失败时采用宽松策略，允许登录
        zap.L().Warn("获取用户会话失败，跳过设备限制检查",
            zap.String("user_id", userID),
            zap.Error(err),
        )
        return nil
    }

    // 2. 如果未超限，直接返回
    if len(sessions) < maxDevices {
        return nil
    }

    // 3. 超限时，计算需要踢出的设备数量
    numToKick := len(sessions) - maxDevices + 1 // +1 为新设备留位置

    // 4. 按创建时间排序（最老的在前）
    sort.Slice(sessions, func(i, j int) bool {
        return sessions[i].CreatedAt.Before(sessions[j].CreatedAt)
    })

    // 5. 踢出最老的N个设备
    for i := 0; i < numToKick && i < len(sessions); i++ {
        oldSession := sessions[i]
        if err := s.DestroySession(ctx, oldSession.ID); err != nil {
            zap.L().Warn("踢出旧设备失败",
                zap.String("session_id", oldSession.ID),
                zap.Error(err),
            )
            // 继续尝试踢出其他设备
            continue
        }

        zap.L().Info("自动踢出旧设备",
            zap.String("user_id", userID),
            zap.String("session_id", oldSession.ID),
            zap.Time("created_at", oldSession.CreatedAt),
        )
    }

    return nil
}
```

**关键改进**:
- ✅ 自动踢出最老设备（FIFO策略）
- ✅ 踢出失败时继续尝试其他设备（容错）
- ✅ 详细日志记录
- ✅ 允许新设备登录

---

### Step 2: 更新AuthService调用（15分钟）

**修改文件**: `service/shared/auth/auth_service.go`

**当前调用**（133行）:
```go
// 2.5. MVP: 检查多端登录限制（最多5台设备）
if err := s.sessionService.CheckDeviceLimit(ctx, loginResp.User.ID, 5); err != nil {
    return nil, fmt.Errorf("登录失败: %w", err)
}
```

**修改为**:
```go
// 2.5. MVP: 强制执行多端登录限制（最多5台设备，超限踢出最老设备）
if err := s.sessionService.EnforceDeviceLimit(ctx, loginResp.User.ID, 5); err != nil {
    // 记录错误但不中断登录（宽松策略）
    zap.L().Warn("设备限制执行失败，允许登录",
        zap.String("user_id", loginResp.User.ID),
        zap.Error(err),
    )
}
```

**关键改进**:
- ✅ 使用`EnforceDeviceLimit`替代`CheckDeviceLimit`
- ✅ 失败时不中断登录（宽松策略）
- ✅ 详细日志

---

### Step 3: 更新SessionService接口（15分钟）

**修改文件**: `service/shared/auth/interfaces.go`

**当前接口**（68-79行）:
```go
type SessionService interface {
    CreateSession(ctx context.Context, userID string) (*Session, error)
    GetSession(ctx context.Context, sessionID string) (*Session, error)
    UpdateSession(ctx context.Context, sessionID string, data map[string]interface{}) error
    DestroySession(ctx context.Context, sessionID string) error
    RefreshSession(ctx context.Context, sessionID string) error
    // MVP: 多端登录限制相关方法
    CheckDeviceLimit(ctx context.Context, userID string, maxDevices int) error
    GetUserSessions(ctx context.Context, userID string) ([]*Session, error)
    DestroyUserSessions(ctx context.Context, userID string) error
}
```

**修改为**:
```go
type SessionService interface {
    CreateSession(ctx context.Context, userID string) (*Session, error)
    GetSession(ctx context.Context, sessionID string) (*Session, error)
    UpdateSession(ctx context.Context, sessionID string, data map[string]interface{}) error
    DestroySession(ctx context.Context, sessionID string) error
    RefreshSession(ctx context.Context, sessionID string) error
    // MVP: 多端登录限制相关方法
    CheckDeviceLimit(ctx context.Context, userID string, maxDevices int) error          // 保留向后兼容
    EnforceDeviceLimit(ctx context.Context, userID string, maxDevices int) error        // 新增：自动踢出
    GetUserSessions(ctx context.Context, userID string) ([]*Session, error)
    DestroyUserSessions(ctx context.Context, userID string) error
}
```

**说明**:
- 保留`CheckDeviceLimit`（只检查不踢出）
- 新增`EnforceDeviceLimit`（检查+踢出）
- 向后兼容

---

### Step 4: 添加设备管理API（延后到Phase 4）

**API设计**（延后实现）:

```go
// GET /api/v1/auth/devices - 查看设备列表
// DELETE /api/v1/auth/devices/:sessionId - 踢出指定设备
// DELETE /api/v1/auth/devices - 踢出所有其他设备
```

**延后理由**:
- MVP只需要自动踢出功能
- 设备管理UI需要前端支持
- 可在Phase 4完善用户体验时添加

---

## ⏱️ 时间分配

| 步骤 | 预计时间 | 说明 |
|-----|---------|------|
| Step 1: EnforceDeviceLimit实现 | 1小时 | 核心逻辑 |
| Step 2: AuthService调用更新 | 15分钟 | 修改调用 |
| Step 3: 接口更新 | 15分钟 | 添加新接口 |
| Step 4: 测试和验证 | 30分钟 | Lint和逻辑验证 |
| Step 5: 文档编写 | 30分钟 | 报告编写 |
| **总计** | **3小时** | **压缩实施** |

---

## ✅ 验收标准

### 功能验收
- [ ] EnforceDeviceLimit实现完成
- [ ] 自动踢出最老设备（FIFO）
- [ ] AuthService正确调用EnforceDeviceLimit
- [ ] 保留CheckDeviceLimit向后兼容
- [ ] 超限时不阻止登录

### 质量验收
- [ ] 0 lint错误
- [ ] 0编译错误
- [ ] 详细日志记录
- [ ] 容错处理完善

### 延后功能
- ⏸️ 设备管理API（Phase 4）
- ⏸️ 不同等级不同限制（Phase 5）
- ⏸️ 设备信任机制（Phase 5）

---

## 💡 设计要点

### 1. FIFO策略

**排序依据**: `Session.CreatedAt`
**踢出数量**: `len(sessions) - maxDevices + 1`

**示例**:
```
当前会话: 5个（创建时间从早到晚：S1, S2, S3, S4, S5）
限制: 5台设备
新设备登录: 需要1个位置
踢出数量: 5 - 5 + 1 = 1
踢出设备: S1（最老的）
结果: S2, S3, S4, S5, 新设备
```

### 2. 宽松策略

**失败场景处理**:
- 查询失败 → 允许登录
- 踢出失败 → 继续尝试，不中断
- 接口调用失败 → 允许登录

**理由**:
- 用户体验优先
- 避免因限制功能故障导致无法登录
- 详细日志便于排查

### 3. 并发安全

**保护机制**:
- `withUserSessionLock()` - 分布式锁
- 保证同一用户的会话列表修改原子性
- 避免竞态条件

---

## 📝 实施记录

**开始时间**: 2025-10-29 深夜  
**预计完成**: 2025-10-30 凌晨

**下一步**: Step 1 - 实现EnforceDeviceLimit

