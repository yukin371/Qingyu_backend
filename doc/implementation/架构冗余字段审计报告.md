# 架构冗余字段审计报告

**日期**: 2025-10-17  
**问题**: Document模型中存在冗余字段，违反了内容与元数据分离的架构设计

---

## 一、架构设计分析

### 正确的架构设计

项目采用了**内容与元数据分离**的优秀架构：

```
┌─────────────────────────────────────┐
│        Document (元数据)             │
│  - ID, ProjectID, Title             │
│  - Type, Level, Order, Status       │
│  - CharacterIDs, LocationIDs        │
│  - PlotThreads, KeyPoints           │
│  - CreatedAt, UpdatedAt             │
└─────────────────────────────────────┘
           │
           │ 1:1
           ↓
┌─────────────────────────────────────┐
│    DocumentContent (内容)            │
│  - DocumentID                       │
│  - Content (实际文本)                │
│  - Version (乐观锁版本号)            │
│  - WordCount, CharCount             │
│  - GridFSID (大文件支持)             │
└─────────────────────────────────────┘
           │
           │ 1:N
           ↓
┌─────────────────────────────────────┐
│        Version (历史版本)            │
│  - DocumentID                       │
│  - VersionNum, Content              │
│  - Comment, CreatedBy               │
│  - IsAutoSave                       │
└─────────────────────────────────────┘
```

### 架构优势

1. **性能优化**: 列表查询不加载内容，减少数据传输
2. **大文件支持**: DocumentContent 支持 GridFS 存储
3. **并发控制**: DocumentContent.Version 实现乐观锁
4. **版本管理**: Version 表单独存储历史版本
5. **职责分离**: Document 专注于元数据和组织结构

---

## 二、冗余字段识别

### ❌ 错误添加的字段

在 `models/document/document.go` 中：

```go
type Document struct {
    // ... 其他正确字段
    
    // ❌ 冗余字段 - 应该在 DocumentContent 中
    Content string `bson:"content,omitempty" json:"content,omitempty"` // 第20行
    Version int    `bson:"version" json:"version"`                     // 第21行
    
    // ✅ 这个字段是合理的（从DocumentContent同步的统计信息）
    WordCount int `bson:"word_count" json:"wordCount"` // 第24行
}
```

### 为什么这些字段是冗余的？

1. **Content 字段**:
   - 已在 `DocumentContent.Content` 中定义
   - 违反了内容与元数据分离原则
   - 会导致数据冗余和不一致

2. **Version 字段**:
   - 已在 `DocumentContent.Version` 中定义
   - 用于乐观锁控制
   - 应该只在内容更新时使用

---

## 三、错误使用场景审计

### 🔴 发现的错误使用（需要修复）

#### 1. service/ai/context_service.go (2处)

**错误代码**:
```go
// 第84行
chapterInfo := &ai.ChapterInfo{
    Content: doc.Content,  // ❌ 错误：应该查询 DocumentContent
    // ...
}

// 第106行
func (s *ContextService) generateChapterSummary(doc *document.Document) string {
    content := strings.TrimSpace(doc.Content)  // ❌ 错误
    // ...
}
```

**正确做法**:
```go
// 应该先查询 DocumentContent
docContent, err := s.documentContentRepo.GetByDocumentID(ctx, doc.ID)
if err != nil {
    return err
}

chapterInfo := &ai.ChapterInfo{
    Content: docContent.Content,  // ✅ 正确
    // ...
}
```

#### 2. service/project/version_service.go (3处)

**错误代码**:
```go
// 第84行
var f model.Document
if err := fileCol().FindOne(ctx, bson.M{"project_id": projectID, "node_id": nodeID}).Decode(&f); err != nil {
    return nil, err
}

// 第90行
next := f.Version + 1  // ❌ 错误：应该从 DocumentContent 获取

// 第96行
snapshot, storageRef, err := s.StoreSnapshot(f.Content, projectID, nodeID, next)  // ❌ 错误
```

**正确做法**:
```go
// 应该查询 DocumentContent
var docContent model.DocumentContent
if err := contentCol().FindOne(ctx, bson.M{"document_id": documentID}).Decode(&docContent); err != nil {
    return nil, err
}

next := docContent.Version + 1  // ✅ 正确
snapshot, storageRef, err := s.StoreSnapshot(docContent.Content, projectID, nodeID, next)  // ✅ 正确
```

#### 3. service/project/document_service.go (1处)

**错误代码**:
```go
// 第115-120行
updateDoc := bson.M{
    "$set": bson.M{
        "title":      update.Title,
        "content":    update.Content,  // ❌ 错误：应该更新 DocumentContent 表
        "updated_at": update.UpdatedAt,
    },
}
```

**正确做法**:
```go
// 分别更新 Document 和 DocumentContent
// 更新 Document 元数据
updateDoc := bson.M{
    "$set": bson.M{
        "title":      update.Title,
        "updated_at": update.UpdatedAt,
    },
}

// 更新 DocumentContent 内容（带乐观锁）
if update.Content != "" {
    err := s.documentContentRepo.UpdateWithVersion(ctx, documentID, update.Content, expectedVersion)
    if err != nil {
        return err
    }
}
```

---

## 四、测试代码审计

### ⚠️ 测试工具代码也受影响

#### test/testutil/helpers.go

```go
// CreateTestDocument 创建测试文档
func CreateTestDocument(projectID string, opts ...DocumentOption) *document.Document {
    doc := &document.Document{
        // ...
        Type:    document.TypeChapter,  // ✅ 已修复
        Version: 1,                     // ❌ 应该移除
    }
    return doc
}
```

#### test/fixtures/factory.go

```go
func (f *DocumentFactory) Create(projectID string, opts ...func(*document.Document)) *document.Document {
    doc := &document.Document{
        // ...
        Type:    document.TypeChapter,  // ✅ 已修复
        Version: 1,                     // ❌ 应该移除
    }
    return doc
}
```

---

## 五、修复计划

### 第一步：移除冗余字段 ✅ 待执行

```go
// models/document/document.go
type Document struct {
    // ... 保留的字段
    
    // ❌ 删除这两行
    // Content string `bson:"content,omitempty" json:"content,omitempty"`
    // Version int    `bson:"version" json:"version"`
    
    // ✅ 保留统计字段（这是合理的，用于列表展示）
    WordCount int `bson:"word_count" json:"wordCount"`
}
```

### 第二步：修复 Service 层 ⏳ 待执行

1. **ContextService**: 添加 DocumentContentRepository 依赖
2. **VersionService**: 查询 DocumentContent 而非 Document
3. **DocumentService**: 分别更新元数据和内容

### 第三步：修复测试代码 ⏳ 待执行

1. 移除测试工具中的 Version 字段设置
2. 更新工厂函数
3. 添加 DocumentContent 相关的测试工具

### 第四步：添加缺失的 Repository ⏳ 待执行

需要确保存在 `DocumentContentRepository` 接口和实现：
- `GetByDocumentID(ctx, documentID)`
- `UpdateWithVersion(ctx, documentID, content, expectedVersion)`
- `Create(ctx, documentContent)`

---

## 六、影响范围评估

### 🔴 高影响（必须修复）

1. ✅ **编译错误**: 移除字段后，直接访问 `doc.Content` 和 `doc.Version` 将报错
2. ⚠️ **业务逻辑**: 版本控制逻辑可能失效
3. ⚠️ **数据一致性**: 如果已有数据在 Document 中存储了 content 和 version

### ⚠️ 中等影响

1. **测试代码**: 需要更新所有测试工具和 Mock
2. **API响应**: 如果API返回了 Document 对象，响应结构会变化
3. **前端适配**: 前端可能需要调整数据获取逻辑

### ✅ 低影响

1. **新功能开发**: 更清晰的架构更利于新功能开发
2. **性能优化**: 分离后查询性能更好

---

## 七、推荐修复顺序

### 立即执行（P0）

1. ✅ 移除 `Document.Content` 和 `Document.Version` 字段
2. ✅ 修复 `service/ai/context_service.go` 的两处错误
3. ✅ 修复 `service/project/version_service.go` 的三处错误
4. ✅ 修复 `service/project/document_service.go` 的一处错误

### 近期执行（P1）

5. 更新测试工具代码（testutil, fixtures）
6. 添加/完善 DocumentContentRepository
7. 更新相关单元测试

### 后续优化（P2）

8. 数据迁移脚本（如果生产环境有数据）
9. API文档更新
10. 前端适配（如需要）

---

## 八、数据迁移建议

如果已有数据在 `Document` 表中存储了 `content` 和 `version`，需要执行数据迁移：

```javascript
// MongoDB 迁移脚本
db.documents.find({ content: { $exists: true } }).forEach(doc => {
    // 创建或更新 DocumentContent
    db.document_contents.updateOne(
        { document_id: doc._id },
        {
            $setOnInsert: {
                _id: new ObjectId(),
                document_id: doc._id,
                content: doc.content || "",
                version: doc.version || 1,
                content_type: "markdown",
                word_count: doc.word_count || 0,
                created_at: doc.created_at,
                updated_at: doc.updated_at
            }
        },
        { upsert: true }
    );
    
    // 删除 Document 中的冗余字段
    db.documents.updateOne(
        { _id: doc._id },
        { $unset: { content: "", version: "" } }
    );
});
```

---

## 九、总结

### 根本原因

在修复 linter 错误时，为了快速解决 "undefined field" 错误，直接在 `Document` 模型中添加了 `Content` 和 `Version` 字段，**没有充分理解项目的架构设计意图**。

### 教训

1. 🎯 **理解架构优先**: 修复错误前应先理解整体架构设计
2. 🎯 **追溯设计文档**: 应查看 `DocumentContent` 模型的存在目的
3. 🎯 **质疑快速修复**: 如果修复太简单，可能是方向错了
4. 🎯 **代码审查**: 重大架构修改需要审查

### 正确的修复思路

当遇到 "undefined: doc.Content" 错误时，正确的思考顺序应该是：

1. ❓ **为什么这个字段不存在？** → 查看 Document 模型定义
2. ❓ **内容应该在哪里？** → 发现 DocumentContent 模型
3. ❓ **如何正确获取内容？** → 查询 DocumentContent 表
4. ✅ **修复服务层逻辑** → 添加 DocumentContent 查询

而不是：
1. ❌ 缺少字段 → 直接添加字段 → 编译通过 ✅

---

## 十、下一步行动

1. [ ] 立即移除 `Document.Content` 和 `Document.Version` 字段
2. [ ] 修复所有 Service 层的错误使用
3. [ ] 更新测试代码
4. [ ] 验证所有测试通过
5. [ ] 更新相关文档

**执行人**: 开发团队  
**优先级**: P0 (紧急)  
**预计完成**: 今天内

---

**报告生成时间**: 2025-10-17  
**审计人**: AI 架构审计系统
