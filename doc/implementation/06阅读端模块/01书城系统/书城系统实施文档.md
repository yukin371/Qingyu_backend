# 书城系统实施文档

> **模块名称**: 书城系统 (Bookstore System)  
> **实施状态**: ✅ 已完成  
> **完成度**: 70%
> **实施日期**: 2025-10-08
> **负责人**: 青羽后端团队

## 📋 目录

1. [实施概述](#1-实施概述)
2. [架构实现](#2-架构实现)
3. [Model层实现](#3-model层实现)
4. [Repository层实现](#4-repository层实现)
5. [Service层实现](#5-service层实现)
6. [API层实现](#6-api层实现)
7. [Router层实现](#7-router层实现)
8. [缓存策略实现](#8-缓存策略实现)
9. [测试指南](#9-测试指南)
10. [部署说明](#10-部署说明)

## 1. 实施概述

### 1.1 功能范围

书城系统是阅读端的核心模块，提供以下功能：

✅ **已实现功能**:
- 书籍管理（CRUD）
- 分类管理（层级结构）
- Banner管理（轮播图）
- 首页数据聚合
- 书籍搜索和筛选
- 榜单管理（实时/周/月榜）
- 统计功能（浏览量、点赞等）
- Redis缓存集成
- 定时任务调度

⏸️ **暂时禁用功能**:
- 书籍评分API
- 书籍统计API

### 1.2 技术栈

- **编程语言**: Go 1.21+
- **Web框架**: Gin
- **数据库**: MongoDB 5.0+
- **缓存**: Redis 6.0+
- **依赖注入**: 自定义ServiceContainer
- **日志**: Zap

### 1.3 目录结构

```
书城系统目录结构
├── models/reading/bookstore/          # 数据模型层
│   ├── book.go                        # 书籍模型
│   ├── category.go                    # 分类模型
│   ├── banner.go                      # Banner模型
│   ├── chapter.go                     # 章节模型
│   ├── ranking.go                     # 榜单模型
│   ├── book_detail.go                 # 书籍详情
│   ├── book_rating.go                 # 书籍评分
│   └── book_statistics.go             # 书籍统计
│
├── repository/                        # 仓储层
│   ├── interfaces/bookstore/          # 仓储接口
│   │   ├── book_repository.go
│   │   ├── category_repository.go
│   │   ├── banner_repository.go
│   │   ├── chapter_repository.go
│   │   ├── ranking_repository.go
│   │   ├── book_detail_repository.go
│   │   └── book_rating_repository.go
│   │
│   └── mongodb/bookstore/             # MongoDB实现
│       ├── book_repository_mongo.go
│       ├── category_repository_mongo.go
│       ├── banner_repository_mongo.go
│       ├── chapter_repository_mongo.go
│       ├── ranking_repository_mongo.go
│       ├── book_detail_repository_mongo.go
│       └── book_rating_repository_mongo.go
│
├── service/bookstore/                 # 业务逻辑层
│   ├── bookstore_service.go           # 核心书城服务
│   ├── cache_service.go               # 缓存服务
│   ├── cached_bookstore_service.go    # 带缓存的服务包装
│   ├── ranking_scheduler.go           # 榜单调度器
│   ├── chapter_service.go             # 章节服务
│   ├── book_detail_service.go         # 书籍详情服务
│   ├── book_rating_service.go         # 评分服务
│   └── book_statistics_service.go     # 统计服务
│
├── api/v1/reading/                    # API接口层
│   ├── bookstore_api.go               # 书城主API
│   ├── chapter_api.go                 # 章节API
│   ├── book_detail_api.go             # 详情API
│   ├── book_rating_api.go.disabled    # 评分API（禁用）
│   └── book_statistics_api.go.disabled # 统计API（禁用）
│
└── router/bookstore/                  # 路由层
    └── bookstore_router.go            # 路由配置
```

## 2. 架构实现

### 2.1 分层架构

书城系统严格遵循五层架构设计：

```
请求流程
┌─────────────────────────────────────────────────┐
│ Client Request                                   │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│ Router Layer (路由层)                            │
│ - 路由分发                                       │
│ - 中间件处理                                     │
│ - 参数验证                                       │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│ API Layer (接口层)                               │
│ - HTTP请求处理                                   │
│ - 参数绑定                                       │
│ - 响应格式化                                     │
│ - 错误转换                                       │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│ Service Layer (业务逻辑层)                       │
│ - 业务规则处理                                   │
│ - 数据聚合                                       │
│ - 缓存管理                                       │
│ - 事件发布                                       │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│ Repository Layer (仓储层)                        │
│ - 数据访问                                       │
│ - 查询封装                                       │
│ - 事务管理                                       │
│ - 缓存策略                                       │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│ Model Layer (模型层)                             │
│ - 数据结构定义                                   │
│ - 字段验证                                       │
│ - 业务规则                                       │
└─────────────────────────────────────────────────┘
```

### 2.2 依赖关系

```go
// 依赖注入示例
type BookstoreService struct {
    bookRepo     bookstore.BookRepository      // Repository接口
    categoryRepo bookstore.CategoryRepository
    bannerRepo   bookstore.BannerRepository
    eventBus     base.EventBus                 // 事件总线
}

// 构造函数注入
func NewBookstoreService(
    bookRepo bookstore.BookRepository,
    categoryRepo bookstore.CategoryRepository,
    bannerRepo bookstore.BannerRepository,
    eventBus base.EventBus,
) *BookstoreService {
    return &BookstoreService{
        bookRepo:     bookRepo,
        categoryRepo: categoryRepo,
        bannerRepo:   bannerRepo,
        eventBus:     eventBus,
    }
}
```

### 2.3 设计模式应用

#### 2.3.1 装饰器模式 - 缓存服务

```go
// CachedBookstoreService 包装原始服务添加缓存功能
type CachedBookstoreService struct {
    bookstoreService *BookstoreService
    cacheService     *CacheService
}

func (s *CachedBookstoreService) GetBook(ctx context.Context, id string) (*models.Book, error) {
    // 1. 尝试从缓存获取
    if book := s.cacheService.GetBook(id); book != nil {
        return book, nil
    }
    
    // 2. 缓存未命中，从原始服务获取
    book, err := s.bookstoreService.GetBook(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    s.cacheService.SetBook(id, book)
    
    return book, nil
}
```

#### 2.3.2 工厂模式 - Repository创建

```go
// MongoDB Repository工厂
type MongoRepositoryFactory struct {
    db *mongo.Database
}

func (f *MongoRepositoryFactory) CreateBookRepository() BookRepository {
    return mongodb.NewMongoBookRepository(f.db)
}

func (f *MongoRepositoryFactory) CreateCategoryRepository() CategoryRepository {
    return mongodb.NewMongoCategoryRepository(f.db)
}
```

#### 2.3.3 策略模式 - 榜单计算

```go
// 榜单计算策略接口
type RankingStrategy interface {
    Calculate(books []*models.Book) []*models.Book
}

// 热度榜策略
type HotRankingStrategy struct{}

func (s *HotRankingStrategy) Calculate(books []*models.Book) []*models.Book {
    // 按浏览量和点赞数排序
    sort.Slice(books, func(i, j int) bool {
        return books[i].ViewCount > books[j].ViewCount
    })
    return books
}
```

## 3. Model层实现

### 3.1 Book模型

**文件位置**: `models/reading/bookstore/book.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Book 书籍模型
type Book struct {
    ID           primitive.ObjectID   `bson:"_id,omitempty" json:"id"`
    Title        string              `bson:"title" json:"title" validate:"required,min=1,max=200"`
    Author       string              `bson:"author" json:"author" validate:"required"`
    AuthorID     primitive.ObjectID   `bson:"author_id,omitempty" json:"authorId,omitempty"`
    Introduction string              `bson:"introduction" json:"introduction"`
    Cover        string              `bson:"cover" json:"cover"`
    CategoryIDs  []primitive.ObjectID `bson:"category_ids" json:"categoryIds"`
    Tags         []string            `bson:"tags" json:"tags"`
    Status       string              `bson:"status" json:"status" validate:"required,oneof=draft published"`
    WordCount    int64               `bson:"word_count" json:"wordCount"`
    ChapterCount int                 `bson:"chapter_count" json:"chapterCount"`
    ViewCount    int64               `bson:"view_count" json:"viewCount"`
    LikeCount    int64               `bson:"like_count" json:"likeCount"`
    CommentCount int64               `bson:"comment_count" json:"commentCount"`
    Rating       float64             `bson:"rating" json:"rating"`
    RatingCount  int64               `bson:"rating_count" json:"ratingCount"`
    IsRecommended bool               `bson:"is_recommended" json:"isRecommended"`
    IsFeatured   bool                `bson:"is_featured" json:"isFeatured"`
    PublishedAt  *time.Time          `bson:"published_at,omitempty" json:"publishedAt,omitempty"`
    CreatedAt    time.Time           `bson:"created_at" json:"createdAt"`
    UpdatedAt    time.Time           `bson:"updated_at" json:"updatedAt"`
}

// 业务方法
func (b *Book) IsPublished() bool {
    return b.Status == "published"
}

func (b *Book) HasCategories() bool {
    return len(b.CategoryIDs) > 0
}
```

**关键字段说明**:

| 字段 | 类型 | 说明 | 验证规则 |
|-----|------|------|---------|
| ID | ObjectID | MongoDB主键 | - |
| Title | string | 书名 | required, 1-200字符 |
| Author | string | 作者名 | required |
| Status | string | 状态 | draft/published |
| CategoryIDs | []ObjectID | 分类ID列表 | - |
| Tags | []string | 标签 | - |
| ViewCount | int64 | 浏览量 | - |
| LikeCount | int64 | 点赞数 | - |
| Rating | float64 | 评分(0-5) | - |
| IsRecommended | bool | 是否推荐 | - |
| IsFeatured | bool | 是否精选 | - |

### 3.2 Category模型

**文件位置**: `models/reading/bookstore/category.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Category 分类模型
type Category struct {
    ID          primitive.ObjectID  `bson:"_id,omitempty" json:"id"`
    Name        string             `bson:"name" json:"name" validate:"required,min=1,max=50"`
    Description string             `bson:"description" json:"description"`
    Icon        string             `bson:"icon" json:"icon"`
    ParentID    *primitive.ObjectID `bson:"parent_id,omitempty" json:"parentId,omitempty"`
    Level       int                `bson:"level" json:"level"`
    SortOrder   int                `bson:"sort_order" json:"sortOrder"`
    BookCount   int64              `bson:"book_count" json:"bookCount"`
    IsActive    bool               `bson:"is_active" json:"isActive"`
    CreatedAt   time.Time          `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time          `bson:"updated_at" json:"updatedAt"`
}

// 业务方法
func (c *Category) IsTopLevel() bool {
    return c.ParentID == nil || c.Level == 0
}

func (c *Category) HasParent() bool {
    return c.ParentID != nil
}
```

**层级结构说明**:
- Level 0: 顶级分类（如：玄幻、都市、历史）
- Level 1: 二级分类（如：玄幻下的东方玄幻、异世大陆）
- ParentID: 指向父分类的ID

### 3.3 Banner模型

**文件位置**: `models/reading/bookstore/banner.go`

```go
package bookstore

import (
    "time"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// Banner 轮播图模型
type Banner struct {
    ID          primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Title       string            `bson:"title" json:"title" validate:"required"`
    Description string            `bson:"description" json:"description"`
    Image       string            `bson:"image" json:"image" validate:"required,url"`
    Target      string            `bson:"target" json:"target"`
    TargetType  string            `bson:"target_type" json:"targetType" validate:"oneof=book category url"`
    SortOrder   int               `bson:"sort_order" json:"sortOrder"`
    IsActive    bool              `bson:"is_active" json:"isActive"`
    StartTime   *time.Time        `bson:"start_time,omitempty" json:"startTime,omitempty"`
    EndTime     *time.Time        `bson:"end_time,omitempty" json:"endTime,omitempty"`
    ClickCount  int64             `bson:"click_count" json:"clickCount"`
    CreatedAt   time.Time         `bson:"created_at" json:"createdAt"`
    UpdatedAt   time.Time         `bson:"updated_at" json:"updatedAt"`
}

// 业务方法
func (b *Banner) IsInTimeRange() bool {
    now := time.Now()
    if b.StartTime != nil && now.Before(*b.StartTime) {
        return false
    }
    if b.EndTime != nil && now.After(*b.EndTime) {
        return false
    }
    return true
}

func (b *Banner) CanDisplay() bool {
    return b.IsActive && b.IsInTimeRange()
}
```

**TargetType说明**:
- `book`: 跳转到书籍详情页
- `category`: 跳转到分类页
- `url`: 跳转到外部链接

## 4. Repository层实现

### 4.1 BookRepository接口

**文件位置**: `repository/interfaces/bookstore/book_repository.go`

```go
package bookstore

import (
    "context"
    "Qingyu_backend/models/reading/bookstore"
    "Qingyu_backend/repository/interfaces/infrastructure"
    "go.mongodb.org/mongo-driver/bson/primitive"
)

// BookRepository 书籍仓储接口
type BookRepository interface {
    // 基础CRUD操作
    Create(ctx context.Context, book *bookstore.Book) error
    GetByID(ctx context.Context, id primitive.ObjectID) (*bookstore.Book, error)
    Update(ctx context.Context, id primitive.ObjectID, updates map[string]interface{}) error
    Delete(ctx context.Context, id primitive.ObjectID) error
    
    // 列表查询
    List(ctx context.Context, filter infrastructure.Filter) ([]*bookstore.Book, error)
    GetByCategory(ctx context.Context, categoryID primitive.ObjectID, limit, offset int64) ([]*bookstore.Book, error)
    GetByAuthor(ctx context.Context, author string, limit, offset int64) ([]*bookstore.Book, error)
    GetByAuthorID(ctx context.Context, authorID primitive.ObjectID, limit, offset int64) ([]*bookstore.Book, error)
    GetByStatus(ctx context.Context, status string, limit, offset int64) ([]*bookstore.Book, error)
    
    // 特殊查询
    GetRecommended(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetFeatured(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetHotBooks(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetNewReleases(ctx context.Context, limit int64) ([]*bookstore.Book, error)
    GetFreeBooks(ctx context.Context, limit, offset int64) ([]*bookstore.Book, error)
    GetByPriceRange(ctx context.Context, minPrice, maxPrice int64, limit, offset int64) ([]*bookstore.Book, error)
    
    // 搜索
    Search(ctx context.Context, keyword string, limit, offset int64) ([]*bookstore.Book, error)
    SearchWithFilter(ctx context.Context, filter *bookstore.BookSearchFilter) ([]*bookstore.Book, error)
    
    // 统计
    Count(ctx context.Context, filter infrastructure.Filter) (int64, error)
    CountByCategory(ctx context.Context, categoryID primitive.ObjectID) (int64, error)
    CountByAuthor(ctx context.Context, author string) (int64, error)
    CountByStatus(ctx context.Context, status string) (int64, error)
    
    // 批量操作
    BatchUpdateStatus(ctx context.Context, ids []primitive.ObjectID, status string) error
    BatchUpdateCategory(ctx context.Context, ids []primitive.ObjectID, categoryID primitive.ObjectID) error
    BatchUpdateRecommended(ctx context.Context, ids []primitive.ObjectID, isRecommended bool) error
    BatchUpdateFeatured(ctx context.Context, ids []primitive.ObjectID, isFeatured bool) error
    
    // 统计更新
    IncrementViewCount(ctx context.Context, id primitive.ObjectID) error
    IncrementLikeCount(ctx context.Context, id primitive.ObjectID) error
    IncrementCommentCount(ctx context.Context, id primitive.ObjectID) error
    UpdateRating(ctx context.Context, id primitive.ObjectID, rating float64, count int64) error
    
    // 事务支持
    Transaction(ctx context.Context, fn func(ctx context.Context) error) error
    
    // 健康检查
    Health(ctx context.Context) error
}
```

### 4.2 MongoDB实现

**文件位置**: `repository/mongodb/bookstore/book_repository_mongo.go`

```go
package bookstore

import (
    "context"
    "fmt"
    "time"
    
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    
    "Qingyu_backend/models/reading/bookstore"
    "Qingyu_backend/repository/interfaces/infrastructure"
)

type MongoBookRepository struct {
    collection *mongo.Collection
    db         *mongo.Database
}

func NewMongoBookRepository(db *mongo.Database) *MongoBookRepository {
    return &MongoBookRepository{
        collection: db.Collection("books"),
        db:         db,
    }
}

// Create 创建书籍
func (r *MongoBookRepository) Create(ctx context.Context, book *bookstore.Book) error {
    if book.ID.IsZero() {
        book.ID = primitive.NewObjectID()
    }
    book.CreatedAt = time.Now()
    book.UpdatedAt = time.Now()
    
    _, err := r.collection.InsertOne(ctx, book)
    if err != nil {
        if mongo.IsDuplicateKeyError(err) {
            return fmt.Errorf("书籍已存在")
        }
        return fmt.Errorf("创建书籍失败: %w", err)
    }
    
    return nil
}

// GetByID 根据ID获取书籍
func (r *MongoBookRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*bookstore.Book, error) {
    var book bookstore.Book
    err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&book)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return nil, fmt.Errorf("书籍不存在")
        }
        return nil, fmt.Errorf("查询书籍失败: %w", err)
    }
    
    return &book, nil
}

// GetRecommended 获取推荐书籍
func (r *MongoBookRepository) GetRecommended(ctx context.Context, limit int64) ([]*bookstore.Book, error) {
    filter := bson.M{
        "is_recommended": true,
        "status":         "published",
    }
    
    opts := options.Find().
        SetLimit(limit).
        SetSort(bson.D{
            {Key: "rating", Value: -1},
            {Key: "view_count", Value: -1},
        })
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("查询推荐书籍失败: %w", err)
    }
    defer cursor.Close(ctx)
    
    var books []*bookstore.Book
    if err = cursor.All(ctx, &books); err != nil {
        return nil, fmt.Errorf("解析书籍数据失败: %w", err)
    }
    
    return books, nil
}

// Search 搜索书籍
func (r *MongoBookRepository) Search(ctx context.Context, keyword string, limit, offset int64) ([]*bookstore.Book, error) {
    filter := bson.M{
        "$or": []bson.M{
            {"title": bson.M{"$regex": keyword, "$options": "i"}},
            {"author": bson.M{"$regex": keyword, "$options": "i"}},
            {"tags": bson.M{"$in": []string{keyword}}},
        },
        "status": "published",
    }
    
    opts := options.Find().
        SetSkip(offset).
        SetLimit(limit).
        SetSort(bson.D{{Key: "view_count", Value: -1}})
    
    cursor, err := r.collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, fmt.Errorf("搜索书籍失败: %w", err)
    }
    defer cursor.Close(ctx)
    
    var books []*bookstore.Book
    if err = cursor.All(ctx, &books); err != nil {
        return nil, fmt.Errorf("解析搜索结果失败: %w", err)
    }
    
    return books, nil
}

// IncrementViewCount 增加浏览量
func (r *MongoBookRepository) IncrementViewCount(ctx context.Context, id primitive.ObjectID) error {
    update := bson.M{
        "$inc": bson.M{"view_count": 1},
        "$set": bson.M{"updated_at": time.Now()},
    }
    
    _, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
    if err != nil {
        return fmt.Errorf("更新浏览量失败: %w", err)
    }
    
    return nil
}

// Transaction 执行事务
func (r *MongoBookRepository) Transaction(ctx context.Context, fn func(ctx context.Context) error) error {
    session, err := r.db.Client().StartSession()
    if err != nil {
        return fmt.Errorf("启动会话失败: %w", err)
    }
    defer session.EndSession(ctx)
    
    _, err = session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) {
        return nil, fn(sessCtx)
    })
    
    return err
}

// Health 健康检查
func (r *MongoBookRepository) Health(ctx context.Context) error {
    return r.db.Client().Ping(ctx, nil)
}
```

**实现要点**:
1. ✅ 所有方法返回错误信息
2. ✅ 使用context进行超时控制
3. ✅ 自动设置CreatedAt和UpdatedAt
4. ✅ 支持分页查询
5. ✅ 支持排序
6. ✅ 支持事务操作

### 4.3 索引策略

**MongoDB索引配置**:

```javascript
// books集合索引
db.books.createIndex({ "title": "text", "author": "text" })  // 全文搜索
db.books.createIndex({ "author": 1 })                         // 作者查询
db.books.createIndex({ "category_ids": 1 })                   // 分类查询
db.books.createIndex({ "status": 1 })                         // 状态查询
db.books.createIndex({ "is_recommended": 1 })                 // 推荐书籍
db.books.createIndex({ "is_featured": 1 })                    // 精选书籍
db.books.createIndex({ "rating": -1, "view_count": -1 })      // 排序复合索引
db.books.createIndex({ "created_at": -1 })                    // 时间排序
db.books.createIndex({ "published_at": -1 })                  // 发布时间

// categories集合索引
db.categories.createIndex({ "parent_id": 1 })                 // 父分类查询
db.categories.createIndex({ "level": 1 })                     // 层级查询
db.categories.createIndex({ "sort_order": 1 })                // 排序
db.categories.createIndex({ "is_active": 1 })                 // 状态查询

// banners集合索引
db.banners.createIndex({ "is_active": 1 })                    // 状态查询
db.banners.createIndex({ "sort_order": 1 })                   // 排序
db.banners.createIndex({ "start_time": 1, "end_time": 1 })    // 时间范围
```

## 5. Service层实现

### 5.1 BookstoreService核心服务

**文件位置**: `service/bookstore/bookstore_service.go`

```go
package bookstore

import (
    "context"
    "fmt"
    
    "go.mongodb.org/mongo-driver/bson/primitive"
    
    "Qingyu_backend/models/reading/bookstore"
    bookstoreRepo "Qingyu_backend/repository/interfaces/bookstore"
    "Qingyu_backend/service/base"
)

type BookstoreService struct {
    bookRepo     bookstoreRepo.BookRepository
    categoryRepo bookstoreRepo.CategoryRepository
    bannerRepo   bookstoreRepo.BannerRepository
    eventBus     base.EventBus
}

func NewBookstoreService(
    bookRepo bookstoreRepo.BookRepository,
    categoryRepo bookstoreRepo.CategoryRepository,
    bannerRepo bookstoreRepo.BannerRepository,
    eventBus base.EventBus,
) *BookstoreService {
    return &BookstoreService{
        bookRepo:     bookRepo,
        categoryRepo: categoryRepo,
        bannerRepo:   bannerRepo,
        eventBus:     eventBus,
    }
}

// GetHomepage 获取首页数据
func (s *BookstoreService) GetHomepage(ctx context.Context) (*HomepageResponse, error) {
    // 1. 获取活动Banner
    banners, err := s.bannerRepo.GetActive(ctx, 5)
    if err != nil {
        return nil, fmt.Errorf("获取Banner失败: %w", err)
    }
    
    // 2. 获取推荐书籍
    recommendedBooks, err := s.bookRepo.GetRecommended(ctx, 20)
    if err != nil {
        return nil, fmt.Errorf("获取推荐书籍失败: %w", err)
    }
    
    // 3. 获取精选书籍
    featuredBooks, err := s.bookRepo.GetFeatured(ctx, 10)
    if err != nil {
        return nil, fmt.Errorf("获取精选书籍失败: %w", err)
    }
    
    // 4. 获取热门书籍
    hotBooks, err := s.bookRepo.GetHotBooks(ctx, 10)
    if err != nil {
        return nil, fmt.Errorf("获取热门书籍失败: %w", err)
    }
    
    // 5. 获取分类列表
    categories, err := s.categoryRepo.GetTopLevel(ctx)
    if err != nil {
        return nil, fmt.Errorf("获取分类列表失败: %w", err)
    }
    
    // 6. 统计数据
    totalBooks, _ := s.bookRepo.CountByStatus(ctx, "published")
    
    return &HomepageResponse{
        Banners:          banners,
        RecommendedBooks: recommendedBooks,
        FeaturedBooks:    featuredBooks,
        HotBooks:         hotBooks,
        Categories:       categories,
        Stats: Stats{
            TotalBooks: totalBooks,
        },
    }, nil
}

// SearchBooks 搜索书籍
func (s *BookstoreService) SearchBooks(ctx context.Context, req *SearchBooksRequest) (*SearchBooksResponse, error) {
    // 参数验证
    if req.Keyword == "" && len(req.CategoryIDs) == 0 && len(req.Tags) == 0 {
        return nil, fmt.Errorf("搜索条件不能为空")
    }
    
    // 构建搜索过滤器
    filter := &bookstore.BookSearchFilter{
        Keyword:     req.Keyword,
        CategoryIDs: req.CategoryIDs,
        Author:      req.Author,
        Tags:        req.Tags,
        MinRating:   req.MinRating,
        SortBy:      req.SortBy,
        SortOrder:   req.SortOrder,
    }
    
    // 执行搜索
    books, err := s.bookRepo.SearchWithFilter(ctx, filter)
    if err != nil {
        return nil, fmt.Errorf("搜索失败: %w", err)
    }
    
    // 分页处理
    offset := (req.Page - 1) * req.PageSize
    limit := req.PageSize
    
    paginatedBooks := paginateBooks(books, offset, limit)
    
    return &SearchBooksResponse{
        Books: paginatedBooks,
        Total: int64(len(books)),
        Page:  req.Page,
        Size:  req.PageSize,
    }, nil
}

// IncrementViewCount 增加浏览量
func (s *BookstoreService) IncrementViewCount(ctx context.Context, bookID string) error {
    id, err := primitive.ObjectIDFromHex(bookID)
    if err != nil {
        return fmt.Errorf("无效的书籍ID: %w", err)
    }
    
    // 更新浏览量
    if err := s.bookRepo.IncrementViewCount(ctx, id); err != nil {
        return fmt.Errorf("更新浏览量失败: %w", err)
    }
    
    // 发布浏览事件
    event := &base.BaseEvent{
        EventType: "book.viewed",
        EventData: map[string]interface{}{
            "book_id": bookID,
        },
    }
    s.eventBus.PublishAsync(ctx, event)
    
    return nil
}
```

**HomepageResponse结构**:

```go
type HomepageResponse struct {
    Banners          []*bookstore.Banner   `json:"banners"`
    RecommendedBooks []*bookstore.Book     `json:"recommendedBooks"`
    FeaturedBooks    []*bookstore.Book     `json:"featuredBooks"`
    HotBooks         []*bookstore.Book     `json:"hotBooks"`
    Categories       []*bookstore.Category `json:"categories"`
    Stats            Stats                 `json:"stats"`
}

type Stats struct {
    TotalBooks      int64 `json:"totalBooks"`
    PublishedBooks  int64 `json:"publishedBooks"`
}
```

### 5.2 缓存服务

**文件位置**: `service/bookstore/cache_service.go`

```go
package bookstore

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
    
    "Qingyu_backend/models/reading/bookstore"
)

type CacheService struct {
    client *redis.Client
}

func NewCacheService(client *redis.Client) *CacheService {
    return &CacheService{
        client: client,
    }
}

// GetBook 从缓存获取书籍
func (s *CacheService) GetBook(bookID string) (*bookstore.Book, error) {
    key := fmt.Sprintf("book:detail:%s", bookID)
    
    data, err := s.client.Get(context.Background(), key).Result()
    if err == redis.Nil {
        return nil, nil // 缓存未命中
    }
    if err != nil {
        return nil, err
    }
    
    var book bookstore.Book
    if err := json.Unmarshal([]byte(data), &book); err != nil {
        return nil, err
    }
    
    return &book, nil
}

// SetBook 设置书籍缓存
func (s *CacheService) SetBook(bookID string, book *bookstore.Book) error {
    key := fmt.Sprintf("book:detail:%s", bookID)
    
    data, err := json.Marshal(book)
    if err != nil {
        return err
    }
    
    // 缓存1天
    return s.client.Set(context.Background(), key, data, 24*time.Hour).Err()
}

// GetHotBooks 获取热门书籍缓存
func (s *CacheService) GetHotBooks() ([]*bookstore.Book, error) {
    key := "book:hot:list"
    
    data, err := s.client.Get(context.Background(), key).Result()
    if err == redis.Nil {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    var books []*bookstore.Book
    if err := json.Unmarshal([]byte(data), &books); err != nil {
        return nil, err
    }
    
    return books, nil
}

// SetHotBooks 设置热门书籍缓存
func (s *CacheService) SetHotBooks(books []*bookstore.Book) error {
    key := "book:hot:list"
    
    data, err := json.Marshal(books)
    if err != nil {
        return err
    }
    
    // 缓存1小时
    return s.client.Set(context.Background(), key, data, 1*time.Hour).Err()
}

// InvalidateBook 使书籍缓存失效
func (s *CacheService) InvalidateBook(bookID string) error {
    key := fmt.Sprintf("book:detail:%s", bookID)
    return s.client.Del(context.Background(), key).Err()
}
```

### 5.3 榜单调度器

**文件位置**: `service/bookstore/ranking_scheduler.go`

```go
package bookstore

import (
    "context"
    "log"
    "time"
    
    "Qingyu_backend/models/reading/bookstore"
    bookstoreRepo "Qingyu_backend/repository/interfaces/bookstore"
)

type RankingScheduler struct {
    bookRepo    bookstoreRepo.BookRepository
    rankingRepo bookstoreRepo.RankingRepository
    cacheService *CacheService
    ticker      *time.Ticker
    stopChan    chan bool
}

func NewRankingScheduler(
    bookRepo bookstoreRepo.BookRepository,
    rankingRepo bookstoreRepo.RankingRepository,
    cacheService *CacheService,
) *RankingScheduler {
    return &RankingScheduler{
        bookRepo:     bookRepo,
        rankingRepo:  rankingRepo,
        cacheService: cacheService,
        stopChan:     make(chan bool),
    }
}

// Start 启动调度器
func (s *RankingScheduler) Start() {
    // 每小时更新一次榜单
    s.ticker = time.NewTicker(1 * time.Hour)
    
    // 立即执行一次
    s.updateRankings()
    
    go func() {
        for {
            select {
            case <-s.ticker.C:
                s.updateRankings()
            case <-s.stopChan:
                return
            }
        }
    }()
    
    log.Println("榜单调度器已启动")
}

// Stop 停止调度器
func (s *RankingScheduler) Stop() {
    s.ticker.Stop()
    s.stopChan <- true
    log.Println("榜单调度器已停止")
}

// updateRankings 更新所有榜单
func (s *RankingScheduler) updateRankings() {
    ctx := context.Background()
    
    log.Println("开始更新榜单...")
    
    // 1. 更新实时热度榜
    if err := s.updateHotRanking(ctx); err != nil {
        log.Printf("更新热度榜失败: %v", err)
    }
    
    // 2. 更新周榜
    if err := s.updateWeeklyRanking(ctx); err != nil {
        log.Printf("更新周榜失败: %v", err)
    }
    
    // 3. 更新月榜
    if err := s.updateMonthlyRanking(ctx); err != nil {
        log.Printf("更新月榜失败: %v", err)
    }
    
    // 4. 更新新书榜
    if err := s.updateNewReleaseRanking(ctx); err != nil {
        log.Printf("更新新书榜失败: %v", err)
    }
    
    log.Println("榜单更新完成")
}

// updateHotRanking 更新热度榜
func (s *RankingScheduler) updateHotRanking(ctx context.Context) error {
    // 获取热门书籍（按浏览量和点赞数排序）
    books, err := s.bookRepo.GetHotBooks(ctx, 100)
    if err != nil {
        return err
    }
    
    // 保存到榜单表
    ranking := &bookstore.Ranking{
        Type:      "hot",
        BookIDs:   extractBookIDs(books),
        UpdatedAt: time.Now(),
    }
    
    if err := s.rankingRepo.Update(ctx, ranking); err != nil {
        return err
    }
    
    // 更新缓存
    return s.cacheService.SetHotBooks(books[:min(20, len(books))])
}

// extractBookIDs 提取书籍ID列表
func extractBookIDs(books []*bookstore.Book) []primitive.ObjectID {
    ids := make([]primitive.ObjectID, len(books))
    for i, book := range books {
        ids[i] = book.ID
    }
    return ids
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**(待续...文档太长，我将分部分创建)**

让我继续创建后续部分：
