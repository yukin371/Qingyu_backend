# 书城系统使用指南

> **面向对象**: 前端开发者、测试人员、产品经理  
> **难度级别**: ⭐⭐  
> **预计阅读时间**: 20分钟

## 📋 目录

1. [快速开始](#1-快速开始)
2. [核心功能使用](#2-核心功能使用)
3. [高级功能](#3-高级功能)
4. [最佳实践](#4-最佳实践)
5. [常见问题](#5-常见问题)
6. [故障排查](#6-故障排查)

## 1. 快速开始

### 1.1 环境准备

**后端环境**:
- Go 1.21+
- MongoDB 5.0+
- Redis 6.0+

**前端环境**:
- 任何支持HTTP请求的环境
- 建议使用axios或fetch

### 1.2 第一个请求

最简单的请求 - 获取首页数据：

```javascript
// 使用fetch
fetch('http://api.example.com/api/v1/bookstore/homepage')
  .then(response => response.json())
  .then(data => {
    console.log('首页数据:', data);
  })
  .catch(error => {
    console.error('请求失败:', error);
  });
```

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "banners": [...],
    "recommendedBooks": [...],
    "featuredBooks": [...],
    "categories": [...]
  }
}
```

### 1.3 基础配置

```javascript
// 推荐的API客户端配置
const bookstoreClient = {
  baseURL: 'http://api.example.com/api/v1/bookstore',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
};

// 使用axios的示例
import axios from 'axios';

const api = axios.create(bookstoreClient);

// 添加请求拦截器
api.interceptors.request.use(config => {
  // 添加token（如果有）
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 添加响应拦截器
api.interceptors.response.use(
  response => response.data,
  error => {
    console.error('API错误:', error);
    return Promise.reject(error);
  }
);
```

## 2. 核心功能使用

### 2.1 首页展示

#### 场景：展示书城首页

```javascript
class BookstoreHomepage {
  constructor() {
    this.api = api;
  }
  
  // 加载首页数据
  async loadHomepage() {
    try {
      const data = await this.api.get('/homepage');
      
      // 渲染Banner
      this.renderBanners(data.banners);
      
      // 渲染推荐书籍
      this.renderBooks('recommended', data.recommendedBooks);
      
      // 渲染精选书籍
      this.renderBooks('featured', data.featuredBooks);
      
      // 渲染分类
      this.renderCategories(data.categories);
      
      // 显示统计
      this.showStats(data.stats);
      
    } catch (error) {
      this.showError('加载首页失败');
    }
  }
  
  // 渲染Banner
  renderBanners(banners) {
    const container = document.getElementById('banner-carousel');
    container.innerHTML = banners.map(banner => `
      <div class="banner-item" onclick="handleBannerClick('${banner.id}', '${banner.targetType}', '${banner.target}')">
        <img src="${banner.image}" alt="${banner.title}">
        <div class="banner-title">${banner.title}</div>
        <div class="banner-desc">${banner.description}</div>
      </div>
    `).join('');
  }
  
  // 渲染书籍列表
  renderBooks(section, books) {
    const container = document.getElementById(`${section}-books`);
    container.innerHTML = books.map(book => `
      <div class="book-card" onclick="viewBook('${book.id}')">
        <img class="book-cover" src="${book.cover}" alt="${book.title}">
        <h3 class="book-title">${book.title}</h3>
        <p class="book-author">${book.author}</p>
        <div class="book-stats">
          <span class="rating">⭐ ${book.rating}</span>
          <span class="views">👁️ ${formatNumber(book.viewCount)}</span>
        </div>
      </div>
    `).join('');
  }
}

// 使用
const homepage = new BookstoreHomepage();
homepage.loadHomepage();
```

### 2.2 书籍详情

#### 场景：查看书籍详情

```javascript
class BookDetail {
  constructor(bookId) {
    this.bookId = bookId;
    this.api = api;
  }
  
  // 加载书籍详情
  async loadBookDetail() {
    try {
      const book = await this.api.get(`/books/${this.bookId}`);
      
      // 渲染书籍信息
      this.renderBookInfo(book);
      
      // 记录浏览
      this.recordView();
      
      // 加载推荐书籍
      this.loadRecommendations();
      
    } catch (error) {
      if (error.response && error.response.status === 404) {
        this.showError('书籍不存在');
      } else {
        this.showError('加载失败');
      }
    }
  }
  
  // 渲染书籍信息
  renderBookInfo(book) {
    document.getElementById('book-detail').innerHTML = `
      <div class="book-detail-container">
        <div class="book-cover-section">
          <img src="${book.cover}" alt="${book.title}">
          <div class="book-actions">
            <button onclick="startReading('${book.id}')">开始阅读</button>
            <button onclick="addToShelf('${book.id}')">加入书架</button>
          </div>
        </div>
        
        <div class="book-info-section">
          <h1>${book.title}</h1>
          <p class="author">作者：${book.author}</p>
          
          <div class="book-meta">
            <span class="rating">⭐ ${book.rating} (${book.ratingCount}人评分)</span>
            <span class="views">👁️ ${formatNumber(book.viewCount)} 阅读</span>
            <span class="likes">👍 ${formatNumber(book.likeCount)} 点赞</span>
          </div>
          
          <div class="book-tags">
            ${book.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
          </div>
          
          <div class="book-stats">
            <span>${formatNumber(book.wordCount)} 字</span>
            <span>${book.chapterCount} 章节</span>
            <span>${book.status === 'published' ? '连载中' : '草稿'}</span>
          </div>
          
          <div class="book-intro">
            <h3>作品简介</h3>
            <p>${book.introduction}</p>
          </div>
        </div>
      </div>
    `;
  }
  
  // 记录浏览
  async recordView() {
    try {
      await this.api.post(`/books/${this.bookId}/view`);
    } catch (error) {
      // 浏览记录失败不影响用户体验
      console.error('记录浏览失败:', error);
    }
  }
  
  // 加载推荐书籍
  async loadRecommendations() {
    try {
      const { books } = await this.api.get('/books/recommended', {
        params: { limit: 6 }
      });
      this.renderRecommendations(books);
    } catch (error) {
      console.error('加载推荐失败:', error);
    }
  }
}

// 使用
const bookDetail = new BookDetail('65f1234567890abcdef12346');
bookDetail.loadBookDetail();
```

### 2.3 书籍搜索

#### 场景：搜索书籍

```javascript
class BookSearch {
  constructor() {
    this.api = api;
    this.currentPage = 1;
    this.pageSize = 20;
  }
  
  // 搜索书籍
  async search(keyword, filters = {}) {
    try {
      const params = {
        keyword: keyword,
        page: this.currentPage,
        size: this.pageSize,
        ...filters
      };
      
      const result = await this.api.post('/books/search', params);
      
      this.renderResults(result);
      this.renderPagination(result.total, result.page, result.size);
      
    } catch (error) {
      this.showError('搜索失败');
    }
  }
  
  // 高级搜索
  async advancedSearch(filters) {
    const {
      keyword,
      categoryIds,
      author,
      tags,
      minRating,
      sortBy,
      sortOrder
    } = filters;
    
    try {
      const result = await this.api.post('/books/search', {
        keyword,
        categoryIds,
        author,
        tags,
        minRating,
        sortBy: sortBy || 'viewCount',
        sortOrder: sortOrder || 'desc',
        page: this.currentPage,
        size: this.pageSize
      });
      
      this.renderResults(result);
      
    } catch (error) {
      this.showError('搜索失败');
    }
  }
  
  // 渲染搜索结果
  renderResults(result) {
    const container = document.getElementById('search-results');
    
    if (result.books.length === 0) {
      container.innerHTML = '<div class="no-results">没有找到相关书籍</div>';
      return;
    }
    
    container.innerHTML = `
      <div class="search-summary">
        找到 ${result.total} 本相关书籍
      </div>
      <div class="book-list">
        ${result.books.map(book => this.renderBookItem(book)).join('')}
      </div>
    `;
  }
  
  // 渲染单个书籍项
  renderBookItem(book) {
    return `
      <div class="book-item" onclick="viewBook('${book.id}')">
        <img class="book-cover" src="${book.cover}" alt="${book.title}">
        <div class="book-info">
          <h3>${book.title}</h3>
          <p class="author">${book.author}</p>
          <p class="intro">${book.introduction.substring(0, 100)}...</p>
          <div class="book-meta">
            <span class="rating">⭐ ${book.rating}</span>
            <span class="views">👁️ ${formatNumber(book.viewCount)}</span>
            <span class="chapters">${book.chapterCount}章</span>
          </div>
        </div>
      </div>
    `;
  }
}

// 使用
const search = new BookSearch();

// 简单搜索
search.search('修真');

// 高级搜索
search.advancedSearch({
  keyword: '修真',
  categoryIds: ['65f1234567890abcdef12347'],
  minRating: 4.0,
  sortBy: 'rating',
  sortOrder: 'desc'
});
```

### 2.4 分类浏览

#### 场景：按分类浏览书籍

```javascript
class CategoryBrowser {
  constructor() {
    this.api = api;
  }
  
  // 加载分类树
  async loadCategoryTree() {
    try {
      const { tree } = await this.api.get('/categories/tree');
      this.renderCategoryTree(tree);
    } catch (error) {
      this.showError('加载分类失败');
    }
  }
  
  // 渲染分类树
  renderCategoryTree(tree) {
    const container = document.getElementById('category-tree');
    container.innerHTML = this.buildCategoryHTML(tree);
  }
  
  // 构建分类HTML
  buildCategoryHTML(categories, level = 0) {
    return categories.map(category => `
      <div class="category-item level-${level}">
        <div class="category-header" onclick="toggleCategory('${category.id}')">
          <span class="category-name">${category.name}</span>
          <span class="book-count">${category.bookCount}本</span>
          ${category.children.length > 0 ? '<span class="toggle-icon">▼</span>' : ''}
        </div>
        ${category.children.length > 0 ? `
          <div class="category-children" id="children-${category.id}">
            ${this.buildCategoryHTML(category.children, level + 1)}
          </div>
        ` : ''}
      </div>
    `).join('');
  }
  
  // 加载分类下的书籍
  async loadCategoryBooks(categoryId, page = 1, size = 20) {
    try {
      const result = await this.api.get(`/categories/${categoryId}/books`, {
        params: { page, size }
      });
      
      this.renderCategoryBooks(result);
      
    } catch (error) {
      this.showError('加载书籍失败');
    }
  }
  
  // 渲染分类书籍
  renderCategoryBooks(result) {
    const container = document.getElementById('category-books');
    
    container.innerHTML = `
      <div class="category-info">
        <h2>${result.category.name}</h2>
        <p>共 ${result.total} 本书籍</p>
      </div>
      <div class="book-grid">
        ${result.books.map(book => this.renderBookCard(book)).join('')}
      </div>
      <div class="pagination">
        ${this.renderPagination(result.total, result.page, result.size)}
      </div>
    `;
  }
}

// 使用
const browser = new CategoryBrowser();
browser.loadCategoryTree();
browser.loadCategoryBooks('65f1234567890abcdef12347');
```

## 3. 高级功能

### 3.1 实时更新

使用WebSocket或轮询实现实时更新：

```javascript
class RealtimeBookstore {
  constructor() {
    this.api = api;
    this.updateInterval = 30000; // 30秒更新一次
  }
  
  // 启动实时更新
  startRealtimeUpdates() {
    // 立即更新一次
    this.updateHotBooks();
    
    // 定时更新
    this.intervalId = setInterval(() => {
      this.updateHotBooks();
    }, this.updateInterval);
  }
  
  // 停止实时更新
  stopRealtimeUpdates() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  
  // 更新热门书籍
  async updateHotBooks() {
    try {
      const { books } = await this.api.get('/books/hot', {
        params: { limit: 10 }
      });
      
      this.updateHotBooksList(books);
      
    } catch (error) {
      console.error('更新热门书籍失败:', error);
    }
  }
  
  // 更新热门书籍列表
  updateHotBooksList(books) {
    const container = document.getElementById('hot-books');
    
    // 使用淡入淡出动画
    container.style.opacity = '0';
    
    setTimeout(() => {
      container.innerHTML = books.map((book, index) => `
        <div class="hot-book-item" data-rank="${index + 1}">
          <span class="rank">${index + 1}</span>
          <img src="${book.cover}" alt="${book.title}">
          <div class="book-info">
            <h4>${book.title}</h4>
            <p>${book.author}</p>
          </div>
          <div class="hot-indicator">🔥 ${formatNumber(book.viewCount)}</div>
        </div>
      `).join('');
      
      container.style.opacity = '1';
    }, 300);
  }
}

// 使用
const realtime = new RealtimeBookstore();
realtime.startRealtimeUpdates();

// 页面卸载时停止
window.addEventListener('beforeunload', () => {
  realtime.stopRealtimeUpdates();
});
```

### 3.2 缓存策略

前端缓存策略示例：

```javascript
class BookstoreCache {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5分钟TTL
  }
  
  // 获取缓存
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) {
      return null;
    }
    
    // 检查是否过期
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  // 设置缓存
  set(key, data, ttl = this.ttl) {
    this.cache.set(key, {
      data: data,
      expiry: Date.now() + ttl
    });
  }
  
  // 清除缓存
  clear() {
    this.cache.clear();
  }
}

// 带缓存的API客户端
class CachedBookstoreAPI {
  constructor() {
    this.api = api;
    this.cache = new BookstoreCache();
  }
  
  // 获取首页（带缓存）
  async getHomepage() {
    const cacheKey = 'homepage';
    const cached = this.cache.get(cacheKey);
    
    if (cached) {
      return cached;
    }
    
    const data = await this.api.get('/homepage');
    this.cache.set(cacheKey, data);
    
    return data;
  }
  
  // 获取书籍详情（带缓存）
  async getBook(bookId) {
    const cacheKey = `book:${bookId}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached) {
      return cached;
    }
    
    const data = await this.api.get(`/books/${bookId}`);
    this.cache.set(cacheKey, data, 10 * 60 * 1000); // 书籍详情缓存10分钟
    
    return data;
  }
}
```

### 3.3 性能优化

图片懒加载和列表虚拟化：

```javascript
class OptimizedBookList {
  constructor() {
    this.observer = null;
    this.initLazyLoad();
  }
  
  // 初始化图片懒加载
  initLazyLoad() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.add('loaded');
          this.observer.unobserve(img);
        }
      });
    }, {
      rootMargin: '50px'
    });
  }
  
  // 渲染书籍列表（使用懒加载）
  renderBooks(books) {
    const html = books.map(book => `
      <div class="book-card">
        <img 
          class="book-cover lazy" 
          data-src="${book.cover}" 
          alt="${book.title}"
          src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 280'%3E%3Crect fill='%23ddd' width='200' height='280'/%3E%3C/svg%3E"
        >
        <h3>${book.title}</h3>
        <p>${book.author}</p>
      </div>
    `).join('');
    
    document.getElementById('book-list').innerHTML = html;
    
    // 观察所有懒加载图片
    document.querySelectorAll('.lazy').forEach(img => {
      this.observer.observe(img);
    });
  }
  
  // 虚拟滚动（大列表优化）
  virtualScroll(books, itemHeight = 200) {
    const container = document.getElementById('book-list');
    const viewport = document.getElementById('viewport');
    
    let scrollTop = 0;
    let startIndex = 0;
    let endIndex = 0;
    
    const visibleCount = Math.ceil(viewport.clientHeight / itemHeight);
    const bufferCount = 5;
    
    function render() {
      startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferCount);
      endIndex = Math.min(books.length, startIndex + visibleCount + bufferCount * 2);
      
      const visibleBooks = books.slice(startIndex, endIndex);
      const offsetY = startIndex * itemHeight;
      
      container.style.transform = `translateY(${offsetY}px)`;
      container.innerHTML = visibleBooks.map((book, index) => 
        this.renderBookItem(book, startIndex + index)
      ).join('');
    }
    
    viewport.addEventListener('scroll', () => {
      scrollTop = viewport.scrollTop;
      requestAnimationFrame(render);
    });
    
    render();
  }
}
```

## 4. 最佳实践

### 4.1 错误处理

```javascript
class ErrorHandler {
  // 统一错误处理
  static handle(error, context) {
    // 记录错误
    console.error(`[${context}] 错误:`, error);
    
    // 根据错误类型处理
    if (error.response) {
      // HTTP错误
      switch (error.response.status) {
        case 400:
          this.showMessage('请求参数错误', 'warning');
          break;
        case 401:
          this.showMessage('请先登录', 'warning');
          this.redirectToLogin();
          break;
        case 404:
          this.showMessage('资源不存在', 'error');
          break;
        case 500:
          this.showMessage('服务器错误，请稍后重试', 'error');
          break;
        default:
          this.showMessage('请求失败', 'error');
      }
    } else if (error.request) {
      // 网络错误
      this.showMessage('网络连接失败，请检查网络', 'error');
    } else {
      // 其他错误
      this.showMessage('操作失败', 'error');
    }
  }
  
  // 显示消息
  static showMessage(message, type) {
    // 实现消息提示UI
    console.log(`[${type}] ${message}`);
  }
  
  // 重定向到登录页
  static redirectToLogin() {
    window.location.href = '/login';
  }
}

// 使用
try {
  const data = await api.get('/books/123');
} catch (error) {
  ErrorHandler.handle(error, 'getBookDetail');
}
```

### 4.2 数据格式化

```javascript
class DataFormatter {
  // 格式化数字
  static formatNumber(num) {
    if (num >= 100000000) {
      return (num / 100000000).toFixed(1) + '亿';
    } else if (num >= 10000) {
      return (num / 10000).toFixed(1) + '万';
    }
    return num.toString();
  }
  
  // 格式化时间
  static formatTime(date) {
    const now = new Date();
    const target = new Date(date);
    const diff = now - target;
    
    const minute = 60 * 1000;
    const hour = 60 * minute;
    const day = 24 * hour;
    
    if (diff < minute) {
      return '刚刚';
    } else if (diff < hour) {
      return Math.floor(diff / minute) + '分钟前';
    } else if (diff < day) {
      return Math.floor(diff / hour) + '小时前';
    } else if (diff < 7 * day) {
      return Math.floor(diff / day) + '天前';
    } else {
      return target.toLocaleDateString();
    }
  }
  
  // 截断文本
  static truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength) + '...';
  }
}
```

### 4.3 状态管理

```javascript
// 使用简单的状态管理
class BookstoreStore {
  constructor() {
    this.state = {
      books: [],
      categories: [],
      currentBook: null,
      loading: false,
      error: null
    };
    
    this.listeners = [];
  }
  
  // 订阅状态变化
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  // 更新状态
  setState(updates) {
    this.state = { ...this.state, ...updates };
    this.notify();
  }
  
  // 通知所有监听器
  notify() {
    this.listeners.forEach(listener => listener(this.state));
  }
  
  // 获取状态
  getState() {
    return this.state;
  }
}

// 使用
const store = new BookstoreStore();

// 订阅状态变化
const unsubscribe = store.subscribe((state) => {
  console.log('状态更新:', state);
  // 更新UI
});

// 更新状态
store.setState({ loading: true });
store.setState({ books: [...], loading: false });
```

## 5. 常见问题

### Q1: 如何处理图片加载失败？

```javascript
function handleImageError(img) {
  img.onerror = function() {
    this.src = '/default-book-cover.png'; // 使用默认图片
    this.onerror = null; // 防止无限循环
  };
}

// 在渲染时使用
<img src="${book.cover}" onerror="handleImageError(this)" alt="${book.title}">
```

### Q2: 如何实现无限滚动加载？

```javascript
class InfiniteScroll {
  constructor(loadMoreFn) {
    this.loadMoreFn = loadMoreFn;
    this.loading = false;
    this.hasMore = true;
    
    this.init();
  }
  
  init() {
    window.addEventListener('scroll', () => {
      if (this.shouldLoadMore()) {
        this.loadMore();
      }
    });
  }
  
  shouldLoadMore() {
    if (this.loading || !this.hasMore) {
      return false;
    }
    
    const scrollTop = window.scrollY;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    
    return scrollTop + windowHeight >= documentHeight - 200;
  }
  
  async loadMore() {
    this.loading = true;
    
    try {
      const hasMore = await this.loadMoreFn();
      this.hasMore = hasMore;
    } catch (error) {
      console.error('加载失败:', error);
    } finally {
      this.loading = false;
    }
  }
}

// 使用
let currentPage = 1;
const infiniteScroll = new InfiniteScroll(async () => {
  const result = await api.get('/books', {
    params: { page: currentPage++, size: 20 }
  });
  
  appendBooks(result.books);
  return result.books.length > 0;
});
```

### Q3: 如何实现搜索防抖？

```javascript
function debounce(fn, delay = 300) {
  let timer = null;
  
  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }
    
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const searchInput = document.getElementById('search-input');
const debouncedSearch = debounce((keyword) => {
  search.search(keyword);
}, 300);

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});
```

## 6. 故障排查

### 6.1 常见错误

**错误1: 跨域问题**

```
Access to XMLHttpRequest at 'http://api.example.com' 
from origin 'http://localhost:3000' has been blocked by CORS policy
```

**解决方案**:
1. 后端配置CORS
2. 使用代理服务器
3. 开发环境配置代理

```javascript
// vue.config.js (Vue项目)
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true
      }
    }
  }
}
```

**错误2: 请求超时**

```javascript
// 设置合理的超时时间
const api = axios.create({
  baseURL: 'http://api.example.com',
  timeout: 10000 // 10秒超时
});

// 处理超时错误
api.interceptors.response.use(
  response => response,
  error => {
    if (error.code === 'ECONNABORTED') {
      ErrorHandler.handle(new Error('请求超时'), 'timeout');
    }
    return Promise.reject(error);
  }
);
```

### 6.2 调试技巧

```javascript
// 启用调试模式
class Debug {
  static enabled = process.env.NODE_ENV === 'development';
  
  static log(...args) {
    if (this.enabled) {
      console.log('[DEBUG]', ...args);
    }
  }
  
  static logRequest(config) {
    this.log('Request:', {
      url: config.url,
      method: config.method,
      params: config.params,
      data: config.data
    });
  }
  
  static logResponse(response) {
    this.log('Response:', {
      status: response.status,
      data: response.data
    });
  }
}

// 使用
api.interceptors.request.use(config => {
  Debug.logRequest(config);
  return config;
});

api.interceptors.response.use(response => {
  Debug.logResponse(response);
  return response;
});
```

---

**文档维护**: 青羽后端团队  
**最后更新**: 2025-10-08  
**技术支持**: support@qingyu.com

