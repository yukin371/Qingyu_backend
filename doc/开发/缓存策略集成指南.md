# ç¼“å­˜ç­–ç•¥é›†æˆæŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2026-01-06
> **é€‚ç”¨ç³»ç»Ÿ**: é’ç¾½å†™ä½œå¹³å°åç«¯

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯´æ˜å¦‚ä½•åœ¨å®é™…ä¸šåŠ¡ä»£ç ä¸­é›†æˆå’Œä½¿ç”¨ `pkg/cache/strategy.go` ä¸­å®šä¹‰çš„ç¼“å­˜ç­–ç•¥ç®¡ç†å™¨ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. åˆå§‹åŒ–ç¼“å­˜ç­–ç•¥ç®¡ç†å™¨

åœ¨æœåŠ¡å®¹å™¨æˆ–åˆå§‹åŒ–ä»£ç ä¸­ï¼š

```go
// core/services.go
package core

import (
    "Qingyu_backend/pkg/cache"
    "github.com/redis/go-redis/v9"
)

var (
    cacheStrategy *cache.CacheStrategy
)

func InitCacheStrategy() error {
    // è·å–Rediså®¢æˆ·ç«¯
    redisClient := cache.GetRedisClient()

    // åˆ›å»ºç¼“å­˜ç­–ç•¥ç®¡ç†å™¨
    cacheStrategy = cache.NewCacheStrategy(redisClient)

    return nil
}

func GetCacheStrategy() *cache.CacheStrategy {
    return cacheStrategy
}
```

### 2. åœ¨æœåŠ¡ä¸­ä½¿ç”¨ç¼“å­˜

#### ç¤ºä¾‹1: ä¹¦ç±æœåŠ¡

```go
// service/bookstore/book_service.go
package bookstore

import (
    "context"
    "fmt"
    "Qingyu_backend/pkg/cache"
)

type BookService struct {
    repo          BookRepository
    cacheStrategy *cache.CacheStrategy
}

func NewBookService(repo BookRepository, cacheStrategy *cache.CacheStrategy) *BookService {
    return &BookService{
        repo:          repo,
        cacheStrategy: cacheStrategy,
    }
}

// GetBook è·å–ä¹¦ç±è¯¦æƒ…ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (s *BookService) GetBook(ctx context.Context, bookID string) (*Book, error) {
    // 1. æ„å»ºç¼“å­˜key
    cacheKey := cache.BuildBookKey(bookID, "detail")

    var book Book

    // 2. å°è¯•ä»ç¼“å­˜è·å–
    err := s.cacheStrategy.Get(ctx, cacheKey, &book)
    if err == nil {
        return &book, nil
    }

    // 3. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
    book, err = s.repo.GetByID(ctx, bookID)
    if err != nil {
        return nil, err
    }

    // 4. å†™å…¥ç¼“å­˜ï¼ˆè‡ªåŠ¨ä½¿ç”¨é¢„å®šä¹‰çš„book:detailç­–ç•¥ï¼‰
    s.cacheStrategy.Set(ctx, cacheKey, &book)

    return &book, nil
}

// UpdateBook æ›´æ–°ä¹¦ç±ï¼ˆåˆ é™¤ç¼“å­˜ï¼‰
func (s *BookService) UpdateBook(ctx context.Context, book *Book) error {
    // 1. æ›´æ–°æ•°æ®åº“
    err := s.repo.Update(ctx, book)
    if err != nil {
        return err
    }

    // 2. åˆ é™¤ç¼“å­˜
    cacheKey := cache.BuildBookKey(book.ID, "detail")
    s.cacheStrategy.Delete(ctx, cacheKey)

    return nil
}
```

#### ç¤ºä¾‹2: ç”¨æˆ·æœåŠ¡

```go
// service/user/user_service.go
package user

import (
    "context"
    "Qingyu_backend/pkg/cache"
)

type UserService struct {
    repo          UserRepository
    cacheStrategy *cache.CacheStrategy
}

// GetUserInfo è·å–ç”¨æˆ·ä¿¡æ¯
func (s *UserService) GetUserInfo(ctx context.Context, userID string) (*User, error) {
    cacheKey := cache.BuildUserKey(userID, "info")

    var user User

    // ä½¿ç”¨GetOrLoadæ¨¡å¼ï¼Œç®€åŒ–ç¼“å­˜é€»è¾‘
    err := s.cacheStrategy.GetOrLoad(ctx, cacheKey, &user, func() (interface{}, error) {
        return s.repo.GetByID(ctx, userID)
    })

    return &user, err
}

// UpdateUserStatus æ›´æ–°ç”¨æˆ·çŠ¶æ€
func (s *UserService) UpdateUserStatus(ctx context.Context, userID string, status string) error {
    // æ›´æ–°æ•°æ®åº“
    err := s.repo.UpdateStatus(ctx, userID, status)
    if err != nil {
        return err
    }

    // åˆ é™¤ç›¸å…³ç¼“å­˜
    s.cacheStrategy.Delete(ctx,
        cache.BuildUserKey(userID, "info"),
        cache.BuildUserKey(userID, "profile"),
    )

    return nil
}
```

#### ç¤ºä¾‹3: æ¨èæœåŠ¡

```go
// service/recommendation/recommendation_service.go
package recommendation

import (
    "context"
    "Qingyu_backend/pkg/cache"
)

type RecommendationService struct {
    repo          RecommendationRepository
    cacheStrategy *cache.CacheStrategy
}

// GetHotBooks è·å–çƒ­é—¨ä¹¦ç±ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (s *RecommendationService) GetHotBooks(ctx context.Context, limit int) ([]Book, error) {
    cacheKey := fmt.Sprintf("book:hot:list:limit:%d", limit)

    var books []Book

    // ä½¿ç”¨GetOrLoadæ¨¡å¼
    err := s.cacheStrategy.GetOrLoad(ctx, cacheKey, &books, func() (interface{}, error) {
        return s.repo.GetHotBooks(ctx, limit)
    })

    return books, err
}

// GetPersonalizedRecommendations è·å–ä¸ªæ€§åŒ–æ¨è
func (s *RecommendationService) GetPersonalizedRecommendations(ctx context.Context, userID string) ([]Book, error) {
    cacheKey := fmt.Sprintf("recommend:user:%s", userID)

    var books []Book

    err := s.cacheStrategy.GetOrLoad(ctx, cacheKey, &books, func() (interface{}, error) {
        return s.repo.GetRecommendations(ctx, userID)
    })

    return books, err
}
```

## ğŸ“š é¢„å®šä¹‰ç¼“å­˜ç­–ç•¥

ç³»ç»Ÿå·²é¢„å®šä¹‰12ç§ç¼“å­˜ç­–ç•¥ï¼Œè‡ªåŠ¨åŒ¹é…keyå‰ç¼€ï¼š

| Keyå‰ç¼€ | ç­–ç•¥ | TTL | éšæœºTTL | ç”¨é€” |
|---------|------|-----|---------|------|
| `user:session` | Cache Aside | 7å¤© | 1å°æ—¶ | ç”¨æˆ·ä¼šè¯ |
| `user:info` | Cache Aside | 30åˆ†é’Ÿ | 5åˆ†é’Ÿ | ç”¨æˆ·ä¿¡æ¯ |
| `book:detail` | Cache Aside | 1å°æ—¶ | 10åˆ†é’Ÿ | ä¹¦ç±è¯¦æƒ… |
| `book:chapter` | Cache Aside | 6å°æ—¶ | 30åˆ†é’Ÿ | ç« èŠ‚å†…å®¹ï¼ˆå‹ç¼©ï¼‰ |
| `book:catalog` | Cache Aside | 6å°æ—¶ | 30åˆ†é’Ÿ | ä¹¦ç±ç›®å½• |
| `book:hot` | Cache Aside | 15åˆ†é’Ÿ | 3åˆ†é’Ÿ | çƒ­é—¨åˆ—è¡¨ |
| `book:recommend` | Cache Aside | 15åˆ†é’Ÿ | 3åˆ†é’Ÿ | æ¨èåˆ—è¡¨ |
| `search:result` | Cache Aside | 10åˆ†é’Ÿ | 2åˆ†é’Ÿ | æœç´¢ç»“æœ |
| `stats` | Write Behind | 5åˆ†é’Ÿ | 1åˆ†é’Ÿ | ç»Ÿè®¡æ•°æ® |
| `reading:progress` | Write Through | 5åˆ†é’Ÿ | 1åˆ†é’Ÿ | é˜…è¯»è¿›åº¦ |
| `comment:list` | Cache Aside | 30åˆ†é’Ÿ | 5åˆ†é’Ÿ | è¯„è®ºåˆ—è¡¨ |
| `config` | Cache Aside | 1å°æ—¶ | 10åˆ†é’Ÿ | é…ç½®ä¿¡æ¯ |

## ğŸ¯ ç¼“å­˜Keyæ„å»ºå·¥å…·

ä½¿ç”¨æä¾›çš„å·¥å…·å‡½æ•°æ„å»ºè§„èŒƒçš„ç¼“å­˜keyï¼š

```go
// ç”¨æˆ·ç›¸å…³
cache.BuildUserKey(userID, "info")        // "user:info:123"
cache.BuildUserKey(userID, "session")     // "user:session:123"

// ä¹¦ç±ç›¸å…³
cache.BuildBookKey(bookID, "detail")      // "book:detail:456"
cache.BuildBookKey(bookID, "catalog")     // "book:catalog:456"

// ç« èŠ‚ç›¸å…³
cache.BuildChapterKey(bookID, 1)          // "book:chapter:456:1"

// æœç´¢ç›¸å…³
cache.BuildSearchKey("keyword", 1)        // "search:result:keyword:page:1"

// è‡ªå®šä¹‰key
cache.BuildKey("custom", "module", "id")  // "custom:module:id"
```

## ğŸ”§ é«˜çº§ç”¨æ³•

### 1. è‡ªå®šä¹‰ç¼“å­˜ç­–ç•¥

```go
// æ³¨å†Œè‡ªå®šä¹‰ç­–ç•¥
cacheStrategy.RegisterPolicy("my:custom", &cache.CachePolicy{
    TTL:       2 * time.Hour,
    RandomTTL: 15 * time.Minute,
    Strategy:  cache.StrategyCacheAside,
    Compress:  false,
})
```

### 2. æ‰¹é‡æ“ä½œ

```go
// æ‰¹é‡è·å–
keys := []string{
    cache.BuildBookKey("1", "detail"),
    cache.BuildBookKey("2", "detail"),
    cache.BuildBookKey("3", "detail"),
}
data, err := cacheStrategy.MGet(ctx, keys)

// æ‰¹é‡è®¾ç½®
items := map[string]interface{}{
    cache.BuildBookKey("1", "detail"): book1,
    cache.BuildBookKey("2", "detail"): book2,
    cache.BuildBookKey("3", "detail"): book3,
}
err := cacheStrategy.MSet(ctx, items)
```

### 3. ç¼“å­˜é¢„çƒ­

```go
// å¯åŠ¨æ—¶é¢„çƒ­çƒ­é—¨æ•°æ®
func WarmUpCache() {
    ctx := context.Background()

    // é¢„çƒ­çƒ­é—¨ä¹¦ç±
    err := cacheStrategy.WarmUpCache(ctx, func() (map[string]interface{}, error) {
        books := getHotBooks()
        data := make(map[string]interface{})
        for _, book := range books {
            key := cache.BuildBookKey(book.ID, "detail")
            data[key] = book
        }
        return data, nil
    })

    if err != nil {
        log.Printf("ç¼“å­˜é¢„çƒ­å¤±è´¥: %v", err)
    }
}
```

### 4. ç¼“å­˜ç©¿é€é˜²æŠ¤

```go
func (s *BookService) GetBookWithProtection(ctx context.Context, bookID string) (*Book, error) {
    cacheKey := cache.BuildBookKey(bookID, "detail")

    var book Book

    // ä½¿ç”¨GetOrLoadï¼Œè‡ªåŠ¨å¤„ç†ç¼“å­˜æœªå‘½ä¸­
    err := s.cacheStrategy.GetOrLoad(ctx, cacheKey, &book, func() (interface{}, error) {
        // æŸ¥è¯¢æ•°æ®åº“
        b, err := s.repo.GetByID(ctx, bookID)
        if err != nil {
            if errors.Is(err, gorm.ErrRecordNotFound) {
                // è¿”å›ç‰¹å®šé”™è¯¯ï¼Œå¯ä»¥ç¼“å­˜ç©ºå€¼
                return nil, ErrBookNotFound
            }
            return nil, err
        }
        return b, nil
    })

    return &book, err
}
```

## ğŸ“Š ç›‘æ§å’Œè°ƒè¯•

### 1. æŸ¥çœ‹ç¼“å­˜ç»Ÿè®¡

```go
// è·å–ç¼“å­˜ç»Ÿè®¡
stats := cacheStrategy.GetStats()
log.Printf("ç¼“å­˜å‘½ä¸­ç‡: %.2f%%", stats.HitRate())
log.Printf("å‘½ä¸­æ¬¡æ•°: %d", stats.Hits)
log.Printf("æœªå‘½ä¸­æ¬¡æ•°: %d", stats.Misses)
```

### 2. æŸ¥çœ‹ç¼“å­˜ç­–ç•¥

```go
// è·å–ç‰¹å®škeyçš„ç­–ç•¥
policy, exists := cacheStrategy.GetPolicy("book:detail:123")
if exists {
    log.Printf("TTL: %v", policy.TTL)
    log.Printf("Strategy: %s", policy.Strategy)
}
```

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. æ•°æ®ä¸€è‡´æ€§

æ›´æ–°æ•°æ®æ—¶è®°å¾—åˆ é™¤ç¼“å­˜ï¼š

```go
func (s *BookService) UpdateBook(ctx context.Context, book *Book) error {
    // å…ˆæ›´æ–°æ•°æ®åº“
    if err := s.repo.Update(ctx, book); err != nil {
        return err
    }

    // å†åˆ é™¤ç¼“å­˜ï¼ˆä¸è¦æ›´æ–°ç¼“å­˜ï¼‰
    cacheKey := cache.BuildBookKey(book.ID, "detail")
    s.cacheStrategy.Delete(ctx, cacheKey)

    return nil
}
```

### 2. ç¼“å­˜é›ªå´©é˜²æŠ¤

å·²é€šè¿‡éšæœºTTLè‡ªåŠ¨é˜²æŠ¤ï¼Œæ— éœ€é¢å¤–å¤„ç†ã€‚

### 3. ç¼“å­˜ç©¿é€é˜²æŠ¤

å¯¹äºä¸å­˜åœ¨çš„æ•°æ®ï¼Œå¯ä»¥ç¼“å­˜ç©ºå€¼æˆ–ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨ã€‚

### 4. å¤§å¯¹è±¡ç¼“å­˜

å¯¹äºå¤§å¯¹è±¡ï¼ˆå¦‚ç« èŠ‚å†…å®¹ï¼‰ï¼Œå¯ç”¨å‹ç¼©ï¼š

```go
// å·²åœ¨ç­–ç•¥ä¸­é…ç½®
s.RegisterPolicy("book:chapter", &CachePolicy{
    Compress: true,  // è‡ªåŠ¨å‹ç¼©
})
```

---

**æ–‡æ¡£ç»´æŠ¤**: é’ç¾½åç«¯æ¶æ„å›¢é˜Ÿ
**æœ€åæ›´æ–°**: 2026-01-06
