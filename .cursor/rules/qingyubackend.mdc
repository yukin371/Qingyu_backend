---
description: Qingyu Backend 项目开发规则和分层架构指导
globs:
alwaysApply: true
---

# Qingyu Backend 项目开发规则

## 项目介绍

**项目名称**：青羽写作后端服务（Qingyu Backend）

青羽写作后端服务是为 AI 辅助写作应用提供核心支持的高性能 API 项目。该项目旨在提供稳定、安全的后端服务，以支持用户管理、文档存储和 AI 文本生成等功能。

**技术栈**
本项目基于 Go 语言，并采用一套现代化的技术栈来确保其性能和可维护性：
后端框架：使用 Gin 框架构建 RESTful API 服务，得益于其高性能和简洁的 API 设计，能高效处理高并发请求。
数据库：采用 MongoDB 作为核心数据存储，其灵活的文档模型非常适合存储用户、文档和配置等非结构化数据。
用户认证：通过 JWT（JSON Web Tokens）实现无状态的用户认证，配合 bcrypt 对用户密码进行加密，确保了用户信息的安全。
配置管理：使用 Viper 读取 .env 文件，实现了配置与代码的解耦，方便在不同环境中灵活部署。
日志系统：集成 Zap 日志库，提供高性能的结构化日志记录，并通过 Gin 的日志中间件进行请求日志管理，便于快速定位和诊断问题。
缓存：利用 Redis 作为缓存服务，并通过 Gin-Cache 中间件提高 API 响应速度和系统吞吐量。
容器化：使用 Docker Compose 实现了项目的容器化部署，简化了开发环境的搭建和生产环境的部署流程，确保了跨平台的一致性。

## 分层架构设计原则

本项目采用清晰的分层架构，遵循单一职责原则和依赖倒置原则。各层级之间保持单向依赖关系，确保代码的可维护性和可测试性。

### 依赖关系链
```
Router -> API -> Service -> Model
```

**重要原则：** 上层可以依赖下层，下层绝不能依赖上层。

---

## 各层级详细说明

### 1. Model 层 (`models/`)

**作用：**
- 定义数据结构：只负责定义应用的数据结构（Go 的 struct）
- 数据操作方法：包含与数据本身强相关的操作方法
- 数据验证：基础的数据验证逻辑

**职责：**
- 只关心数据本身
- 不涉及 HTTP 请求、路由或业务流程
- 不与数据库直接交互
- 不处理复杂的业务逻辑

**示例：**
```go
// models/system/sys_user.go
type User struct {
    ID       string `bson:"_id,omitempty" json:"id"`
    Username string `bson:"username" json:"username"`
    Email    string `bson:"email" json:"email"`
    Password string `bson:"password" json:"-"`
}

// 数据相关的基础方法
func (u *User) SetPassword(password string) error {
    // 密码哈希逻辑
}

func (u *User) ValidatePassword(password string) bool {
    // 密码验证逻辑
}
```

**文件组织：**
```
models/
├── system/           # 系统相关模型
│   ├── sys_user.go
│   └── sys_role.go
├── document/         # 文档相关模型
│   └── document.go
└── enter.go         # 模型入口文件
```

---

### 2. Service 层 (`service/`)

**作用：**
- 处理业务逻辑：所有复杂的业务逻辑都在此层
- 协调数据操作：通过调用数据库操作完成任务
- 业务规则实现：实现具体的业务规则和流程

**职责：**
- 只关心业务逻辑
- 不处理 HTTP 请求细节
- 不直接处理 gin.Context
- 调用 Model 层进行数据操作

**示例：**
```go
// service/system/sys_user.go
type UserService struct {
    // 依赖注入
}

func (s *UserService) RegisterUser(user *models.User) error {
    // 1. 业务验证
    if err := s.validateUser(user); err != nil {
        return err
    }
    
    // 2. 设置密码
    if err := user.SetPassword(user.Password); err != nil {
        return err
    }
    
    // 3. 数据库操作
    collection := init_db.GetCollection("users")
    _, err := collection.InsertOne(context.Background(), user)
    return err
}

func (s *UserService) LoginUser(username, password string) (*models.User, error) {
    // 1. 查找用户
    collection := init_db.GetCollection("users")
    var user models.User
    err := collection.FindOne(context.Background(), bson.M{"username": username}).Decode(&user)
    if err != nil {
        return nil, err
    }
    
    // 2. 验证密码
    if !user.ValidatePassword(password) {
        return nil, errors.New("invalid password")
    }
    
    return &user, nil
}
```

**文件组织：**
```
service/
├── system/           # 系统相关服务
│   ├── sys_user.go
│   └── sys_role.go
├── document/         # 文档相关服务
│   └── document.go
└── enter.go         # 服务入口文件
```

---

### 3. API 层 (`api/v1/`)

**作用：**
- 处理 HTTP 请求和响应
- 参数绑定和验证
- 调用 Service 层处理业务
- 构建 HTTP 响应

**职责：**
- 只关心 HTTP 协议
- 不包含业务逻辑
- 不直接与数据库交互
- 扮演"请求翻译器"和"响应构建器"的角色

**示例：**
```go
// api/v1/system/sys_user.go
type UserApi struct {
    userService *service.UserService
}

func (api *UserApi) Register(c *gin.Context) {
    var user models.User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }
    
    if err := api.userService.RegisterUser(&user); err != nil {
        c.JSON(500, gin.H{"error": "Failed to register user"})
        return
    }
    
    c.JSON(201, gin.H{"message": "User registered successfully"})
}

func (api *UserApi) Login(c *gin.Context) {
    var loginReq struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&loginReq); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }
    
    user, err := api.userService.LoginUser(loginReq.Username, loginReq.Password)
    if err != nil {
        c.JSON(401, gin.H{"error": "Invalid credentials"})
        return
    }
    
    // 生成 JWT token
    token, err := utils.GenerateJWT(user.ID)
    if err != nil {
        c.JSON(500, gin.H{"error": "Failed to generate token"})
        return
    }
    
    c.JSON(200, gin.H{
        "token": token,
        "user":  user,
    })
}
```

**文件组织：**
```
api/
└── v1/               # API 版本
    ├── system/       # 系统相关 API
    │   ├── sys_user.go
    │   └── sys_role.go
    ├── document/     # 文档相关 API
    │   └── document.go
    └── enter.go     # API 入口文件
```

---

### 4. Router 层 (`router/`)

**作用：**
- 管理路由定义
- 中间件应用
- 流量分发

**职责：**
- 只关心路由和流量分发
- 不处理请求参数或业务逻辑
- 将请求路由到对应的 API 处理函数

**示例：**
```go
// router/v1/system/sys_user.go
func InitUserRouter(router *gin.RouterGroup) {
    userApi := api.NewUserApi()
    
    userGroup := router.Group("/user")
    {
        userGroup.POST("/register", userApi.Register)
        userGroup.POST("/login", userApi.Login)
        
        // 需要认证的路由
        authGroup := userGroup.Group("")
        authGroup.Use(middleware.AuthMiddleware())
        {
            authGroup.GET("/profile", userApi.GetProfile)
            authGroup.PUT("/profile", userApi.UpdateProfile)
        }
    }
}
```

**文件组织：**
```
router/
├── v1/               # 路由版本
│   ├── system/       # 系统相关路由
│   │   ├── sys_user.go
│   │   └── sys_role.go
│   ├── document/     # 文档相关路由
│   │   └── document.go
│   └── enter.go     # 路由入口文件
└── enter.go         # 总路由入口
```

---

### 5. Config 层 (`config/`)

**作用：**
- 管理配置信息
- 隔离配置来源
- 提供统一的配置接口

**职责：**
- 只关心配置数据
- 确保配置与代码逻辑分离
- 支持多环境配置

**文件组织：**
```
config/
├── config.go        # 主配置文件
├── database.go      # 数据库配置
├── server.go        # 服务器配置
├── jwt.go          # JWT 配置
└── utils.go        # 配置工具函数
```

**示例：**
```go
// config/config.go
type Config struct {
    Database *DatabaseConfig
    Server   *ServerConfig
    JWT      *JWTConfig
}

func LoadConfig() *Config {
    return &Config{
        Database: LoadDatabaseConfig(),
        Server:   LoadServerConfig(),
        JWT:      LoadJWTConfig(),
    }
}
```

---

### 6. Core 层 (`core/`)

**作用：**
- 应用初始化和生命周期管理
- 核心服务实例管理
- 组件协调

**职责：**
- 只关心应用启动和核心服务管理
- 负责将所有组件组织起来
- 管理全局服务实例

**文件组织：**
```
core/
├── init_db.go       # 数据库初始化
├── init_log.go      # 日志初始化
├── init_cache.go    # 缓存初始化
└── enter.go        # 核心入口
```

**示例：**
```go
// core/init_db.go
func InitDatabase(config *config.DatabaseConfig) error {
    client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(config.MongoURI))
    if err != nil {
        return err
    }
    
    // 存储全局实例
    global.DB = client
    return nil
}
```

---

## 开发规范

### 1. 文件命名规范
- 使用小写字母和下划线：`sys_user.go`
- 包名与目录名一致
- 入口文件统一命名为 `enter.go`

### 2. 结构体命名规范
- 使用大驼峰命名：`UserService`、`UserApi`
- 模型结构体使用名词：`User`、`Document`
- 服务结构体使用名词+Service：`UserService`

### 3. 方法命名规范
- 使用动词开头：`RegisterUser`、`LoginUser`
- API 方法使用 HTTP 动词：`Register`、`Login`、`GetProfile`
- 私有方法使用小写开头：`validateUser`

### 4. 错误处理规范
- Service 层返回业务错误
- API 层将业务错误转换为 HTTP 状态码
- 使用统一的错误响应格式

### 5. 依赖注入规范
- 在 `enter.go` 文件中进行依赖注入
- 使用接口定义依赖关系
- 避免循环依赖

---

## 完整流程示例

### 用户注册流程

1. **Router 层**：接收 `POST /api/v1/user/register` 请求
2. **API 层**：解析请求体，调用 `UserService.RegisterUser`
3. **Service 层**：执行业务逻辑（验证、密码哈希、数据库插入）
4. **Model 层**：提供 `SetPassword` 方法进行密码处理
5. **API 层**：根据 Service 层返回结果构建 HTTP 响应

### 代码示例
```go
// 1. Router 定义路由
router.POST("/register", userApi.Register)

// 2. API 处理请求
func (api *UserApi) Register(c *gin.Context) {
    var user models.User
    c.ShouldBindJSON(&user)
    
    err := api.userService.RegisterUser(&user)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(201, gin.H{"message": "success"})
}

// 3. Service 处理业务
func (s *UserService) RegisterUser(user *models.User) error {
    user.SetPassword(user.Password)  // 调用 Model 方法
    collection := init_db.GetCollection("users")
    _, err := collection.InsertOne(context.Background(), user)
    return err
}

// 4. Model 处理数据
func (u *User) SetPassword(password string) error {
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashed)
    return nil
}
```

---

## 注意事项

1. **严格遵循依赖方向**：上层依赖下层，下层不能依赖上层
2. **单一职责**：每个文件只负责一个明确的职责
3. **接口隔离**：使用接口定义依赖关系，便于测试和扩展
4. **配置分离**：配置与代码逻辑完全分离
5. **错误处理**：每层都要有适当的错误处理机制
6. **日志记录**：在关键位置添加日志记录
7. **测试友好**：设计时要考虑单元测试的便利性

遵循这些规则可以确保代码结构清晰、易于维护和扩展。
