# 事件驱动模块完善计划

## 文档版本

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0 | 2025-01-07 | 初始版本，事件驱动模块完善计划 | AI Assistant |

## 概述

本文档详细说明了事件驱动模块的完善计划，包括当前实现的分析、存在的问题、改进方向和实施步骤。通过系统性的完善，使事件驱动架构更好地支持业务发展和系统扩展。

## 当前实现分析

### 已实现功能

✅ **核心EventBus基础设施**
- Event、EventHandler、EventBus 接口定义
- SimpleEventBus 内存事件总线实现
- 同步和异步事件发布机制
- 多处理器订阅支持

✅ **基础事件定义**
- 用户事件（注册、登录、更新、删除）
- 阅读事件（章节阅读、书签、笔记、进度）
- 写作事件（角色、地点、时间线）

✅ **事件处理器示例**
- WelcomeEmailHandler（欢迎邮件）
- UserActivityLogHandler（用户活动日志）
- UserStatisticsHandler（用户统计）
- ReadingStatisticsHandler（阅读统计）
- RecommendationUpdateHandler（推荐更新）

✅ **服务容器集成**
- EventBus 集成到 ServiceContainer
- 各业务服务通过依赖注入获取 EventBus

✅ **单元测试**
- 完整的单元测试覆盖
- 测试用例包括订阅、发布、多处理器等场景

### 存在的问题

❌ **问题1：事件定义不完整**
- 缺少社交模块事件（点赞、评论、收藏）
- 缺少书城模块事件（购买、订阅、打赏）
- 缺少财务模块事件（充值、提现、结算）
- 缺少通知事件
- 缺少系统事件（配置变更、权限变更）

❌ **问题2：事件处理器缺失**
- 当前只有示例性质的处理器
- 缺少实际业务场景的完整处理器实现
- 缺少跨领域的复杂事件处理流程

❌ **问题3：缺少事件持久化**
- 事件只在内存中传递
- 无法进行事件回放和审计
- 系统重启后事件丢失
- 无法实现事件溯源

❌ **问题4：缺少错误处理和重试**
- 处理器执行失败没有重试机制
- 缺少死信队列
- 无法保证事件最终被处理

❌ **问题5：缺少监控和可观测性**
- 没有事件发布的监控指标
- 没有处理器执行时间的监控
- 缺少事件追踪能力
- 难以排查事件处理问题

❌ **问题6：缺少事件版本管理**
- 事件数据结构变更困难
- 无法支持多版本事件共存
- 缺少向后兼容机制

❌ **问题7：缺少分布式支持**
- 当前只能在单机内存中使用
- 无法支持跨服务的异步通信
- 无法实现微服务架构的事件驱动

## 完善计划

### 阶段一：事件定义完善（1-2周）

#### 目标
补全所有业务领域的事件定义，建立完整的事件体系。

#### 任务清单

##### 1.1 社交模块事件
```go
// service/events/social_events.go
const (
    // 点赞事件
    EventLikeAdded    = "like.added"
    EventLikeRemoved  = "like.removed"

    // 评论事件
    EventCommentCreated      = "comment.created"
    EventCommentUpdated      = "comment.updated"
    EventCommentDeleted      = "comment.deleted"
    EventCommentReplied      = "comment.replied"

    // 收藏事件
    EventCollectionAdded    = "collection.added"
    EventCollectionRemoved  = "collection.removed"

    // 关注事件
    EventFollowAdded    = "follow.added"
    EventFollowRemoved  = "follow.removed"
)

type SocialEventData struct {
    UserID      string                 `json:"user_id"`
    TargetType  string                 `json:"target_type"`   // book/user/comment
    TargetID    string                 `json:"target_id"`
    Action      string                 `json:"action"`
    Time        time.Time              `json:"time"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

##### 1.2 书城模块事件
```go
// service/events/bookstore_events.go
const (
    // 购买事件
    EventBookPurchased       = "book.purchased"
    EventChapterPurchased    = "chapter.purchased"
    EventRefundRequested     = "refund.requested"
    EventRefundApproved      = "refund.approved"

    // 订阅事件
    EventSubscriptionCreated    = "subscription.created"
    EventSubscriptionRenewed    = "subscription.renewed"
    EventSubscriptionExpired    = "subscription.expired"
    EventSubscriptionCancelled  = "subscription.cancelled"

    // 打赏事件
    EventRewardCreated      = "reward.created"
    EventRewardReceived     = "reward.received"

    // VIP事件
    EventVIPPurchased       = "vip.purchased"
    EventVIPActivated       = "vip.activated"
    EventVIPExpired         = "vip.expired"
)

type BookstoreEventData struct {
    UserID      string                 `json:"user_id"`
    BookID      string                 `json:"book_id,omitempty"`
    ChapterID   string                 `json:"chapter_id,omitempty"`
    Amount      float64                `json:"amount,omitempty"`
    Currency    string                 `json:"currency,omitempty"`
    Action      string                 `json:"action"`
    Time        time.Time              `json:"time"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

##### 1.3 财务模块事件
```go
// service/events/finance_events.go
const (
    // 充值事件
    EventDepositCreated      = "deposit.created"
    EventDepositCompleted    = "deposit.completed"
    EventDepositFailed       = "deposit.failed"

    // 提现事件
    EventWithdrawalCreated   = "withdrawal.created"
    EventWithdrawalApproved  = "withdrawal.approved"
    EventWithdrawalRejected  = "withdrawal.rejected"
    EventWithdrawalCompleted = "withdrawal.completed"

    // 结算事件
    EventSettlementGenerated = "settlement.generated"
    EventSettlementPaid      = "settlement.paid"

    // 收入事件
    EventRevenueEarned       = "revenue.earned"
    EventRevenueSettled      = "revenue.settled"
)

type FinanceEventData struct {
    UserID      string                 `json:"user_id"`
    Amount      float64                `json:"amount"`
    Currency    string                 `json:"currency"`
    Status      string                 `json:"status"`
    Action      string                 `json:"action"`
    Time        time.Time              `json:"time"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

##### 1.4 通知事件
```go
// service/events/notification_events.go
const (
    EventNotificationCreated  = "notification.created"
    EventNotificationSent     = "notification.sent"
    EventNotificationRead     = "notification.read"
    EventNotificationDeleted  = "notification.deleted"
)

type NotificationEventData struct {
    UserID      string                 `json:"user_id"`
    Type        string                 `json:"type"`        // system/comment/follow/reward
    Title       string                 `json:"title"`
    Content     string                 `json:"content"`
    Action      string                 `json:"action"`
    Time        time.Time              `json:"time"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

##### 1.5 系统事件
```go
// service/events/system_events.go
const (
    // 配置事件
    EventConfigChanged  = "config.changed"

    // 权限事件
    EventPermissionChanged   = "permission.changed"
    EventRoleChanged         = "role.changed"

    // 审核事件
    EventReviewSubmitted    = "review.submitted"
    EventReviewApproved     = "review.approved"
    EventReviewRejected     = "review.rejected"

    // 内容事件
    EventContentPublished   = "content.published"
    EventContentUnpublished = "content.unpublished"
)

type SystemEventData struct {
    OperatorID  string                 `json:"operator_id"`
    TargetType  string                 `json:"target_type"`
    TargetID    string                 `json:"target_id"`
    Action      string                 `json:"action"`
    Time        time.Time              `json:"time"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

#### 验收标准
- [ ] 所有业务领域的事件定义完整
- [ ] 事件数据结构清晰、合理
- [ ] 事件工厂函数完整
- [ ] 事件定义文档齐全

### 阶段二：事件处理器实现（2-3周）

#### 目标
实现完整的事件处理器，覆盖实际业务场景。

#### 任务清单

##### 2.1 用户事件处理器

**UserWelcomeEmailHandler**
- 发送用户欢迎邮件
- 邮件模板管理
- 发送失败重试

**UserStatisticsHandler**
- 更新用户注册统计
- 更新活跃用户统计
- 更新用户增长趋势

**UserActivityLogHandler**
- 记录用户所有活动
- 活动日志查询
- 活动日志分析

**UserAchievementHandler**
- 检查用户成就
- 颁发成就奖励
- 成就通知

##### 2.2 阅读事件处理器

**ReadingStatisticsHandler**
- 更新书籍阅读次数
- 更新章节阅读热度
- 更新用户阅读时长

**ReadingProgressHandler**
- 更新用户阅读进度
- 阅读进度同步
- 阅读进度通知

**RecommendationUpdateHandler**
- 更新用户阅读偏好
- 重新计算推荐列表
- 推荐结果缓存

**ReadingRewardHandler**
- 阅读时长奖励
- 阅读章节奖励
- 成就解锁

##### 2.3 社交事件处理器

**NotificationHandler**
- 点赞通知
- 评论通知
- 关注通知
- 收藏通知

**SocialStatisticsHandler**
- 更新社交互动统计
- 更新内容热度
- 更新用户影响力

**ContentModerationHandler**
- 评论内容审核
- 敏感词过滤
- 违规内容处理

##### 2.4 书城事件处理器

**PurchaseStatisticsHandler**
- 更新购买统计
- 更新收入统计
- 更新畅销榜单

**RoyaltyCalculationHandler**
- 计算作者版税
- 版税结算
- 版税通知

**VIPBenefitHandler**
- 激活VIP权益
- VIP权益检查
- VIP到期处理

##### 2.5 财务事件处理器

**TransactionHandler**
- 处理充值请求
- 处理提现请求
- 交易记录管理

**SettlementHandler**
- 生成结算单
- 结算审核
- 结算支付

**RevenueHandler**
- 收入统计
- 收入分析
- 收入报表

##### 2.6 通知事件处理器

**EmailNotificationHandler**
- 邮件通知发送
- 邮件模板管理
- 发送状态追踪

**SMSNotificationHandler**
- 短信通知发送
- 短信模板管理
- 发送状态追踪

**PushNotificationHandler**
- 推送通知发送
- 推送渠道管理
- 推送效果统计

#### 验收标准
- [ ] 所有事件处理器实现完整
- [ ] 处理器单元测试覆盖
- [ ] 处理器性能测试通过
- [ ] 处理器文档齐全

### 阶段三：事件持久化（2-3周）

#### 目标
实现事件持久化，支持事件回放和审计。

#### 架构设计

```
┌─────────────────┐
│   Event Bus     │
└────────┬────────┘
         │
         ├──► Memory Handlers (同步处理)
         │
         └──► Event Store (持久化)
                  │
                  ├──► MongoDB (事件日志)
                  │
                  └──► Redis (事件缓存)
```

#### 任务清单

##### 3.1 事件存储接口

```go
// service/events/event_store.go

// EventStore 事件存储接口
type EventStore interface {
    // 存储事件
    Store(ctx context.Context, event Event) error

    // 查询事件
    GetByID(ctx context.Context, eventID string) (*StoredEvent, error)
    GetByType(ctx context.Context, eventType string, limit, offset int64) ([]*StoredEvent, error)
    GetBySource(ctx context.Context, source string, limit, offset int64) ([]*StoredEvent, error)
    GetByTimeRange(ctx context.Context, start, end time.Time, limit, offset int64) ([]*StoredEvent, error)

    // 事件回放
    Replay(ctx context.Context, handler EventHandler, filter EventFilter) error

    // 清理过期事件
    Cleanup(ctx context.Context, before time.Time) (int64, error)
}

// StoredEvent 存储的事件
type StoredEvent struct {
    ID        string      `bson:"_id" json:"id"`
    EventType string      `bson:"event_type" json:"event_type"`
    EventData interface{} `bson:"event_data" json:"event_data"`
    Timestamp time.Time   `bson:"timestamp" json:"timestamp"`
    Source    string      `bson:"source" json:"source"`
    Processed bool        `bson:"processed" json:"processed"`
    CreatedAt time.Time   `bson:"created_at" json:"created_at"`
}

// EventFilter 事件过滤器
type EventFilter struct {
    EventType string    `bson:"event_type,omitempty"`
    Source    string    `bson:"source,omitempty"`
    StartTime time.Time `bson:"start_time,omitempty"`
    EndTime   time.Time `bson:"end_time,omitempty"`
}
```

##### 3.2 MongoDB 实现

```go
// service/events/mongo_event_store.go

type MongoEventStore struct {
    db         *mongo.Database
    collection *mongo.Collection
}

func NewMongoEventStore(db *mongo.Database) EventStore {
    return &MongoEventStore{
        db:         db,
        collection: db.Collection("events_log"),
    }
}

func (s *MongoEventStore) Store(ctx context.Context, event Event) error {
    storedEvent := &StoredEvent{
        ID:        uuid.New().String(),
        EventType: event.GetEventType(),
        EventData: event.GetEventData(),
        Timestamp: event.GetTimestamp(),
        Source:    event.GetSource(),
        Processed: false,
        CreatedAt: time.Now(),
    }

    _, err := s.collection.InsertOne(ctx, storedEvent)
    return err
}
```

##### 3.3 Redis 缓存层

```go
// service/events/redis_event_cache.go

type RedisEventCache struct {
    client *redis.Client
    ttl    time.Duration
}

func NewRedisEventCache(client *redis.Client, ttl time.Duration) *RedisEventCache {
    return &RedisEventCache{
        client: client,
        ttl:    ttl,
    }
}

// 缓存最近的事件（快速查询）
func (c *RedisEventCache) Store(ctx context.Context, event Event) error {
    key := fmt.Sprintf("event:%s", event.GetEventType())
    data, _ := json.Marshal(event)
    return c.client.LPush(ctx, key, data).Err()
}
```

##### 3.4 EventBus 集成

```go
// service/base/persisted_event_bus.go

type PersistedEventBus struct {
    bus        EventBus
    store      EventStore
    cache      *RedisEventCache
}

func NewPersistedEventBus(store EventStore, cache *RedisEventCache) EventBus {
    return &PersistedEventBus{
        bus:   NewSimpleEventBus(),
        store: store,
        cache: cache,
    }
}

func (b *PersistedEventBus) Publish(ctx context.Context, event Event) error {
    // 1. 持久化事件
    if err := b.store.Store(ctx, event); err != nil {
        return err
    }

    // 2. 缓存事件（可选）
    if b.cache != nil {
        _ = b.cache.Store(ctx, event)
    }

    // 3. 发布到内存总线
    return b.bus.Publish(ctx, event)
}
```

#### 数据库设计

```javascript
// events_log 集合
{
  _id: ObjectId,
  event_type: String,        // 事件类型
  event_data: Object,        // 事件数据
  timestamp: ISODate,        // 事件时间
  source: String,            // 事件来源
  processed: Boolean,        // 是否已处理
  created_at: ISODate,       // 存储时间
  expires_at: ISODate        // 过期时间（TTL索引）
}

// 索引
db.events_log.createIndex({ event_type: 1, timestamp: -1 })
db.events_log.createIndex({ source: 1, timestamp: -1 })
db.events_log.createIndex({ expires_at: 1 }, { expireAfterSeconds: 0 })
```

#### 验收标准
- [ ] 事件存储接口定义完整
- [ ] MongoDB 实现完成
- [ ] Redis 缓存层实现完成
- [ ] EventBus 集成完成
- [ ] 事件回放功能测试通过
- [ ] 事件清理功能测试通过

### 阶段四：错误处理和重试（1-2周）

#### 目标
实现完善的错误处理和重试机制，确保事件最终被处理。

#### 架构设计

```
┌─────────────────┐
│   Event Bus     │
└────────┬────────┘
         │
         ├──► Handler (成功)
         │
         ├──► Retry Queue (失败重试)
         │      │
         │      ├──► Retry 1
         │      ├──► Retry 2
         │      └──► Retry 3
         │
         └──► Dead Letter Queue (最终失败)
```

#### 任务清单

##### 4.1 重试接口定义

```go
// service/events/retry_policy.go

// RetryPolicy 重试策略
type RetryPolicy interface {
    ShouldRetry(err error, attempt int) bool
    GetDelay(attempt int) time.Duration
}

// ExponentialBackoffPolicy 指数退避策略
type ExponentialBackoffPolicy struct {
    MaxRetries    int
    InitialDelay  time.Duration
    MaxDelay      time.Duration
    Multiplier    float64
}

func (p *ExponentialBackoffPolicy) ShouldRetry(err error, attempt int) bool {
    return attempt < p.MaxRetries
}

func (p *ExponentialBackoffPolicy) GetDelay(attempt int) time.Duration {
    delay := float64(p.InitialDelay) * math.Pow(p.Multiplier, float64(attempt))
    if delay > float64(p.MaxDelay) {
        return p.MaxDelay
    }
    return time.Duration(delay)
}
```

##### 4.2 重试队列实现

```go
// service/events/retry_queue.go

// RetryQueue 重试队列
type RetryQueue interface {
    // 添加失败事件到重试队列
    Add(ctx context.Context, event Event, handlerName string, err error, attempt int) error

    // 获取需要重试的事件
    Get(ctx context.Context) ([]*RetryItem, error)

    // 标记重试成功
    MarkSuccess(ctx context.Context, itemID string) error

    // 标记重试失败（最终失败，移入死信队列）
    MarkFailed(ctx context.Context, itemID string) error
}

// RetryItem 重试项
type RetryItem struct {
    ID         string      `bson:"_id"`
    Event      Event       `bson:"event"`
    HandlerName string     `bson:"handler_name"`
    Error      string      `bson:"error"`
    Attempt    int         `bson:"attempt"`
    NextRetry  time.Time   `bson:"next_retry"`
    CreatedAt  time.Time   `bson:"created_at"`
}
```

##### 4.3 死信队列实现

```go
// service/events/dead_letter_queue.go

// DeadLetterQueue 死信队列
type DeadLetterQueue interface {
    // 添加到死信队列
    Add(ctx context.Context, item *RetryItem) error

    // 获取死信队列项
    List(ctx context.Context, limit, offset int64) ([]*RetryItem, error)

    // 重新处理
    Reprocess(ctx context.Context, itemID string) error

    // 删除
    Delete(ctx context.Context, itemID string) error
}
```

##### 4.4 EventBus 集成重试

```go
// service/base/retryable_event_bus.go

type RetryableEventBus struct {
    bus           EventBus
    retryQueue    RetryQueue
    deadLetterQueue DeadLetterQueue
    retryPolicy   RetryPolicy
}

func (b *RetryableEventBus) Publish(ctx context.Context, event Event) error {
    bus.mu.RLock()
    handlers := bus.handlers[event.GetEventType()]
    bus.mu.RUnlock()

    for _, handler := range handlers {
        if err := handler.Handle(ctx, event); err != nil {
            // 添加到重试队列
            if b.retryPolicy.ShouldRetry(err, 0) {
                _ = b.retryQueue.Add(ctx, event, handler.GetHandlerName(), err, 0)
            } else {
                // 直接进入死信队列
                _ = b.deadLetterQueue.Add(ctx, &RetryItem{
                    Event:       event,
                    HandlerName: handler.GetHandlerName(),
                    Error:       err.Error(),
                    Attempt:     0,
                })
            }
        }
    }
    return nil
}
```

##### 4.5 后台重试处理器

```go
// service/events/retry_worker.go

// RetryWorker 后台重试处理器
type RetryWorker struct {
    retryQueue    RetryQueue
    deadLetterQueue DeadLetterQueue
    eventBus      EventBus
    retryPolicy   RetryPolicy
    checkInterval time.Duration
}

func (w *RetryWorker) Start(ctx context.Context) {
    ticker := time.NewTicker(w.checkInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            w.processRetryItems(ctx)
        }
    }
}

func (w *RetryWorker) processRetryItems(ctx context.Context) {
    items, _ := w.retryQueue.Get(ctx)
    for _, item := range items {
        if err := w.eventBus.Publish(ctx, item.Event); err != nil {
            // 重试失败，增加重试次数
            item.Attempt++
            if w.retryPolicy.ShouldRetry(err, item.Attempt) {
                item.NextRetry = time.Now().Add(w.retryPolicy.GetDelay(item.Attempt))
                _ = w.retryQueue.Add(ctx, item.Event, item.HandlerName, err, item.Attempt)
            } else {
                // 达到最大重试次数，移入死信队列
                _ = w.deadLetterQueue.Add(ctx, item)
            }
        } else {
            // 重试成功，标记并删除
            _ = w.retryQueue.MarkSuccess(ctx, item.ID)
        }
    }
}
```

#### 验收标准
- [ ] 重试策略实现完整
- [ ] 重试队列实现完成
- [ ] 死信队列实现完成
- [ ] 后台重试处理器运行稳定
- [ ] 重试功能测试通过
- [ ] 死信队列管理功能完成

### 阶段五：监控和可观测性（1-2周）

#### 目标
实现完整的监控体系，提供事件处理的可观测性。

#### 任务清单

##### 5.1 指标定义

```go
// service/events/metrics.go

// EventMetrics 事件指标
type EventMetrics struct {
    // 发布指标
    PublishedTotal      map[string]int64     // 各类型事件发布总数
    PublishedRate       map[string]float64   // 各类型事件发布速率
    PublishDuration     map[string]Duration  // 发布耗时

    // 处理指标
    HandledTotal        map[string]int64     // 各处理器处理总数
    HandleDuration      map[string]Duration  // 处理耗时
    HandleErrors        map[string]int64     // 处理错误数

    // 队列指标
    RetryQueueSize      int64                // 重试队列大小
    DeadLetterQueueSize int64                // 死信队列大小
}

// Duration 耗时统计
type Duration struct {
    Min    time.Duration
    Max    time.Duration
    Avg    time.Duration
    P50    time.Duration
    P95    time.Duration
    P99    time.Duration
}
```

##### 5.2 Prometheus 集成

```go
// service/events/prometheus_metrics.go

var (
    eventsPublishedTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "events_published_total",
            Help: "Total number of events published.",
        },
        []string{"event_type"},
    )

    eventsHandledTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "events_handled_total",
            Help: "Total number of events handled.",
        },
        []string{"event_type", "handler_name"},
    )

    eventHandleDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "event_handle_duration_seconds",
            Help:    "Duration of event handling in seconds.",
            Buckets: prometheus.DefBuckets,
        },
        []string{"event_type", "handler_name"},
    )

    eventsRetryQueueSize = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "events_retry_queue_size",
            Help: "Current size of the retry queue.",
        },
    )
)

func init() {
    prometheus.MustRegister(eventsPublishedTotal)
    prometheus.MustRegister(eventsHandledTotal)
    prometheus.MustRegister(eventHandleDuration)
    prometheus.MustRegister(eventsRetryQueueSize)
}
```

##### 5.3 分布式追踪

```go
// service/events/tracing.go

func (bus *SimpleEventBus) PublishWithTracing(ctx context.Context, event Event) error {
    // 创建Span
    ctx, span := otel.Tracer("eventbus").Start(ctx, "EventBus.Publish",
        trace.WithAttributes(
            attribute.String("event.type", event.GetEventType()),
            attribute.String("event.source", event.GetSource()),
        ),
    )
    defer span.End()

    bus.mu.RLock()
    handlers := bus.handlers[event.GetEventType()]
    bus.mu.RUnlock()

    for _, handler := range handlers {
        // 为每个处理器创建子Span
        handlerCtx, handlerSpan := otel.Tracer("eventbus").Start(ctx,
            "EventHandler.Handle",
            trace.WithAttributes(
                attribute.String("handler.name", handler.GetHandlerName()),
            ),
        )

        if err := handler.Handle(handlerCtx, event); err != nil {
            handlerSpan.RecordError(err)
            handlerSpan.SetStatus(codes.Error, err.Error())
        } else {
            handlerSpan.SetStatus(codes.Ok)
        }
        handlerSpan.End()
    }

    return nil
}
```

##### 5.4 事件日志

```go
// service/events/event_logger.go

type EventLogger struct {
    logger *logrus.Logger
}

func (l *EventLogger) LogEventPublished(event Event) {
    l.logger.WithFields(logrus.Fields{
        "event_type": event.GetEventType(),
        "source":     event.GetSource(),
        "timestamp":  event.GetTimestamp(),
    }).Info("Event published")
}

func (l *EventLogger) LogEventHandled(event Event, handler string, duration time.Duration, err error) {
    fields := logrus.Fields{
        "event_type": event.GetEventType(),
        "handler":    handler,
        "duration":   duration.Milliseconds(),
    }

    if err != nil {
        fields["error"] = err.Error()
        l.logger.WithFields(fields).Error("Event handle failed")
    } else {
        l.logger.WithFields(fields).Info("Event handled successfully")
    }
}
```

##### 5.5 监控面板

```go
// service/events/monitoring.go

type EventMonitoringService struct {
    eventStore EventStore
    metrics    *EventMetrics
}

func (s *EventMonitoringService) GetMetrics(ctx context.Context) (*EventMetrics, error) {
    // 从存储中统计指标
    metrics := &EventMetrics{
        PublishedTotal:  make(map[string]int64),
        PublishedRate:   make(map[string]float64),
        HandleDuration:  make(map[string]Duration),
        HandledTotal:    make(map[string]int64),
        HandleErrors:    make(map[string]int64),
    }

    // 统计过去1小时的数据
    start := time.Now().Add(-1 * time.Hour)
    events, _ := s.eventStore.GetByTimeRange(ctx, start, time.Now(), 1000, 0)

    for _, event := range events {
        metrics.PublishedTotal[event.EventType]++
    }

    return metrics, nil
}
```

#### 验收标准
- [ ] Prometheus 指标完整
- [ ] 分布式追踪集成完成
- [ ] 结构化日志完整
- [ ] 监控面板可用
- [ ] 告警规则配置完成

### 阶段六：事件版本管理（1周）

#### 目标
实现事件版本管理，支持事件数据结构演进。

#### 任务清单

##### 6.1 版本化事件定义

```go
// service/events/versioned_events.go

// VersionedEvent 版本化事件
type VersionedEvent struct {
    Event
    Version    string                 `json:"version"`
    DataSchema string                 `json:"data_schema"`
}

// EventRegistry 事件注册表
type EventRegistry struct {
    versions map[string][]string  // event_type -> supported versions
    schemas  map[string]string    // event_type:version -> schema
    latest   map[string]string    // event_type -> latest version
}

func (r *EventRegistry) Register(eventType, version, schema string) {
    r.versions[eventType] = append(r.versions[eventType], version)
    r.schemas[fmt.Sprintf("%s:%s", eventType, version)] = schema
    r.latest[eventType] = version
}

func (r *EventRegistry) GetLatestVersion(eventType string) string {
    return r.latest[eventType]
}

func (r *EventRegistry) IsVersionSupported(eventType, version string) bool {
    for _, v := range r.versions[eventType] {
        if v == version {
            return true
        }
    }
    return false
}
```

##### 6.2 事件转换器

```go
// service/events/event_transformer.go

// EventTransformer 事件转换器
type EventTransformer interface {
    // 从旧版本转换到新版本
    Transform(oldEvent interface{}) (interface{}, error)
    // 支持的源版本
    SourceVersion() string
    // 目标版本
    TargetVersion() string
}

// UserRegisteredV1ToV2Transformer 用户注册事件转换器
type UserRegisteredV1ToV2Transformer struct{}

func (t *UserRegisteredV1ToV2Transformer) Transform(oldEvent interface{}) (interface{}, error) {
    v1 := oldEvent.(*UserEventDataV1)
    return &UserEventDataV2{
        UserID:    v1.UserID,
        Username:  v1.Username,
        Email:     v1.Email,
        Action:    v1.Action,
        Time:      v1.Time,
        Metadata:  v1.Metadata,
        UserType:  "standard",  // 新增字段
        Referral:  "",          // 新增字段
    }, nil
}

func (t *UserRegisteredV1ToV2Transformer) SourceVersion() string {
    return "1.0"
}

func (t *UserRegisteredV1ToV2Transformer) TargetVersion() string {
    return "2.0"
}
```

##### 6.3 版本兼容处理

```go
// service/base/versioned_event_bus.go

type VersionedEventBus struct {
    bus        EventBus
    registry   *EventRegistry
    transformers map[string][]EventTransformer
}

func (b *VersionedEventBus) Publish(ctx context.Context, event VersionedEvent) error {
    // 检查版本是否支持
    if !b.registry.IsVersionSupported(event.GetEventType(), event.Version) {
        return fmt.Errorf("unsupported event version: %s:%s",
            event.GetEventType(), event.Version)
    }

    // 如果不是最新版本，尝试转换
    latest := b.registry.GetLatestVersion(event.GetEventType())
    if event.Version != latest {
        transformed, err := b.transformEvent(event, latest)
        if err != nil {
            return err
        }
        event = transformed
    }

    return b.bus.Publish(ctx, event.Event)
}

func (b *VersionedEventBus) transformEvent(event VersionedEvent, targetVersion string) (VersionedEvent, error) {
    currentVersion := event.Version

    for currentVersion != targetVersion {
        // 查找合适的转换器
        transformer := b.findTransformer(event.GetEventType(), currentVersion, targetVersion)
        if transformer == nil {
            return VersionedEvent{}, fmt.Errorf("no transformer found from %s to %s",
                currentVersion, targetVersion)
        }

        // 执行转换
        newData, err := transformer.Transform(event.GetEventData())
        if err != nil {
            return VersionedEvent{}, err
        }

        event = VersionedEvent{
            Event: &BaseEvent{
                EventType: event.GetEventType(),
                EventData: newData,
                Timestamp: event.GetTimestamp(),
                Source:    event.GetSource(),
            },
            Version:    transformer.TargetVersion(),
        }
        currentVersion = transformer.TargetVersion()
    }

    return event, nil
}
```

#### 验收标准
- [ ] 事件版本注册表实现
- [ ] 事件转换器框架完成
- [ ] 版本兼容处理完成
- [ ] 向后兼容测试通过

### 阶段七：分布式事件总线（3-4周）

#### 目标
实现分布式事件总线，支持跨服务的异步通信。

#### 架构设计

```
┌──────────────┐         ┌──────────────┐
│   Service A  │         │   Service B  │
└──────┬───────┘         └──────┬───────┘
       │                        │
       └────────┬───────────────┘
                │
        ┌───────▼────────┐
        │  Event Bus     │
        │  (Memory)      │
        └───────┬────────┘
                │
        ┌───────▼────────────────┐
        │  Message Broker        │
        │  (RabbitMQ/Kafka)      │
        └────────────────────────┘
```

#### 任务清单

##### 7.1 RabbitMQ 集成

```go
// service/events/rabbitmq_event_bus.go

type RabbitMQEventBus struct {
    connection *amqp.Connection
    channel    *amqp.Channel
    exchanges  map[string]bool
    queues     map[string]bool
}

func NewRabbitMQEventBus(url string) (EventBus, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }

    ch, err := conn.Channel()
    if err != nil {
        return nil, err
    }

    bus := &RabbitMQEventBus{
        connection: conn,
        channel:    ch,
        exchanges:  make(map[string]bool),
        queues:     make(map[string]bool),
    }

    return bus, nil
}

func (bus *RabbitMQEventBus) Publish(ctx context.Context, event Event) error {
    exchange := bus.getExchangeName(event.GetEventType())

    // 确保exchange存在
    if !bus.exchanges[exchange] {
        err := bus.channel.ExchangeDeclare(
            exchange,
            "topic",  // topic exchange
            true,      // durable
            false,     // auto-deleted
            false,     // internal
            false,     // no-wait
            nil,
        )
        if err != nil {
            return err
        }
        bus.exchanges[exchange] = true
    }

    // 序列化事件
    body, err := json.Marshal(event)
    if err != nil {
        return err
    }

    // 发布消息
    return bus.channel.PublishWithContext(
        ctx,
        exchange,
        event.GetEventType(),  // routing key
        false,  // mandatory
        false,  // immediate
        amqp.Publishing{
            ContentType:  "application/json",
            Body:         body,
            DeliveryMode: amqp.Persistent,  // 持久化
            Timestamp:    time.Now(),
        },
    )
}

func (bus *RabbitMQEventBus) Subscribe(eventType string, handler EventHandler) error {
    exchange := bus.getExchangeName(eventType)
    queueName := fmt.Sprintf("queue_%s", eventType)

    // 声明队列
    if !bus.queues[queueName] {
        _, err := bus.channel.QueueDeclare(
            queueName,
            true,  // durable
            false, // delete when unused
            false, // exclusive
            false, // no-wait
            nil,
        )
        if err != nil {
            return err
        }
        bus.queues[queueName] = true
    }

    // 绑定队列到exchange
    err := bus.channel.QueueBind(
        queueName,
        eventType,  // binding key
        exchange,
        false,
        nil,
    )
    if err != nil {
        return err
    }

    // 开始消费
    msgs, err := bus.channel.Consume(
        queueName,
        "",    // consumer tag
        false, // auto-ack
        false, // exclusive
        false, // no-local
        false, // no-wait
        nil,
    )
    if err != nil {
        return err
    }

    // 启动处理goroutine
    go func() {
        for msg := range msgs {
            var event BaseEvent
            if err := json.Unmarshal(msg.Body, &event); err != nil {
                log.Printf("Failed to unmarshal event: %v", err)
                msg.Nack(false, false)  // 拒绝消息
                continue
            }

            if err := handler.Handle(context.Background(), &event); err != nil {
                log.Printf("Handler failed: %v", err)
                msg.Nack(false, true)  // 重新入队
            } else {
                msg.Ack(false)  // 确认消息
            }
        }
    }()

    return nil
}
```

##### 7.2 Kafka 集成

```go
// service/events/kafka_event_bus.go

type KafkaEventBus struct {
    producer   sarama.SyncProducer
    consumer   sarama.ConsumerGroup
    brokers    []string
    topic      string
    groupID    string
}

func NewKafkaEventBus(brokers []string, topic, groupID string) (EventBus, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.RequiredAcks = sarama.WaitForAll
    config.Producer.Retry.Max = 5
    config.Consumer.Return.Errors = true

    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }

    consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)
    if err != nil {
        return nil, err
    }

    return &KafkaEventBus{
        producer: producer,
        consumer: consumer,
        brokers:  brokers,
        topic:    topic,
        groupID:  groupID,
    }, nil
}

func (bus *KafkaEventBus) Publish(ctx context.Context, event Event) error {
    // 使用事件类型作为消息key，保证相同事件进入同一分区
    key := sarama.StringEncoder(event.GetEventType())

    // 序列化事件
    value, err := json.Marshal(event)
    if err != nil {
        return err
    }

    // 发送消息
    msg := &sarama.ProducerMessage{
        Topic: bus.topic,
        Key:   key,
        Value: sarama.ByteEncoder(value),
    }

    _, _, err = bus.producer.SendMessage(msg)
    return err
}
```

##### 7.3 混合事件总线

```go
// service/base/hybrid_event_bus.go

// HybridEventBus 混合事件总线（内存 + 消息队列）
type HybridEventBus struct {
    localBus    EventBus         // 本地内存总线
    remoteBus   EventBus         // 远程消息队列总线
    localOnly   map[string]bool  // 只在本地处理的事件类型
}

func NewHybridEventBus(local, remote EventBus, localOnly []string) EventBus {
    localOnlyMap := make(map[string]bool)
    for _, eventType := range localOnly {
        localOnlyMap[eventType] = true
    }

    return &HybridEventBus{
        localBus:  local,
        remoteBus: remote,
        localOnly: localOnlyMap,
    }
}

func (bus *HybridEventBus) Publish(ctx context.Context, event Event) error {
    // 本地事件只发布到内存总线
    if bus.localOnly[event.GetEventType()] {
        return bus.localBus.Publish(ctx, event)
    }

    // 其他事件同时发布到本地和远程
    // 先发布到本地（快速响应）
    localErr := bus.localBus.Publish(ctx, event)

    // 再发布到远程（跨服务通信）
    remoteErr := bus.remoteBus.Publish(ctx, event)

    if localErr != nil {
        return localErr
    }
    return remoteErr
}
```

#### 配置管理

```yaml
events:
  eventbus:
    type: hybrid              # memory/rabbitmq/kafka/hybrid
    async_enabled: true
    max_handlers: 100
    timeout: 30s

  # 本地内存总线配置
  memory:
    buffer_size: 1000

  # RabbitMQ配置
  rabbitmq:
    url: amqp://guest:guest@localhost:5672/
    exchanges:
      events:
        type: topic
        durable: true
    queues:
      prefix: queue_
      durable: true

  # Kafka配置
  kafka:
    brokers:
      - localhost:9092
    topic: events
    group_id: event-consumers
    auto_commit: true

  # 本地只处理的事件
  local_only:
    - user.logged_in
    - user.logged_out
```

#### 验收标准
- [ ] RabbitMQ 集成完成
- [ ] Kafka 集成完成
- [ ] 混合模式实现完成
- [ ] 跨服务通信测试通过
- [ ] 性能测试通过
- [ ] 高可用测试通过

## 总体时间规划

| 阶段 | 任务 | 预计时间 | 状态 |
|------|------|----------|------|
| 阶段一 | 事件定义完善 | 1-2周 | 待开始 |
| 阶段二 | 事件处理器实现 | 2-3周 | 待开始 |
| 阶段三 | 事件持久化 | 2-3周 | 待开始 |
| 阶段四 | 错误处理和重试 | 1-2周 | 待开始 |
| 阶段五 | 监控和可观测性 | 1-2周 | 待开始 |
| 阶段六 | 事件版本管理 | 1周 | 待开始 |
| 阶段七 | 分布式事件总线 | 3-4周 | 待开始 |
| **总计** | | **11-17周** | |

## 风险评估

### 高风险项

1. **分布式事件总线的复杂性**
   - 风险：消息队列的运维和调优复杂
   - 缓解：分阶段实施，先在测试环境充分验证

2. **事件版本管理的向后兼容性**
   - 风险：旧版本事件处理可能出错
   - 缓解：充分的兼容性测试，保留版本转换工具

3. **重试机制的消息堆积**
   - 风险：大量失败事件可能导致重试队列堆积
   - 缓解：设置合理的重试上限，实现死信队列清理机制

### 中风险项

1. **性能影响**
   - 风险：事件持久化和监控可能影响性能
   - 缓解：异步处理，性能测试和优化

2. **数据一致性**
   - 风险：分布式环境下的事件顺序和一致性
   - 缓解：使用幂等性设计，实现事件去重

## 成功标准

### 功能完整性
- [ ] 所有业务领域的事件定义完整
- [ ] 所有关键业务场景的处理器实现
- [ ] 事件持久化和重试机制正常运行
- [ ] 监控和告警功能完整

### 性能指标
- [ ] 事件发布延迟 < 10ms（P95）
- [ ] 事件处理延迟 < 100ms（P95）
- [ ] 系统吞吐量 > 10000 events/s
- [ ] 重试成功率 > 95%

### 可靠性指标
- [ ] 事件持久化可靠性 > 99.9%
- [ ] 事件处理成功率 > 99%
- [ ] 系统可用性 > 99.5%

### 可维护性
- [ ] 代码测试覆盖率 > 80%
- [ ] 文档完整度 100%
- [ ] 事件追踪能力完整
- [ ] 问题定位时间 < 5分钟

## 总结

本完善计划系统性地规划了事件驱动模块的演进方向，从基础的事件定义完善到最终的分布式架构，涵盖了功能、性能、可靠性等多个维度。通过分阶段实施，确保每个阶段都能交付可用的功能，同时为下一阶段奠定基础。

事件驱动架构的完善将显著提升系统的：
- **解耦能力**：服务间通过事件通信，降低耦合度
- **可扩展性**：轻松添加新的事件处理器
- **可靠性**：通过重试和死信队列保证事件最终被处理
- **可观测性**：完整的监控和追踪能力
- **灵活性**：支持从单机到分布式的平滑演进

建议按照本计划的阶段顺序实施，每完成一个阶段进行充分测试和验证，确保系统的稳定性和可靠性。
