# ä¹¦åŸç³»ç»Ÿä½¿ç”¨æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-09  
> **é€‚ç”¨å¯¹è±¡**: å‰ç«¯å¼€å‘è€…ã€ç§»åŠ¨ç«¯å¼€å‘è€…  
> **ç³»ç»Ÿç‰ˆæœ¬**: v1.0

## ğŸ“š ç›®å½•

- [1. å¿«é€Ÿå¼€å§‹](#1-å¿«é€Ÿå¼€å§‹)
- [2. å¸¸è§åœºæ™¯](#2-å¸¸è§åœºæ™¯)
- [3. æœ€ä½³å®è·µ](#3-æœ€ä½³å®è·µ)
- [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
- [5. é”™è¯¯å¤„ç†](#5-é”™è¯¯å¤„ç†)
- [6. å¸¸è§é—®é¢˜](#6-å¸¸è§é—®é¢˜)

---

## 1. å¿«é€Ÿå¼€å§‹

### 1.1 ç¯å¢ƒå‡†å¤‡

#### é…ç½®Base URL

```javascript
// JavaScript
const BASE_URL = 'http://your-domain/api/v1';

// TypeScript
const BASE_URL: string = 'http://your-domain/api/v1';
```

```python
# Python
BASE_URL = 'http://your-domain/api/v1'
```

#### åˆ›å»ºHTTPå®¢æˆ·ç«¯

```javascript
// axiosç¤ºä¾‹
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://your-domain/api/v1',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// å“åº”æ‹¦æˆªå™¨
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    console.error('APIé”™è¯¯:', error);
    return Promise.reject(error);
  }
);
```

### 1.2 ç¬¬ä¸€ä¸ªè¯·æ±‚

#### è·å–é¦–é¡µæ•°æ®

```javascript
async function getHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    console.log('é¦–é¡µæ•°æ®:', response.data);
    return response.data;
  } catch (error) {
    console.error('è·å–é¦–é¡µæ•°æ®å¤±è´¥:', error);
    throw error;
  }
}

// ä½¿ç”¨
getHomepage()
  .then(data => {
    // å¤„ç†é¦–é¡µæ•°æ®
    const { banners, recommended_books, featured_books, categories } = data;
    // æ¸²æŸ“é¡µé¢
  });
```

---

## 2. å¸¸è§åœºæ™¯

### 2.1 åœºæ™¯ä¸€ï¼šå±•ç¤ºä¹¦åŸé¦–é¡µ

#### éœ€æ±‚æè¿°

å±•ç¤ºä¹¦åŸé¦–é¡µï¼ŒåŒ…æ‹¬Bannerè½®æ’­å›¾ã€æ¨èä¹¦ç±ã€ç²¾é€‰ä¹¦ç±ã€åˆ†ç±»å¯¼èˆªå’Œæ¦œå•æ•°æ®ã€‚

#### å®ç°æ­¥éª¤

**æ­¥éª¤1ï¼šè·å–é¦–é¡µæ•°æ®**

```javascript
async function loadHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    const {
      banners,
      recommended_books,
      featured_books,
      categories,
      rankings
    } = response.data;
    
    // æ¸²æŸ“å„ä¸ªæ¨¡å—
    renderBanners(banners);
    renderRecommendedBooks(recommended_books);
    renderFeaturedBooks(featured_books);
    renderCategories(categories);
    renderRankings(rankings);
  } catch (error) {
    showErrorMessage('åŠ è½½é¦–é¡µå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
  }
}
```

**æ­¥éª¤2ï¼šæ¸²æŸ“Banner**

```javascript
function renderBanners(banners) {
  // Vueç¤ºä¾‹
  this.banners = banners.map(banner => ({
    id: banner.id,
    imageUrl: banner.image_url,
    linkUrl: banner.link_url,
    title: banner.title,
    onClick: () => handleBannerClick(banner.id, banner.link_url)
  }));
}

async function handleBannerClick(bannerId, linkUrl) {
  // è®°å½•ç‚¹å‡»ç»Ÿè®¡
  try {
    await apiClient.post(`/bookstore/banners/${bannerId}/click`);
  } catch (error) {
    console.warn('è®°å½•Bannerç‚¹å‡»å¤±è´¥:', error);
  }
  
  // è·³è½¬
  window.location.href = linkUrl;
}
```

**æ­¥éª¤3ï¼šæ¸²æŸ“æ¨èä¹¦ç±**

```javascript
function renderRecommendedBooks(books) {
  this.recommendedBooks = books.map(book => ({
    id: book.id,
    title: book.title,
    author: book.author,
    coverUrl: book.cover_image_url,
    categoryName: book.category_name,
    rating: book.rating,
    viewCount: formatNumber(book.view_count),
    onClick: () => navigateToBookDetail(book.id)
  }));
}

// æ•°å­—æ ¼å¼åŒ–
function formatNumber(num) {
  if (num >= 10000) {
    return (num / 10000).toFixed(1) + 'ä¸‡';
  }
  return num.toString();
}
```

#### å®Œæ•´ç¤ºä¾‹ï¼ˆVue 3ï¼‰

```vue
<template>
  <div class="homepage">
    <!-- Bannerè½®æ’­ -->
    <div class="banner-section">
      <swiper :slides="banners" @slide-click="handleBannerClick">
        <template #slide="{ slide }">
          <img :src="slide.imageUrl" :alt="slide.title" />
        </template>
      </swiper>
    </div>
    
    <!-- æ¨èä¹¦ç± -->
    <section class="recommended-section">
      <h2>æ¨èä¹¦ç±</h2>
      <div class="book-grid">
        <book-card
          v-for="book in recommendedBooks"
          :key="book.id"
          :book="book"
          @click="navigateToBookDetail(book.id)"
        />
      </div>
    </section>
    
    <!-- åˆ†ç±»å¯¼èˆª -->
    <section class="category-section">
      <category-nav :categories="categories" />
    </section>
    
    <!-- æ¦œå• -->
    <section class="ranking-section">
      <ranking-list :rankings="rankings" />
    </section>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { apiClient } from '@/utils/api';

const banners = ref([]);
const recommendedBooks = ref([]);
const categories = ref([]);
const rankings = ref([]);

async function loadHomepage() {
  try {
    const response = await apiClient.get('/bookstore/homepage');
    const data = response.data;
    
    banners.value = data.banners;
    recommendedBooks.value = data.recommended_books;
    categories.value = data.categories;
    rankings.value = data.rankings;
  } catch (error) {
    console.error('åŠ è½½é¦–é¡µå¤±è´¥:', error);
  }
}

async function handleBannerClick(banner) {
  try {
    await apiClient.post(`/bookstore/banners/${banner.id}/click`);
  } catch (error) {
    console.warn('è®°å½•ç‚¹å‡»å¤±è´¥:', error);
  }
  navigateTo(banner.linkUrl);
}

function navigateToBookDetail(bookId) {
  router.push(`/books/${bookId}`);
}

onMounted(() => {
  loadHomepage();
});
</script>
```

---

### 2.2 åœºæ™¯äºŒï¼šä¹¦ç±æœç´¢

#### éœ€æ±‚æè¿°

å®ç°ä¹¦ç±æœç´¢åŠŸèƒ½ï¼Œæ”¯æŒå…³é”®è¯æœç´¢ã€åˆ†ç±»ç­›é€‰ã€æ ‡ç­¾ç­›é€‰ã€æ’åºç­‰ã€‚

#### å®ç°æ­¥éª¤

**æ­¥éª¤1ï¼šåˆ›å»ºæœç´¢è¡¨å•**

```javascript
const searchForm = {
  keyword: '',
  categoryId: '',
  author: '',
  tags: [],
  sortBy: 'view_count',
  sortOrder: 'desc',
  page: 1,
  size: 20
};
```

**æ­¥éª¤2ï¼šæ‰§è¡Œæœç´¢**

```javascript
async function searchBooks(params) {
  try {
    const response = await apiClient.get('/bookstore/books/search', {
      params: {
        keyword: params.keyword,
        categoryId: params.categoryId,
        author: params.author,
        tags: params.tags,
        sortBy: params.sortBy,
        sortOrder: params.sortOrder,
        page: params.page,
        size: params.size
      }
    });
    
    return {
      books: response.data,
      total: response.total,
      page: response.page,
      size: response.size
    };
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    throw error;
  }
}
```

**æ­¥éª¤3ï¼šå¤„ç†åˆ†é¡µ**

```javascript
async function handlePageChange(page) {
  searchForm.page = page;
  const result = await searchBooks(searchForm);
  
  this.books = result.books;
  this.total = result.total;
  this.currentPage = result.page;
}
```

#### å®Œæ•´ç¤ºä¾‹ï¼ˆReactï¼‰

```jsx
import React, { useState, useEffect } from 'react';
import { apiClient } from './utils/api';

function BookSearch() {
  const [searchParams, setSearchParams] = useState({
    keyword: '',
    categoryId: '',
    sortBy: 'view_count',
    sortOrder: 'desc',
    page: 1,
    size: 20
  });
  
  const [searchResults, setSearchResults] = useState({
    books: [],
    total: 0,
    page: 1
  });
  
  const [loading, setLoading] = useState(false);
  
  // æ‰§è¡Œæœç´¢
  const handleSearch = async () => {
    setLoading(true);
    try {
      const response = await apiClient.get('/bookstore/books/search', {
        params: searchParams
      });
      
      setSearchResults({
        books: response.data,
        total: response.total,
        page: response.page
      });
    } catch (error) {
      console.error('æœç´¢å¤±è´¥:', error);
      alert('æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    } finally {
      setLoading(false);
    }
  };
  
  // æ›´æ–°æœç´¢å‚æ•°
  const updateSearchParam = (key, value) => {
    setSearchParams(prev => ({
      ...prev,
      [key]: value,
      page: 1 // é‡ç½®é¡µç 
    }));
  };
  
  // åˆ†é¡µå¤„ç†
  const handlePageChange = (page) => {
    setSearchParams(prev => ({
      ...prev,
      page
    }));
  };
  
  // ç›‘å¬æœç´¢å‚æ•°å˜åŒ–
  useEffect(() => {
    if (searchParams.keyword) {
      handleSearch();
    }
  }, [searchParams]);
  
  return (
    <div className="book-search">
      <div className="search-form">
        <input
          type="text"
          placeholder="æœç´¢ä¹¦åã€ä½œè€…..."
          value={searchParams.keyword}
          onChange={(e) => updateSearchParam('keyword', e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
        />
        
        <select
          value={searchParams.sortBy}
          onChange={(e) => updateSearchParam('sortBy', e.target.value)}
        >
          <option value="view_count">æŒ‰çƒ­åº¦</option>
          <option value="rating">æŒ‰è¯„åˆ†</option>
          <option value="created_at">æŒ‰æ—¶é—´</option>
        </select>
        
        <button onClick={handleSearch} disabled={loading}>
          {loading ? 'æœç´¢ä¸­...' : 'æœç´¢'}
        </button>
      </div>
      
      <div className="search-results">
        {searchResults.books.map(book => (
          <BookCard key={book.id} book={book} />
        ))}
      </div>
      
      <Pagination
        current={searchResults.page}
        total={searchResults.total}
        pageSize={searchParams.size}
        onChange={handlePageChange}
      />
    </div>
  );
}
```

---

### 2.3 åœºæ™¯ä¸‰ï¼šé˜…è¯»ç« èŠ‚

#### éœ€æ±‚æè¿°

å±•ç¤ºä¹¦ç±ç« èŠ‚åˆ—è¡¨ï¼Œæ”¯æŒç« èŠ‚å¯¼èˆªï¼ˆä¸Šä¸€ç« /ä¸‹ä¸€ç« ï¼‰ã€ç« èŠ‚å†…å®¹è·å–ã€‚

#### å®ç°æ­¥éª¤

**æ­¥éª¤1ï¼šè·å–ç« èŠ‚åˆ—è¡¨**

```javascript
async function getChapterList(bookId, page = 1, size = 100) {
  try {
    const response = await apiClient.get(`/books/${bookId}/chapters`, {
      params: { page, size }
    });
    
    return {
      chapters: response.data,
      total: response.total
    };
  } catch (error) {
    console.error('è·å–ç« èŠ‚åˆ—è¡¨å¤±è´¥:', error);
    throw error;
  }
}
```

**æ­¥éª¤2ï¼šè·å–ç« èŠ‚å†…å®¹**

```javascript
async function getChapterContent(chapterId) {
  try {
    const response = await apiClient.get(`/chapters/${chapterId}/content`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIPç« èŠ‚éœ€è¦æƒé™
      showVipPrompt();
    } else {
      console.error('è·å–ç« èŠ‚å†…å®¹å¤±è´¥:', error);
    }
    throw error;
  }
}
```

**æ­¥éª¤3ï¼šç« èŠ‚å¯¼èˆª**

```javascript
async function navigateToNextChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/next`);
    const nextChapter = response.data;
    
    // åŠ è½½ä¸‹ä¸€ç« å†…å®¹
    await loadChapter(nextChapter.id);
  } catch (error) {
    if (error.response?.status === 404) {
      showMessage('å·²ç»æ˜¯æœ€åä¸€ç« äº†');
    } else {
      console.error('è·å–ä¸‹ä¸€ç« å¤±è´¥:', error);
    }
  }
}

async function navigateToPreviousChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/previous`);
    const prevChapter = response.data;
    
    // åŠ è½½ä¸Šä¸€ç« å†…å®¹
    await loadChapter(prevChapter.id);
  } catch (error) {
    if (error.response?.status === 404) {
      showMessage('å·²ç»æ˜¯ç¬¬ä¸€ç« äº†');
    } else {
      console.error('è·å–ä¸Šä¸€ç« å¤±è´¥:', error);
    }
  }
}
```

#### å®Œæ•´ç¤ºä¾‹ï¼ˆVue 3 Composition APIï¼‰

```vue
<template>
  <div class="chapter-reader">
    <!-- ç« èŠ‚æ ‡é¢˜ -->
    <div class="chapter-header">
      <h1>{{ currentChapter?.title }}</h1>
      <div class="chapter-info">
        <span>ç¬¬{{ currentChapter?.chapter_num }}ç« </span>
        <span>{{ currentChapter?.word_count }}å­—</span>
      </div>
    </div>
    
    <!-- ç« èŠ‚å†…å®¹ -->
    <div class="chapter-content" v-html="chapterContent"></div>
    
    <!-- ç« èŠ‚å¯¼èˆª -->
    <div class="chapter-nav">
      <button
        @click="navigateToPrevious"
        :disabled="!hasPrevious"
      >
        ä¸Šä¸€ç« 
      </button>
      
      <button @click="showChapterList">
        ç›®å½•
      </button>
      
      <button
        @click="navigateToNext"
        :disabled="!hasNext"
      >
        ä¸‹ä¸€ç« 
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import { apiClient } from '@/utils/api';

const route = useRoute();
const currentChapter = ref(null);
const chapterContent = ref('');
const loading = ref(false);

// åŠ è½½ç« èŠ‚
async function loadChapter(chapterId) {
  loading.value = true;
  try {
    // è·å–ç« èŠ‚ä¿¡æ¯
    const chapterResponse = await apiClient.get(`/chapters/${chapterId}`);
    currentChapter.value = chapterResponse.data;
    
    // è·å–ç« èŠ‚å†…å®¹
    const contentResponse = await apiClient.get(`/chapters/${chapterId}/content`);
    chapterContent.value = contentResponse.data.content;
  } catch (error) {
    console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', error);
    alert('åŠ è½½ç« èŠ‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
  } finally {
    loading.value = false;
  }
}

// ä¸Šä¸€ç« 
async function navigateToPrevious() {
  try {
    const response = await apiClient.get(`/chapters/${currentChapter.value.id}/previous`);
    await loadChapter(response.data.id);
  } catch (error) {
    if (error.response?.status === 404) {
      alert('å·²ç»æ˜¯ç¬¬ä¸€ç« äº†');
    }
  }
}

// ä¸‹ä¸€ç« 
async function navigateToNext() {
  try {
    const response = await apiClient.get(`/chapters/${currentChapter.value.id}/next`);
    await loadChapter(response.data.id);
  } catch (error) {
    if (error.response?.status === 404) {
      alert('å·²ç»æ˜¯æœ€åä¸€ç« äº†');
    }
  }
}

// æ˜¯å¦æœ‰ä¸Šä¸€ç« 
const hasPrevious = computed(() => {
  return currentChapter.value?.chapter_num > 1;
});

// æ˜¯å¦æœ‰ä¸‹ä¸€ç« 
const hasNext = computed(() => {
  // è¿™é‡Œéœ€è¦ä»ä¹¦ç±ä¿¡æ¯ä¸­è·å–æ€»ç« èŠ‚æ•°
  return true; // ç®€åŒ–å¤„ç†
});

onMounted(() => {
  const chapterId = route.params.chapterId;
  loadChapter(chapterId);
});
</script>

<style scoped>
.chapter-content {
  line-height: 1.8;
  font-size: 18px;
  padding: 20px;
  white-space: pre-wrap;
}

.chapter-nav {
  display: flex;
  justify-content: space-between;
  padding: 20px;
  position: sticky;
  bottom: 0;
  background: white;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
}
</style>
```

---

### 2.4 åœºæ™¯å››ï¼šæ¦œå•å±•ç¤º

#### éœ€æ±‚æè¿°

å±•ç¤ºå¤šä¸ªç»´åº¦çš„æ¦œå•ï¼ˆå®æ—¶æ¦œã€å‘¨æ¦œã€æœˆæ¦œã€æ–°äººæ¦œï¼‰ï¼Œæ”¯æŒæ¦œå•åˆ‡æ¢ã€‚

#### å®ç°æ­¥éª¤

**æ­¥éª¤1ï¼šè·å–æ¦œå•æ•°æ®**

```javascript
async function getRanking(type, period = '', limit = 20) {
  try {
    const response = await apiClient.get(`/bookstore/rankings/${type}`, {
      params: { period, limit }
    });
    
    return response.data;
  } catch (error) {
    console.error('è·å–æ¦œå•å¤±è´¥:', error);
    throw error;
  }
}
```

**æ­¥éª¤2ï¼šæ¦œå•åˆ‡æ¢**

```javascript
async function switchRanking(type) {
  currentRankingType.value = type;
  
  // æ ¹æ®ç±»å‹è·å–å¯¹åº”çš„å‘¨æœŸ
  const period = getRankingPeriod(type);
  
  const rankingData = await getRanking(type, period);
  currentRanking.value = rankingData;
}

function getRankingPeriod(type) {
  if (type === 'realtime') {
    return ''; // å®æ—¶æ¦œä¸éœ€è¦å‘¨æœŸ
  } else if (type === 'weekly') {
    // è¿”å›å½“å‰å‘¨æœŸï¼Œæ ¼å¼ï¼š2024-W01
    return getCurrentWeekPeriod();
  } else if (type === 'monthly' || type === 'newbie') {
    // è¿”å›å½“å‰æœˆä»½ï¼Œæ ¼å¼ï¼š2024-01
    return getCurrentMonthPeriod();
  }
  return '';
}

function getCurrentWeekPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const week = getWeekNumber(now);
  return `${year}-W${week.toString().padStart(2, '0')}`;
}

function getCurrentMonthPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  return `${year}-${month.toString().padStart(2, '0')}`;
}
```

#### å®Œæ•´ç¤ºä¾‹ï¼ˆReactï¼‰

```jsx
import React, { useState, useEffect } from 'react';

function RankingList() {
  const [rankingType, setRankingType] = useState('realtime');
  const [rankingData, setRankingData] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const rankingTabs = [
    { type: 'realtime', label: 'å®æ—¶æ¦œ' },
    { type: 'weekly', label: 'å‘¨æ¦œ' },
    { type: 'monthly', label: 'æœˆæ¦œ' },
    { type: 'newbie', label: 'æ–°äººæ¦œ' }
  ];
  
  // åŠ è½½æ¦œå•
  const loadRanking = async (type) => {
    setLoading(true);
    try {
      const period = getRankingPeriod(type);
      const response = await apiClient.get(`/bookstore/rankings/${type}`, {
        params: { period, limit: 20 }
      });
      setRankingData(response.data);
    } catch (error) {
      console.error('åŠ è½½æ¦œå•å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // åˆ‡æ¢æ¦œå•
  const handleTabChange = (type) => {
    setRankingType(type);
    loadRanking(type);
  };
  
  useEffect(() => {
    loadRanking(rankingType);
  }, []);
  
  return (
    <div className="ranking-container">
      {/* æ¦œå•åˆ‡æ¢Tab */}
      <div className="ranking-tabs">
        {rankingTabs.map(tab => (
          <button
            key={tab.type}
            className={rankingType === tab.type ? 'active' : ''}
            onClick={() => handleTabChange(tab.type)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      
      {/* æ¦œå•åˆ—è¡¨ */}
      <div className="ranking-list">
        {loading ? (
          <div className="loading">åŠ è½½ä¸­...</div>
        ) : (
          rankingData.map((item, index) => (
            <div key={item.book_id} className="ranking-item">
              <div className="rank-number">
                {index + 1}
              </div>
              <img
                src={item.cover_image_url}
                alt={item.title}
                className="book-cover"
              />
              <div className="book-info">
                <h3>{item.title}</h3>
                <p className="author">{item.author}</p>
                <div className="stats">
                  <span>çƒ­åº¦: {item.score}</span>
                  {item.trend && (
                    <span className={`trend ${item.trend}`}>
                      {item.trend === 'up' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </div>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

---

## 3. æœ€ä½³å®è·µ

### 3.1 è¯·æ±‚ä¼˜åŒ–

#### 3.1.1 ä½¿ç”¨é˜²æŠ–å’ŒèŠ‚æµ

```javascript
// æœç´¢é˜²æŠ–
import { debounce } from 'lodash';

const handleSearch = debounce(async (keyword) => {
  if (!keyword) return;
  
  const results = await searchBooks({ keyword });
  displaySearchResults(results);
}, 300);

// ä½¿ç”¨
<input
  type="text"
  @input="handleSearch($event.target.value)"
  placeholder="æœç´¢ä¹¦ç±..."
/>
```

#### 3.1.2 è¯·æ±‚å–æ¶ˆ

```javascript
import axios from 'axios';

let cancelTokenSource = null;

async function searchBooks(keyword) {
  // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
  if (cancelTokenSource) {
    cancelTokenSource.cancel('æ–°çš„æœç´¢è¯·æ±‚');
  }
  
  // åˆ›å»ºæ–°çš„å–æ¶ˆä»¤ç‰Œ
  cancelTokenSource = axios.CancelToken.source();
  
  try {
    const response = await apiClient.get('/bookstore/books/search', {
      params: { keyword },
      cancelToken: cancelTokenSource.token
    });
    
    return response.data;
  } catch (error) {
    if (axios.isCancel(error)) {
      console.log('è¯·æ±‚å·²å–æ¶ˆ:', error.message);
    } else {
      throw error;
    }
  }
}
```

#### 3.1.3 æ‰¹é‡è¯·æ±‚

```javascript
// æ‰¹é‡è·å–ä¹¦ç±è¯¦æƒ…
async function getBooksDetails(bookIds) {
  // ä½¿ç”¨Promise.allå¹¶è¡Œè¯·æ±‚
  try {
    const promises = bookIds.map(id =>
      apiClient.get(`/bookstore/books/${id}`)
    );
    
    const results = await Promise.all(promises);
    return results.map(r => r.data);
  } catch (error) {
    console.error('æ‰¹é‡è·å–å¤±è´¥:', error);
    throw error;
  }
}
```

### 3.2 ç¼“å­˜ç­–ç•¥

#### 3.2.1 å†…å­˜ç¼“å­˜

```javascript
class BookstoreCache {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  }
  
  set(key, value) {
    this.cache.set(key, {
      data: value,
      timestamp: Date.now()
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear() {
    this.cache.clear();
  }
}

const cache = new BookstoreCache();

// ä½¿ç”¨ç¼“å­˜
async function getBookWithCache(bookId) {
  const cacheKey = `book:${bookId}`;
  
  // å°è¯•ä»ç¼“å­˜è·å–
  let book = cache.get(cacheKey);
  if (book) {
    console.log('ä»ç¼“å­˜è·å–:', bookId);
    return book;
  }
  
  // ä»APIè·å–
  const response = await apiClient.get(`/bookstore/books/${bookId}`);
  book = response.data;
  
  // å­˜å…¥ç¼“å­˜
  cache.set(cacheKey, book);
  
  return book;
}
```

#### 3.2.2 LocalStorageç¼“å­˜

```javascript
class LocalStorageCache {
  constructor(prefix = 'bookstore') {
    this.prefix = prefix;
  }
  
  getKey(key) {
    return `${this.prefix}:${key}`;
  }
  
  set(key, value, ttl = 3600000) { // é»˜è®¤1å°æ—¶
    const item = {
      data: value,
      expiry: Date.now() + ttl
    };
    
    try {
      localStorage.setItem(
        this.getKey(key),
        JSON.stringify(item)
      );
    } catch (error) {
      console.error('LocalStorageå­˜å‚¨å¤±è´¥:', error);
    }
  }
  
  get(key) {
    try {
      const itemStr = localStorage.getItem(this.getKey(key));
      if (!itemStr) return null;
      
      const item = JSON.parse(itemStr);
      
      // æ£€æŸ¥è¿‡æœŸ
      if (Date.now() > item.expiry) {
        this.remove(key);
        return null;
      }
      
      return item.data;
    } catch (error) {
      console.error('LocalStorageè¯»å–å¤±è´¥:', error);
      return null;
    }
  }
  
  remove(key) {
    localStorage.removeItem(this.getKey(key));
  }
  
  clear() {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith(this.prefix + ':')) {
        localStorage.removeItem(key);
      }
    });
  }
}

const localCache = new LocalStorageCache();

// ä½¿ç”¨LocalStorageç¼“å­˜åˆ†ç±»æ ‘
async function getCategoryTreeWithCache() {
  const cacheKey = 'category_tree';
  
  // å°è¯•ä»ç¼“å­˜è·å–
  let tree = localCache.get(cacheKey);
  if (tree) {
    return tree;
  }
  
  // ä»APIè·å–
  const response = await apiClient.get('/bookstore/categories/tree');
  tree = response.data;
  
  // å­˜å…¥ç¼“å­˜ï¼ˆ1å°æ—¶ï¼‰
  localCache.set(cacheKey, tree, 3600000);
  
  return tree;
}
```

### 3.3 é”™è¯¯å¤„ç†

#### 3.3.1 ç»Ÿä¸€é”™è¯¯å¤„ç†

```javascript
// é”™è¯¯å¤„ç†å·¥å…·
class ErrorHandler {
  static handle(error, context = '') {
    console.error(`[${context}] é”™è¯¯:`, error);
    
    if (error.response) {
      // HTTPé”™è¯¯
      const { status, data } = error.response;
      
      switch (status) {
        case 400:
          return this.handleBadRequest(data);
        case 401:
          return this.handleUnauthorized();
        case 404:
          return this.handleNotFound(data);
        case 500:
          return this.handleServerError(data);
        default:
          return this.handleUnknownError(error);
      }
    } else if (error.request) {
      // ç½‘ç»œé”™è¯¯
      return this.handleNetworkError();
    } else {
      // å…¶ä»–é”™è¯¯
      return this.handleUnknownError(error);
    }
  }
  
  static handleBadRequest(data) {
    const message = data.message || 'è¯·æ±‚å‚æ•°é”™è¯¯';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleUnauthorized() {
    const message = 'è¯·å…ˆç™»å½•';
    showErrorNotification(message);
    // è·³è½¬åˆ°ç™»å½•é¡µ
    router.push('/login');
    return { success: false, message };
  }
  
  static handleNotFound(data) {
    const message = data.message || 'èµ„æºä¸å­˜åœ¨';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleServerError(data) {
    const message = 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleNetworkError() {
    const message = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
    showErrorNotification(message);
    return { success: false, message };
  }
  
  static handleUnknownError(error) {
    const message = 'æœªçŸ¥é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
    showErrorNotification(message);
    return { success: false, message };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function loadBook(bookId) {
  try {
    const response = await apiClient.get(`/bookstore/books/${bookId}`);
    return response.data;
  } catch (error) {
    ErrorHandler.handle(error, 'loadBook');
    return null;
  }
}
```

#### 3.3.2 é‡è¯•æœºåˆ¶

```javascript
async function fetchWithRetry(fetchFn, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchFn();
    } catch (error) {
      console.log(`å°è¯• ${i + 1}/${maxRetries} å¤±è´¥`);
      
      if (i === maxRetries - 1) {
        throw error;
      }
      
      // ç­‰å¾…åé‡è¯•
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // æŒ‡æ•°é€€é¿
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const book = await fetchWithRetry(
  () => apiClient.get(`/bookstore/books/${bookId}`),
  3,
  1000
);
```

### 3.4 æ€§èƒ½ç›‘æ§

#### è®°å½•APIæ€§èƒ½

```javascript
class APIMonitor {
  static async measureAPI(apiName, fetchFn) {
    const startTime = performance.now();
    
    try {
      const result = await fetchFn();
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.logPerformance(apiName, duration, 'success');
      
      return result;
    } catch (error) {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.logPerformance(apiName, duration, 'error');
      
      throw error;
    }
  }
  
  static logPerformance(apiName, duration, status) {
    console.log(`[APIæ€§èƒ½] ${apiName}: ${duration.toFixed(2)}ms [${status}]`);
    
    // å¯ä»¥ä¸ŠæŠ¥åˆ°ç›‘æ§ç³»ç»Ÿ
    if (window.analytics) {
      window.analytics.track('api_performance', {
        api: apiName,
        duration,
        status
      });
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const homepage = await APIMonitor.measureAPI(
  'getHomepage',
  () => apiClient.get('/bookstore/homepage')
);
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 å›¾ç‰‡ä¼˜åŒ–

#### 4.1.1 ä½¿ç”¨CDN

```javascript
function getOptimizedImageUrl(url, options = {}) {
  const {
    width = null,
    quality = 80,
    format = 'webp'
  } = options;
  
  if (!url) return '';
  
  // ä½¿ç”¨CDNå‚æ•°ä¼˜åŒ–å›¾ç‰‡
  const params = new URLSearchParams();
  if (width) params.append('w', width);
  params.append('q', quality);
  params.append('f', format);
  
  return `${url}?${params.toString()}`;
}

// ä½¿ç”¨ç¤ºä¾‹
<img
  :src="getOptimizedImageUrl(book.cover_image_url, { width: 300, quality: 80 })"
  :alt="book.title"
/>
```

#### 4.1.2 æ‡’åŠ è½½

```javascript
// ä½¿ç”¨Intersection Observerå®ç°å›¾ç‰‡æ‡’åŠ è½½
class LazyImageLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            const src = img.dataset.src;
            
            if (src) {
              img.src = src;
              img.removeAttribute('data-src');
              this.observer.unobserve(img);
            }
          }
        });
      },
      {
        rootMargin: '50px'
      }
    );
  }
  
  observe(img) {
    this.observer.observe(img);
  }
  
  disconnect() {
    this.observer.disconnect();
  }
}

const lazyLoader = new LazyImageLoader();

// ä½¿ç”¨ç¤ºä¾‹ï¼ˆVueï¼‰
<img
  v-lazy-load
  :data-src="book.cover_image_url"
  alt="book cover"
/>

// VueæŒ‡ä»¤
app.directive('lazy-load', {
  mounted(el) {
    lazyLoader.observe(el);
  }
});
```

### 4.2 åˆ—è¡¨ä¼˜åŒ–

#### è™šæ‹Ÿæ»šåŠ¨

```javascript
// ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–é•¿åˆ—è¡¨
import { useVirtualList } from '@vueuse/core';

function BookList({ books }) {
  const { list, containerProps, wrapperProps } = useVirtualList(
    books,
    {
      itemHeight: 100, // æ¯é¡¹é«˜åº¦
      overscan: 5 // é¢„æ¸²æŸ“é¡¹æ•°
    }
  );
  
  return (
    <div {...containerProps} style={{ height: '600px', overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.value.map(({ data, index }) => (
          <div key={index} style={{ height: '100px' }}>
            <BookCard book={data} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 4.3 é¢„åŠ è½½

#### é¢„åŠ è½½ä¸‹ä¸€ç« 

```javascript
// é˜…è¯»ç« èŠ‚æ—¶é¢„åŠ è½½ä¸‹ä¸€ç« 
async function loadChapterWithPrefetch(chapterId) {
  // åŠ è½½å½“å‰ç« èŠ‚
  const chapter = await loadChapter(chapterId);
  
  // é¢„åŠ è½½ä¸‹ä¸€ç« 
  prefetchNextChapter(chapterId);
  
  return chapter;
}

async function prefetchNextChapter(currentChapterId) {
  try {
    const response = await apiClient.get(`/chapters/${currentChapterId}/next`);
    const nextChapter = response.data;
    
    // é¢„åŠ è½½ä¸‹ä¸€ç« å†…å®¹ï¼ˆä¸ç­‰å¾…ï¼‰
    apiClient.get(`/chapters/${nextChapter.id}/content`)
      .then(response => {
        // å­˜å…¥ç¼“å­˜
        cache.set(`chapter:${nextChapter.id}`, response.data);
      })
      .catch(error => {
        console.warn('é¢„åŠ è½½ä¸‹ä¸€ç« å¤±è´¥:', error);
      });
  } catch (error) {
    // æ²¡æœ‰ä¸‹ä¸€ç« ï¼Œå¿½ç•¥é”™è¯¯
  }
}
```

---

## 5. é”™è¯¯å¤„ç†

### 5.1 å¸¸è§é”™è¯¯ç±»å‹

#### ç½‘ç»œé”™è¯¯

```javascript
if (error.message === 'Network Error') {
  showErrorNotification('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®');
}
```

#### è¶…æ—¶é”™è¯¯

```javascript
if (error.code === 'ECONNABORTED') {
  showErrorNotification('è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•');
}
```

#### 404é”™è¯¯

```javascript
if (error.response?.status === 404) {
  showErrorNotification('ä¹¦ç±ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶');
  router.push('/404');
}
```

### 5.2 é”™è¯¯ä¸ŠæŠ¥

```javascript
function reportError(error, context) {
  // ä¸ŠæŠ¥åˆ°é”™è¯¯ç›‘æ§ç³»ç»Ÿ
  if (window.Sentry) {
    window.Sentry.captureException(error, {
      tags: {
        component: context.component,
        api: context.api
      },
      extra: {
        params: context.params
      }
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
try {
  const book = await getBook(bookId);
} catch (error) {
  reportError(error, {
    component: 'BookDetail',
    api: 'getBook',
    params: { bookId }
  });
  
  ErrorHandler.handle(error);
}
```

---

## 6. å¸¸è§é—®é¢˜

### 6.1 å¦‚ä½•å¤„ç†VIPç« èŠ‚ï¼Ÿ

**é—®é¢˜**: ç”¨æˆ·ç‚¹å‡»VIPç« èŠ‚æ—¶å¦‚ä½•å¤„ç†æƒé™éªŒè¯ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**:

```javascript
async function loadChapter(chapterId) {
  try {
    const response = await apiClient.get(`/chapters/${chapterId}/content`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIPç« èŠ‚éœ€è¦æƒé™
      showVIPPrompt({
        title: 'è¯¥ç« èŠ‚éœ€è¦VIPæƒé™',
        message: 'å¼€é€šVIPå³å¯é˜…è¯»å…¨éƒ¨ç« èŠ‚',
        onConfirm: () => {
          router.push('/vip');
        }
      });
    } else {
      throw error;
    }
  }
}
```

### 6.2 å¦‚ä½•å®ç°é˜…è¯»è®°å½•ï¼Ÿ

**é—®é¢˜**: è®°å½•ç”¨æˆ·çš„é˜…è¯»è¿›åº¦å’Œå†å²ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```javascript
// ä¿å­˜é˜…è¯»è¿›åº¦åˆ°æœ¬åœ°
class ReadingHistory {
  static save(bookId, chapterId, progress) {
    const history = this.getAll();
    
    history[bookId] = {
      chapter_id: chapterId,
      progress: progress,
      timestamp: Date.now()
    };
    
    localStorage.setItem('reading_history', JSON.stringify(history));
  }
  
  static get(bookId) {
    const history = this.getAll();
    return history[bookId] || null;
  }
  
  static getAll() {
    const historyStr = localStorage.getItem('reading_history');
    return historyStr ? JSON.parse(historyStr) : {};
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// é˜…è¯»ç« èŠ‚æ—¶ä¿å­˜è¿›åº¦
function onChapterRead(bookId, chapterId, scrollProgress) {
  ReadingHistory.save(bookId, chapterId, scrollProgress);
}

// æ‰“å¼€ä¹¦ç±æ—¶æ¢å¤è¿›åº¦
function openBook(bookId) {
  const history = ReadingHistory.get(bookId);
  
  if (history) {
    // è·³è½¬åˆ°ä¸Šæ¬¡é˜…è¯»çš„ç« èŠ‚
    router.push(`/chapters/${history.chapter_id}`);
  } else {
    // è·³è½¬åˆ°ç¬¬ä¸€ç« 
    loadFirstChapter(bookId);
  }
}
```

### 6.3 å¦‚ä½•ä¼˜åŒ–æœç´¢ä½“éªŒï¼Ÿ

**é—®é¢˜**: æœç´¢æ—¶é¢‘ç¹è¯·æ±‚å¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```javascript
import { debounce } from 'lodash';

// ä½¿ç”¨é˜²æŠ– + ç¼“å­˜
const searchCache = new Map();

const debouncedSearch = debounce(async (keyword) => {
  // æ£€æŸ¥ç¼“å­˜
  if (searchCache.has(keyword)) {
    displayResults(searchCache.get(keyword));
    return;
  }
  
  // æ‰§è¡Œæœç´¢
  try {
    const results = await apiClient.get('/bookstore/books/search', {
      params: { keyword }
    });
    
    // å­˜å…¥ç¼“å­˜
    searchCache.set(keyword, results.data);
    
    // æ˜¾ç¤ºç»“æœ
    displayResults(results.data);
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
  }
}, 300);

// ä½¿ç”¨
<input
  type="text"
  @input="debouncedSearch($event.target.value)"
  placeholder="æœç´¢ä¹¦ç±..."
/>
```

### 6.4 å¦‚ä½•å¤„ç†åˆ†é¡µåŠ è½½ï¼Ÿ

**é—®é¢˜**: å®ç°æ— é™æ»šåŠ¨åˆ†é¡µåŠ è½½ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```javascript
// ä½¿ç”¨Intersection Observerå®ç°æ— é™æ»šåŠ¨
function useInfiniteScroll(loadMore) {
  const sentinel = ref(null);
  const loading = ref(false);
  const hasMore = ref(true);
  
  onMounted(() => {
    const observer = new IntersectionObserver(
      async (entries) => {
        const entry = entries[0];
        
        if (entry.isIntersecting && !loading.value && hasMore.value) {
          loading.value = true;
          
          try {
            const result = await loadMore();
            hasMore.value = result.hasMore;
          } catch (error) {
            console.error('åŠ è½½æ›´å¤šå¤±è´¥:', error);
          } finally {
            loading.value = false;
          }
        }
      },
      {
        rootMargin: '100px'
      }
    );
    
    if (sentinel.value) {
      observer.observe(sentinel.value);
    }
    
    onUnmounted(() => {
      observer.disconnect();
    });
  });
  
  return { sentinel, loading, hasMore };
}

// ä½¿ç”¨ç¤ºä¾‹
const books = ref([]);
const currentPage = ref(1);

async function loadMoreBooks() {
  const response = await apiClient.get('/bookstore/books/recommended', {
    params: {
      page: currentPage.value,
      size: 20
    }
  });
  
  books.value.push(...response.data);
  currentPage.value++;
  
  return {
    hasMore: response.data.length === 20
  };
}

const { sentinel, loading } = useInfiniteScroll(loadMoreBooks);
```

---

## é™„å½•

### A. å®Œæ•´ç¤ºä¾‹é¡¹ç›®

**é¡¹ç›®ç»“æ„**

```
bookstore-frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ client.js          # APIå®¢æˆ·ç«¯é…ç½®
â”‚   â”‚   â”œâ”€â”€ bookstore.js       # ä¹¦åŸAPI
â”‚   â”‚   â”œâ”€â”€ chapter.js         # ç« èŠ‚API
â”‚   â”‚   â””â”€â”€ ranking.js         # æ¦œå•API
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ cache.js           # ç¼“å­˜å·¥å…·
â”‚   â”‚   â”œâ”€â”€ error-handler.js   # é”™è¯¯å¤„ç†
â”‚   â”‚   â””â”€â”€ monitor.js         # æ€§èƒ½ç›‘æ§
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ BookCard.vue       # ä¹¦ç±å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ ChapterList.vue    # ç« èŠ‚åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ RankingList.vue    # æ¦œå•åˆ—è¡¨
â”‚   â””â”€â”€ views/
â”‚       â”œâ”€â”€ Homepage.vue       # é¦–é¡µ
â”‚       â”œâ”€â”€ BookDetail.vue     # ä¹¦ç±è¯¦æƒ…
â”‚       â””â”€â”€ ChapterReader.vue  # ç« èŠ‚é˜…è¯»
â””â”€â”€ package.json
```

### B. èµ„æºé“¾æ¥

- APIæ–‡æ¡£: [ä¹¦åŸç³»ç»ŸAPIæ–‡æ¡£](./ä¹¦åŸç³»ç»ŸAPIæ–‡æ¡£.md)
- Swaggeræ–‡æ¡£: `http://your-domain/swagger/index.html`
- æŠ€æœ¯æ”¯æŒ: dev@qingyu.com

---

**æ–‡æ¡£ç»´æŠ¤**: é’ç¾½å‰ç«¯å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-09

