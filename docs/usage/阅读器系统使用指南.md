# é˜…è¯»å™¨ç³»ç»Ÿä½¿ç”¨æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-09  
> **é€‚ç”¨å¯¹è±¡**: å‰ç«¯å¼€å‘è€…ã€ç§»åŠ¨ç«¯å¼€å‘è€…  
> **ç³»ç»Ÿç‰ˆæœ¬**: v1.0

## ğŸ“š ç›®å½•

- [1. å¿«é€Ÿå¼€å§‹](#1-å¿«é€Ÿå¼€å§‹)
- [2. å¸¸è§åœºæ™¯](#2-å¸¸è§åœºæ™¯)
- [3. æœ€ä½³å®è·µ](#3-æœ€ä½³å®è·µ)
- [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
- [5. å¸¸è§é—®é¢˜](#5-å¸¸è§é—®é¢˜)

---

## 1. å¿«é€Ÿå¼€å§‹

### 1.1 ç¯å¢ƒå‡†å¤‡

#### é…ç½®è®¤è¯

```javascript
import axios from 'axios';

// åˆ›å»ºAPIå®¢æˆ·ç«¯
const apiClient = axios.create({
  baseURL: 'http://your-domain/api/v1',
  timeout: 10000
});

// è¯·æ±‚æ‹¦æˆªå™¨ - æ·»åŠ Token
apiClient.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// å“åº”æ‹¦æˆªå™¨ - å¤„ç†é”™è¯¯
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      // Tokenè¿‡æœŸï¼Œè·³è½¬ç™»å½•
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### 1.2 ç¬¬ä¸€ä¸ªè¯·æ±‚

#### è·å–ç« èŠ‚å†…å®¹

```javascript
async function loadChapter(chapterId) {
  try {
    // è·å–ç« èŠ‚ä¿¡æ¯
    const chapterInfo = await apiClient.get(`/reader/chapters/${chapterId}`);
    
    // è·å–ç« èŠ‚å†…å®¹
    const contentRes = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    
    return {
      info: chapterInfo.data,
      content: contentRes.data.content
    };
  } catch (error) {
    if (error.response?.status === 403) {
      // VIPç« èŠ‚
      showVIPDialog();
    } else {
      console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', error);
    }
    throw error;
  }
}

// ä½¿ç”¨
loadChapter('507f1f77bcf86cd799439011')
  .then(({ info, content }) => {
    console.log('ç« èŠ‚æ ‡é¢˜:', info.title);
    console.log('ç« èŠ‚å†…å®¹:', content);
  });
```

---

## 2. å¸¸è§åœºæ™¯

### 2.1 åœºæ™¯ä¸€ï¼šå®ç°å®Œæ•´çš„é˜…è¯»å™¨

#### éœ€æ±‚æè¿°

å®ç°ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„é˜…è¯»å™¨ï¼ŒåŒ…æ‹¬ï¼š
- åŠ è½½ç« èŠ‚å†…å®¹
- è‡ªåŠ¨ä¿å­˜é˜…è¯»è¿›åº¦
- ç« èŠ‚å¯¼èˆªï¼ˆä¸Šä¸€ç« /ä¸‹ä¸€ç« ï¼‰
- ä¹¦ç­¾ã€é«˜äº®ã€ç¬”è®°åŠŸèƒ½
- ä¸ªæ€§åŒ–é˜…è¯»è®¾ç½®

#### å®ç°æ­¥éª¤

**æ­¥éª¤1ï¼šåˆ›å»ºé˜…è¯»å™¨ç»„ä»¶**

```vue
<template>
  <div class="reader-container" :style="readerStyle">
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <div class="reader-header">
      <button @click="goBack">è¿”å›</button>
      <h1>{{ chapterInfo?.title }}</h1>
      <button @click="toggleSettings">è®¾ç½®</button>
    </div>
    
    <!-- ç« èŠ‚å†…å®¹ -->
    <div 
      ref="contentRef"
      class="reader-content" 
      @mouseup="handleTextSelection"
      @scroll="handleScroll"
    >
      <div v-html="renderedContent"></div>
    </div>
    
    <!-- åº•éƒ¨å¯¼èˆª -->
    <div class="reader-footer">
      <button @click="goPrevChapter" :disabled="!hasPrev">ä¸Šä¸€ç« </button>
      <div class="progress">{{ (scrollProgress * 100).toFixed(0) }}%</div>
      <button @click="goNextChapter" :disabled="!hasNext">ä¸‹ä¸€ç« </button>
    </div>
    
    <!-- é€‰ä¸­æ–‡æœ¬å·¥å…·æ  -->
    <div v-if="selectedText" class="text-toolbar" :style="toolbarStyle">
      <button @click="createHighlight">é«˜äº®</button>
      <button @click="createNote">ç¬”è®°</button>
      <button @click="createBookmark">ä¹¦ç­¾</button>
    </div>
    
    <!-- è®¾ç½®é¢æ¿ -->
    <SettingsPanel 
      v-if="showSettings" 
      :settings="settings"
      @update="updateSettings"
      @close="showSettings = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { apiClient } from '@/utils/api';

const route = useRoute();
const router = useRouter();

// æ•°æ®çŠ¶æ€
const chapterInfo = ref(null);
const chapterContent = ref('');
const annotations = ref([]);
const settings = ref(null);
const scrollProgress = ref(0);
const selectedText = ref('');
const toolbarStyle = ref({});
const showSettings = ref(false);

// ç« èŠ‚å¯¼èˆª
const navigation = ref({
  prevChapter: null,
  nextChapter: null
});

// è®¡ç®—å±æ€§
const hasPrev = computed(() => !!navigation.value.prevChapter);
const hasNext = computed(() => !!navigation.value.nextChapter);

const readerStyle = computed(() => ({
  fontSize: `${settings.value?.fontSize || 16}px`,
  fontFamily: settings.value?.fontFamily || 'Microsoft YaHei',
  lineHeight: settings.value?.lineHeight || 1.8,
  backgroundColor: settings.value?.backgroundColor || '#FFFFFF',
  color: settings.value?.textColor || '#000000'
}));

const renderedContent = computed(() => {
  // å°†æ ‡æ³¨æ¸²æŸ“åˆ°å†…å®¹ä¸­
  let content = chapterContent.value;
  
  // åº”ç”¨é«˜äº®
  annotations.value
    .filter(a => a.type === 'highlight')
    .forEach(annotation => {
      const [start, end] = annotation.range.split('-').map(Number);
      // ç®€åŒ–å¤„ç†ï¼šå®é™…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
      content = highlightText(content, start, end);
    });
  
  return content;
});

// åŠ è½½ç« èŠ‚
async function loadChapter(chapterId) {
  try {
    // å¹¶è¡ŒåŠ è½½ç« èŠ‚ä¿¡æ¯ã€å†…å®¹ã€æ ‡æ³¨
    const [infoRes, contentRes, annotationsRes] = await Promise.all([
      apiClient.get(`/reader/chapters/${chapterId}`),
      apiClient.get(`/reader/chapters/${chapterId}/content`),
      apiClient.get(`/reader/annotations/chapter`, {
        params: {
          bookId: route.params.bookId,
          chapterId
        }
      })
    ]);
    
    chapterInfo.value = infoRes.data;
    chapterContent.value = contentRes.data.content;
    annotations.value = annotationsRes.data;
    
    // åŠ è½½ç« èŠ‚å¯¼èˆª
    loadNavigation();
    
    // æ¢å¤é˜…è¯»è¿›åº¦
    await restoreProgress();
  } catch (error) {
    if (error.response?.status === 403) {
      showVIPDialog();
    } else {
      console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', error);
    }
  }
}

// åŠ è½½ç« èŠ‚å¯¼èˆª
async function loadNavigation() {
  const res = await apiClient.get('/reader/chapters/navigation', {
    params: {
      bookId: route.params.bookId,
      chapterNum: chapterInfo.value.chapterNum
    }
  });
  
  navigation.value = res.data;
}

// æ¢å¤é˜…è¯»è¿›åº¦
async function restoreProgress() {
  const res = await apiClient.get(`/reader/progress/${route.params.bookId}`);
  const progress = res.data;
  
  if (progress && progress.chapterId === chapterInfo.value.id) {
    // æ»šåŠ¨åˆ°ä¸Šæ¬¡é˜…è¯»ä½ç½®
    setTimeout(() => {
      const contentEl = contentRef.value;
      contentEl.scrollTop = contentEl.scrollHeight * progress.progress;
    }, 100);
  }
}

// ç›‘å¬æ»šåŠ¨ï¼Œè®¡ç®—è¿›åº¦
const contentRef = ref(null);
const saveProgressTimer = ref(null);

function handleScroll(e) {
  const el = e.target;
  scrollProgress.value = el.scrollTop / (el.scrollHeight - el.clientHeight);
  
  // é˜²æŠ–ä¿å­˜è¿›åº¦
  if (saveProgressTimer.value) {
    clearTimeout(saveProgressTimer.value);
  }
  
  saveProgressTimer.value = setTimeout(() => {
    saveProgress();
  }, 2000);
}

// ä¿å­˜é˜…è¯»è¿›åº¦
async function saveProgress() {
  try {
    await apiClient.post('/reader/progress', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      progress: scrollProgress.value
    });
  } catch (error) {
    console.error('ä¿å­˜è¿›åº¦å¤±è´¥:', error);
  }
}

// æ–‡æœ¬é€‰æ‹©å¤„ç†
function handleTextSelection() {
  const selection = window.getSelection();
  const text = selection.toString().trim();
  
  if (text) {
    selectedText.value = text;
    
    // è®¡ç®—å·¥å…·æ ä½ç½®
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    
    toolbarStyle.value = {
      top: `${rect.top - 50}px`,
      left: `${rect.left + rect.width / 2}px`,
      transform: 'translateX(-50%)'
    };
  } else {
    selectedText.value = '';
  }
}

// åˆ›å»ºé«˜äº®
async function createHighlight() {
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'highlight',
      text: selectedText.value,
      range: getSelectionRange()
    });
    
    // åˆ·æ–°æ ‡æ³¨
    await loadAnnotations();
    selectedText.value = '';
  } catch (error) {
    console.error('åˆ›å»ºé«˜äº®å¤±è´¥:', error);
  }
}

// åˆ›å»ºç¬”è®°
async function createNote() {
  const note = prompt('è¯·è¾“å…¥ç¬”è®°å†…å®¹ï¼š');
  if (!note) return;
  
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'note',
      text: selectedText.value,
      note: note,
      range: getSelectionRange()
    });
    
    selectedText.value = '';
  } catch (error) {
    console.error('åˆ›å»ºç¬”è®°å¤±è´¥:', error);
  }
}

// åˆ›å»ºä¹¦ç­¾
async function createBookmark() {
  try {
    await apiClient.post('/reader/annotations', {
      bookId: route.params.bookId,
      chapterId: chapterInfo.value.id,
      type: 'bookmark'
    });
    
    alert('ä¹¦ç­¾å·²æ·»åŠ ');
  } catch (error) {
    console.error('åˆ›å»ºä¹¦ç­¾å¤±è´¥:', error);
  }
}

// ç« èŠ‚å¯¼èˆª
async function goPrevChapter() {
  if (navigation.value.prevChapter) {
    await loadChapter(navigation.value.prevChapter.id);
    contentRef.value.scrollTop = 0;
  }
}

async function goNextChapter() {
  if (navigation.value.nextChapter) {
    await loadChapter(navigation.value.nextChapter.id);
    contentRef.value.scrollTop = 0;
  }
}

// åŠ è½½é˜…è¯»è®¾ç½®
async function loadSettings() {
  const res = await apiClient.get('/reader/settings');
  settings.value = res.data;
}

// æ›´æ–°è®¾ç½®
async function updateSettings(newSettings) {
  try {
    await apiClient.put('/reader/settings', newSettings);
    settings.value = { ...settings.value, ...newSettings };
  } catch (error) {
    console.error('æ›´æ–°è®¾ç½®å¤±è´¥:', error);
  }
}

// è®°å½•é˜…è¯»æ—¶é•¿
let startTime = Date.now();
let readingDuration = 0;

const readingTimer = setInterval(() => {
  readingDuration = Math.floor((Date.now() - startTime) / 1000);
}, 1000);

// ç»„ä»¶æŒ‚è½½
onMounted(() => {
  loadSettings();
  loadChapter(route.params.chapterId);
});

// ç»„ä»¶å¸è½½
onUnmounted(() => {
  // ä¿å­˜è¿›åº¦å’Œæ—¶é•¿
  saveProgress();
  
  if (readingDuration > 0) {
    apiClient.put('/reader/progress/reading-time', {
      bookId: route.params.bookId,
      duration: readingDuration
    });
  }
  
  clearInterval(readingTimer);
});
</script>

<style scoped>
.reader-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.reader-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  border-bottom: 1px solid #eee;
}

.reader-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  line-height: inherit;
}

.reader-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  border-top: 1px solid #eee;
}

.text-toolbar {
  position: fixed;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 5px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  z-index: 1000;
}

.text-toolbar button {
  margin: 0 5px;
}
</style>
```

**æ­¥éª¤2ï¼šè¾…åŠ©å‡½æ•°**

```javascript
// è·å–é€‰ä¸­æ–‡æœ¬çš„èŒƒå›´
function getSelectionRange() {
  const selection = window.getSelection();
  if (!selection.rangeCount) return '';
  
  const range = selection.getRangeAt(0);
  const contentEl = contentRef.value;
  
  // è®¡ç®—ç›¸å¯¹äºå†…å®¹å®¹å™¨çš„ä½ç½®
  const preRange = range.cloneRange();
  preRange.selectNodeContents(contentEl);
  preRange.setEnd(range.startContainer, range.startOffset);
  
  const start = preRange.toString().length;
  const end = start + range.toString().length;
  
  return `${start}-${end}`;
}

// é«˜äº®æ–‡æœ¬
function highlightText(content, start, end) {
  return content.substring(0, start) +
    '<mark>' + content.substring(start, end) + '</mark>' +
    content.substring(end);
}

// æ˜¾ç¤ºVIPå¯¹è¯æ¡†
function showVIPDialog() {
  if (confirm('è¯¥ç« èŠ‚éœ€è¦VIPæƒé™ï¼Œæ˜¯å¦å‰å¾€å¼€é€šï¼Ÿ')) {
    router.push('/vip');
  }
}
```

---

### 2.2 åœºæ™¯äºŒï¼šå®ç°é˜…è¯»å†å²

#### éœ€æ±‚æè¿°

æ˜¾ç¤ºç”¨æˆ·çš„é˜…è¯»å†å²è®°å½•ï¼ŒåŒ…æ‹¬æœ€è¿‘é˜…è¯»å’Œæ‰€æœ‰å†å²ã€‚

#### å®ç°æ­¥éª¤

```vue
<template>
  <div class="reading-history">
    <!-- Tabåˆ‡æ¢ -->
    <div class="tabs">
      <button 
        :class="{ active: currentTab === 'recent' }"
        @click="currentTab = 'recent'"
      >
        æœ€è¿‘é˜…è¯»
      </button>
      <button 
        :class="{ active: currentTab === 'unfinished' }"
        @click="currentTab = 'unfinished'"
      >
        æœªè¯»å®Œ
      </button>
      <button 
        :class="{ active: currentTab === 'finished' }"
        @click="currentTab = 'finished'"
      >
        å·²è¯»å®Œ
      </button>
    </div>
    
    <!-- æœ€è¿‘é˜…è¯» -->
    <div v-if="currentTab === 'recent'" class="book-list">
      <div 
        v-for="progress in recentReading" 
        :key="progress.bookId"
        class="book-item"
        @click="continueReading(progress)"
      >
        <img :src="progress.bookCover" alt="å°é¢" />
        <div class="book-info">
          <h3>{{ progress.bookTitle }}</h3>
          <p>å·²è¯»è‡³ï¼š{{ progress.chapterTitle }}</p>
          <div class="progress-bar">
            <div 
              class="progress-fill" 
              :style="{ width: `${progress.progress * 100}%` }"
            ></div>
          </div>
          <p class="time">{{ formatTime(progress.lastReadAt) }}</p>
        </div>
      </div>
    </div>
    
    <!-- æœªè¯»å®Œ -->
    <div v-if="currentTab === 'unfinished'" class="book-list">
      <div 
        v-for="progress in unfinishedBooks" 
        :key="progress.bookId"
        class="book-item"
      >
        <!-- Similar structure -->
      </div>
    </div>
    
    <!-- å·²è¯»å®Œ -->
    <div v-if="currentTab === 'finished'" class="book-list">
      <div 
        v-for="progress in finishedBooks" 
        :key="progress.bookId"
        class="book-item"
      >
        <!-- Similar structure -->
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue';
import { useRouter } from 'vue-router';
import { apiClient } from '@/utils/api';

const router = useRouter();
const currentTab = ref('recent');
const recentReading = ref([]);
const unfinishedBooks = ref([]);
const finishedBooks = ref([]);

// åŠ è½½æœ€è¿‘é˜…è¯»
async function loadRecentReading() {
  const res = await apiClient.get('/reader/progress/recent', {
    params: { limit: 20 }
  });
  recentReading.value = res.data;
}

// åŠ è½½æœªè¯»å®Œä¹¦ç±
async function loadUnfinishedBooks() {
  const res = await apiClient.get('/reader/progress/unfinished');
  unfinishedBooks.value = res.data;
}

// åŠ è½½å·²è¯»å®Œä¹¦ç±
async function loadFinishedBooks() {
  const res = await apiClient.get('/reader/progress/finished');
  finishedBooks.value = res.data;
}

// ç»§ç»­é˜…è¯»
function continueReading(progress) {
  router.push({
    name: 'Reader',
    params: {
      bookId: progress.bookId,
      chapterId: progress.chapterId
    }
  });
}

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timestamp) {
  const date = new Date(timestamp);
  const now = new Date();
  const diff = now - date;
  
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  
  if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
  if (hours < 24) return `${hours}å°æ—¶å‰`;
  if (days < 7) return `${days}å¤©å‰`;
  
  return date.toLocaleDateString();
}

// Tabåˆ‡æ¢æ—¶åŠ è½½æ•°æ®
watch(currentTab, (newTab) => {
  if (newTab === 'recent' && !recentReading.value.length) {
    loadRecentReading();
  } else if (newTab === 'unfinished' && !unfinishedBooks.value.length) {
    loadUnfinishedBooks();
  } else if (newTab === 'finished' && !finishedBooks.value.length) {
    loadFinishedBooks();
  }
});

onMounted(() => {
  loadRecentReading();
});
</script>
```

---

### 2.3 åœºæ™¯ä¸‰ï¼šå®ç°ç¬”è®°ç®¡ç†

#### éœ€æ±‚æè¿°

å±•ç¤ºç”¨æˆ·çš„æ‰€æœ‰ç¬”è®°ï¼Œæ”¯æŒæœç´¢å’Œè·³è½¬ã€‚

#### å®ç°æ­¥éª¤

```vue
<template>
  <div class="notes-manager">
    <!-- æœç´¢æ  -->
    <div class="search-bar">
      <input 
        v-model="searchKeyword"
        type="text"
        placeholder="æœç´¢ç¬”è®°..."
        @input="debounceSearch"
      />
    </div>
    
    <!-- ç¬”è®°åˆ—è¡¨ -->
    <div class="notes-list">
      <div 
        v-for="note in notes" 
        :key="note.id"
        class="note-item"
        @click="jumpToNote(note)"
      >
        <div class="note-header">
          <h3>{{ note.bookTitle }}</h3>
          <span class="note-time">{{ formatDate(note.createdAt) }}</span>
        </div>
        <div class="note-content">
          <div class="original-text">
            <strong>åŸæ–‡ï¼š</strong>
            <p>{{ note.text }}</p>
          </div>
          <div class="note-text">
            <strong>ç¬”è®°ï¼š</strong>
            <p>{{ note.note }}</p>
          </div>
        </div>
        <div class="note-footer">
          <span>{{ note.chapterTitle }}</span>
          <button @click.stop="deleteNote(note.id)">åˆ é™¤</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { debounce } from 'lodash';
import { apiClient } from '@/utils/api';

const router = useRouter();
const searchKeyword = ref('');
const notes = ref([]);

// åŠ è½½æ‰€æœ‰ç¬”è®°
async function loadNotes(bookId) {
  const res = await apiClient.get('/reader/annotations/notes', {
    params: { bookId }
  });
  notes.value = res.data;
}

// æœç´¢ç¬”è®°
async function searchNotes() {
  if (!searchKeyword.value) {
    loadNotes();
    return;
  }
  
  const res = await apiClient.get('/reader/annotations/notes/search', {
    params: { keyword: searchKeyword.value }
  });
  notes.value = res.data;
}

// é˜²æŠ–æœç´¢
const debounceSearch = debounce(searchNotes, 300);

// è·³è½¬åˆ°ç¬”è®°ä½ç½®
function jumpToNote(note) {
  router.push({
    name: 'Reader',
    params: {
      bookId: note.bookId,
      chapterId: note.chapterId
    },
    query: {
      highlightAnnotation: note.id
    }
  });
}

// åˆ é™¤ç¬”è®°
async function deleteNote(noteId) {
  if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç¬”è®°å—ï¼Ÿ')) return;
  
  try {
    await apiClient.delete(`/reader/annotations/${noteId}`);
    notes.value = notes.value.filter(n => n.id !== noteId);
  } catch (error) {
    console.error('åˆ é™¤ç¬”è®°å¤±è´¥:', error);
  }
}

// æ ¼å¼åŒ–æ—¥æœŸ
function formatDate(timestamp) {
  return new Date(timestamp).toLocaleString();
}

onMounted(() => {
  loadNotes();
});
</script>
```

---

## 3. æœ€ä½³å®è·µ

### 3.1 è¿›åº¦ä¿å­˜ç­–ç•¥

#### 3.1.1 é˜²æŠ–ä¿å­˜

```javascript
// ä½¿ç”¨é˜²æŠ–é¿å…é¢‘ç¹è¯·æ±‚
const saveProgressDebounced = debounce(async (progress) => {
  await apiClient.post('/reader/progress', progress);
}, 2000);

// æ»šåŠ¨æ—¶è°ƒç”¨
function handleScroll() {
  const progress = calculateProgress();
  saveProgressDebounced(progress);
}
```

#### 3.1.2 æœ¬åœ°ç¼“å­˜ + å®šæ—¶åŒæ­¥

```javascript
class ProgressManager {
  constructor() {
    this.cache = new Map();
    this.syncInterval = null;
  }
  
  // æœ¬åœ°ä¿å­˜
  saveLocal(bookId, progress) {
    this.cache.set(bookId, {
      ...progress,
      timestamp: Date.now()
    });
    
    // åŒæ—¶ä¿å­˜åˆ°localStorage
    localStorage.setItem(
      `progress:${bookId}`,
      JSON.stringify(progress)
    );
  }
  
  // å®šæ—¶åŒæ­¥åˆ°æœåŠ¡å™¨
  startSync() {
    this.syncInterval = setInterval(() => {
      this.syncToServer();
    }, 30000); // æ¯30ç§’åŒæ­¥ä¸€æ¬¡
  }
  
  async syncToServer() {
    for (const [bookId, progress] of this.cache) {
      try {
        await apiClient.post('/reader/progress', progress);
        console.log(`åŒæ­¥è¿›åº¦æˆåŠŸ: ${bookId}`);
      } catch (error) {
        console.error(`åŒæ­¥è¿›åº¦å¤±è´¥: ${bookId}`, error);
      }
    }
  }
  
  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
}

// ä½¿ç”¨
const progressManager = new ProgressManager();
progressManager.startSync();

// é¡µé¢å¸è½½æ—¶åœæ­¢
window.addEventListener('beforeunload', () => {
  progressManager.stopSync();
  progressManager.syncToServer(); // ç«‹å³åŒæ­¥ä¸€æ¬¡
});
```

### 3.2 æ ‡æ³¨é«˜äº®æ¸²æŸ“

#### ä½¿ç”¨Range APIç²¾ç¡®å®šä½

```javascript
class AnnotationRenderer {
  constructor(container) {
    this.container = container;
  }
  
  // åº”ç”¨æ‰€æœ‰æ ‡æ³¨
  applyAnnotations(annotations) {
    annotations.forEach(annotation => {
      if (annotation.type === 'highlight') {
        this.highlightText(annotation);
      }
    });
  }
  
  // é«˜äº®æ–‡æœ¬
  highlightText(annotation) {
    const [start, end] = annotation.range.split('-').map(Number);
    
    const textNodes = this.getTextNodes(this.container);
    let currentPos = 0;
    
    for (const node of textNodes) {
      const nodeLength = node.textContent.length;
      
      if (currentPos + nodeLength < start) {
        currentPos += nodeLength;
        continue;
      }
      
      if (currentPos > end) {
        break;
      }
      
      const rangeStart = Math.max(0, start - currentPos);
      const rangeEnd = Math.min(nodeLength, end - currentPos);
      
      if (rangeStart < rangeEnd) {
        const range = document.createRange();
        range.setStart(node, rangeStart);
        range.setEnd(node, rangeEnd);
        
        const mark = document.createElement('mark');
        mark.className = 'highlight';
        mark.dataset.annotationId = annotation.id;
        
        range.surroundContents(mark);
      }
      
      currentPos += nodeLength;
    }
  }
  
  // è·å–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
  getTextNodes(element) {
    const textNodes = [];
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    return textNodes;
  }
}

// ä½¿ç”¨
const renderer = new AnnotationRenderer(contentElement);
renderer.applyAnnotations(annotations);
```

### 3.3 é˜…è¯»è®¾ç½®æŒä¹…åŒ–

```javascript
class SettingsManager {
  static DEFAULTS = {
    fontSize: 16,
    fontFamily: 'Microsoft YaHei',
    lineHeight: 1.8,
    backgroundColor: '#FFFFFF',
    textColor: '#000000',
    pageMode: 'scroll',
    autoSave: true,
    showProgress: true
  };
  
  // è·å–è®¾ç½®ï¼ˆæœ¬åœ°ä¼˜å…ˆï¼‰
  static async getSettings() {
    // å…ˆä»localStorageè·å–
    const localSettings = localStorage.getItem('readerSettings');
    if (localSettings) {
      return JSON.parse(localSettings);
    }
    
    // ä»æœåŠ¡å™¨è·å–
    try {
      const res = await apiClient.get('/reader/settings');
      const settings = res.data || this.DEFAULTS;
      
      // ä¿å­˜åˆ°æœ¬åœ°
      localStorage.setItem('readerSettings', JSON.stringify(settings));
      
      return settings;
    } catch (error) {
      return this.DEFAULTS;
    }
  }
  
  // æ›´æ–°è®¾ç½®
  static async updateSettings(updates) {
    // ç«‹å³æ›´æ–°æœ¬åœ°
    const current = JSON.parse(localStorage.getItem('readerSettings')) || {};
    const newSettings = { ...current, ...updates };
    localStorage.setItem('readerSettings', JSON.stringify(newSettings));
    
    // å¼‚æ­¥åŒæ­¥åˆ°æœåŠ¡å™¨
    try {
      await apiClient.put('/reader/settings', updates);
    } catch (error) {
      console.error('åŒæ­¥è®¾ç½®å¤±è´¥:', error);
    }
    
    return newSettings;
  }
}
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 ç« èŠ‚é¢„åŠ è½½

```javascript
class ChapterPreloader {
  constructor() {
    this.cache = new Map();
    this.preloading = new Set();
  }
  
  // é¢„åŠ è½½ä¸‹ä¸€ç« 
  async preloadNext(bookId, currentChapterNum) {
    const nextChapterNum = currentChapterNum + 1;
    const cacheKey = `${bookId}:${nextChapterNum}`;
    
    if (this.cache.has(cacheKey) || this.preloading.has(cacheKey)) {
      return;
    }
    
    this.preloading.add(cacheKey);
    
    try {
      // è·å–ä¸‹ä¸€ç« ä¿¡æ¯
      const navRes = await apiClient.get('/reader/chapters/navigation', {
        params: { bookId, chapterNum: currentChapterNum }
      });
      
      const nextChapter = navRes.data.nextChapter;
      if (!nextChapter) return;
      
      // é¢„åŠ è½½å†…å®¹
      const contentRes = await apiClient.get(
        `/reader/chapters/${nextChapter.id}/content`
      );
      
      this.cache.set(cacheKey, {
        info: nextChapter,
        content: contentRes.data.content,
        timestamp: Date.now()
      });
      
      console.log(`é¢„åŠ è½½å®Œæˆ: ç¬¬${nextChapterNum}ç« `);
    } catch (error) {
      console.error('é¢„åŠ è½½å¤±è´¥:', error);
    } finally {
      this.preloading.delete(cacheKey);
    }
  }
  
  // è·å–ç¼“å­˜
  getCache(bookId, chapterNum) {
    const cacheKey = `${bookId}:${chapterNum}`;
    const cached = this.cache.get(cacheKey);
    
    if (!cached) return null;
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸï¼ˆ10åˆ†é’Ÿï¼‰
    if (Date.now() - cached.timestamp > 600000) {
      this.cache.delete(cacheKey);
      return null;
    }
    
    return cached;
  }
  
  // æ¸…ç†ç¼“å­˜
  clearCache() {
    this.cache.clear();
  }
}

// ä½¿ç”¨
const preloader = new ChapterPreloader();

// åŠ è½½ç« èŠ‚æ—¶è§¦å‘é¢„åŠ è½½
async function loadChapter(bookId, chapterId, chapterNum) {
  // å°è¯•ä»ç¼“å­˜è·å–
  const cached = preloader.getCache(bookId, chapterNum);
  if (cached) {
    displayChapter(cached);
  } else {
    // æ­£å¸¸åŠ è½½
    await normalLoadChapter(bookId, chapterId);
  }
  
  // é¢„åŠ è½½ä¸‹ä¸€ç« 
  preloader.preloadNext(bookId, chapterNum);
}
```

### 4.2 è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–é•¿ç« èŠ‚

```javascript
import { useVirtualList } from '@vueuse/core';

function LongChapterReader({ paragraphs }) {
  const { list, containerProps, wrapperProps } = useVirtualList(
    paragraphs,
    {
      itemHeight: 100, // ä¼°è®¡æ¯æ®µè½é«˜åº¦
      overscan: 5
    }
  );
  
  return (
    <div {...containerProps} style={{ height: '600px', overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.value.map(({ data, index }) => (
          <p key={index} style={{ minHeight: '100px' }}>
            {data}
          </p>
        ))}
      </div>
    </div>
  );
}
```

---

## 5. å¸¸è§é—®é¢˜

### 5.1 å¦‚ä½•å¤„ç†VIPç« èŠ‚ï¼Ÿ

**é—®é¢˜**: ç”¨æˆ·ç‚¹å‡»VIPç« èŠ‚æ—¶å¦‚ä½•å¤„ç†ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**:

```javascript
async function loadChapter(chapterId) {
  try {
    const res = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    return res.data.content;
  } catch (error) {
    if (error.response?.status === 403) {
      // VIPç« èŠ‚
      const confirmed = await showVIPDialog({
        title: 'è¯¥ç« èŠ‚éœ€è¦VIPæƒé™',
        message: 'å¼€é€šVIPå³å¯æ— é™ç•…è¯»',
        confirmText: 'ç«‹å³å¼€é€š'
      });
      
      if (confirmed) {
        router.push('/vip');
      }
    } else {
      throw error;
    }
  }
}
```

### 5.2 å¦‚ä½•å®ç°ç¦»çº¿é˜…è¯»ï¼Ÿ

**é—®é¢˜**: æ”¯æŒç”¨æˆ·ä¸‹è½½ç« èŠ‚ç¦»çº¿é˜…è¯»ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```javascript
class OfflineManager {
  constructor() {
    this.db = null;
    this.initDB();
  }
  
  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('ReaderDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        if (!db.objectStoreNames.contains('chapters')) {
          db.createObjectStore('chapters', { keyPath: 'id' });
        }
      };
    });
  }
  
  // ä¸‹è½½ç« èŠ‚
  async downloadChapter(chapterId) {
    const content = await apiClient.get(`/reader/chapters/${chapterId}/content`);
    
    const transaction = this.db.transaction(['chapters'], 'readwrite');
    const store = transaction.objectStore('chapters');
    
    await store.put({
      id: chapterId,
      content: content.data.content,
      downloadedAt: Date.now()
    });
  }
  
  // è·å–ç¦»çº¿ç« èŠ‚
  async getOfflineChapter(chapterId) {
    const transaction = this.db.transaction(['chapters'], 'readonly');
    const store = transaction.objectStore('chapters');
    
    return new Promise((resolve, reject) => {
      const request = store.get(chapterId);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```

### 5.3 å¦‚ä½•å®ç°é˜…è¯»ç»Ÿè®¡çœ‹æ¿ï¼Ÿ

**é—®é¢˜**: å±•ç¤ºç”¨æˆ·çš„é˜…è¯»æ•°æ®ç»Ÿè®¡ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```vue
<template>
  <div class="reading-stats">
    <div class="stat-card">
      <h3>æ€»é˜…è¯»æ—¶é•¿</h3>
      <p class="stat-value">{{ formatDuration(stats.totalReadingTime) }}</p>
    </div>
    
    <div class="stat-card">
      <h3>æœ¬å‘¨é˜…è¯»</h3>
      <p class="stat-value">{{ formatDuration(stats.weekReadingTime) }}</p>
    </div>
    
    <div class="stat-card">
      <h3>å·²è¯»ä¹¦ç±</h3>
      <p class="stat-value">{{ stats.finishedCount }}æœ¬</p>
    </div>
    
    <div class="stat-card">
      <h3>åœ¨è¯»ä¹¦ç±</h3>
      <p class="stat-value">{{ stats.unfinishedCount }}æœ¬</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { apiClient } from '@/utils/api';

const stats = ref({
  totalReadingTime: 0,
  weekReadingTime: 0,
  finishedCount: 0,
  unfinishedCount: 0
});

async function loadStats() {
  // å¹¶è¡ŒåŠ è½½ç»Ÿè®¡æ•°æ®
  const [totalRes, weekRes] = await Promise.all([
    apiClient.get('/reader/progress/stats', { params: { period: 'all' } }),
    apiClient.get('/reader/progress/stats', { params: { period: 'week' } })
  ]);
  
  stats.value = {
    totalReadingTime: totalRes.data.totalReadingTime,
    weekReadingTime: weekRes.data.totalReadingTime,
    finishedCount: totalRes.data.finishedCount,
    unfinishedCount: totalRes.data.unfinishedCount
  };
}

function formatDuration(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  
  if (hours > 0) {
    return `${hours}å°æ—¶${minutes}åˆ†é’Ÿ`;
  }
  return `${minutes}åˆ†é’Ÿ`;
}

onMounted(() => {
  loadStats();
});
</script>
```

---

## é™„å½•

### A. å®Œæ•´ç¤ºä¾‹é¡¹ç›®ç»“æ„

```
reader-frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ chapter.js       # ç« èŠ‚API
â”‚   â”‚   â”œâ”€â”€ progress.js      # è¿›åº¦API
â”‚   â”‚   â”œâ”€â”€ annotation.js    # æ ‡æ³¨API
â”‚   â”‚   â””â”€â”€ settings.js      # è®¾ç½®API
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Reader.vue       # é˜…è¯»å™¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ChapterNav.vue   # ç« èŠ‚å¯¼èˆª
â”‚   â”‚   â”œâ”€â”€ AnnotationTool.vue  # æ ‡æ³¨å·¥å…·
â”‚   â”‚   â””â”€â”€ SettingsPanel.vue   # è®¾ç½®é¢æ¿
â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”œâ”€â”€ ReaderPage.vue      # é˜…è¯»é¡µé¢
â”‚   â”‚   â”œâ”€â”€ HistoryPage.vue     # å†å²è®°å½•
â”‚   â”‚   â””â”€â”€ NotesPage.vue       # ç¬”è®°ç®¡ç†
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ preloader.js        # é¢„åŠ è½½
â”‚   â”‚   â”œâ”€â”€ progress.js         # è¿›åº¦ç®¡ç†
â”‚   â”‚   â””â”€â”€ offline.js          # ç¦»çº¿ç®¡ç†
â”‚   â””â”€â”€ stores/
â”‚       â”œâ”€â”€ reader.js           # é˜…è¯»å™¨çŠ¶æ€
â”‚       â””â”€â”€ settings.js         # è®¾ç½®çŠ¶æ€
â””â”€â”€ package.json
```

### B. èµ„æºé“¾æ¥

- APIæ–‡æ¡£: [é˜…è¯»å™¨ç³»ç»ŸAPIæ–‡æ¡£](./é˜…è¯»å™¨ç³»ç»ŸAPIæ–‡æ¡£.md)
- Swaggeræ–‡æ¡£: `http://your-domain/swagger/index.html`

---

**æ–‡æ¡£ç»´æŠ¤**: é’ç¾½å‰ç«¯å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-09

