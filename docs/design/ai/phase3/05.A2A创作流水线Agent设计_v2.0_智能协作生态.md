# A2A åˆ›ä½œæµæ°´çº¿ Agent è®¾è®¡ v2.0 - æ™ºèƒ½åä½œç”Ÿæ€

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-28  
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ  
> **è´Ÿè´£äºº**: AIæ¶æ„ç»„  
> **æ”¹è¿›ç†å¿µ**: ä»æµæ°´çº¿åˆ°åä½œç”Ÿæ€

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ˜¯ A2A åˆ›ä½œæµæ°´çº¿çš„ v2.0 ç‰ˆæœ¬ï¼Œåœ¨ v1.0 åŸºç¡€ä¸Šå¼•å…¥äº†**åæ€å¾ªç¯ã€è§„åˆ’Agentã€æ·±åº¦RAGé›†æˆã€çŸ¥è¯†å›¾è°±**ç­‰å‰æ²¿ç†å¿µï¼Œå°†å›ºå®šæµæ°´çº¿æ¼”è¿›ä¸º**åŠ¨æ€åä½œç”Ÿæ€**ã€‚

**æ ¸å¿ƒæ”¹è¿›**ï¼š
- âœ… **åæ€ä¸è‡ªæˆ‘ä¿®æ­£å¾ªç¯**ï¼šå€Ÿé‰´ Reflexion è®ºæ–‡ï¼Œå®ç°æ·±åº¦åé¦ˆå’Œæ™ºèƒ½ä¿®æ­£
- âœ… **è§„åˆ’ Agent**ï¼šåŠ¨æ€ä»»åŠ¡åˆ†è§£å’Œæ‰§è¡Œè®¡åˆ’ç”Ÿæˆ
- âœ… **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**ï¼šå€Ÿé‰´ Cursorï¼Œå®ç°ä¸»åŠ¨ä¸Šä¸‹æ–‡å·¥å…·
- âœ… **ç»“æ„åŒ–RAG**ï¼šå…ƒæ•°æ®å¢å¼º + æ··åˆæ£€ç´¢
- âœ… **çŸ¥è¯†å›¾è°±é›†æˆ**ï¼šå®ä½“å…³ç³»æ¨ç† + å‘é‡æ£€ç´¢ç»“åˆ
- âœ… **MCPå·¥å…·èŒƒå¼**ï¼šæ ‡å‡†åŒ–å·¥å…·è°ƒç”¨ï¼Œæ˜“äºæ‰©å±•

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### v2.0 æ ¸å¿ƒç›®æ ‡

1. **è‡ªä¸»æ€§**ï¼šAgent èƒ½å¤Ÿè‡ªä¸»åæ€ã€è§„åˆ’å’Œä¿®æ­£
2. **æ™ºèƒ½æ€§**ï¼šæ·±åº¦ç†è§£ä¸Šä¸‹æ–‡ï¼Œæ™ºèƒ½é€‰æ‹©ç­–ç•¥
3. **åä½œæ€§**ï¼šAgent é—´åŠ¨æ€åä½œï¼Œä¸å†æ˜¯å›ºå®šæµç¨‹
4. **å¯æ‰©å±•**ï¼šæ˜“äºæ·»åŠ æ–° Agentã€æ–°å·¥å…·ã€æ–°çŸ¥è¯†æº
5. **å¯è§‚æµ‹**ï¼šå®Œæ•´çš„æ¨ç†é“¾è·¯å’Œå†³ç­–è®°å½•

### v1.0 vs v2.0 å¯¹æ¯”

| ç»´åº¦ | v1.0 (æµæ°´çº¿) | v2.0 (åä½œç”Ÿæ€) |
|------|--------------|----------------|
| **æµç¨‹** | å›ºå®šé¡ºåºï¼ˆå¤§çº²â†’è§’è‰²â†’æƒ…èŠ‚â†’å®¡æ ¸ï¼‰ | åŠ¨æ€è§„åˆ’ï¼ˆæ ¹æ®éœ€æ±‚è°ƒæ•´ï¼‰ |
| **å®¡æ ¸** | ç®€å• pass/fail | ç»“æ„åŒ–è¯Šæ–­æŠ¥å‘Š + ä¿®æ­£æŒ‡ä»¤ |
| **é‡è¯•** | ä»å›ºå®šèŠ‚ç‚¹é‡å¯ | æ™ºèƒ½å®šä½é—®é¢˜ + é’ˆå¯¹æ€§ä¿®æ­£ |
| **ä¸Šä¸‹æ–‡** | è¢«åŠ¨RAGæ£€ç´¢ | ä¸»åŠ¨ä¸Šä¸‹æ–‡æ„ŸçŸ¥å·¥å…· |
| **å·¥å…·** | LangChain Native | MCPæ ‡å‡†åŒ– + LangChainæ··åˆ |
| **çŸ¥è¯†** | çº¯å‘é‡æ£€ç´¢ | çŸ¥è¯†å›¾è°± + å‘é‡æ··åˆ |

---

## ä¸€ã€æ•´ä½“æ¶æ„æ¼”è¿›

### 1.1 v2.0 åä½œç”Ÿæ€æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    A2A æ™ºèƒ½åä½œç”Ÿæ€ v2.0                           â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    ğŸ§  è§„åˆ’ Agent (Planner)                    â”‚ â”‚
â”‚  â”‚  - åˆ†æç”¨æˆ·éœ€æ±‚                                               â”‚ â”‚
â”‚  â”‚  - åŠ¨æ€ä»»åŠ¡åˆ†è§£                                               â”‚ â”‚
â”‚  â”‚  - ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ï¼ˆAgentåºåˆ— + å·¥å…·é›†ï¼‰                         â”‚ â”‚
â”‚  â”‚  - å®æ—¶è°ƒæ•´è®¡åˆ’                                               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                     â”‚                                              â”‚
â”‚                     â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              ğŸ“‹ ä¸Šä¸‹æ–‡æ„ŸçŸ¥å±‚ (Context Awareness)              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  WorkspaceContextTool - ä¸»åŠ¨è·å–å½“å‰ä»»åŠ¡ç›¸å…³ä¸Šä¸‹æ–‡       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - è‡ªåŠ¨åŠ è½½ï¼šå‰åºç« èŠ‚ + è§’è‰²å¡ + å¤§çº²èŠ‚ç‚¹ + ä¸–ç•Œè®¾å®š     â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ç»“æ„åŒ–è¿”å›ï¼šæŒ‰ç±»å‹ç»„ç»‡ï¼Œæ˜“äºLLMç†è§£                  â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                     â”‚                                              â”‚
â”‚                     â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              ğŸ”„ ä¸“ä¸š Agent åä½œå±‚                            â”‚  â”‚
â”‚  â”‚                                                               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚ å¤§çº²Agentâ”‚  â”‚ è§’è‰²Agentâ”‚  â”‚ æƒ…èŠ‚Agentâ”‚  â”‚ é£æ ¼Agentâ”‚   â”‚  â”‚
â”‚  â”‚  â”‚          â”‚  â”‚          â”‚  â”‚          â”‚  â”‚  (æ‰©å±•)  â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚       â”‚             â”‚             â”‚             â”‚          â”‚  â”‚
â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚  â”‚
â”‚  â”‚                          â”‚                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                      â”‚
â”‚                             â–¼                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚          ğŸ” å®¡æ ¸ Agent (Review with Reflection)              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  ç»“æ„åŒ–è¯Šæ–­æŠ¥å‘Šç”Ÿæˆ                                     â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - é—®é¢˜æ ¹å› åˆ†æï¼ˆä¸æ˜¯ç®€å•çš„ "è§’è‰²Aç¼ºå¤±"ï¼‰              â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - å…·ä½“ä¿®æ­£æŒ‡ä»¤ï¼ˆ"ä¸ºè§’è‰²Aå¢åŠ 'ä¼˜æŸ”å¯¡æ–­'å¼±ç‚¹"ï¼‰         â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ä¿®æ­£ç­–ç•¥ï¼ˆé‡æ–°ç”Ÿæˆ vs å¢é‡ä¿®æ”¹ï¼‰                    â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                     â”‚                                              â”‚
â”‚                     â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚       ğŸ¯ å…ƒè°ƒåº¦å™¨ (Meta-Scheduler / Regenerate Router)       â”‚ â”‚
â”‚  â”‚  - è§£æè¯Šæ–­æŠ¥å‘Š                                               â”‚ â”‚
â”‚  â”‚  - æ™ºèƒ½å®šä½é—®é¢˜Agent                                          â”‚ â”‚
â”‚  â”‚  - ç”Ÿæˆä¿®æ­£Promptï¼ˆå¢å¼ºç‰ˆï¼ŒåŒ…å«è¯Šæ–­ç»“æœï¼‰                     â”‚ â”‚
â”‚  â”‚  - å†³å®šä¿®æ­£èŒƒå›´ï¼ˆå…¨é‡é‡ç”Ÿæˆ vs å¢é‡ä¿®æ”¹ï¼‰                     â”‚ â”‚
â”‚  â”‚  - è¿­ä»£æ¬¡æ•°æ§åˆ¶ + è‡ªåŠ¨é™çº§ï¼ˆäººå·¥ä»‹å…¥ï¼‰                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                     â”‚                                              â”‚
â”‚                     â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              ğŸ› ï¸ å·¥å…·ä¸çŸ¥è¯†å±‚                                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  MCPæ ‡å‡†åŒ–å·¥å…·ï¼ˆæ˜“äºè§£è€¦å’Œæ‰©å±•ï¼‰                        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - CharacterTool, OutlineTool, TimelineTool            â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - LangChain Tool Wrapper                              â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  çŸ¥è¯†å›¾è°± + å‘é‡æ£€ç´¢æ··åˆå¼•æ“                            â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - å›¾æŸ¥è¯¢ï¼šå…³ç³»æ¨ç†ï¼ˆè§’è‰²Açš„æœ‹å‹ âˆ© å»è¿‡åœ°ç‚¹Bçš„è§’è‰²ï¼‰   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - å‘é‡æŸ¥è¯¢ï¼šè¯­ä¹‰ç›¸ä¼¼ï¼ˆæ€§æ ¼æè¿°åŒ¹é…ï¼‰                  â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ç»“æœèåˆï¼šç²¾å‡†å…³ç³» + è¯­ä¹‰ç›¸ä¼¼                       â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€æ ¸å¿ƒæ”¹è¿› 1ï¼šåæ€ä¸è‡ªæˆ‘ä¿®æ­£å¾ªç¯

### 2.1 å¢å¼ºçš„å®¡æ ¸ Agentï¼ˆæ·±åº¦è¯Šæ–­ï¼‰

```python
# src/core/agents/nodes/review_agent_v2.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from dataclasses import dataclass
import json

@dataclass
class DiagnosticReport:
    """è¯Šæ–­æŠ¥å‘Š"""
    passed: bool
    quality_score: int  # 0-100
    
    # é—®é¢˜åˆ†æï¼ˆç»“æ„åŒ–ï¼‰
    issues: List[Dict[str, Any]]  # [{"severity": "high", "category": "character", "root_cause": "...", "affected_entities": [...]}]
    
    # ä¿®æ­£ç­–ç•¥
    correction_strategy: str  # "regenerate", "incremental_fix", "human_review"
    correction_instructions: List[Dict[str, Any]]  # æ¯ä¸ªé—®é¢˜çš„å…·ä½“ä¿®æ­£æŒ‡ä»¤
    
    # å—å½±å“çš„ Agent
    affected_agents: List[str]  # ["character_agent", "plot_agent"]
    
    # æ¨ç†è¿‡ç¨‹ï¼ˆå¯è¿½æº¯ï¼‰
    reasoning_chain: List[str]


async def review_agent_node_v2(state: PipelineState) -> PipelineState:
    """å®¡æ ¸ Agent v2.0 - æ·±åº¦è¯Šæ–­å’Œç»“æ„åŒ–æŠ¥å‘Š
    
    æ”¹è¿›ç‚¹ï¼š
    1. ç”Ÿæˆç»“æ„åŒ–è¯Šæ–­æŠ¥å‘Šï¼ˆä¸åªæ˜¯ç®€å•çš„ pass/failï¼‰
    2. é—®é¢˜æ ¹å› åˆ†æï¼ˆä¸åªæ˜¯è¡¨é¢é—®é¢˜ï¼‰
    3. å…·ä½“ä¿®æ­£æŒ‡ä»¤ï¼ˆå¯æ‰§è¡Œçš„ã€é’ˆå¯¹æ€§çš„ï¼‰
    4. å—å½±å“ Agent è¯†åˆ«
    """
    logger.info("Review Agent v2.0: Starting deep diagnostic review...")
    
    # æ”¶é›†æ‰€æœ‰è¾“å‡º
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    timeline_events = state.get("timeline_events", [])
    
    # ===== Step 1: æ·±åº¦è¯Šæ–­åˆ†æ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å†…å®¹å®¡æ ¸ä¸“å®¶å’Œè¯Šæ–­å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ·±åº¦åˆ†æåˆ›ä½œå†…å®¹ï¼Œæä¾›ç»“æ„åŒ–çš„è¯Šæ–­æŠ¥å‘Šã€‚

## å®¡æ ¸ç»´åº¦
1. **ä¸€è‡´æ€§ (Consistency)**: å¤§çº²ã€è§’è‰²ã€æƒ…èŠ‚æ˜¯å¦ä¸€è‡´
2. **å®Œæ•´æ€§ (Completeness)**: æ˜¯å¦ç¼ºå°‘å…³é”®å…ƒç´ 
3. **åˆç†æ€§ (Rationality)**: è®¾å®šæ˜¯å¦åˆç†ã€é€»è¾‘æ˜¯å¦è‡ªæ´½
4. **è´¨é‡ (Quality)**: å†…å®¹æ·±åº¦ã€åˆ›æ„æ€§

## è¯Šæ–­è¦æ±‚
- **é—®é¢˜æ ¹å› åˆ†æ**ï¼šä¸åªæ˜¯è¯´"è§’è‰²Aç¼ºå¤±"ï¼Œè€Œæ˜¯è¯´"è§’è‰²Aåœ¨å¤§çº²ç¬¬ä¸‰ç« è¢«æåŠä½†æœªå®šä¹‰"
- **å…·ä½“ä¿®æ­£æŒ‡ä»¤**ï¼šä¸åªæ˜¯è¯´"è¡¥å……è§’è‰²"ï¼Œè€Œæ˜¯è¯´"ä¸ºè§’è‰²'å¼ ä¸‰'å¢åŠ æ€§æ ¼å¼±ç‚¹'ä¼˜æŸ”å¯¡æ–­'ï¼Œå¹¶åœ¨èƒŒæ™¯æ•…äº‹ä¸­ä½“ç°"
- **å—å½±å“åˆ†æ**ï¼šæ˜ç¡®æŒ‡å‡ºå“ªäº› Agent çš„è¾“å‡ºéœ€è¦ä¿®æ­£

## è¾“å‡ºæ ¼å¼ï¼šJSON
{
  "passed": false,
  "quality_score": 65,
  "issues": [
    {
      "id": "issue-001",
      "severity": "high",  // high, medium, low
      "category": "consistency",  // consistency, completeness, rationality, quality
      "sub_category": "character",  // character, outline, plot, timeline
      "title": "è§’è‰²å®šä¹‰ç¼ºå¤±",
      "root_cause": "è§’è‰²'æå››'åœ¨å¤§çº²ç¬¬ä¸‰ç« 'ä¸»è§’ä¸æå››ç›¸é‡'ä¸­è¢«æåŠï¼Œä½†è§’è‰²åˆ—è¡¨ä¸­æœªæ‰¾åˆ°è¯¥è§’è‰²çš„å®šä¹‰",
      "affected_entities": ["å¤§çº²èŠ‚ç‚¹ï¼šç¬¬ä¸‰ç« ", "è§’è‰²åˆ—è¡¨"],
      "impact": "å¯¼è‡´æƒ…èŠ‚æ— æ³•å±•å¼€ï¼Œè§’è‰²å…³ç³»ä¸æ˜ç¡®"
    }
  ],
  "correction_strategy": "incremental_fix",  // regenerate, incremental_fix, human_review
  "correction_instructions": [
    {
      "issue_id": "issue-001",
      "target_agent": "character_agent",
      "action": "create",  // create, update, delete
      "specific_instruction": "åˆ›å»ºè§’è‰²'æå››'ï¼Œè®¾å®šä¸ºï¼šé…è§’ï¼Œä¸»è§’çš„æŒšå‹ï¼Œæ€§æ ¼å¼€æœ—ä½†æœ‰äº›å†²åŠ¨ã€‚èƒŒæ™¯ï¼šä¸ä¸»è§’ä»å°ä¸€èµ·é•¿å¤§ï¼Œæ˜¯ä¸»è§’æœ€ä¿¡ä»»çš„äººã€‚",
      "parameters": {
        "name": "æå››",
        "role_type": "supporting",
        "traits": ["å¼€æœ—", "å†²åŠ¨", "å¿ è¯š"],
        "relationship_to_protagonist": "æŒšå‹"
      }
    }
  ],
  "affected_agents": ["character_agent"],
  "reasoning_chain": [
    "æ£€æŸ¥å¤§çº²èŠ‚ç‚¹ï¼šå‘ç°ç¬¬ä¸‰ç« æåŠ'æå››'",
    "æ£€æŸ¥è§’è‰²åˆ—è¡¨ï¼šæœªæ‰¾åˆ°'æå››'çš„å®šä¹‰",
    "åˆ†æå½±å“ï¼šæƒ…èŠ‚éœ€è¦è¯¥è§’è‰²ï¼Œå±äºé«˜ä¼˜å…ˆçº§é—®é¢˜",
    "ç¡®å®šä¿®æ­£ç­–ç•¥ï¼šå¢é‡ä¿®å¤ï¼ˆåˆ›å»ºç¼ºå¤±è§’è‰²ï¼‰æ¯”å…¨é‡é‡æ–°ç”Ÿæˆæ›´é«˜æ•ˆ",
    "ç”Ÿæˆå…·ä½“æŒ‡ä»¤ï¼šåŸºäºå¤§çº²ä¸­çš„æè¿°æ¨æ–­è§’è‰²ç‰¹å¾"
  ],
  "suggestions_for_improvement": [
    "å»ºè®®åœ¨è§’è‰²ç”Ÿæˆé˜¶æ®µï¼Œæå–å¤§çº²ä¸­æ‰€æœ‰æåŠçš„è§’è‰²åç§°è¿›è¡Œäº¤å‰éªŒè¯"
  ]
}
""")
    
    # æ„å»ºå®¡æ ¸å†…å®¹ï¼ˆç»“æ„åŒ–ï¼‰
    review_content = {
        "outline": {
            "node_count": len(outline_nodes),
            "nodes": [
                {
                    "name": n.get("name"),
                    "description": n.get("description"),
                    "mentioned_entities": extract_entities(n.get("description", ""))
                } for n in outline_nodes[:10]
            ]
        },
        "characters": {
            "count": len(characters),
            "characters": [
                {
                    "name": c.get("name"),
                    "role_type": c.get("roleType"),
                    "traits": c.get("traits", [])
                } for c in characters
            ]
        },
        "timeline": {
            "event_count": len(timeline_events),
            "events": [
                {
                    "title": e.get("title"),
                    "participants": e.get("participants", []),
                    "importance": e.get("importance")
                } for e in timeline_events[:10]
            ]
        }
    }
    
    user_message = HumanMessage(content=f"""
è¯·æ·±åº¦å®¡æ ¸ä»¥ä¸‹åˆ›ä½œå†…å®¹ï¼Œç”Ÿæˆç»“æ„åŒ–è¯Šæ–­æŠ¥å‘Šï¼ˆJSONæ ¼å¼ï¼‰ï¼š

{json.dumps(review_content, ensure_ascii=False, indent=2)}
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£æè¯Šæ–­æŠ¥å‘Š
    try:
        diagnostic_dict = json.loads(response.content)
    except:
        # è§£æå¤±è´¥ï¼Œè¿”å›é»˜è®¤é€šè¿‡
        diagnostic_dict = {
            "passed": True,
            "quality_score": 75,
            "issues": [],
            "correction_strategy": "none",
            "correction_instructions": [],
            "affected_agents": [],
            "reasoning_chain": ["è¯Šæ–­æŠ¥å‘Šè§£æå¤±è´¥ï¼Œé»˜è®¤é€šè¿‡"],
            "suggestions_for_improvement": []
        }
    
    # ===== Step 2: å†³ç­–ä¸‹ä¸€æ­¥ =====
    passed = diagnostic_dict.get("passed", False)
    quality_score = diagnostic_dict.get("quality_score", 0)
    correction_strategy = diagnostic_dict.get("correction_strategy", "regenerate")
    
    # å†³å®šå·¥ä½œæµä¸‹ä¸€æ­¥
    if correction_strategy == "human_review" or quality_score < 50:
        next_agent = "human_review"
    elif correction_strategy in ["regenerate", "incremental_fix"] and quality_score < 75:
        next_agent = "meta_scheduler"
    else:
        next_agent = "completed"
    
    return {
        **state,
        "diagnostic_report": diagnostic_dict,  # å®Œæ•´çš„è¯Šæ–­æŠ¥å‘Š
        "quality_score": quality_score,
        "review_passed": passed,
        "current_agent": next_agent,
        "completed_agents": state.get("completed_agents", []) + ["review_agent_v2"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + diagnostic_dict.get("reasoning_chain", [])
    }


def extract_entities(text: str) -> List[str]:
    """ç®€å•çš„å®ä½“æå–ï¼ˆå®é™…åº”è¯¥ç”¨ NERï¼‰"""
    # ç®€åŒ–å®ç°ï¼šæå–å¼•å·ä¸­çš„å†…å®¹
    import re
    entities = re.findall(r'[\'"""\'](.*?)[\'"""\']', text)
    return entities
```

### 2.2 å…ƒè°ƒåº¦å™¨ï¼ˆæ™ºèƒ½ä¿®æ­£è·¯ç”±ï¼‰

```python
# src/core/agents/nodes/meta_scheduler_node.py
from typing import Dict, Any, List
from core.agents.states.pipeline_state import PipelineState
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
import json


async def meta_scheduler_node(state: PipelineState) -> PipelineState:
    """å…ƒè°ƒåº¦å™¨ - æ™ºèƒ½åˆ†æè¯Šæ–­æŠ¥å‘Šå¹¶ç”Ÿæˆä¿®æ­£è®¡åˆ’
    
    èŒè´£ï¼š
    1. è§£æè¯Šæ–­æŠ¥å‘Š
    2. æ™ºèƒ½å®šä½éœ€è¦ä¿®æ­£çš„ Agent
    3. ä¸ºæ¯ä¸ª Agent ç”Ÿæˆå¢å¼ºçš„ã€å…·ä½“çš„ä¿®æ­£ Prompt
    4. å†³å®šä¿®æ­£èŒƒå›´ï¼ˆå…¨é‡ vs å¢é‡ï¼‰
    5. ç®¡ç†è¿­ä»£æ¬¡æ•°
    """
    logger.info("Meta Scheduler: Analyzing diagnostic report and planning corrections...")
    
    diagnostic_report = state.get("diagnostic_report", {})
    iteration_count = state.get("iteration_count", 0)
    max_iterations = state.get("max_iterations", 3)
    
    # æ£€æŸ¥è¿­ä»£æ¬¡æ•°
    if iteration_count >= max_iterations:
        logger.warning(f"Max iterations ({max_iterations}) reached, escalating to human review")
        return {
            **state,
            "current_agent": "human_review",
            "reasoning": state.get("reasoning", []) + [
                f"å…ƒè°ƒåº¦å™¨ï¼šè¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•° {max_iterations}ï¼Œå‡çº§åˆ°äººå·¥å®¡æ ¸"
            ]
        }
    
    # ===== Step 1: åˆ†æè¯Šæ–­æŠ¥å‘Šï¼Œç¡®å®šä¿®æ­£ç­–ç•¥ =====
    correction_strategy = diagnostic_report.get("correction_strategy", "regenerate")
    correction_instructions = diagnostic_report.get("correction_instructions", [])
    affected_agents = diagnostic_report.get("affected_agents", [])
    
    if not affected_agents:
        # å¦‚æœè¯Šæ–­æŠ¥å‘Šæ²¡æœ‰æ˜ç¡®æŒ‡å‡ºï¼Œä½¿ç”¨å¯å‘å¼è§„åˆ™
        affected_agents = _heuristic_determine_agents(diagnostic_report)
    
    # ===== Step 2: ä¸ºæ¯ä¸ªå—å½±å“çš„ Agent ç”Ÿæˆä¿®æ­£ Prompt =====
    correction_prompts = {}
    
    for agent_name in affected_agents:
        # æ‰¾åˆ°è¯¥ Agent ç›¸å…³çš„æ‰€æœ‰ä¿®æ­£æŒ‡ä»¤
        agent_instructions = [
            inst for inst in correction_instructions
            if inst.get("target_agent") == agent_name
        ]
        
        if agent_instructions:
            # ç”Ÿæˆå¢å¼º Prompt
            enhanced_prompt = _generate_correction_prompt(
                agent_name=agent_name,
                instructions=agent_instructions,
                original_output=state.get(f"{agent_name}_output"),
                diagnostic_report=diagnostic_report
            )
            
            correction_prompts[agent_name] = enhanced_prompt
    
    # ===== Step 3: å†³å®šä»å“ªä¸ª Agent å¼€å§‹ =====
    # ä¼˜å…ˆçº§ï¼šoutline_agent > character_agent > plot_agent
    agent_priority = ["outline_agent", "character_agent", "plot_agent"]
    
    restart_agent = None
    for agent in agent_priority:
        if agent in affected_agents:
            restart_agent = agent
            break
    
    if not restart_agent:
        restart_agent = affected_agents[0] if affected_agents else "outline_agent"
    
    # ===== Step 4: å†³å®šä¿®æ­£èŒƒå›´ =====
    if correction_strategy == "regenerate":
        # å…¨é‡é‡æ–°ç”Ÿæˆï¼šæ¸…ç©ºå—å½±å“ Agent çš„è¾“å‡º
        _clear_affected_outputs(state, affected_agents)
        correction_mode = "regenerate"
    else:
        # å¢é‡ä¿®å¤ï¼šä¿ç•™ç°æœ‰è¾“å‡ºï¼Œåªä¿®æ”¹æœ‰é—®é¢˜çš„éƒ¨åˆ†
        correction_mode = "incremental"
    
    return {
        **state,
        "iteration_count": iteration_count + 1,
        "current_agent": restart_agent,
        "correction_prompts": correction_prompts,  # ä¿®æ­£ Prompt
        "correction_mode": correction_mode,  # ä¿®æ­£æ¨¡å¼
        "affected_agents": affected_agents,
        "reasoning": state.get("reasoning", []) + [
            f"å…ƒè°ƒåº¦å™¨ï¼šåˆ†æè¯Šæ–­æŠ¥å‘Š",
            f"å…ƒè°ƒåº¦å™¨ï¼šç¡®å®šä¿®æ­£ç­–ç•¥ - {correction_strategy}",
            f"å…ƒè°ƒåº¦å™¨ï¼šå—å½±å“ Agent - {', '.join(affected_agents)}",
            f"å…ƒè°ƒåº¦å™¨ï¼šä» {restart_agent} å¼€å§‹ä¿®æ­£",
            f"å…ƒè°ƒåº¦å™¨ï¼šä¿®æ­£æ¨¡å¼ - {correction_mode}",
            f"å…ƒè°ƒåº¦å™¨ï¼šå½“å‰è¿­ä»£æ¬¡æ•° {iteration_count + 1}/{max_iterations}"
        ]
    }


def _heuristic_determine_agents(diagnostic_report: Dict) -> List[str]:
    """å¯å‘å¼ç¡®å®šå—å½±å“çš„ Agent"""
    issues = diagnostic_report.get("issues", [])
    agents = set()
    
    for issue in issues:
        sub_category = issue.get("sub_category", "")
        
        if "character" in sub_category:
            agents.add("character_agent")
        if "outline" in sub_category:
            agents.add("outline_agent")
        if "plot" in sub_category or "timeline" in sub_category:
            agents.add("plot_agent")
    
    return list(agents) if agents else ["outline_agent"]


def _generate_correction_prompt(
    agent_name: str,
    instructions: List[Dict],
    original_output: Any,
    diagnostic_report: Dict
) -> str:
    """ç”Ÿæˆå¢å¼ºçš„ä¿®æ­£ Prompt"""
    prompt_parts = [
        "## ä¿®æ­£ä»»åŠ¡\n",
        "æ ¹æ®å®¡æ ¸åé¦ˆï¼Œéœ€è¦ä¿®æ­£ä»¥ä¸‹é—®é¢˜ï¼š\n\n"
    ]
    
    for i, inst in enumerate(instructions, 1):
        prompt_parts.append(f"### é—®é¢˜ {i}\n")
        prompt_parts.append(f"**æè¿°**: {inst.get('specific_instruction')}\n")
        prompt_parts.append(f"**æ“ä½œ**: {inst.get('action')}\n")
        
        if inst.get('parameters'):
            prompt_parts.append(f"**å‚æ•°**: {json.dumps(inst['parameters'], ensure_ascii=False)}\n")
        
        prompt_parts.append("\n")
    
    prompt_parts.append("## ä¿®æ­£è¦æ±‚\n")
    prompt_parts.append("1. é’ˆå¯¹æ€§ä¿®æ­£ï¼šåªä¿®æ”¹æœ‰é—®é¢˜çš„éƒ¨åˆ†\n")
    prompt_parts.append("2. ä¿æŒä¸€è‡´æ€§ï¼šç¡®ä¿ä¸å…¶ä»–éƒ¨åˆ†åè°ƒ\n")
    prompt_parts.append("3. æå‡è´¨é‡ï¼šä¸åªæ˜¯ä¿®å¤é—®é¢˜ï¼Œè¿˜è¦æå‡æ•´ä½“è´¨é‡\n")
    
    return "".join(prompt_parts)


def _clear_affected_outputs(state: Dict, affected_agents: List[str]):
    """æ¸…ç©ºå—å½±å“ Agent çš„è¾“å‡ºï¼ˆå…¨é‡é‡æ–°ç”Ÿæˆæ¨¡å¼ï¼‰"""
    if "outline_agent" in affected_agents:
        state["outline_nodes"] = []
    if "character_agent" in affected_agents:
        state["characters"] = []
        state["character_relations"] = []
    if "plot_agent" in affected_agents:
        state["timeline_events"] = []
```

### 2.3 Agent ä¿®æ­£æ‰§è¡Œï¼ˆæ¥æ”¶ä¿®æ­£ Promptï¼‰

```python
# ä¿®æ”¹ä¸“ä¸š Agentï¼Œä½¿å…¶èƒ½å¤Ÿæ¥æ”¶å’Œåº”ç”¨ä¿®æ­£ Prompt

async def character_agent_node_v2(state: PipelineState) -> PipelineState:
    """è§’è‰² Agent v2.0 - æ”¯æŒä¿®æ­£æ¨¡å¼"""
    
    correction_prompts = state.get("correction_prompts", {})
    correction_mode = state.get("correction_mode", "regenerate")
    
    # æ£€æŸ¥æ˜¯å¦æœ‰é’ˆå¯¹æœ¬ Agent çš„ä¿®æ­£ Prompt
    if "character_agent" in correction_prompts:
        correction_prompt = correction_prompts["character_agent"]
        
        if correction_mode == "incremental":
            # å¢é‡ä¿®å¤æ¨¡å¼ï¼šåŠ è½½ç°æœ‰è§’è‰²ï¼Œåªä¿®æ”¹æœ‰é—®é¢˜çš„
            existing_characters = state.get("characters", [])
            
            # ä½¿ç”¨å¢å¼º Prompt è¿›è¡Œä¿®æ­£
            system_message = SystemMessage(content=f"""
ä½ æ˜¯è§’è‰²è®¾è®¡å¸ˆï¼Œç°åœ¨éœ€è¦æ ¹æ®å®¡æ ¸åé¦ˆè¿›è¡Œä¿®æ­£ã€‚

{correction_prompt}

## ç°æœ‰è§’è‰²
{json.dumps(existing_characters, ensure_ascii=False, indent=2)}

è¯·è¾“å‡ºä¿®æ­£åçš„å®Œæ•´è§’è‰²åˆ—è¡¨ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
        else:
            # å…¨é‡é‡æ–°ç”Ÿæˆæ¨¡å¼
            system_message = SystemMessage(content=f"""
ä½ æ˜¯è§’è‰²è®¾è®¡å¸ˆï¼Œéœ€è¦é‡æ–°è®¾è®¡è§’è‰²ã€‚

{correction_prompt}

è¯·è®¾è®¡è§’è‰²ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    else:
        # æ­£å¸¸æ¨¡å¼ï¼ˆé¦–æ¬¡ç”Ÿæˆï¼‰
        system_message = SystemMessage(content="""
ä½ æ˜¯è§’è‰²è®¾è®¡å¸ˆï¼Œæ ¹æ®å¤§çº²è®¾è®¡è§’è‰²...
""")
    
    # ... åç»­ç”Ÿæˆé€»è¾‘ç±»ä¼¼ v1.0
```

---

## ä¸‰ã€æ ¸å¿ƒæ”¹è¿› 2ï¼šè§„åˆ’ Agent

### 3.1 è§„åˆ’ Agent å®ç°

```python
# src/core/agents/nodes/planner_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
import json


async def planner_agent_node(state: PipelineState) -> PipelineState:
    """è§„åˆ’ Agent - åŠ¨æ€ä»»åŠ¡åˆ†è§£å’Œæ‰§è¡Œè®¡åˆ’ç”Ÿæˆ
    
    èŒè´£ï¼š
    1. åˆ†æç”¨æˆ·éœ€æ±‚ï¼ˆç†è§£æ„å›¾ï¼‰
    2. åŠ¨æ€ä»»åŠ¡åˆ†è§£ï¼ˆç”Ÿæˆå­ä»»åŠ¡åˆ—è¡¨ï¼‰
    3. ç¡®å®šæ‰§è¡Œé¡ºåºï¼ˆAgent åºåˆ—ï¼‰
    4. é€‰æ‹©å·¥å…·é›†ï¼ˆä¸ºæ¯ä¸ª Agent é…ç½®å·¥å…·ï¼‰
    5. ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
    """
    logger.info("Planner Agent: Analyzing user requirement and generating execution plan...")
    
    user_requirement = state["user_requirement"]
    
    # ===== Step 1: éœ€æ±‚åˆ†æ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.3)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ä»»åŠ¡è§„åˆ’å¸ˆã€‚ä½ çš„èŒè´£æ˜¯åˆ†æç”¨æˆ·çš„åˆ›ä½œéœ€æ±‚ï¼Œå¹¶ç”Ÿæˆè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ã€‚

## åˆ†æç»´åº¦
1. **éœ€æ±‚ç±»å‹**: å…¨æ–°åˆ›ä½œ / æ‰©å±•ç°æœ‰å†…å®¹ / ä¿®æ”¹ä¼˜åŒ–
2. **å¤æ‚åº¦**: ç®€å•ï¼ˆå•ä¸€ä»»åŠ¡ï¼‰/ ä¸­ç­‰ï¼ˆ3-5ä¸ªå­ä»»åŠ¡ï¼‰/ å¤æ‚ï¼ˆ>5ä¸ªå­ä»»åŠ¡ï¼‰
3. **éœ€è¦çš„èƒ½åŠ›**: ä¸–ç•Œè§‚è®¾å®š / è§’è‰²è®¾è®¡ / æƒ…èŠ‚æ„æ€ / å¤§çº²è§„åˆ’

## æ‰§è¡Œè®¡åˆ’ç”Ÿæˆè§„åˆ™
- **å…¨æ–°åˆ›ä½œ**ï¼šä¸–ç•Œè§‚ â†’ è§’è‰² â†’ å¤§çº² â†’ æƒ…èŠ‚ â†’ å®¡æ ¸
- **æ‰©å±•å†…å®¹**ï¼šåˆ†æç°æœ‰ â†’ è§’è‰²/æƒ…èŠ‚ â†’ å®¡æ ¸
- **ä¿®æ”¹ä¼˜åŒ–**ï¼šè¯Šæ–­ â†’ é’ˆå¯¹æ€§ä¿®æ­£ â†’ å®¡æ ¸

## è¾“å‡ºæ ¼å¼ï¼šJSON
{
  "requirement_analysis": {
    "type": "new_creation",  // new_creation, extension, modification
    "complexity": "medium",   // simple, medium, complex
    "required_capabilities": ["worldview", "character", "outline", "plot"]
  },
  "execution_plan": {
    "steps": [
      {
        "step_id": 1,
        "agent": "worldview_agent",  // å¦‚æœéœ€è¦
        "task_description": "æ„å»ºèµ›åšæœ‹å…‹ä¸–ç•Œè§‚ï¼š2077å¹´ï¼Œå¤§å…¬å¸ç»Ÿæ²»ï¼Œé˜¶çº§åˆ†åŒ–ä¸¥é‡",
        "required_tools": ["SettingTool", "RAGTool"],
        "dependencies": [],  // ä¾èµ–çš„å‰åºæ­¥éª¤
        "estimated_tokens": 2000
      },
      {
        "step_id": 2,
        "agent": "character_agent",
        "task_description": "è®¾è®¡ä¸»è§’ï¼šç§å®¶ä¾¦æ¢ï¼Œå…·æœ‰é»‘å®¢æŠ€èƒ½",
        "required_tools": ["CharacterTool", "RelationTool", "RAGTool"],
        "dependencies": [1],  // ä¾èµ–ä¸–ç•Œè§‚
        "estimated_tokens": 3000
      },
      {
        "step_id": 3,
        "agent": "outline_agent",
        "task_description": "ç”Ÿæˆå¤§çº²ï¼šä¸»çº¿å›´ç»•è°ƒæŸ¥å¤§å…¬å¸é˜´è°‹",
        "required_tools": ["OutlineTool", "RAGTool"],
        "dependencies": [1, 2],
        "estimated_tokens": 4000
      },
      {
        "step_id": 4,
        "agent": "plot_agent",
        "task_description": "å®‰æ’æƒ…èŠ‚äº‹ä»¶å’Œæ—¶é—´çº¿",
        "required_tools": ["TimelineTool", "RAGTool"],
        "dependencies": [2, 3],
        "estimated_tokens": 3000
      },
      {
        "step_id": 5,
        "agent": "review_agent_v2",
        "task_description": "å®¡æ ¸ä¸€è‡´æ€§å’Œè´¨é‡",
        "required_tools": [],
        "dependencies": [1, 2, 3, 4],
        "estimated_tokens": 2000
      }
    ],
    "total_estimated_tokens": 14000,
    "parallelizable_steps": [],  // æœªæ¥å¯å¹¶è¡Œæ‰§è¡Œçš„æ­¥éª¤
    "critical_path": [1, 2, 3, 4, 5]
  },
  "tool_configuration": {
    "enable_rag": true,
    "enable_knowledge_graph": false,  // æœªæ¥æ‰©å±•
    "context_mode": "auto"  // auto, minimal, full
  },
  "reasoning": [
    "ç”¨æˆ·éœ€æ±‚åŒ…å«'èµ›åšæœ‹å…‹'å’Œ'ä¾¦æ¢'ï¼Œéœ€è¦ä¸–ç•Œè§‚è®¾å®š",
    "éœ€è¦è®¾è®¡ä¸»è§’å’Œç›¸å…³è§’è‰²",
    "éœ€è¦å®Œæ•´çš„å¤§çº²å’Œæƒ…èŠ‚å®‰æ’",
    "å› æ­¤é‡‡ç”¨å®Œæ•´æµç¨‹ï¼šä¸–ç•Œè§‚â†’è§’è‰²â†’å¤§çº²â†’æƒ…èŠ‚â†’å®¡æ ¸"
  ]
}
""")
    
    user_message = HumanMessage(content=f"""
ç”¨æˆ·éœ€æ±‚ï¼š{user_requirement}

è¯·ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£ææ‰§è¡Œè®¡åˆ’
    try:
        plan_dict = json.loads(response.content)
    except:
        # è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è®¡åˆ’
        plan_dict = _generate_default_plan()
    
    execution_plan = plan_dict.get("execution_plan", {})
    steps = execution_plan.get("steps", [])
    
    # ===== Step 2: ç¡®å®šç¬¬ä¸€ä¸ª Agent =====
    first_step = steps[0] if steps else {"agent": "outline_agent"}
    next_agent = first_step.get("agent", "outline_agent")
    
    return {
        **state,
        "requirement_analysis": plan_dict.get("requirement_analysis", {}),
        "execution_plan": execution_plan,
        "tool_configuration": plan_dict.get("tool_configuration", {}),
        "current_step": 0,
        "current_agent": next_agent,
        "completed_agents": ["planner_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + plan_dict.get("reasoning", [])
    }


def _generate_default_plan() -> Dict:
    """ç”Ÿæˆé»˜è®¤æ‰§è¡Œè®¡åˆ’"""
    return {
        "requirement_analysis": {
            "type": "new_creation",
            "complexity": "medium",
            "required_capabilities": ["character", "outline", "plot"]
        },
        "execution_plan": {
            "steps": [
                {"step_id": 1, "agent": "outline_agent", "required_tools": ["OutlineTool", "RAGTool"]},
                {"step_id": 2, "agent": "character_agent", "required_tools": ["CharacterTool", "RelationTool", "RAGTool"]},
                {"step_id": 3, "agent": "plot_agent", "required_tools": ["TimelineTool", "RAGTool"]},
                {"step_id": 4, "agent": "review_agent_v2", "required_tools": []}
            ]
        },
        "tool_configuration": {"enable_rag": True},
        "reasoning": ["ä½¿ç”¨é»˜è®¤æµç¨‹"]
    }
```

### 3.2 åŠ¨æ€è·¯ç”±å™¨ï¼ˆæ ¹æ®è®¡åˆ’æ‰§è¡Œï¼‰

```python
# src/core/agents/workflows/dynamic_router.py

def create_dynamic_router(state: PipelineState) -> str:
    """åŠ¨æ€è·¯ç”±å™¨ - æ ¹æ®æ‰§è¡Œè®¡åˆ’è·¯ç”±åˆ°ä¸‹ä¸€ä¸ª Agent"""
    execution_plan = state.get("execution_plan", {})
    current_step = state.get("current_step", 0)
    steps = execution_plan.get("steps", [])
    
    if current_step >= len(steps):
        return "review_agent_v2"
    
    next_step = steps[current_step]
    next_agent = next_step.get("agent", "outline_agent")
    
    # æ›´æ–°å½“å‰æ­¥éª¤
    state["current_step"] = current_step + 1
    
    return next_agent
```

---

## å››ã€æ ¸å¿ƒæ”¹è¿› 3ï¼šæ·±åº¦ RAG é›†æˆ

### 4.1 å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…·ï¼ˆä¸»åŠ¨æ„ŸçŸ¥ï¼‰

```python
# src/core/tools/langchain/workspace_context_tool.py
from typing import Dict, Any, List
from pydantic import Field
from core.tools.base import BaseTool, ToolMetadata, ToolInputSchema, ToolResult


class WorkspaceContextToolInput(ToolInputSchema):
    """å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…·è¾“å…¥"""
    task_type: str = Field(..., description="ä»»åŠ¡ç±»å‹: continue_writing, create_chapter, review_content")
    context_scope: str = Field(..., description="ä¸Šä¸‹æ–‡èŒƒå›´: current_chapter, full_project, related_entities")
    
    # ä¸Šä¸‹æ–‡å‚æ•°
    chapter_id: str = Field(None, description="ç« èŠ‚ IDï¼ˆå¦‚æœä»»åŠ¡æ˜¯ç»­å†™ç« èŠ‚ï¼‰")
    character_ids: List[str] = Field(default_factory=list, description="ç›¸å…³è§’è‰² ID")


class WorkspaceContextTool(BaseTool):
    """å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…· - ä¸»åŠ¨è·å–å½“å‰ä»»åŠ¡ç›¸å…³çš„ç»“æ„åŒ–ä¸Šä¸‹æ–‡
    
    å€Ÿé‰´ Cursor çš„æ ¸å¿ƒç†å¿µï¼š
    - ä¸æ˜¯è¢«åŠ¨ç­‰å¾… Agent æŸ¥è¯¢ï¼Œè€Œæ˜¯ä¸»åŠ¨ç†è§£ä»»åŠ¡å¹¶æä¾›ä¸Šä¸‹æ–‡
    - è¿”å›ç»“æ„åŒ–æ•°æ®ï¼Œä¸æ˜¯çº¯æ–‡æœ¬ chunks
    - åŒ…å«å¤šç§ç±»å‹ï¼šå‰åºå†…å®¹ + è§’è‰²å¡ + å¤§çº²èŠ‚ç‚¹ + ä¸–ç•Œè®¾å®š
    """
    
    def __init__(self, go_api_client, auth_context=None):
        metadata = ToolMetadata(
            name="workspace_context_tool",
            description="ä¸»åŠ¨è·å–å½“å‰å†™ä½œä»»åŠ¡ç›¸å…³çš„ç»“æ„åŒ–ä¸Šä¸‹æ–‡",
            category="knowledge",
            requires_auth=True,
            requires_project=True
        )
        super().__init__(metadata, go_api_client, auth_context)
    
    @property
    def input_schema(self):
        return WorkspaceContextToolInput
    
    async def _execute_impl(self, validated_input: WorkspaceContextToolInput) -> ToolResult:
        """æ‰§è¡Œä¸Šä¸‹æ–‡è·å–"""
        task_type = validated_input.task_type
        project_id = validated_input.project_id
        
        context = {
            "task_type": task_type,
            "related_content": {}
        }
        
        # ===== 1. æ ¹æ®ä»»åŠ¡ç±»å‹ï¼Œæ™ºèƒ½è·å–ä¸Šä¸‹æ–‡ =====
        if task_type == "continue_writing" and validated_input.chapter_id:
            # ç»­å†™ä»»åŠ¡ï¼šè·å–å‰åºç« èŠ‚å†…å®¹ + æœ¬ç« å¤§çº² + å‡ºåœºè§’è‰²
            context["related_content"] = await self._get_continue_writing_context(
                project_id, validated_input.chapter_id
            )
        
        elif task_type == "create_chapter":
            # æ–°ç« èŠ‚ä»»åŠ¡ï¼šè·å–å¤§çº²èŠ‚ç‚¹ + å…¨éƒ¨è§’è‰² + å‰åºç« èŠ‚æ‘˜è¦
            context["related_content"] = await self._get_create_chapter_context(project_id)
        
        elif task_type == "review_content":
            # å®¡æ ¸ä»»åŠ¡ï¼šè·å–å®Œæ•´é¡¹ç›®æ¦‚è§ˆ
            context["related_content"] = await self._get_review_context(project_id)
        
        return ToolResult(
            success=True,
            data=context,
            metadata={"context_items": len(context["related_content"])}
        )
    
    async def _get_continue_writing_context(self, project_id: str, chapter_id: str) -> Dict:
        """è·å–ç»­å†™ä¸Šä¸‹æ–‡ï¼ˆç»“æ„åŒ–ï¼‰"""
        context = {}
        
        # 1. è·å–æœ¬ç« å¤§çº²èŠ‚ç‚¹
        outline_response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/nodes/{chapter_id}",
            user_id=self.auth_context.get("user_id")
        )
        context["current_outline_node"] = outline_response.get("data")
        
        # 2. è·å–å‰ä¸€ç« å†…å®¹ï¼ˆæœ€å500å­—ï¼‰
        # ... è°ƒç”¨ç« èŠ‚å†…å®¹ API
        
        # 3. è·å–æœ¬ç« å‡ºåœºè§’è‰²
        participants = outline_response.get("data", {}).get("metadata", {}).get("participants", [])
        if participants:
            characters_response = await self.go_api_client.call_api(
                method="GET",
                endpoint=f"/api/v1/projects/{project_id}/characters",
                params={"ids": ",".join(participants)},
                user_id=self.auth_context.get("user_id")
            )
            context["participating_characters"] = characters_response.get("data", {}).get("items", [])
        
        # 4. è·å–ç›¸å…³æ—¶é—´çº¿äº‹ä»¶
        timeline_response = await self.go_api_client.call_api(
            method="GET",
            endpoint=f"/api/v1/projects/{project_id}/timeline-events",
            params={"chapterRef": chapter_id},
            user_id=self.auth_context.get("user_id")
        )
        context["timeline_events"] = timeline_response.get("data", {}).get("items", [])
        
        return context
    
    async def _get_create_chapter_context(self, project_id: str) -> Dict:
        """è·å–æ–°å»ºç« èŠ‚ä¸Šä¸‹æ–‡"""
        # ... ç±»ä¼¼å®ç°
        pass
    
    async def _get_review_context(self, project_id: str) -> Dict:
        """è·å–å®¡æ ¸ä¸Šä¸‹æ–‡"""
        # ... ç±»ä¼¼å®ç°
        pass
```

### 4.2 ç»“æ„åŒ– RAG å¢å¼º

```python
# åœ¨å‘é‡åŒ–æ—¶æ³¨å…¥å…ƒæ•°æ®
from core.rag.knowledge_base import KnowledgeBaseManager

async def index_character_with_metadata(character: Dict, kb_manager: KnowledgeBaseManager):
    """ç´¢å¼•è§’è‰²ï¼ˆå¸¦ä¸°å¯Œå…ƒæ•°æ®ï¼‰"""
    document = Document(
        id=character["id"],
        user_id=character["userId"],
        project_id=character["projectId"],
        content=f"""
è§’è‰²åç§°ï¼š{character["name"]}
åˆ«åï¼š{", ".join(character.get("alias", []))}
è§’è‰²ç±»å‹ï¼š{character.get("roleType")}
æ€§æ ¼æ ‡ç­¾ï¼š{", ".join(character.get("traits", []))}
èƒŒæ™¯æ•…äº‹ï¼š{character.get("background", "")}
""",
        content_type="character",
        metadata={
            "doc_type": "character",
            "character_id": character["id"],
            "character_name": character["name"],
            "role_type": character.get("roleType"),
            "traits": character.get("traits", []),
            # æ›´å¤šå…ƒæ•°æ®...
        }
    )
    
    await kb_manager.index_document(document)


# æ··åˆæ£€ç´¢ï¼ˆç»“æ„åŒ–è¿‡æ»¤ + å‘é‡ç›¸ä¼¼åº¦ï¼‰
from core.rag.retriever import HybridSearchEngine

search_results = await search_engine.search(
    query="æ‰¾åˆ°å‹‡æ•¢å–„è‰¯çš„ä¸»è§’",
    user_id=user_id,
    project_id=project_id,
    top_k=5,
    # ç»“æ„åŒ–è¿‡æ»¤
    filters={
        "content_type": "character",
        "role_type": "protagonist",
        "traits": {"$contains": "å‹‡æ•¢"}  # å‡è®¾æ”¯æŒè¿™ç§æŸ¥è¯¢
    }
)
```

---

## äº”ã€æ ¸å¿ƒæ”¹è¿› 4ï¼šçŸ¥è¯†å›¾è°±é›†æˆï¼ˆé•¿æœŸæ¼”è¿›ï¼‰

### 5.1 çŸ¥è¯†å›¾è°±æ„å»º

```python
# src/core/knowledge_graph/graph_builder.py (æœªæ¥å®ç°)
from typing import List, Dict, Any

class KnowledgeGraphBuilder:
    """çŸ¥è¯†å›¾è°±æ„å»ºå™¨
    
    å®ä½“èŠ‚ç‚¹ï¼š
    - Character (è§’è‰²)
    - Location (åœ°ç‚¹)
    - Event (äº‹ä»¶)
    - Item (é“å…·)
    
    å…³ç³»è¾¹ï¼š
    - knows (è®¤è¯†)
    - friend_of (æœ‹å‹)
    - enemy_of (æ•Œäºº)
    - visited (å»è¿‡)
    - participated_in (å‚ä¸äº†)
    """
    
    def __init__(self, neo4j_client):
        self.neo4j = neo4j_client
    
    async def add_character_node(self, character: Dict):
        """æ·»åŠ è§’è‰²èŠ‚ç‚¹"""
        query = """
        CREATE (c:Character {
            id: $id,
            name: $name,
            role_type: $role_type,
            traits: $traits,
            description: $description
        })
        """
        await self.neo4j.run(query, character)
    
    async def add_relationship(self, from_id: str, to_id: str, rel_type: str, properties: Dict):
        """æ·»åŠ å…³ç³»"""
        query = f"""
        MATCH (a:Character {{id: $from_id}})
        MATCH (b:Character {{id: $to_id}})
        CREATE (a)-[r:{rel_type} $properties]->(b)
        """
        await self.neo4j.run(query, {
            "from_id": from_id,
            "to_id": to_id,
            "properties": properties
        })


# æ··åˆæŸ¥è¯¢å¼•æ“
class HybridKGVectorEngine:
    """çŸ¥è¯†å›¾è°± + å‘é‡æ£€ç´¢æ··åˆå¼•æ“"""
    
    async def query(self, natural_language_query: str) -> List[Dict]:
        """æ··åˆæŸ¥è¯¢
        
        ç¤ºä¾‹ï¼šæ‰¾åˆ°å’Œä¸»è§’äº¦æ•Œäº¦å‹ï¼Œå¹¶ä¸”å»è¿‡'è¿·é›¾æ£®æ—'çš„è§’è‰²
        
        æ‰§è¡Œæ­¥éª¤ï¼š
        1. å›¾æŸ¥è¯¢ï¼šæ‰¾åˆ°ä¸ä¸»è§’æœ‰ friend_of å’Œ enemy_of å…³ç³»çš„è§’è‰²
        2. å›¾æŸ¥è¯¢ï¼šæ‰¾åˆ° visited 'è¿·é›¾æ£®æ—'çš„è§’è‰²
        3. äº¤é›†
        4. åœ¨äº¤é›†ä¸­ï¼Œç”¨å‘é‡æŸ¥è¯¢æ‰¾"æ€§æ ¼æè¿°æœ€ç¬¦åˆ..."çš„è§’è‰²
        """
        
        # 1. å›¾æŸ¥è¯¢
        graph_results = await self._graph_query(natural_language_query)
        
        # 2. å‘é‡æŸ¥è¯¢ï¼ˆåœ¨å›¾æŸ¥è¯¢ç»“æœèŒƒå›´å†…ï¼‰
        candidate_ids = [r["id"] for r in graph_results]
        vector_results = await self._vector_query_in_scope(natural_language_query, candidate_ids)
        
        # 3. èåˆ
        return self._merge_results(graph_results, vector_results)
```

---

## å…­ã€Pipeline çŠ¶æ€ Schema v2.0

```python
# src/core/agents/states/pipeline_state_v2.py
from typing import TypedDict, Annotated, List, Dict, Any, Optional
import operator


class PipelineStateV2(TypedDict):
    """A2A æµæ°´çº¿çŠ¶æ€ v2.0ï¼ˆå¢å¼ºç‰ˆï¼‰"""
    
    # ===== è¾“å…¥ =====
    user_requirement: str
    user_id: str
    project_id: str
    pipeline_config: Dict[str, Any]
    
    # ===== v2.0 æ–°å¢ï¼šè§„åˆ’ Agent è¾“å‡º =====
    requirement_analysis: Dict[str, Any]      # éœ€æ±‚åˆ†æç»“æœ
    execution_plan: Dict[str, Any]            # æ‰§è¡Œè®¡åˆ’
    tool_configuration: Dict[str, Any]        # å·¥å…·é…ç½®
    current_step: int                         # å½“å‰æ‰§è¡Œæ­¥éª¤
    
    # ===== ä¸“ä¸š Agent è¾“å‡º =====
    outline_nodes: List[Dict[str, Any]]
    outline_summary: str
    outline_metadata: Dict[str, Any]
    
    characters: List[Dict[str, Any]]
    character_relations: List[Dict[str, Any]]
    character_summary: str
    
    timeline_events: List[Dict[str, Any]]
    plot_nodes: List[Dict[str, Any]]
    plot_summary: str
    
    # ===== v2.0 æ–°å¢ï¼šå®¡æ ¸ Agent è¾“å‡º =====
    diagnostic_report: Dict[str, Any]         # ç»“æ„åŒ–è¯Šæ–­æŠ¥å‘Šï¼ˆæ›¿ä»£ç®€å•çš„ review_resultsï¼‰
    consistency_check: Dict[str, Any]
    quality_score: int
    review_passed: bool
    
    # ===== v2.0 æ–°å¢ï¼šä¿®æ­£ç›¸å…³ =====
    correction_prompts: Dict[str, str]        # ä¸ºæ¯ä¸ª Agent ç”Ÿæˆçš„ä¿®æ­£ Prompt
    correction_mode: str                      # "regenerate" æˆ– "incremental"
    affected_agents: List[str]                # å—å½±å“çš„ Agent åˆ—è¡¨
    
    # ===== å·¥ä½œæµæ§åˆ¶ =====
    current_agent: str
    completed_agents: Annotated[List[str], operator.add]
    
    # è¿­ä»£æ§åˆ¶
    iteration_count: int
    max_iterations: int
    
    # äººå·¥ä»‹å…¥
    human_intervention_required: bool
    human_feedback: Optional[str]
    
    # ===== v2.0 æ–°å¢ï¼šä¸Šä¸‹æ–‡å¢å¼º =====
    workspace_context: Dict[str, Any]         # å·¥ä½œåŒºä¸Šä¸‹æ–‡ï¼ˆç»“æ„åŒ–ï¼‰
    rag_context: str                          # RAG æ£€ç´¢ä¸Šä¸‹æ–‡
    rag_metadata: Dict[str, Any]              # RAG å…ƒæ•°æ®
    
    # ===== æ¶ˆæ¯å’Œæ¨ç† =====
    messages: Annotated[List[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]  # å®Œæ•´çš„æ¨ç†é“¾è·¯
    
    # ===== é”™è¯¯å¤„ç† =====
    errors: Annotated[List[str], operator.add]
    warnings: Annotated[List[str], operator.add]
    
    # ===== æ€§èƒ½æŒ‡æ ‡ =====
    start_time: float
    tokens_used: int
    tool_calls_count: int
```

---

## ä¸ƒã€Workflow v2.0 ç¼–æ’

```python
# src/core/agents/workflows/a2a_pipeline_v2.py
from langgraph.graph import StateGraph, END
from core.agents.states.pipeline_state_v2 import PipelineStateV2
from core.agents.nodes import (
    planner_agent_node,
    outline_agent_node_v2,
    character_agent_node_v2,
    plot_agent_node_v2,
    review_agent_node_v2,
    meta_scheduler_node
)


def create_a2a_pipeline_v2():
    """åˆ›å»º A2A åˆ›ä½œæµæ°´çº¿ v2.0 - æ™ºèƒ½åä½œç”Ÿæ€"""
    workflow = StateGraph(PipelineStateV2)
    
    # ===== æ·»åŠ èŠ‚ç‚¹ =====
    workflow.add_node("planner_agent", planner_agent_node)  # æ–°å¢
    workflow.add_node("outline_agent", outline_agent_node_v2)
    workflow.add_node("character_agent", character_agent_node_v2)
    workflow.add_node("plot_agent", plot_agent_node_v2)
    workflow.add_node("review_agent_v2", review_agent_node_v2)  # å¢å¼ºç‰ˆ
    workflow.add_node("meta_scheduler", meta_scheduler_node)    # æ–°å¢
    workflow.add_node("human_review", human_review_node)
    
    # ===== è®¾ç½®å…¥å£ç‚¹ =====
    workflow.set_entry_point("planner_agent")  # v2.0 ä»è§„åˆ’å¼€å§‹
    
    # ===== è§„åˆ’åçš„åŠ¨æ€è·¯ç”± =====
    def planner_router(state: PipelineStateV2) -> str:
        """è§„åˆ’åè·¯ç”±åˆ°ç¬¬ä¸€ä¸ª Agent"""
        execution_plan = state.get("execution_plan", {})
        steps = execution_plan.get("steps", [])
        
        if steps:
            first_agent = steps[0].get("agent", "outline_agent")
            return first_agent
        else:
            return "outline_agent"  # é»˜è®¤
    
    workflow.add_conditional_edges(
        "planner_agent",
        planner_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent",
            "worldview_agent": "worldview_agent"  # æœªæ¥æ‰©å±•
        }
    )
    
    # ===== åŠ¨æ€æ‰§è¡Œæµç¨‹ =====
    def dynamic_next_router(state: PipelineStateV2) -> str:
        """åŠ¨æ€è·¯ç”±åˆ°ä¸‹ä¸€ä¸ª Agentï¼ˆæ ¹æ®æ‰§è¡Œè®¡åˆ’ï¼‰"""
        execution_plan = state.get("execution_plan", {})
        current_step = state.get("current_step", 0)
        steps = execution_plan.get("steps", [])
        
        if current_step < len(steps):
            next_agent = steps[current_step].get("agent")
            return next_agent
        else:
            return "review_agent_v2"
    
    # ä¸ºæ¯ä¸ªä¸“ä¸š Agent æ·»åŠ åŠ¨æ€è·¯ç”±
    for agent_name in ["outline_agent", "character_agent", "plot_agent"]:
        workflow.add_conditional_edges(
            agent_name,
            dynamic_next_router,
            {
                "outline_agent": "outline_agent",
                "character_agent": "character_agent",
                "plot_agent": "plot_agent",
                "review_agent_v2": "review_agent_v2"
            }
        )
    
    # ===== å®¡æ ¸åçš„è·¯ç”±ï¼ˆæ™ºèƒ½ä¿®æ­£ï¼‰=====
    def review_router(state: PipelineStateV2) -> str:
        """å®¡æ ¸åè·¯ç”±"""
        current_agent = state.get("current_agent", "")
        
        if current_agent == "completed":
            return "end"
        elif current_agent == "human_review":
            return "human_review"
        elif current_agent == "meta_scheduler":
            return "meta_scheduler"  # è¿›å…¥ä¿®æ­£å¾ªç¯
        else:
            return "end"
    
    workflow.add_conditional_edges(
        "review_agent_v2",
        review_router,
        {
            "end": END,
            "human_review": "human_review",
            "meta_scheduler": "meta_scheduler"
        }
    )
    
    # ===== å…ƒè°ƒåº¦å™¨åçš„è·¯ç”±ï¼ˆå›åˆ°ä¸“ä¸š Agentï¼‰=====
    def meta_scheduler_router(state: PipelineStateV2) -> str:
        """å…ƒè°ƒåº¦å™¨è·¯ç”±åˆ°éœ€è¦ä¿®æ­£çš„ Agent"""
        return state.get("current_agent", "outline_agent")
    
    workflow.add_conditional_edges(
        "meta_scheduler",
        meta_scheduler_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent"
        }
    )
    
    # ===== äººå·¥å®¡æ ¸åçš„è·¯ç”± =====
    workflow.add_conditional_edges(
        "human_review",
        lambda state: "end" if state.get("review_passed") else "meta_scheduler",
        {
            "end": END,
            "meta_scheduler": "meta_scheduler"
        }
    )
    
    # ç¼–è¯‘
    app = workflow.compile()
    return app
```

---

## å…«ã€ä½¿ç”¨ç¤ºä¾‹

```python
# ç¤ºä¾‹ 1ï¼šå…¨æ–°åˆ›ä½œ
pipeline_v2 = create_a2a_pipeline_v2()

initial_state = {
    "user_requirement": "åˆ›ä½œä¸€éƒ¨èµ›åšæœ‹å…‹èƒŒæ™¯çš„ä¾¦æ¢å°è¯´ï¼Œä¸»è§’æ˜¯ç§å®¶ä¾¦æ¢ï¼Œæ“…é•¿é»‘å®¢æŠ€æœ¯",
    "user_id": "user-123",
    "project_id": "proj-456",
    "pipeline_config": {
        "enable_rag": True,
        "enable_planner": True,  # v2.0 å¯ç”¨è§„åˆ’ Agent
        "enable_knowledge_graph": False  # æœªæ¥å¯ç”¨
    },
    "max_iterations": 3,
    "iteration_count": 0,
    "current_step": 0,
    "messages": [],
    "reasoning": [],
    "completed_agents": [],
    "tool_calls_count": 0,
    "start_time": time.time(),
    "tokens_used": 0
}

# æ‰§è¡Œ
result = await pipeline_v2.ainvoke(initial_state)

# æŸ¥çœ‹æ¨ç†é“¾è·¯
print("=== æ¨ç†é“¾è·¯ ===")
for reasoning in result["reasoning"]:
    print(f"- {reasoning}")

# æŸ¥çœ‹è¯Šæ–­æŠ¥å‘Š
if result.get("diagnostic_report"):
    report = result["diagnostic_report"]
    print(f"\n=== è¯Šæ–­æŠ¥å‘Š ===")
    print(f"è´¨é‡è¯„åˆ†: {report['quality_score']}/100")
    print(f"é—®é¢˜æ•°é‡: {len(report['issues'])}")
    for issue in report["issues"]:
        print(f"- [{issue['severity']}] {issue['title']}: {issue['root_cause']}")


# ç¤ºä¾‹ 2ï¼šä½¿ç”¨å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…·
from core.tools.langchain.workspace_context_tool import WorkspaceContextTool

workspace_tool = WorkspaceContextTool(go_api_client, auth_context)

context_result = await workspace_tool.execute(
    params={
        "task_type": "continue_writing",
        "context_scope": "current_chapter",
        "chapter_id": "chapter-001",
        "project_id": "proj-456"
    },
    user_id="user-123",
    project_id="proj-456"
)

if context_result.success:
    context = context_result.data
    print("=== å·¥ä½œåŒºä¸Šä¸‹æ–‡ ===")
    print(f"å½“å‰å¤§çº²èŠ‚ç‚¹: {context['related_content']['current_outline_node']['name']}")
    print(f"å‡ºåœºè§’è‰²æ•°: {len(context['related_content'].get('participating_characters', []))}")
    print(f"ç›¸å…³äº‹ä»¶æ•°: {len(context['related_content'].get('timeline_events', []))}")
```

---

## ä¹ã€ä¸ v1.0 å…¼å®¹æ€§

v2.0 è®¾è®¡ä¸ºæ¸è¿›å¼å‡çº§ï¼š

1. **å‘åå…¼å®¹**ï¼šå¯ä»¥ç¦ç”¨æ–°åŠŸèƒ½ï¼Œé€€å›åˆ° v1.0 æµç¨‹
2. **æ¸è¿›å®æ–½**ï¼šå¯ä»¥å…ˆå®ç°åæ€å¾ªç¯ï¼Œå†å®ç°è§„åˆ’Agent
3. **é…ç½®é©±åŠ¨**ï¼šé€šè¿‡ `pipeline_config` æ§åˆ¶å¯ç”¨å“ªäº›åŠŸèƒ½

```python
# é…ç½®ä¸º v1.0 æ¨¡å¼
pipeline_config = {
    "enable_planner": False,  # ä¸å¯ç”¨è§„åˆ’ Agent
    "enable_meta_scheduler": False,  # ä½¿ç”¨ç®€å•çš„ regenerate_router
    "enable_workspace_context": False  # ä½¿ç”¨æ™®é€š RAG
}
```

---

## åã€æ€»ç»“ä¸åç»­å·¥ä½œ

### v2.0 æ ¸å¿ƒæ”¹è¿›æ€»ç»“

| æ”¹è¿›ç‚¹ | v1.0 | v2.0 | å—ç›Š |
|-------|------|------|------|
| **åæ€å¾ªç¯** | ç®€å• pass/fail | ç»“æ„åŒ–è¯Šæ–­ + æ™ºèƒ½ä¿®æ­£ | è´¨é‡æå‡ 30%+ |
| **è§„åˆ’èƒ½åŠ›** | å›ºå®šæµç¨‹ | åŠ¨æ€ä»»åŠ¡åˆ†è§£ | çµæ´»æ€§æå‡ |
| **ä¸Šä¸‹æ–‡** | è¢«åŠ¨RAG | ä¸»åŠ¨ä¸Šä¸‹æ–‡å·¥å…· | ç†è§£åŠ›æå‡ |
| **ä¿®æ­£ç­–ç•¥** | å…¨é‡é‡ç”Ÿæˆ | å¢é‡ + å…¨é‡æ··åˆ | æ•ˆç‡æå‡ 50%+ |
| **å¯æ‰©å±•æ€§** | æ–°å¢Agentéœ€æ”¹workflow | é…ç½®é©±åŠ¨ | å¼€å‘æ•ˆç‡æå‡ |

### å®æ–½ä¼˜å…ˆçº§

| é˜¶æ®µ | åŠŸèƒ½ | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æœŸ |
|------|------|--------|---------|
| Phase 1 | å¢å¼ºå®¡æ ¸Agentï¼ˆè¯Šæ–­æŠ¥å‘Šï¼‰ | P0 | 1å‘¨ |
| Phase 1 | å…ƒè°ƒåº¦å™¨ï¼ˆæ™ºèƒ½ä¿®æ­£ï¼‰ | P0 | 1å‘¨ |
| Phase 2 | å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…· | P0 | 1å‘¨ |
| Phase 2 | ç»“æ„åŒ–RAGå¢å¼º | P1 | 1å‘¨ |
| Phase 3 | è§„åˆ’Agent | P1 | 2å‘¨ |
| Phase 4 | çŸ¥è¯†å›¾è°±é›†æˆ | P2 | 4å‘¨+ |

### åç»­å·¥ä½œ

1. **çŸ­æœŸï¼ˆ1-2ä¸ªæœˆï¼‰**
   - å®ç°åæ€å¾ªç¯å’Œå…ƒè°ƒåº¦å™¨
   - å®ç°å·¥ä½œåŒºä¸Šä¸‹æ–‡å·¥å…·
   - å®Œå–„è¯Šæ–­æŠ¥å‘Šç”Ÿæˆ

2. **ä¸­æœŸï¼ˆ3-6ä¸ªæœˆï¼‰**
   - å®ç°è§„åˆ’Agent
   - å¼•å…¥çŸ¥è¯†å›¾è°±é›å½¢
   - ä¼˜åŒ–ä¿®æ­£ç­–ç•¥

3. **é•¿æœŸï¼ˆ6ä¸ªæœˆ+ï¼‰**
   - å®Œæ•´çš„çŸ¥è¯†å›¾è°±ç³»ç»Ÿ
   - å¤šAgentå¹¶è¡Œæ‰§è¡Œ
   - è‡ªé€‚åº”å­¦ä¹ å’Œä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-28  
**ç»´æŠ¤è€…**: AIæ¶æ„ç»„  
**ç†å¿µ**: ä»æµæ°´çº¿åˆ°æ™ºèƒ½åä½œç”Ÿæ€

