# MCP å·¥å…·åè®®é›†æˆè®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¶é—´**: 2025-10-27
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µï¼ˆå¯é€‰å®ç°ï¼‰
> **è´Ÿè´£äºº**: AIæ¶æ„ç»„

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è®¾è®¡ MCPï¼ˆModel Context Protocolï¼‰å·¥å…·åè®®çš„é›†æˆæ–¹æ¡ˆï¼Œä½œä¸ºå¯é€‰çš„æ ‡å‡†åŒ–å·¥å…·å±‚ä¸ LangChain Tools å¹¶å­˜ã€‚

**MCP å®šä½**ï¼š
- ä½œä¸ºå¯é€‰çš„æ ‡å‡†åŒ–å·¥å…·æ¥å£å±‚
- ä¸ LangChain Tools å¹¶å­˜ï¼ˆLangChain åŒ…è£… MCPï¼‰
- ä¾¿äºæœªæ¥é›†æˆç¬¬ä¸‰æ–¹å·¥å…·

---

## ä¸€ã€MCP åè®®æ¦‚è¿°

### 1.1 MCP æ ¸å¿ƒæ¦‚å¿µ

```python
# MCP åè®®ç”± Anthropic æå‡ºï¼Œæä¾›æ ‡å‡†åŒ–çš„å·¥å…·è°ƒç”¨æ¥å£

# æ ¸å¿ƒç»„ä»¶ï¼š
# 1. Tool Server: æä¾›å·¥å…·çš„æœåŠ¡ç«¯
# 2. Tool Client: è°ƒç”¨å·¥å…·çš„å®¢æˆ·ç«¯
# 3. Tool Schema: å·¥å…·æè¿°æ ¼å¼ï¼ˆJSON Schemaï¼‰
# 4. Transport: ä¼ è¾“åè®®ï¼ˆHTTP/SSE/stdioï¼‰
```

---

## äºŒã€MCP Server å®ç°

### 2.1 MCP Tool Server

```python
# src/infrastructure/mcp/server.py
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import asyncio


@dataclass
class MCPTool:
    """MCP å·¥å…·å®šä¹‰"""
    name: str
    description: str
    input_schema: Dict[str, Any]
    handler: Callable


class MCPToolInvokeRequest(BaseModel):
    """MCP å·¥å…·è°ƒç”¨è¯·æ±‚"""
    name: str
    arguments: Dict[str, Any]


class MCPToolInvokeResponse(BaseModel):
    """MCP å·¥å…·è°ƒç”¨å“åº”"""
    content: List[Dict[str, Any]]
    is_error: bool = False


class MCPServer:
    """MCP å·¥å…·æœåŠ¡å™¨"""
    
    def __init__(self):
        self.tools: Dict[str, MCPTool] = {}
        self.app = FastAPI()
        self._setup_routes()
    
    def register_tool(self, tool: MCPTool):
        """æ³¨å†Œå·¥å…·"""
        self.tools[tool.name] = tool
    
    def _setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        
        @self.app.get("/mcp/v1/tools/list")
        async def list_tools():
            """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
            tools = []
            for tool in self.tools.values():
                tools.append({
                    "name": tool.name,
                    "description": tool.description,
                    "inputSchema": tool.input_schema
                })
            return {"tools": tools}
        
        @self.app.post("/mcp/v1/tools/call")
        async def call_tool(request: MCPToolInvokeRequest):
            """è°ƒç”¨å·¥å…·"""
            tool = self.tools.get(request.name)
            
            if not tool:
                raise HTTPException(status_code=404, detail=f"Tool not found: {request.name}")
            
            try:
                # è°ƒç”¨å·¥å…·å¤„ç†å™¨
                result = await tool.handler(request.arguments)
                
                return MCPToolInvokeResponse(
                    content=[{
                        "type": "text",
                        "text": str(result)
                    }],
                    is_error=False
                )
            except Exception as e:
                return MCPToolInvokeResponse(
                    content=[{
                        "type": "text",
                        "text": f"Error: {str(e)}"
                    }],
                    is_error=True
                )
```

### 2.2 æ³¨å†Œ LangChain Tools åˆ° MCP

```python
# src/infrastructure/mcp/langchain_adapter.py
from core.tools.base import BaseTool
from infrastructure.mcp.server import MCPServer, MCPTool


class LangChainToMCPAdapter:
    """LangChain Tools åˆ° MCP çš„é€‚é…å™¨"""
    
    @staticmethod
    def register_langchain_tool(mcp_server: MCPServer, langchain_tool: BaseTool):
        """å°† LangChain Tool æ³¨å†Œåˆ° MCP Server"""
        
        # è·å–å‚æ•° Schema
        parameters_schema = langchain_tool.input_schema.schema()
        
        # åˆ›å»ºå¤„ç†å™¨
        async def handler(arguments: dict):
            result = await langchain_tool.execute(params=arguments)
            if result.success:
                return result.data
            else:
                raise Exception(result.error)
        
        # åˆ›å»º MCP Tool
        mcp_tool = MCPTool(
            name=langchain_tool.metadata.name,
            description=langchain_tool.metadata.description,
            input_schema={
                "type": "object",
                "properties": parameters_schema.get("properties", {}),
                "required": parameters_schema.get("required", [])
            },
            handler=handler
        )
        
        # æ³¨å†Œ
        mcp_server.register_tool(mcp_tool)


# ä½¿ç”¨ç¤ºä¾‹
mcp_server = MCPServer()
adapter = LangChainToMCPAdapter()

# æ³¨å†Œæ‰€æœ‰ LangChain Tools
from core.tools.registry import ToolRegistry
tool_registry = ToolRegistry()

for tool in tool_registry._tools.values():
    adapter.register_langchain_tool(mcp_server, tool)
```

---

## ä¸‰ã€MCP Client å®ç°

### 3.1 MCP Tool Client

```python
# src/infrastructure/mcp/client.py
import aiohttp
from typing import List, Dict, Any


class MCPClient:
    """MCP å·¥å…·å®¢æˆ·ç«¯"""
    
    def __init__(self, server_url: str):
        self.server_url = server_url.rstrip('/')
        self.session: aiohttp.ClientSession = None
    
    async def initialize(self):
        """åˆå§‹åŒ–"""
        self.session = aiohttp.ClientSession()
    
    async def close(self):
        """å…³é—­"""
        if self.session:
            await self.session.close()
    
    async def list_tools(self) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
        async with self.session.get(f"{self.server_url}/mcp/v1/tools/list") as response:
            data = await response.json()
            return data.get("tools", [])
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """è°ƒç”¨å·¥å…·"""
        async with self.session.post(
            f"{self.server_url}/mcp/v1/tools/call",
            json={"name": tool_name, "arguments": arguments}
        ) as response:
            return await response.json()
```

---

## å››ã€MCP ä¸ LangChain çš„ååŒ

### 4.1 LangChain Tool åŒ…è£… MCP

```python
# src/core/tools/mcp/mcp_wrapper.py
from langchain.tools import BaseTool as LangChainBaseTool
from infrastructure.mcp.client import MCPClient


class MCPToolWrapper(LangChainBaseTool):
    """å°† MCP Tool åŒ…è£…ä¸º LangChain Tool"""
    
    def __init__(self, mcp_client: MCPClient, tool_info: Dict[str, Any]):
        self.mcp_client = mcp_client
        self.tool_info = tool_info
        
        # è®¾ç½® LangChain Tool å±æ€§
        self.name = tool_info["name"]
        self.description = tool_info["description"]
    
    async def _arun(self, **kwargs):
        """å¼‚æ­¥æ‰§è¡Œ"""
        result = await self.mcp_client.call_tool(
            tool_name=self.name,
            arguments=kwargs
        )
        
        if result.get("is_error"):
            raise Exception(result["content"][0]["text"])
        
        return result["content"][0]["text"]
    
    def _run(self, **kwargs):
        """åŒæ­¥æ‰§è¡Œ"""
        import asyncio
        return asyncio.run(self._arun(**kwargs))


# åŠ¨æ€åŠ è½½ MCP Tools
async def load_mcp_tools(mcp_server_url: str) -> List[LangChainBaseTool]:
    """ä» MCP Server åŠ è½½å·¥å…·"""
    client = MCPClient(mcp_server_url)
    await client.initialize()
    
    tools = []
    mcp_tools = await client.list_tools()
    
    for tool_info in mcp_tools:
        wrapper = MCPToolWrapper(client, tool_info)
        tools.append(wrapper)
    
    return tools
```

---

## äº”ã€éƒ¨ç½²æ¶æ„

### 5.1 ç‹¬ç«‹ MCP Server éƒ¨ç½²

```yaml
# docker-compose.mcp.yml
version: '3.8'

services:
  mcp-server:
    build:
      context: .
      dockerfile: docker/Dockerfile.mcp
    ports:
      - "8081:8080"
    environment:
      - MCP_SERVER_PORT=8080
      - GO_API_URL=http://go-backend:8080
    depends_on:
      - go-backend
```

### 5.2 Python FastAPI ä¸­é›†æˆ MCP

```python
# src/main.py FastAPI åº”ç”¨ä¸­é›†æˆ
from fastapi import FastAPI
from infrastructure.mcp.server import MCPServer
from infrastructure.mcp.langchain_adapter import LangChainToMCPAdapter

app = FastAPI()

# åˆ›å»º MCP Server
mcp_server = MCPServer()

# æ³¨å†Œæ‰€æœ‰ LangChain Tools
# ... æ³¨å†Œé€»è¾‘

# æŒ‚è½½ MCP è·¯ç”±
app.mount("/mcp", mcp_server.app)
```

---

## å…­ã€ä½¿ç”¨åœºæ™¯

### 6.1 åœºæ™¯ 1ï¼šLangGraph ä½¿ç”¨ MCP Tools

```python
from langgraph.prebuilt import ToolNode

# åŠ è½½ MCP Tools
mcp_tools = await load_mcp_tools("http://localhost:8081")

# åˆ›å»º ToolNode
tool_node = ToolNode(mcp_tools)

# æ·»åŠ åˆ°å·¥ä½œæµ
workflow.add_node("tools", tool_node)
```

### 6.2 åœºæ™¯ 2ï¼šç¬¬ä¸‰æ–¹ MCP Server

```python
# é›†æˆå¤–éƒ¨ MCP Serverï¼ˆå¦‚æœªæ¥çš„ç¬¬ä¸‰æ–¹å·¥å…·ï¼‰
external_mcp_tools = await load_mcp_tools("https://external-mcp-server.com")

# æ··åˆä½¿ç”¨
all_tools = langchain_native_tools + mcp_tools + external_mcp_tools
```

---

## ä¸ƒã€æ€»ç»“

æœ¬æ–‡æ¡£è®¾è®¡äº† MCP å·¥å…·åè®®çš„é›†æˆæ–¹æ¡ˆï¼š

- âœ… MCP Server å®ç°ï¼ˆFastAPIï¼‰
- âœ… MCP Client å®ç°
- âœ… LangChain Tools åˆ° MCP çš„é€‚é…å™¨
- âœ… MCP Tools åˆ° LangChain çš„åŒ…è£…å™¨
- âœ… ä¸ LangChain çš„ååŒç­–ç•¥

**å…³é”®å†³ç­–**ï¼š
- MCP ä½œä¸ºå¯é€‰å±‚
- ä¸ LangChain Tools å¹¶å­˜
- ä¼˜å…ˆä½¿ç”¨ LangChain åŸç”Ÿå·¥å…·
- MCP ç”¨äºæ ‡å‡†åŒ–å’Œç¬¬ä¸‰æ–¹é›†æˆ

**å®æ–½ä¼˜å…ˆçº§**ï¼šä¸­ï¼ˆå¯é€‰å®ç°ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-10-27
**ç»´æŠ¤è€…**: AIæ¶æ„ç»„
