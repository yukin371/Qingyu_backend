# A2A åˆ›ä½œæµæ°´çº¿ Agent è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¶é—´**: 2025-10-27
> **å®æ–½çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
> **è´Ÿè´£äºº**: AIæ¶æ„ç»„

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡ A2Aï¼ˆAgent-to-Agentï¼‰åˆ›ä½œæµæ°´çº¿ï¼ŒåŒ…æ‹¬å››ä¸ªä¸“ä¸š Agentï¼ˆå¤§çº² Agentã€è§’è‰² Agentã€æƒ…èŠ‚ Agentã€å®¡æ ¸ Agentï¼‰çš„å®ç°å’Œæµæ°´çº¿ç¼–æ’ç­–ç•¥ã€‚

**é€‚ç”¨èŒƒå›´**ï¼š
- A2A åˆ›ä½œæµæ°´çº¿æ¶æ„
- å››ä¸ªä¸“ä¸š Agent è®¾è®¡
- Agent é—´åä½œæœºåˆ¶
- è¿­ä»£ä¼˜åŒ–å¾ªç¯
- äººå·¥ä»‹å…¥ç­–ç•¥

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. **èŒè´£æ¸…æ™°**ï¼šæ¯ä¸ª Agent ä¸“æ³¨ä¸€ä¸ªé¢†åŸŸ
2. **é¡ºåºåä½œ**ï¼šå¤§çº² â†’ è§’è‰² â†’ æƒ…èŠ‚ â†’ å®¡æ ¸
3. **è¿­ä»£ä¼˜åŒ–**ï¼šæ”¯æŒå¤šè½®ä¼˜åŒ–å¾ªç¯
4. **å¯è¿½æº¯æ€§**ï¼šæ¯ä¸ª Agent çš„è¾“å…¥è¾“å‡ºå¯è¿½è¸ª
5. **äººå·¥ä»‹å…¥**ï¼šå…³é”®èŠ‚ç‚¹æ”¯æŒäººå·¥å®¡æ ¸

### A2A ä¼˜åŠ¿

- âœ… **ä¸“ä¸šåŒ–**ï¼šæ¯ä¸ª Agent ä¸“æ³¨ä¸€ä¸ªä»»åŠ¡ï¼Œæé«˜è´¨é‡
- âœ… **å¯ç»´æŠ¤**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºè°ƒè¯•å’Œä¼˜åŒ–
- âœ… **å¯æ‰©å±•**ï¼šæ˜“äºæ·»åŠ æ–° Agentï¼ˆå¦‚é£æ ¼ Agentï¼‰
- âœ… **å¯æ§**ï¼šæ˜¾å¼æµç¨‹ï¼Œæ˜“äºæ§åˆ¶å’Œç›‘æ§

---

## ä¸€ã€A2A æµæ°´çº¿æ¶æ„

### 1.1 æ•´ä½“æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ·éœ€æ±‚    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            å¤§çº² Agent                    â”‚
â”‚  - åˆ†æéœ€æ±‚                             â”‚
â”‚  - RAG æ£€ç´¢å‚è€ƒå¤§çº²                     â”‚
â”‚  - ç”Ÿæˆç« èŠ‚ç»“æ„                         â”‚
â”‚  - è¾“å‡ºï¼šç»“æ„åŒ–å¤§çº²æ ‘                   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            è§’è‰² Agent                    â”‚
â”‚  - åŸºäºå¤§çº²æå–è§’è‰²éœ€æ±‚                 â”‚
â”‚  - RAG æ£€ç´¢ç°æœ‰è§’è‰²                     â”‚
â”‚  - ç”Ÿæˆæ–°è§’è‰² / æ›´æ–°ç°æœ‰è§’è‰²            â”‚
â”‚  - å»ºç«‹è§’è‰²å…³ç³»å›¾                       â”‚
â”‚  - è¾“å‡ºï¼šè§’è‰²å¡ + å…³ç³»å›¾                â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            æƒ…èŠ‚ Agent                    â”‚
â”‚  - åŸºäºå¤§çº² + è§’è‰²ç”Ÿæˆæƒ…èŠ‚èŠ‚ç‚¹          â”‚
â”‚  - åˆ›å»ºæ—¶é—´çº¿äº‹ä»¶                       â”‚
â”‚  - å®‰æ’å…³é”®åœºæ™¯                         â”‚
â”‚  - è¾“å‡ºï¼šæ—¶é—´çº¿ + æƒ…èŠ‚èŠ‚ç‚¹              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            å®¡æ ¸ Agent                    â”‚
â”‚  - æ£€æŸ¥å¤§çº²ã€è§’è‰²ã€æƒ…èŠ‚çš„ä¸€è‡´æ€§         â”‚
â”‚  - è¯„ä¼°è´¨é‡                             â”‚
â”‚  - æä¾›æ”¹è¿›å»ºè®®                         â”‚
â”‚  - å†³ç­–ï¼šé€šè¿‡ / é‡æ–°ç”Ÿæˆ / äººå·¥å®¡æ ¸     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€[ä¸é€šè¿‡]â”€â”€â”€â–º é‡æ–°ç”Ÿæˆï¼ˆå›åˆ°å¯¹åº”Agentï¼‰
       â”‚
       â”œâ”€â”€â”€[éœ€äººå·¥]â”€â”€â”€â–º ç­‰å¾…äººå·¥å®¡æ ¸
       â”‚
       â–¼
   [å®Œæˆè¾“å‡º]
```

### 1.2 Pipeline State Schema

```python
# src/core/agents/states/pipeline_state.py
from typing import TypedDict, Annotated, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator


class PipelineState(TypedDict):
    """A2A æµæ°´çº¿çŠ¶æ€"""
    
    # ===== è¾“å…¥ =====
    user_requirement: str                        # ç”¨æˆ·éœ€æ±‚
    user_id: str
    project_id: str
    
    # æµæ°´çº¿é…ç½®
    pipeline_config: Dict[str, Any]              # æµæ°´çº¿é…ç½®
    
    # ===== å¤§çº² Agent è¾“å‡º =====
    outline_nodes: List[Dict[str, Any]]          # å¤§çº²èŠ‚ç‚¹åˆ—è¡¨
    outline_summary: str                         # å¤§çº²æ€»ç»“
    outline_metadata: Dict[str, Any]             # å¤§çº²å…ƒæ•°æ®
    
    # ===== è§’è‰² Agent è¾“å‡º =====
    characters: List[Dict[str, Any]]             # è§’è‰²åˆ—è¡¨
    character_relations: List[Dict[str, Any]]    # è§’è‰²å…³ç³»åˆ—è¡¨
    character_summary: str                       # è§’è‰²æ€»ç»“
    
    # ===== æƒ…èŠ‚ Agent è¾“å‡º =====
    timeline_events: List[Dict[str, Any]]        # æ—¶é—´çº¿äº‹ä»¶åˆ—è¡¨
    plot_nodes: List[Dict[str, Any]]             # æƒ…èŠ‚èŠ‚ç‚¹åˆ—è¡¨
    plot_summary: str                            # æƒ…èŠ‚æ€»ç»“
    
    # ===== å®¡æ ¸ Agent è¾“å‡º =====
    review_results: Dict[str, Any]               # å®¡æ ¸ç»“æœ
    consistency_check: Dict[str, Any]            # ä¸€è‡´æ€§æ£€æŸ¥
    quality_score: int                           # è´¨é‡è¯„åˆ†ï¼ˆ0-100ï¼‰
    review_passed: bool                          # æ˜¯å¦é€šè¿‡
    improvement_suggestions: List[str]           # æ”¹è¿›å»ºè®®
    
    # ===== å·¥ä½œæµæ§åˆ¶ =====
    current_agent: str                           # å½“å‰ Agent
    completed_agents: Annotated[List[str], operator.add]  # å·²å®Œæˆçš„ Agent
    
    # è¿­ä»£æ§åˆ¶
    iteration_count: int                         # è¿­ä»£æ¬¡æ•°
    max_iterations: int                          # æœ€å¤§è¿­ä»£æ¬¡æ•°
    
    # äººå·¥ä»‹å…¥
    human_intervention_required: bool            # æ˜¯å¦éœ€è¦äººå·¥ä»‹å…¥
    human_feedback: Optional[str]                # äººå·¥åé¦ˆ
    
    # ===== æ¶ˆæ¯å’Œæ¨ç† =====
    messages: Annotated[List[BaseMessage], operator.add]
    reasoning: Annotated[List[str], operator.add]
    
    # ===== é”™è¯¯å¤„ç† =====
    errors: Annotated[List[str], operator.add]
    warnings: Annotated[List[str], operator.add]
    
    # ===== æ€§èƒ½æŒ‡æ ‡ =====
    start_time: float
    tokens_used: int
    tool_calls_count: int
```

---

## äºŒã€ä¸“ä¸š Agent å®ç°

### 2.1 å¤§çº² Agent

```python
# src/core/agents/nodes/outline_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.outline_tool import OutlineTool
from core.tools.langchain.rag_tool import RAGTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def outline_agent_node(state: PipelineState) -> PipelineState:
    """å¤§çº² Agent
    
    èŒè´£ï¼š
    1. åˆ†æç”¨æˆ·éœ€æ±‚
    2. RAG æ£€ç´¢å‚è€ƒå¤§çº²
    3. ç”Ÿæˆç« èŠ‚ç»“æ„
    4. åˆ›å»ºå¤§çº²èŠ‚ç‚¹
    
    Args:
        state: æµæ°´çº¿çŠ¶æ€
        
    Returns:
        æ›´æ–°åçš„çŠ¶æ€
    """
    logger.info("Outline Agent: Starting outline generation...")
    
    user_requirement = state["user_requirement"]
    project_id = state["project_id"]
    
    # ===== Step 1: RAG æ£€ç´¢å‚è€ƒå¤§çº² =====
    rag_tool = state.get("_rag_tool")
    reference_outlines = []
    
    if rag_tool:
        rag_result = await rag_tool.execute(
            params={
                "query": f"å°è¯´å¤§çº² {user_requirement}",
                "project_id": project_id,
                "content_types": ["outline"],
                "top_k": 3
            },
            user_id=state["user_id"],
            project_id=project_id
        )
        
        if rag_result.success:
            reference_outlines = rag_result.data.get("results", [])
    
    # ===== Step 2: ç”Ÿæˆå¤§çº²ç»“æ„ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å°è¯´å¤§çº²ç­–åˆ’å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç”¨æˆ·éœ€æ±‚ç”Ÿæˆä¸€ä¸ªå®Œæ•´ã€åˆç†çš„å°è¯´å¤§çº²ã€‚

å¤§çº²è¦æ±‚ï¼š
1. ç« èŠ‚ç»“æ„æ¸…æ™°ï¼ˆå· â†’ ç«  â†’ èŠ‚ï¼‰
2. æ¯ä¸ªç« èŠ‚æœ‰æ˜ç¡®çš„ç›®æ ‡å’Œå†²çª
3. æƒ…èŠ‚å‘å±•åˆç†è¿è´¯
4. èŠ‚å¥æ§åˆ¶å¾—å½“

è¾“å‡ºæ ¼å¼ï¼šJSON æ•°ç»„
[
  {
    "level": 1,
    "name": "ç¬¬ä¸€å·ï¼šèµ·å§‹",
    "description": "æ•…äº‹å¼€ç«¯ï¼Œä¸»è§’å‡ºåœº",
    "children": [
      {
        "level": 2,
        "name": "ç¬¬ä¸€ç« ï¼šå‘½è¿ä¹‹é—¨",
        "description": "ä¸»è§’å‘ç°ç¥ç§˜ä¹‹é—¨",
        "goals": ["å¼•å…¥ä¸»è§’", "è®¾ç½®æ‚¬å¿µ"],
        "conflicts": ["ä¸»è§’å†…å¿ƒæŒ£æ‰"],
        "children": []
      }
    ]
  }
]
""")
    
    # æ„å»ºå‚è€ƒèµ„æ–™
    reference_text = ""
    if reference_outlines:
        reference_text = "\nå‚è€ƒå¤§çº²ï¼š\n"
        for i, ref in enumerate(reference_outlines, 1):
            reference_text += f"\nã€å‚è€ƒ{i}ã€‘{ref.get('content', '')[:200]}\n"
    
    user_message = HumanMessage(content=f"""
ç”¨æˆ·éœ€æ±‚ï¼š{user_requirement}

{reference_text}

è¯·ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„å°è¯´å¤§çº²ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£æå¤§çº²ç»“æ„
    try:
        outline_structure = json.loads(response.content)
    except:
        # è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç»“æ„
        outline_structure = [
            {
                "level": 1,
                "name": "ç¬¬ä¸€å·",
                "description": "å¼€ç¯‡",
                "children": [
                    {
                        "level": 2,
                        "name": "ç¬¬ä¸€ç« ",
                        "description": "èµ·å§‹",
                        "children": []
                    }
                ]
            }
        ]
    
    # ===== Step 3: è°ƒç”¨ OutlineTool åˆ›å»ºèŠ‚ç‚¹ =====
    outline_tool = state.get("_outline_tool")
    created_nodes = []
    
    if outline_tool:
        created_nodes = await _create_outline_nodes_recursive(
            outline_tool,
            outline_structure,
            project_id,
            parent_id=None,
            user_id=state["user_id"]
        )
    
    # ===== Step 4: ç”Ÿæˆå¤§çº²æ€»ç»“ =====
    outline_summary = f"ç”Ÿæˆå¤§çº²ï¼šå…± {len(created_nodes)} ä¸ªèŠ‚ç‚¹"
    
    return {
        **state,
        "outline_nodes": created_nodes,
        "outline_summary": outline_summary,
        "outline_metadata": {
            "node_count": len(created_nodes),
            "reference_count": len(reference_outlines)
        },
        "current_agent": "character_agent",
        "completed_agents": state.get("completed_agents", []) + ["outline_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"å¤§çº² Agentï¼šåˆ†æç”¨æˆ·éœ€æ±‚",
            f"å¤§çº² Agentï¼šæ£€ç´¢åˆ° {len(reference_outlines)} ä¸ªå‚è€ƒå¤§çº²",
            f"å¤§çº² Agentï¼šç”Ÿæˆ {len(created_nodes)} ä¸ªå¤§çº²èŠ‚ç‚¹"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_nodes)
    }


async def _create_outline_nodes_recursive(
    outline_tool: OutlineTool,
    nodes: List[Dict[str, Any]],
    project_id: str,
    parent_id: Optional[str],
    user_id: str
) -> List[Dict[str, Any]]:
    """é€’å½’åˆ›å»ºå¤§çº²èŠ‚ç‚¹"""
    created = []
    
    for node in nodes:
        # åˆ›å»ºå½“å‰èŠ‚ç‚¹
        result = await outline_tool.execute(
            params={
                "action": "create_node",
                "project_id": project_id,
                "parent_id": parent_id or "",
                "name": node["name"],
                "description": node.get("description", ""),
                "metadata": {
                    "level": node.get("level", 1),
                    "goals": node.get("goals", []),
                    "conflicts": node.get("conflicts", [])
                }
            },
            user_id=user_id,
            project_id=project_id
        )
        
        if result.success:
            node_data = result.data
            created.append(node_data)
            
            # é€’å½’åˆ›å»ºå­èŠ‚ç‚¹
            if node.get("children"):
                children = await _create_outline_nodes_recursive(
                    outline_tool,
                    node["children"],
                    project_id,
                    parent_id=node_data.get("id"),
                    user_id=user_id
                )
                created.extend(children)
    
    return created
```

### 2.2 è§’è‰² Agent

```python
# src/core/agents/nodes/character_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.character_tool import CharacterTool
from core.tools.langchain.relation_tool import RelationTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def character_agent_node(state: PipelineState) -> PipelineState:
    """è§’è‰² Agent
    
    èŒè´£ï¼š
    1. åŸºäºå¤§çº²æå–è§’è‰²éœ€æ±‚
    2. RAG æ£€ç´¢ç°æœ‰è§’è‰²
    3. ç”Ÿæˆæ–°è§’è‰²å¡
    4. å»ºç«‹è§’è‰²å…³ç³»
    
    Args:
        state: æµæ°´çº¿çŠ¶æ€
        
    Returns:
        æ›´æ–°åçš„çŠ¶æ€
    """
    logger.info("Character Agent: Starting character generation...")
    
    outline_summary = state.get("outline_summary", "")
    outline_nodes = state.get("outline_nodes", [])
    project_id = state["project_id"]
    
    # ===== Step 1: åˆ†æå¤§çº²ï¼Œæå–è§’è‰²éœ€æ±‚ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²è®¾è®¡å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®å°è¯´å¤§çº²è®¾è®¡è§’è‰²ã€‚

è§’è‰²è®¾è®¡è¦æ±‚ï¼š
1. ä¸»è§’ã€é…è§’ã€åæ´¾é½å…¨
2. æ€§æ ¼é²œæ˜ï¼Œæœ‰ç‹¬ç‰¹æ ‡ç­¾
3. èƒŒæ™¯åˆç†ï¼Œç¬¦åˆå¤§çº²è®¾å®š
4. è§’è‰²é—´å…³ç³»æ¸…æ™°

è¾“å‡ºæ ¼å¼ï¼šJSON
{
  "characters": [
    {
      "name": "å¼ ä¸‰",
      "role_type": "protagonist",  // protagonist, supporting, antagonist
      "summary": "çƒ­è¡€å°‘å¹´ï¼Œæ­£ä¹‰æ„Ÿå¼º",
      "traits": ["å‹‡æ•¢", "å–„è‰¯", "å†²åŠ¨"],
      "background": "å¹³å‡¡å®¶åº­å‡ºèº«...",
      "personality_prompt": "æ€§æ ¼å¼€æœ—ï¼Œå–œæ¬¢å¸®åŠ©ä»–äºº",
      "speech_pattern": "è¯´è¯ç›´ç‡ï¼Œä¸æ‹å¼¯æŠ¹è§’"
    }
  ],
  "relations": [
    {
      "from": "å¼ ä¸‰",
      "to": "æå››",
      "type": "æœ‹å‹",
      "strength": 80,
      "notes": "ä»å°ä¸€èµ·é•¿å¤§çš„å¥½å‹"
    }
  ]
}
""")
    
    # æ„å»ºå¤§çº²æ‘˜è¦
    outline_text = f"å¤§çº²æ€»ç»“ï¼š{outline_summary}\n\n"
    outline_text += "å¤§çº²èŠ‚ç‚¹ï¼š\n"
    for node in outline_nodes[:5]:  # åªå–å‰5ä¸ªèŠ‚ç‚¹
        outline_text += f"- {node.get('name')}: {node.get('description', '')}\n"
    
    user_message = HumanMessage(content=f"""
{outline_text}

è¯·æ ¹æ®å¤§çº²è®¾è®¡è§’è‰²ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£æè§’è‰²æ•°æ®
    try:
        character_data = json.loads(response.content)
        character_designs = character_data.get("characters", [])
        relation_designs = character_data.get("relations", [])
    except:
        character_designs = []
        relation_designs = []
    
    # ===== Step 2: è°ƒç”¨ CharacterTool åˆ›å»ºè§’è‰² =====
    character_tool = state.get("_character_tool")
    created_characters = []
    
    if character_tool:
        for char_design in character_designs:
            result = await character_tool.execute(
                params={
                    "action": "create",
                    "project_id": project_id,
                    "name": char_design["name"],
                    "summary": char_design.get("summary", ""),
                    "traits": char_design.get("traits", []),
                    "background": char_design.get("background", ""),
                    "personality_prompt": char_design.get("personality_prompt", ""),
                    "speech_pattern": char_design.get("speech_pattern", "")
                },
                user_id=state["user_id"],
                project_id=project_id
            )
            
            if result.success:
                created_characters.append(result.data)
    
    # ===== Step 3: å»ºç«‹è§’è‰²å…³ç³» =====
    relation_tool = state.get("_relation_tool")
    created_relations = []
    
    if relation_tool and len(created_characters) >= 2:
        # æ„å»ºè§’è‰²ååˆ° ID çš„æ˜ å°„
        name_to_id = {char["name"]: char["id"] for char in created_characters}
        
        for relation_design in relation_designs:
            from_id = name_to_id.get(relation_design["from"])
            to_id = name_to_id.get(relation_design["to"])
            
            if from_id and to_id:
                result = await relation_tool.execute(
                    params={
                        "action": "create",
                        "project_id": project_id,
                        "from_id": from_id,
                        "to_id": to_id,
                        "relation_type": relation_design.get("type", "å…¶ä»–"),
                        "strength": relation_design.get("strength", 50),
                        "notes": relation_design.get("notes", "")
                    },
                    user_id=state["user_id"],
                    project_id=project_id
                )
                
                if result.success:
                    created_relations.append(result.data)
    
    # ===== Step 4: ç”Ÿæˆè§’è‰²æ€»ç»“ =====
    character_summary = f"åˆ›å»º {len(created_characters)} ä¸ªè§’è‰²ï¼Œ{len(created_relations)} ä¸ªå…³ç³»"
    
    return {
        **state,
        "characters": created_characters,
        "character_relations": created_relations,
        "character_summary": character_summary,
        "current_agent": "plot_agent",
        "completed_agents": state.get("completed_agents", []) + ["character_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"è§’è‰² Agentï¼šåˆ†æå¤§çº²",
            f"è§’è‰² Agentï¼šè®¾è®¡ {len(character_designs)} ä¸ªè§’è‰²",
            f"è§’è‰² Agentï¼šåˆ›å»º {len(created_characters)} ä¸ªè§’è‰²å¡",
            f"è§’è‰² Agentï¼šå»ºç«‹ {len(created_relations)} ä¸ªå…³ç³»"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_characters) + len(created_relations)
    }
```

### 2.3 æƒ…èŠ‚ Agent

```python
# src/core/agents/nodes/plot_agent.py
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from core.tools.langchain.timeline_tool import TimelineTool
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def plot_agent_node(state: PipelineState) -> PipelineState:
    """æƒ…èŠ‚ Agent
    
    èŒè´£ï¼š
    1. åŸºäºå¤§çº² + è§’è‰²ç”Ÿæˆæƒ…èŠ‚
    2. åˆ›å»ºæ—¶é—´çº¿äº‹ä»¶
    3. å®‰æ’å…³é”®åœºæ™¯
    
    Args:
        state: æµæ°´çº¿çŠ¶æ€
        
    Returns:
        æ›´æ–°åçš„çŠ¶æ€
    """
    logger.info("Plot Agent: Starting plot generation...")
    
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    project_id = state["project_id"]
    
    # ===== Step 1: ç”Ÿæˆæ—¶é—´çº¿ =====
    timeline_tool = state.get("_timeline_tool")
    timeline_id = None
    
    if timeline_tool:
        result = await timeline_tool.execute(
            params={
                "action": "create_timeline",
                "project_id": project_id,
                "timeline_name": "ä¸»çº¿æ—¶é—´çº¿",
                "timeline_description": "å°è¯´ä¸»è¦æƒ…èŠ‚æ—¶é—´çº¿"
            },
            user_id=state["user_id"],
            project_id=project_id
        )
        
        if result.success:
            timeline_id = result.data.get("id")
    
    # ===== Step 2: åŸºäºå¤§çº²å’Œè§’è‰²ç”Ÿæˆæƒ…èŠ‚äº‹ä»¶ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0.7)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æƒ…èŠ‚è®¾è®¡å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®å¤§çº²å’Œè§’è‰²è®¾è®¡æƒ…èŠ‚äº‹ä»¶ã€‚

æƒ…èŠ‚è®¾è®¡è¦æ±‚ï¼š
1. äº‹ä»¶ç¬¦åˆå¤§çº²ç« èŠ‚ç›®æ ‡
2. è§’è‰²è¡Œä¸ºç¬¦åˆæ€§æ ¼
3. å†²çªå’Œé«˜æ½®å®‰æ’åˆç†
4. æ—¶é—´çº¿æ¸…æ™°è¿è´¯

è¾“å‡ºæ ¼å¼ï¼šJSON
{
  "events": [
    {
      "title": "ä¸»è§’è§‰é†’",
      "description": "ä¸»è§’åœ¨å±æœºä¸­è§‰é†’ç‰¹æ®Šèƒ½åŠ›",
      "event_type": "plot",  // plot, character, milestone
      "importance": 9,
      "participants": ["å¼ ä¸‰", "æå››"],
      "chapter_ref": "ç¬¬ä¸€ç« ",
      "story_time": {"day": 1, "time": "æ¸…æ™¨"}
    }
  ]
}
""")
    
    # æ„å»ºä¸Šä¸‹æ–‡
    context = f"å¤§çº²èŠ‚ç‚¹æ•°ï¼š{len(outline_nodes)}\n"
    context += f"è§’è‰²ï¼š{', '.join([c['name'] for c in characters])}\n\n"
    context += "å¤§çº²æ‘˜è¦ï¼š\n"
    for node in outline_nodes[:10]:
        context += f"- {node.get('name')}\n"
    
    user_message = HumanMessage(content=f"""
{context}

è¯·æ ¹æ®å¤§çº²å’Œè§’è‰²è®¾è®¡æƒ…èŠ‚äº‹ä»¶ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£æäº‹ä»¶æ•°æ®
    try:
        plot_data = json.loads(response.content)
        event_designs = plot_data.get("events", [])
    except:
        event_designs = []
    
    # ===== Step 3: åˆ›å»ºæ—¶é—´çº¿äº‹ä»¶ =====
    created_events = []
    
    if timeline_tool and timeline_id:
        # æ„å»ºè§’è‰²ååˆ° ID çš„æ˜ å°„
        name_to_id = {char["name"]: char["id"] for char in characters}
        
        for event_design in event_designs:
            # è½¬æ¢å‚ä¸è€…åç§°ä¸º ID
            participant_ids = [
                name_to_id[name]
                for name in event_design.get("participants", [])
                if name in name_to_id
            ]
            
            result = await timeline_tool.execute(
                params={
                    "action": "create_event",
                    "project_id": project_id,
                    "timeline_id": timeline_id,
                    "title": event_design["title"],
                    "description": event_design.get("description", ""),
                    "event_type": event_design.get("event_type", "plot"),
                    "importance": event_design.get("importance", 5),
                    "participants": participant_ids,
                    "story_time": event_design.get("story_time")
                },
                user_id=state["user_id"],
                project_id=project_id
            )
            
            if result.success:
                created_events.append(result.data)
    
    # ===== Step 4: ç”Ÿæˆæƒ…èŠ‚æ€»ç»“ =====
    plot_summary = f"åˆ›å»º {len(created_events)} ä¸ªæ—¶é—´çº¿äº‹ä»¶"
    
    return {
        **state,
        "timeline_events": created_events,
        "plot_summary": plot_summary,
        "current_agent": "review_agent",
        "completed_agents": state.get("completed_agents", []) + ["plot_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"æƒ…èŠ‚ Agentï¼šåˆ†æå¤§çº²å’Œè§’è‰²",
            f"æƒ…èŠ‚ Agentï¼šè®¾è®¡ {len(event_designs)} ä¸ªæƒ…èŠ‚äº‹ä»¶",
            f"æƒ…èŠ‚ Agentï¼šåˆ›å»ºæ—¶é—´çº¿äº‹ä»¶ {len(created_events)} ä¸ª"
        ],
        "tool_calls_count": state.get("tool_calls_count", 0) + len(created_events) + 1  # +1 for timeline creation
    }
```

### 2.4 å®¡æ ¸ Agent

```python
# src/core/agents/nodes/review_agent.py
from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from core.agents.states.pipeline_state import PipelineState
from utils.logging import get_logger
import json

logger = get_logger(__name__)


async def review_agent_node(state: PipelineState) -> PipelineState:
    """å®¡æ ¸ Agent
    
    èŒè´£ï¼š
    1. æ£€æŸ¥å¤§çº²ã€è§’è‰²ã€æƒ…èŠ‚çš„ä¸€è‡´æ€§
    2. è¯„ä¼°è´¨é‡
    3. æä¾›æ”¹è¿›å»ºè®®
    4. å†³ç­–ï¼šé€šè¿‡ / é‡æ–°ç”Ÿæˆ / äººå·¥å®¡æ ¸
    
    Args:
        state: æµæ°´çº¿çŠ¶æ€
        
    Returns:
        æ›´æ–°åçš„çŠ¶æ€
    """
    logger.info("Review Agent: Starting review...")
    
    outline_summary = state.get("outline_summary", "")
    character_summary = state.get("character_summary", "")
    plot_summary = state.get("plot_summary", "")
    
    outline_nodes = state.get("outline_nodes", [])
    characters = state.get("characters", [])
    timeline_events = state.get("timeline_events", [])
    
    # ===== Step 1: ä¸€è‡´æ€§æ£€æŸ¥ =====
    llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
    
    system_message = SystemMessage(content="""
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å†…å®¹å®¡æ ¸ä¸“å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯è¯„ä¼°å°è¯´åˆ›ä½œå†…å®¹çš„è´¨é‡å’Œä¸€è‡´æ€§ã€‚

å®¡æ ¸æ ‡å‡†ï¼š
1. ä¸€è‡´æ€§ï¼šå¤§çº²ã€è§’è‰²ã€æƒ…èŠ‚æ˜¯å¦ä¸€è‡´
2. å®Œæ•´æ€§ï¼šæ˜¯å¦ç¼ºå°‘å…³é”®å…ƒç´ 
3. åˆç†æ€§ï¼šè®¾å®šæ˜¯å¦åˆç†
4. è´¨é‡ï¼šå†…å®¹è´¨é‡æ˜¯å¦è¾¾æ ‡

è¾“å‡ºæ ¼å¼ï¼šJSON
{
  "passed": true/false,
  "quality_score": 85,
  "consistency_check": {
    "outline_character_consistency": "good",  // good, fair, poor
    "character_plot_consistency": "good",
    "logical_consistency": "fair"
  },
  "issues": [
    {"severity": "high", "type": "consistency", "description": "è§’è‰²Aåœ¨å¤§çº²ä¸­æœªæåŠ"},
    {"severity": "medium", "type": "quality", "description": "æƒ…èŠ‚å‘å±•è¿‡äºä»“ä¿ƒ"}
  ],
  "suggestions": [
    "å»ºè®®åœ¨å¤§çº²ä¸­è¡¥å……è§’è‰²Açš„å‡ºåœº",
    "å»ºè®®å¢åŠ è¿‡æ¸¡æƒ…èŠ‚"
  ],
  "decision": "pass",  // pass, regenerate, human_review
  "decision_reason": "æ•´ä½“è´¨é‡è‰¯å¥½ï¼Œå°é—®é¢˜å¯åæœŸä¿®æ­£"
}
""")
    
    # æ„å»ºå®¡æ ¸å†…å®¹
    review_content = f"""
ã€å¤§çº²ã€‘
- èŠ‚ç‚¹æ•°ï¼š{len(outline_nodes)}
- æ€»ç»“ï¼š{outline_summary}
- å‰3ä¸ªèŠ‚ç‚¹ï¼š{', '.join([n.get('name', '') for n in outline_nodes[:3]])}

ã€è§’è‰²ã€‘
- è§’è‰²æ•°ï¼š{len(characters)}
- æ€»ç»“ï¼š{character_summary}
- è§’è‰²åˆ—è¡¨ï¼š{', '.join([c.get('name', '') for c in characters])}

ã€æƒ…èŠ‚ã€‘
- äº‹ä»¶æ•°ï¼š{len(timeline_events)}
- æ€»ç»“ï¼š{plot_summary}
- å‰3ä¸ªäº‹ä»¶ï¼š{', '.join([e.get('title', '') for e in timeline_events[:3]])}
"""
    
    user_message = HumanMessage(content=f"""
{review_content}

è¯·å®¡æ ¸ä»¥ä¸Šå†…å®¹ï¼ˆJSONæ ¼å¼ï¼‰ã€‚
""")
    
    response = await llm.ainvoke([system_message, user_message])
    
    # è§£æå®¡æ ¸ç»“æœ
    try:
        review_result = json.loads(response.content)
    except:
        # è§£æå¤±è´¥ï¼Œé»˜è®¤é€šè¿‡
        review_result = {
            "passed": True,
            "quality_score": 75,
            "consistency_check": {},
            "issues": [],
            "suggestions": [],
            "decision": "pass",
            "decision_reason": "å®¡æ ¸é€šè¿‡"
        }
    
    passed = review_result.get("passed", False)
    quality_score = review_result.get("quality_score", 0)
    decision = review_result.get("decision", "pass")
    
    # å†³å®šä¸‹ä¸€æ­¥
    if decision == "human_review":
        human_intervention_required = True
        current_agent = "human_review"
    elif decision == "regenerate" or quality_score < 60:
        human_intervention_required = False
        current_agent = "regenerate"
    else:
        human_intervention_required = False
        current_agent = "completed"
    
    return {
        **state,
        "review_results": review_result,
        "consistency_check": review_result.get("consistency_check", {}),
        "quality_score": quality_score,
        "review_passed": passed,
        "improvement_suggestions": review_result.get("suggestions", []),
        "human_intervention_required": human_intervention_required,
        "current_agent": current_agent,
        "completed_agents": state.get("completed_agents", []) + ["review_agent"],
        "messages": state.get("messages", []) + [system_message, user_message, response],
        "reasoning": state.get("reasoning", []) + [
            f"å®¡æ ¸ Agentï¼šè´¨é‡è¯„åˆ† {quality_score}",
            f"å®¡æ ¸ Agentï¼šå‘ç° {len(review_result.get('issues', []))} ä¸ªé—®é¢˜",
            f"å®¡æ ¸ Agentï¼šå†³ç­– - {decision}"
        ]
    }
```

---

## ä¸‰ã€æµæ°´çº¿ç¼–æ’

### 3.1 A2A Workflow

```python
# src/core/agents/workflows/a2a_pipeline.py
from langgraph.graph import StateGraph, END
from core.agents.states.pipeline_state import PipelineState
from core.agents.nodes import (
    outline_agent_node,
    character_agent_node,
    plot_agent_node,
    review_agent_node
)
from utils.logging import get_logger

logger = get_logger(__name__)


def create_a2a_pipeline():
    """åˆ›å»º A2A åˆ›ä½œæµæ°´çº¿
    
    Returns:
        ç¼–è¯‘åçš„æµæ°´çº¿
    """
    logger.info("Creating A2A pipeline...")
    
    # åˆ›å»ºçŠ¶æ€å›¾
    workflow = StateGraph(PipelineState)
    
    # æ·»åŠ  Agent èŠ‚ç‚¹
    workflow.add_node("outline_agent", outline_agent_node)
    workflow.add_node("character_agent", character_agent_node)
    workflow.add_node("plot_agent", plot_agent_node)
    workflow.add_node("review_agent", review_agent_node)
    
    # æ·»åŠ é‡æ–°ç”ŸæˆèŠ‚ç‚¹
    async def regenerate_router_node(state: PipelineState) -> PipelineState:
        """é‡æ–°ç”Ÿæˆè·¯ç”±èŠ‚ç‚¹"""
        issues = state.get("review_results", {}).get("issues", [])
        
        # åˆ†æé—®é¢˜ç±»å‹ï¼Œå†³å®šä»å“ªä¸ª Agent é‡æ–°å¼€å§‹
        has_outline_issue = any("outline" in issue.get("description", "").lower() for issue in issues)
        has_character_issue = any("character" in issue.get("description", "").lower() or "è§’è‰²" in issue.get("description", "") for issue in issues)
        has_plot_issue = any("plot" in issue.get("description", "").lower() or "æƒ…èŠ‚" in issue.get("description", "") for issue in issues)
        
        if has_outline_issue:
            restart_agent = "outline_agent"
        elif has_character_issue:
            restart_agent = "character_agent"
        elif has_plot_issue:
            restart_agent = "plot_agent"
        else:
            restart_agent = "outline_agent"  # é»˜è®¤ä»å¤´å¼€å§‹
        
        return {
            **state,
            "iteration_count": state.get("iteration_count", 0) + 1,
            "current_agent": restart_agent,
            "reasoning": state.get("reasoning", []) + [
                f"é‡æ–°ç”Ÿæˆï¼šä» {restart_agent} å¼€å§‹"
            ]
        }
    
    workflow.add_node("regenerate_router", regenerate_router_node)
    
    # æ·»åŠ äººå·¥å®¡æ ¸èŠ‚ç‚¹
    async def human_review_node(state: PipelineState) -> PipelineState:
        """äººå·¥å®¡æ ¸èŠ‚ç‚¹ï¼ˆä¸­æ–­ç­‰å¾…ï¼‰"""
        from langgraph.graph import interrupt
        
        feedback = interrupt({
            "message": "è¯·å®¡æ ¸åˆ›ä½œå†…å®¹",
            "outline_summary": state.get("outline_summary"),
            "character_summary": state.get("character_summary"),
            "plot_summary": state.get("plot_summary"),
            "review_results": state.get("review_results")
        })
        
        if feedback.get("approved"):
            return {
                **state,
                "review_passed": True,
                "current_agent": "completed",
                "human_feedback": feedback.get("comment", ""),
                "reasoning": state.get("reasoning", []) + ["äººå·¥å®¡æ ¸ï¼šé€šè¿‡"]
            }
        else:
            return {
                **state,
                "review_passed": False,
                "current_agent": "regenerate",
                "human_feedback": feedback.get("comment", ""),
                "reasoning": state.get("reasoning", []) + [
                    f"äººå·¥å®¡æ ¸ï¼šä¸é€šè¿‡ - {feedback.get('comment', '')}"
                ]
            }
    
    workflow.add_node("human_review", human_review_node)
    
    # ===== è®¾ç½®æµç¨‹ =====
    workflow.set_entry_point("outline_agent")
    
    # é¡ºåºè¾¹
    workflow.add_edge("outline_agent", "character_agent")
    workflow.add_edge("character_agent", "plot_agent")
    workflow.add_edge("plot_agent", "review_agent")
    
    # æ¡ä»¶è¾¹ï¼šå®¡æ ¸åçš„è·¯ç”±
    def review_router(state: PipelineState) -> str:
        """å®¡æ ¸è·¯ç”±"""
        current_agent = state.get("current_agent", "")
        
        if current_agent == "completed":
            return "end"
        elif current_agent == "human_review":
            return "human_review"
        elif current_agent == "regenerate":
            # æ£€æŸ¥è¿­ä»£æ¬¡æ•°
            iteration = state.get("iteration_count", 0)
            max_iterations = state.get("max_iterations", 3)
            
            if iteration >= max_iterations:
                logger.warning(f"Max iterations ({max_iterations}) reached")
                return "end"
            return "regenerate"
        else:
            return "end"
    
    workflow.add_conditional_edges(
        "review_agent",
        review_router,
        {
            "end": END,
            "human_review": "human_review",
            "regenerate": "regenerate_router"
        }
    )
    
    # äººå·¥å®¡æ ¸åçš„è·¯ç”±
    workflow.add_conditional_edges(
        "human_review",
        lambda state: "end" if state.get("review_passed") else "regenerate",
        {
            "end": END,
            "regenerate": "regenerate_router"
        }
    )
    
    # é‡æ–°ç”Ÿæˆè·¯ç”±
    def regenerate_router(state: PipelineState) -> str:
        """é‡æ–°ç”Ÿæˆè·¯ç”±"""
        return state.get("current_agent", "outline_agent")
    
    workflow.add_conditional_edges(
        "regenerate_router",
        regenerate_router,
        {
            "outline_agent": "outline_agent",
            "character_agent": "character_agent",
            "plot_agent": "plot_agent"
        }
    )
    
    # ç¼–è¯‘
    app = workflow.compile()
    
    logger.info("A2A pipeline created successfully")
    return app
```

---

## å››ã€ä½¿ç”¨ç¤ºä¾‹

```python
# åˆ›å»ºæµæ°´çº¿
from core.agents.workflows.a2a_pipeline import create_a2a_pipeline

pipeline = create_a2a_pipeline()

# å‡†å¤‡åˆå§‹çŠ¶æ€
initial_state = {
    "user_requirement": "åˆ›ä½œä¸€éƒ¨ä¿®ä»™å°è¯´ï¼Œä¸»è§’ä»å°é•‡å‡ºå‘ï¼Œå†ç»ç£¨éš¾æˆä¸ºä»™å¸",
    "user_id": "user-123",
    "project_id": "proj-456",
    "pipeline_config": {
        "enable_rag": True,
        "enable_human_review": False
    },
    "max_iterations": 3,
    "iteration_count": 0,
    "messages": [],
    "reasoning": [],
    "errors": [],
    "warnings": [],
    "completed_agents": [],
    "tool_calls_count": 0,
    "start_time": time.time(),
    "tokens_used": 0
}

# æ‰§è¡Œæµæ°´çº¿
result = await pipeline.ainvoke(initial_state)

# æŸ¥çœ‹ç»“æœ
print(f"å¤§çº²èŠ‚ç‚¹æ•°ï¼š{len(result['outline_nodes'])}")
print(f"è§’è‰²æ•°ï¼š{len(result['characters'])}")
print(f"æ—¶é—´çº¿äº‹ä»¶æ•°ï¼š{len(result['timeline_events'])}")
print(f"è´¨é‡è¯„åˆ†ï¼š{result['quality_score']}")
print(f"å®¡æ ¸æ˜¯å¦é€šè¿‡ï¼š{result['review_passed']}")
```

---

## äº”ã€æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡äº† A2A åˆ›ä½œæµæ°´çº¿ï¼ŒåŒ…æ‹¬ï¼š

- âœ… å››ä¸ªä¸“ä¸š Agentï¼ˆå¤§çº²ã€è§’è‰²ã€æƒ…èŠ‚ã€å®¡æ ¸ï¼‰
- âœ… é¡ºåºåä½œæµç¨‹
- âœ… è¿­ä»£ä¼˜åŒ–å¾ªç¯
- âœ… äººå·¥ä»‹å…¥æœºåˆ¶
- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†

**å…³é”®ç‰¹æ€§**ï¼š
- ä¸“ä¸šåŒ–åˆ†å·¥
- æ˜¾å¼æµç¨‹æ§åˆ¶
- æ”¯æŒå¤šè½®è¿­ä»£
- æ”¯æŒäººå·¥å®¡æ ¸
- å®Œæ•´çš„å¯è¿½æº¯æ€§

**åç»­å·¥ä½œ**ï¼š
- æ€§èƒ½ä¼˜åŒ–ï¼ˆå¹¶è¡Œæ‰§è¡Œéƒ¨åˆ†èŠ‚ç‚¹ï¼‰
- æ·»åŠ æ›´å¤šä¸“ä¸š Agentï¼ˆé£æ ¼ Agentã€ä¸–ç•Œè§‚ Agentï¼‰
- å®Œå–„è´¨é‡è¯„ä¼°æ ‡å‡†

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-10-27
**ç»´æŠ¤è€…**: AIæ¶æ„ç»„
