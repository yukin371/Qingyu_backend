# é…ç½®ä¸­å¿ƒé›†æˆè®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-21

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è®¾è®¡é…ç½®ä¸­å¿ƒé›†æˆæ–¹æ¡ˆï¼Œæ”¯æŒPromptæ¨¡æ¿ç®¡ç†å’ŒAIé…ç½®çƒ­æ›´æ–°ã€‚

---

## ä¸€ã€é…ç½®ä¸­å¿ƒé€‰å‹

### 1.1 æ–¹æ¡ˆå¯¹æ¯”

| é…ç½®ä¸­å¿ƒ | ä¼˜åŠ¿ | åŠ£åŠ¿ | æ¨èåº¦ |
|---------|------|------|--------|
| **Apollo** | åŠŸèƒ½å®Œå–„ã€ç•Œé¢å‹å¥½ã€æƒé™ç®¡ç† | è¾ƒé‡ | â­â­â­â­â­ |
| **Consul** | è½»é‡ã€æœåŠ¡å‘ç°é›†æˆ | åŠŸèƒ½ç›¸å¯¹ç®€å• | â­â­â­â­ |
| **Nacos** | é˜¿é‡Œç³»ã€å›½å†…æ–‡æ¡£å¥½ | ç”Ÿæ€ç›¸å¯¹å° | â­â­â­â­ |

**æ¨è**ï¼šApolloï¼ˆåŠŸèƒ½æœ€å®Œå–„ï¼‰

---

## äºŒã€Promptæ¨¡æ¿ç®¡ç†

### 2.1 æ¨¡æ¿å­˜å‚¨ç»“æ„

```yaml
# Apolloé…ç½®ç¤ºä¾‹
prompts:
  creative_writing:
    continue_writing: |
      ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å†™ä½œåŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ç»§ç»­åˆ›ä½œï¼š
      
      è§’è‰²ä¿¡æ¯ï¼š
      {{characters}}
      
      ä¸–ç•Œè§‚è®¾å®šï¼š
      {{settings}}
      
      å‰æ–‡å†…å®¹ï¼š
      {{previous_content}}
      
      è¯·ç»§ç»­åˆ›ä½œï¼Œä¿æŒé£æ ¼ä¸€è‡´ã€‚
    
    dialogue_generation: |
      è¯·ä¸ºä»¥ä¸‹è§’è‰²ç”Ÿæˆå¯¹è¯ï¼š
      
      è§’è‰²Aï¼š{{character_a}}
      è§’è‰²Bï¼š{{character_b}}
      
      åœºæ™¯ï¼š{{scene}}
      å†²çªï¼š{{conflict}}
      
  analysis:
    style_analysis: |
      è¯·åˆ†æä»¥ä¸‹æ–‡æœ¬çš„å†™ä½œé£æ ¼ï¼š
      
      {{text}}
      
      åˆ†æç»´åº¦ï¼šæ–‡é£ã€èŠ‚å¥ã€æƒ…æ„Ÿã€è¯­è¨€ç‰¹ç‚¹
```

### 2.2 Go Templateå¼•æ“é›†æˆ

```go
package prompt

import (
    "bytes"
    "text/template"
)

type PromptTemplate struct {
    Name     string
    Template *template.Template
}

type PromptManager struct {
    templates map[string]*PromptTemplate
    apollo    *apollo.Client
}

func (pm *PromptManager) RenderPrompt(name string, data map[string]interface{}) (string, error) {
    tmpl, exists := pm.templates[name]
    if !exists {
        return "", fmt.Errorf("æ¨¡æ¿ä¸å­˜åœ¨: %s", name)
    }
    
    var buf bytes.Buffer
    if err := tmpl.Template.Execute(&buf, data); err != nil {
        return "", err
    }
    
    return buf.String(), nil
}

func (pm *PromptManager) LoadFromApollo() error {
    // ä»ApolloåŠ è½½æ¨¡æ¿
    config := pm.apollo.GetConfig("prompts")
    
    for name, content := range config {
        tmpl, err := template.New(name).Parse(content)
        if err != nil {
            return err
        }
        
        pm.templates[name] = &PromptTemplate{
            Name:     name,
            Template: tmpl,
        }
    }
    
    return nil
}

// ç›‘å¬é…ç½®å˜åŒ–
func (pm *PromptManager) WatchConfigChanges() {
    pm.apollo.OnChange(func(event *apollo.ChangeEvent) {
        log.Info("Promptæ¨¡æ¿æ›´æ–°", "namespace", event.Namespace)
        pm.LoadFromApollo()
    })
}
```

---

## ä¸‰ã€AIé…ç½®çƒ­æ›´æ–°

### 3.1 é…ç½®ç»“æ„

```yaml
ai:
  models:
    gpt-4:
      temperature: 0.7
      max_tokens: 2000
      top_p: 0.9
    gpt-3.5-turbo:
      temperature: 0.8
      max_tokens: 1500
  
  routing:
    creative_writing: gpt-4
    dialogue: gpt-3.5-turbo
    analysis: gpt-4
  
  quotas:
    default_daily_limit: 10000
    vip_daily_limit: 50000
```

### 3.2 é…ç½®ç›‘å¬

```go
type AIConfigManager struct {
    config *AIConfig
    mu     sync.RWMutex
    apollo *apollo.Client
}

func (acm *AIConfigManager) GetModelConfig(model string) *ModelConfig {
    acm.mu.RLock()
    defer acm.mu.RUnlock()
    
    return acm.config.Models[model]
}

func (acm *AIConfigManager) WatchChanges() {
    acm.apollo.OnChange(func(event *apollo.ChangeEvent) {
        newConfig, err := parseAIConfig(event.NewValue)
        if err != nil {
            log.Error("è§£æé…ç½®å¤±è´¥", "error", err)
            return
        }
        
        acm.mu.Lock()
        acm.config = newConfig
        acm.mu.Unlock()
        
        log.Info("AIé…ç½®å·²æ›´æ–°")
    })
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-21

