# æµ‹è¯•å·¥å…·è®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-25  
**çŠ¶æ€**: âœ… æ­£å¼å‘å¸ƒ

---

## ä¸€ã€æ¦‚è¿°

### 1.1 ç›®æ ‡

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜é’ç¾½å†™ä½œåç«¯æœåŠ¡æµ‹è¯•å·¥å…·çš„è®¾è®¡ã€æ¶æ„å’Œä½¿ç”¨æ–¹æ³•ï¼ŒåŒ…æ‹¬TestHelperæ¡†æ¶ã€æµ‹è¯•æ•°æ®å·¥å‚ã€ç¯å¢ƒéªŒè¯å·¥å…·ç­‰ã€‚

### 1.2 æ ¸å¿ƒå·¥å…·

1. **TestHelperæ¡†æ¶** - ç»Ÿä¸€çš„æµ‹è¯•è¾…åŠ©å·¥å…·
2. **è·¯å¾„å¸¸é‡ç³»ç»Ÿ** - é›†ä¸­çš„APIè·¯å¾„ç®¡ç†
3. **æµ‹è¯•æ•°æ®å·¥å‚** - ä¾¿æ·çš„æµ‹è¯•æ•°æ®åˆ›å»º
4. **ç¯å¢ƒéªŒè¯å·¥å…·** - æµ‹è¯•ç¯å¢ƒè‡ªåŠ¨æ£€æŸ¥
5. **æ•°æ®å‡†å¤‡è„šæœ¬** - è‡ªåŠ¨åŒ–æµ‹è¯•æ•°æ®å¯¼å…¥

---

## äºŒã€TestHelperæ¡†æ¶

### 2.1 è®¾è®¡ç›®æ ‡

**é—®é¢˜**ï¼š
- âŒ é‡å¤çš„ç™»å½•ä»£ç ï¼ˆæ¯ä¸ªæµ‹è¯•~20è¡Œï¼‰
- âŒ æ‰‹åŠ¨æ„é€ HTTPè¯·æ±‚ï¼ˆæ˜“å‡ºé”™ï¼‰
- âŒ ç®€å•çš„æ–­è¨€ï¼ˆé”™è¯¯ä¿¡æ¯ä¸è¯¦ç»†ï¼‰
- âŒ åˆ†æ•£çš„æµ‹è¯•å·¥å…·å‡½æ•°

**è§£å†³æ–¹æ¡ˆ**ï¼š
- âœ… ç»Ÿä¸€çš„TestHelperæ¡†æ¶
- âœ… ä¸€è¡Œä»£ç å®Œæˆç™»å½•
- âœ… è¯¦ç»†çš„é”™è¯¯è¯Šæ–­ä¿¡æ¯
- âœ… é›†ä¸­ç®¡ç†æµ‹è¯•å·¥å…·

### 2.2 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TestHelper æ¡†æ¶                    â”‚
â”‚  file: test/integration/helpers.go              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ è®¤è¯æ¨¡å—      â”‚  â”‚ HTTPæ¨¡å—     â”‚            â”‚
â”‚  â”‚              â”‚  â”‚              â”‚            â”‚
â”‚  â”‚ LoginUser()  â”‚  â”‚ DoRequest()  â”‚            â”‚
â”‚  â”‚ LoginTest    â”‚  â”‚ DoAuthReq()  â”‚            â”‚
â”‚  â”‚ User()       â”‚  â”‚              â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ æ–­è¨€æ¨¡å—      â”‚  â”‚ æ•°æ®åº“æ¨¡å—   â”‚            â”‚
â”‚  â”‚              â”‚  â”‚              â”‚            â”‚
â”‚  â”‚ AssertSuccessâ”‚  â”‚ GetTestBook()â”‚            â”‚
â”‚  â”‚ AssertError  â”‚  â”‚ Cleanup      â”‚            â”‚
â”‚  â”‚              â”‚  â”‚ TestData()   â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ æ—¥å¿—æ¨¡å—      â”‚  â”‚ è·¯å¾„å¸¸é‡     â”‚            â”‚
â”‚  â”‚              â”‚  â”‚              â”‚            â”‚
â”‚  â”‚ LogSuccess() â”‚  â”‚ LoginPath    â”‚            â”‚
â”‚  â”‚ LogError()   â”‚  â”‚ ReaderBooks  â”‚            â”‚
â”‚  â”‚              â”‚  â”‚ Path         â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 æ ¸å¿ƒç»“æ„

#### 2.3.1 TestHelperç»“æ„ä½“

```go
// TestHelper æµ‹è¯•è¾…åŠ©å·¥å…·
type TestHelper struct {
    t      *testing.T        // æµ‹è¯•å®ä¾‹
    router *gin.Engine       // Ginè·¯ç”±
    ctx    context.Context   // ä¸Šä¸‹æ–‡
}

// NewTestHelper åˆ›å»ºæµ‹è¯•è¾…åŠ©å·¥å…·
func NewTestHelper(t *testing.T, router *gin.Engine) *TestHelper {
    return &TestHelper{
        t:      t,
        router: router,
        ctx:    context.Background(),
    }
}
```

**è®¾è®¡æ€è·¯**ï¼š
- å°è£…æµ‹è¯•ä¸Šä¸‹æ–‡
- ç»‘å®šç‰¹å®šçš„æµ‹è¯•å®ä¾‹
- æä¾›ç»Ÿä¸€çš„APIæ¥å£

### 2.4 åŠŸèƒ½æ¨¡å—è¯¦è§£

#### 2.4.1 è®¤è¯æ¨¡å—

**ç›®æ ‡**ï¼šç®€åŒ–ç”¨æˆ·ç™»å½•æµç¨‹

**æ ¸å¿ƒå‡½æ•°**ï¼š

```go
// LoginUser ç”¨æˆ·ç™»å½•å¹¶è¿”å›token
func (h *TestHelper) LoginUser(username, password string) string {
    loginData := map[string]interface{}{
        "username": username,
        "password": password,
    }

    body, _ := json.Marshal(loginData)
    req := httptest.NewRequest("POST", LoginPath, bytes.NewReader(body))
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()
    h.router.ServeHTTP(w, req)

    // è¯¦ç»†çš„é”™è¯¯è¯Šæ–­
    if w.Code != http.StatusOK {
        h.t.Logf("âŒ ç™»å½•å¤±è´¥\n"+
            "  ç”¨æˆ·å: %s\n"+
            "  çŠ¶æ€ç : %d (æœŸæœ›: 200)\n"+
            "  å“åº”: %s",
            username, w.Code, w.Body.String())
        return ""
    }

    // è§£æå“åº”è·å–token
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    data := response["data"].(map[string]interface{})
    token := data["token"].(string)

    h.t.Logf("âœ“ ç™»å½•æˆåŠŸ: %s (token: %s...)", username, token[:20])
    return token
}

// LoginTestUser ç™»å½•é»˜è®¤æµ‹è¯•ç”¨æˆ·
func (h *TestHelper) LoginTestUser() string {
    return h.LoginUser("test_user01", "Test@123456")
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```go
// è¿ç§»å‰ï¼ˆ~20è¡Œä»£ç ï¼‰
loginData := map[string]interface{}{
    "username": "test_user01",
    "password": "Test@123456",
}
body, _ := json.Marshal(loginData)
req := httptest.NewRequest("POST", "/api/v1/login", bytes.NewReader(body))
req.Header.Set("Content-Type", "application/json")
w := httptest.NewRecorder()
router.ServeHTTP(w, req)
// ... è§£æå“åº”è·å–token

// è¿ç§»åï¼ˆ1è¡Œä»£ç ï¼‰
token := helper.LoginTestUser()
```

**ä¼˜åŠ¿**ï¼š
- âœ… ä»£ç å‡å°‘95%
- âœ… é”™è¯¯ä¿¡æ¯è¯¦ç»†
- âœ… è‡ªåŠ¨è®°å½•æ—¥å¿—

#### 2.4.2 HTTPè¯·æ±‚æ¨¡å—

**ç›®æ ‡**ï¼šç»Ÿä¸€HTTPè¯·æ±‚æ„é€ å’Œå‘é€

**æ ¸å¿ƒå‡½æ•°**ï¼š

```go
// DoRequest æ‰§è¡ŒHTTPè¯·æ±‚
func (h *TestHelper) DoRequest(method, path string, body interface{}, token string) *httptest.ResponseRecorder {
    var bodyReader io.Reader
    if body != nil {
        bodyBytes, _ := json.Marshal(body)
        bodyReader = bytes.NewReader(bodyBytes)
    }

    req := httptest.NewRequest(method, path, bodyReader)
    req.Header.Set("Content-Type", "application/json")
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }

    w := httptest.NewRecorder()
    h.router.ServeHTTP(w, req)
    return w
}

// DoAuthRequest æ‰§è¡Œéœ€è¦è®¤è¯çš„è¯·æ±‚
func (h *TestHelper) DoAuthRequest(method, path string, body interface{}, token string) *httptest.ResponseRecorder {
    require.NotEmpty(h.t, token, "Tokenä¸èƒ½ä¸ºç©ºï¼Œè¯·å…ˆç™»å½•")
    return h.DoRequest(method, path, body, token)
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```go
// è¿ç§»å‰ï¼ˆ~10è¡Œä»£ç ï¼‰
reqBody := map[string]interface{}{
    "book_id": bookID,
    "note": "æµ‹è¯•ç¬”è®°",
}
body, _ := json.Marshal(reqBody)
req := httptest.NewRequest("POST", "/api/v1/reader/collections", bytes.NewReader(body))
req.Header.Set("Content-Type", "application/json")
req.Header.Set("Authorization", "Bearer "+token)
w := httptest.NewRecorder()
router.ServeHTTP(w, req)

// è¿ç§»åï¼ˆ1è¡Œä»£ç ï¼‰
w := helper.DoAuthRequest("POST", integration.ReaderCollectionsPath, reqBody, token)
```

**ä¼˜åŠ¿**ï¼š
- âœ… è‡ªåŠ¨è®¾ç½®å¿…è¦çš„Header
- âœ… è‡ªåŠ¨åºåˆ—åŒ–è¯·æ±‚Body
- âœ… TokenéªŒè¯é˜²æ­¢é—æ¼

#### 2.4.3 å“åº”æ–­è¨€æ¨¡å—

**ç›®æ ‡**ï¼šæä¾›è¯¦ç»†çš„é”™è¯¯è¯Šæ–­ä¿¡æ¯

**æ ¸å¿ƒå‡½æ•°**ï¼š

```go
// AssertSuccess æ–­è¨€è¯·æ±‚æˆåŠŸ
func (h *TestHelper) AssertSuccess(w *httptest.ResponseRecorder, expectedStatus int, msgAndArgs ...interface{}) map[string]interface{} {
    // æ„å»ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
    msg := ""
    if len(msgAndArgs) > 0 {
        if format, ok := msgAndArgs[0].(string); ok {
            msg = fmt.Sprintf(format, msgAndArgs[1:]...)
        }
    }

    detailedMsg := fmt.Sprintf("%s\n"+
        "æœŸæœ›çŠ¶æ€ç : %d\n"+
        "å®é™…çŠ¶æ€ç : %d\n"+
        "å“åº”å†…å®¹: %s",
        msg, expectedStatus, w.Code, h.formatResponse(w.Body.String()))

    assert.Equal(h.t, expectedStatus, w.Code, detailedMsg)

    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(h.t, err, "è§£æå“åº”å¤±è´¥: %s", w.Body.String())

    return response
}

// AssertError æ–­è¨€è¯·æ±‚å¤±è´¥å¹¶åŒ…å«ç‰¹å®šé”™è¯¯ä¿¡æ¯
func (h *TestHelper) AssertError(w *httptest.ResponseRecorder, expectedStatus int, expectedMsg string, msgAndArgs ...interface{}) {
    msg := ""
    if len(msgAndArgs) > 0 {
        if format, ok := msgAndArgs[0].(string); ok {
            msg = fmt.Sprintf(format, msgAndArgs[1:]...)
        }
    }

    detailedMsg := fmt.Sprintf("%s\n"+
        "æœŸæœ›çŠ¶æ€ç : %d\n"+
        "å®é™…çŠ¶æ€ç : %d\n"+
        "æœŸæœ›é”™è¯¯ä¿¡æ¯åŒ…å«: %s\n"+
        "å“åº”å†…å®¹: %s",
        msg, expectedStatus, w.Code, expectedMsg, h.formatResponse(w.Body.String()))

    assert.Equal(h.t, expectedStatus, w.Code, detailedMsg)

    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)

    if message, ok := response["message"].(string); ok {
        assert.Contains(h.t, message, expectedMsg, "é”™è¯¯ä¿¡æ¯ä¸åŒ¹é…")
    } else if msg, ok := response["msg"].(string); ok {
        assert.Contains(h.t, msg, expectedMsg, "é”™è¯¯ä¿¡æ¯ä¸åŒ¹é…")
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```go
// è¿ç§»å‰ï¼ˆç®€å•æ–­è¨€ï¼‰
assert.Equal(t, 201, w.Code, "æ·»åŠ æ”¶è—å¤±è´¥")
// å¤±è´¥æ—¶è¾“å‡ºï¼š
//   Expected: 201
//   Actual: 400

// è¿ç§»åï¼ˆè¯¦ç»†æ–­è¨€ï¼‰
helper.AssertSuccess(w, 201, "æ·»åŠ æ”¶è—å¤±è´¥")
// å¤±è´¥æ—¶è¾“å‡ºï¼š
//   æ·»åŠ æ”¶è—å¤±è´¥
//   æœŸæœ›çŠ¶æ€ç : 201
//   å®é™…çŠ¶æ€ç : 400
//   å“åº”å†…å®¹: {"code":40001,"message":"è¯¥ä¹¦ç±å·²ç»æ”¶è—","data":null}
```

**ä¼˜åŠ¿**ï¼š
- âœ… é”™è¯¯ä¿¡æ¯åŒ…å«å®Œæ•´ä¸Šä¸‹æ–‡
- âœ… è‡ªåŠ¨æ˜¾ç¤ºå“åº”å†…å®¹
- âœ… æ”¯æŒè‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯

#### 2.4.4 æ•°æ®åº“æ¨¡å—

**ç›®æ ‡**ï¼šç®€åŒ–æµ‹è¯•æ•°æ®æ“ä½œ

**æ ¸å¿ƒå‡½æ•°**ï¼š

```go
// GetTestBook è·å–æµ‹è¯•ä¹¦ç±
func (h *TestHelper) GetTestBook() string {
    var book struct {
        ID primitive.ObjectID `bson:"_id"`
    }

    err := global.DB.Collection("books").FindOne(h.ctx, bson.M{}).Decode(&book)
    if err != nil {
        h.t.Logf("âš  æ•°æ®åº“ä¸­æ²¡æœ‰æµ‹è¯•ä¹¦ç±")
        return ""
    }

    return book.ID.Hex()
}

// GetTestBooks è·å–å¤šæœ¬æµ‹è¯•ä¹¦ç±
func (h *TestHelper) GetTestBooks(limit int) []string {
    cursor, err := global.DB.Collection("books").Find(h.ctx, bson.M{})
    if err != nil {
        h.t.Logf("âš  æŸ¥è¯¢æµ‹è¯•ä¹¦ç±å¤±è´¥: %v", err)
        return nil
    }
    defer cursor.Close(h.ctx)

    var books []struct {
        ID primitive.ObjectID `bson:"_id"`
    }

    for cursor.Next(h.ctx) && len(books) < limit {
        var book struct {
            ID primitive.ObjectID `bson:"_id"`
        }
        if err := cursor.Decode(&book); err == nil {
            books = append(books, book)
        }
    }

    bookIDs := make([]string, len(books))
    for i, book := range books {
        bookIDs[i] = book.ID.Hex()
    }

    h.t.Logf("âœ“ è·å–%dæœ¬æµ‹è¯•ä¹¦ç±", len(bookIDs))
    return bookIDs
}

// CleanupTestData æ¸…ç†æµ‹è¯•æ•°æ®
func (h *TestHelper) CleanupTestData(collections ...string) {
    for _, coll := range collections {
        _, err := global.DB.Collection(coll).DeleteMany(h.ctx, bson.M{
            "user_id": bson.M{"$regex": "^test_"},
        })
        if err != nil {
            h.t.Logf("âš  æ¸…ç†é›†åˆ %s å¤±è´¥: %v", coll, err)
        }
    }
}

// VerifyBookExists éªŒè¯ä¹¦ç±æ˜¯å¦å­˜åœ¨
func (h *TestHelper) VerifyBookExists(bookID string) bool {
    objectID, err := primitive.ObjectIDFromHex(bookID)
    if err != nil {
        return false
    }

    count, err := global.DB.Collection("books").CountDocuments(h.ctx, bson.M{"_id": objectID})
    return err == nil && count > 0
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```go
// è·å–æµ‹è¯•æ•°æ®
bookID := helper.GetTestBook()
if bookID == "" {
    t.Skip("æ²¡æœ‰æµ‹è¯•æ•°æ®ï¼Œè·³è¿‡æµ‹è¯•")
}

// è·å–å¤šæœ¬ä¹¦
bookIDs := helper.GetTestBooks(5)

// éªŒè¯æ•°æ®å­˜åœ¨
if !helper.VerifyBookExists(bookID) {
    t.Fatalf("ä¹¦ç± %s ä¸å­˜åœ¨", bookID)
}

// æ¸…ç†æµ‹è¯•æ•°æ®
defer helper.CleanupTestData("collections", "reading_progress")
```

#### 2.4.5 æ—¥å¿—æ¨¡å—

**ç›®æ ‡**ï¼šç»“æ„åŒ–çš„æµ‹è¯•æ—¥å¿—

**æ ¸å¿ƒå‡½æ•°**ï¼š

```go
// LogSuccess è®°å½•æˆåŠŸæ—¥å¿—
func (h *TestHelper) LogSuccess(format string, args ...interface{}) {
    h.t.Logf("âœ“ "+format, args...)
}

// LogInfo è®°å½•ä¿¡æ¯æ—¥å¿—
func (h *TestHelper) LogInfo(format string, args ...interface{}) {
    h.t.Logf("â„¹ "+format, args...)
}

// LogWarning è®°å½•è­¦å‘Šæ—¥å¿—
func (h *TestHelper) LogWarning(format string, args ...interface{}) {
    h.t.Logf("âš  "+format, args...)
}

// LogError è®°å½•é”™è¯¯æ—¥å¿—
func (h *TestHelper) LogError(format string, args ...interface{}) {
    h.t.Logf("âŒ "+format, args...)
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```go
helper.LogInfo("å¼€å§‹æµ‹è¯•æ”¶è—åŠŸèƒ½")
helper.LogSuccess("æ·»åŠ æ”¶è—æˆåŠŸï¼ŒID: %s", collectionID)
helper.LogWarning("æµ‹è¯•æ•°æ®ä¸è¶³ï¼Œåªæœ‰%dæœ¬ä¹¦", len(bookIDs))
helper.LogError("è·å–æ”¶è—åˆ—è¡¨å¤±è´¥: %v", err)
```

**è¾“å‡ºæ•ˆæœ**ï¼š
```
â„¹ å¼€å§‹æµ‹è¯•æ”¶è—åŠŸèƒ½
âœ“ ç™»å½•æˆåŠŸ: test_user01 (token: eyJhbGciOiJIUzI1NiIs...)
âœ“ è·å–5æœ¬æµ‹è¯•ä¹¦ç±
âœ“ æ·»åŠ æ”¶è—æˆåŠŸï¼ŒID: 671a2b3c4d5e6f7g8h9i
âš  æµ‹è¯•æ•°æ®ä¸è¶³ï¼Œåªæœ‰3æœ¬ä¹¦
```

---

## ä¸‰ã€è·¯å¾„å¸¸é‡ç³»ç»Ÿ

### 3.1 è®¾è®¡ç›®æ ‡

**é—®é¢˜**ï¼š
- âŒ è·¯å¾„ç¡¬ç¼–ç åœ¨å„ä¸ªæµ‹è¯•æ–‡ä»¶ä¸­
- âŒ è·¯å¾„ä¿®æ”¹éœ€è¦æ”¹åŠ¨å¤šå¤„
- âŒ å®¹æ˜“å‡ºç°æ‹¼å†™é”™è¯¯
- âŒ ä¸æ”¯æŒç‰ˆæœ¬ç®¡ç†

**è§£å†³æ–¹æ¡ˆ**ï¼š
- âœ… é›†ä¸­å®šä¹‰æ‰€æœ‰APIè·¯å¾„
- âœ… ä½¿ç”¨å¸¸é‡é¿å…é­”æ³•å­—ç¬¦ä¸²
- âœ… æŒ‰æ¨¡å—åˆ†ç»„ä¾¿äºæŸ¥æ‰¾
- âœ… æ”¯æŒç‰ˆæœ¬å·ç®¡ç†

### 3.2 è·¯å¾„å¸¸é‡å®šä¹‰

```go
// ========================================
// API è·¯å¾„å¸¸é‡
// ========================================

const (
    // åŸºç¡€è·¯å¾„
    APIBasePath = "/api/v1"

    // è®¤è¯ç›¸å…³
    LoginPath    = APIBasePath + "/login"
    RegisterPath = APIBasePath + "/register"

    // ç”¨æˆ·ç›¸å…³
    UserProfilePath  = APIBasePath + "/users/profile"
    UserPasswordPath = APIBasePath + "/users/password"

    // é˜…è¯»å™¨ç›¸å…³
    ReaderBooksPath       = APIBasePath + "/reader/books"
    ReaderChaptersPath    = APIBasePath + "/reader/chapters"
    ReaderProgressPath    = APIBasePath + "/reader/progress"
    ReaderAnnotationsPath = APIBasePath + "/reader/annotations"
    ReaderCommentsPath    = APIBasePath + "/reader/comments"
    ReaderCollectionsPath = APIBasePath + "/reader/collections"
    ReaderLikesPath       = APIBasePath + "/reader/likes"

    // ä¹¦åŸç›¸å…³
    BookstoreHomePath    = APIBasePath + "/bookstore/homepage"
    BookstoreBooksPath   = APIBasePath + "/bookstore/books"
    BookstoreRankingPath = APIBasePath + "/bookstore/rankings"
)
```

### 3.3 ä½¿ç”¨æ–¹å¼

```go
// âœ… æ¨èï¼šä½¿ç”¨è·¯å¾„å¸¸é‡
w := helper.DoRequest("GET", integration.BookstoreHomePath, nil, "")

// âŒ ä¸æ¨èï¼šç¡¬ç¼–ç è·¯å¾„
w := helper.DoRequest("GET", "/api/v1/bookstore/homepage", nil, "")
```

### 3.4 ä¼˜åŠ¿

1. **é›†ä¸­ç®¡ç†**ï¼šæ‰€æœ‰è·¯å¾„åœ¨ä¸€ä¸ªåœ°æ–¹å®šä¹‰
2. **æ˜“äºä¿®æ”¹**ï¼šè·¯å¾„å˜æ›´åªéœ€æ”¹ä¸€å¤„
3. **é¿å…é”™è¯¯**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œå‡å°‘æ‹¼å†™é”™è¯¯
4. **ç‰ˆæœ¬æ”¯æŒ**ï¼šè½»æ¾æ”¯æŒå¤šä¸ªAPIç‰ˆæœ¬
5. **IDEå‹å¥½**ï¼šä»£ç è¡¥å…¨å’Œè·³è½¬

---

## å››ã€å¢å¼ºé”™è¯¯è¯Šæ–­åŠŸèƒ½

### 4.1 éœ€æ±‚åˆ†æ

å½“å‰TestHelperå·²æä¾›åŸºç¡€æ–­è¨€åŠŸèƒ½ï¼Œä½†è¿˜éœ€è¦æ›´å¼ºå¤§çš„è¯Šæ–­å·¥å…·ï¼š

**éœ€è¦æ·»åŠ çš„åŠŸèƒ½**ï¼š
1. è¯¦ç»†çš„è¯·æ±‚æ—¥å¿—
2. è¯¦ç»†çš„å“åº”æ—¥å¿—
3. æµ‹è¯•ä¸Šä¸‹æ–‡æ—¥å¿—
4. æ ¼å¼åŒ–çš„å“åº”è¾“å‡º

### 4.2 æ–°å¢è¯Šæ–­å‡½æ•°

#### 4.2.1 è¯·æ±‚æ—¥å¿—

```go
// LogRequest è®°å½•è¯¦ç»†çš„è¯·æ±‚ä¿¡æ¯
func (h *TestHelper) LogRequest(method, path string, body interface{}, token string) {
    h.t.Logf("â†’ è¯·æ±‚: %s %s", method, path)
    
    if body != nil {
        bodyJSON, _ := json.MarshalIndent(body, "", "  ")
        h.t.Logf("  Body: %s", bodyJSON)
    }
    
    if token != "" {
        h.t.Logf("  Token: %s...", token[:min(len(token), 20)])
    }
}
```

#### 4.2.2 å“åº”æ—¥å¿—

```go
// LogResponse è®°å½•è¯¦ç»†çš„å“åº”ä¿¡æ¯
func (h *TestHelper) LogResponse(w *httptest.ResponseRecorder) {
    h.t.Logf("â† å“åº”: %d", w.Code)
    
    // å°è¯•æ ¼å¼åŒ–JSON
    var prettyJSON bytes.Buffer
    if err := json.Indent(&prettyJSON, w.Body.Bytes(), "", "  "); err == nil {
        h.t.Logf("  Body: %s", prettyJSON.String())
    } else {
        h.t.Logf("  Body: %s", w.Body.String())
    }
}
```

#### 4.2.3 æµ‹è¯•ä¸Šä¸‹æ–‡æ—¥å¿—

```go
// LogTestContext è®°å½•æµ‹è¯•æ‰§è¡Œä¸Šä¸‹æ–‡
func (h *TestHelper) LogTestContext(step string, details ...interface{}) {
    h.t.Logf("â”Œâ”€ %s â”€â”", step)
    for i, detail := range details {
        h.t.Logf("â”‚ [%d] %v", i+1, detail)
    }
    h.t.Logf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
}
```

#### 4.2.4 æ ¼å¼åŒ–å“åº”

```go
// GetResponseString è¿”å›æ ¼å¼åŒ–çš„å“åº”å­—ç¬¦ä¸²
func (h *TestHelper) GetResponseString(w *httptest.ResponseRecorder) string {
    var prettyJSON bytes.Buffer
    if err := json.Indent(&prettyJSON, w.Body.Bytes(), "", "  "); err == nil {
        return prettyJSON.String()
    }
    return w.Body.String()
}
```

### 4.3 ä½¿ç”¨ç¤ºä¾‹

```go
func TestExample(t *testing.T) {
    helper := integration.NewTestHelper(t, router)
    token := helper.LoginTestUser()
    
    reqBody := map[string]interface{}{
        "book_id": "xxx",
        "note": "æµ‹è¯•ç¬”è®°",
    }
    
    // è®°å½•è¯·æ±‚
    helper.LogRequest("POST", integration.ReaderCollectionsPath, reqBody, token)
    
    // å‘é€è¯·æ±‚
    w := helper.DoAuthRequest("POST", integration.ReaderCollectionsPath, reqBody, token)
    
    // è®°å½•å“åº”
    helper.LogResponse(w)
    
    // è®°å½•æµ‹è¯•ä¸Šä¸‹æ–‡
    helper.LogTestContext("æ·»åŠ æ”¶è—æµ‹è¯•", 
        fmt.Sprintf("ç”¨æˆ·Token: %s...", token[:20]),
        fmt.Sprintf("ä¹¦ç±ID: %s", bookID),
    )
    
    // æ–­è¨€
    helper.AssertSuccess(w, 201, "æ·»åŠ æ”¶è—å¤±è´¥")
}
```

---

## äº”ã€æµ‹è¯•æ•°æ®å·¥å‚

### 5.1 è®¾è®¡ç›®æ ‡

**é—®é¢˜**ï¼š
- âŒ æ¯ä¸ªæµ‹è¯•æ‰‹åŠ¨åˆ›å»ºæ•°æ®
- âŒ åˆ›å»ºé€»è¾‘é‡å¤
- âŒ æ•°æ®æ¸…ç†ä¸ä¸€è‡´
- âŒ éš¾ä»¥åˆ›å»ºå¤æ‚çš„æµ‹è¯•åœºæ™¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
- âœ… ç»Ÿä¸€çš„æ•°æ®å·¥å‚æ¨¡å¼
- âœ… æ”¯æŒé»˜è®¤å€¼å’Œè‡ªå®šä¹‰
- âœ… è‡ªåŠ¨ç®¡ç†æ•°æ®ç”Ÿå‘½å‘¨æœŸ
- âœ… æ”¯æŒå¤æ‚æ•°æ®å…³ç³»

### 5.2 å·¥å‚è®¾è®¡

**æ–°æ–‡ä»¶**ï¼š`test/testutil/factory.go`

```go
package testutil

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/require"
    "go.mongodb.org/mongo-driver/bson/primitive"
    
    "Qingyu_backend/global"
    "Qingyu_backend/models/bookstore"
    "Qingyu_backend/models/users"
)

// TestDataFactory æµ‹è¯•æ•°æ®å·¥å‚
type TestDataFactory struct {
    t   *testing.T
    ctx context.Context
    
    // è®°å½•åˆ›å»ºçš„å®ä½“IDï¼Œç”¨äºæ¸…ç†
    bookIDs    []string
    userIDs    []string
    chapterIDs []string
}

// NewTestDataFactory åˆ›å»ºæµ‹è¯•æ•°æ®å·¥å‚
func NewTestDataFactory(t *testing.T) *TestDataFactory {
    return &TestDataFactory{
        t:   t,
        ctx: context.Background(),
        bookIDs:    make([]string, 0),
        userIDs:    make([]string, 0),
        chapterIDs: make([]string, 0),
    }
}

// CreateTestBook åˆ›å»ºæµ‹è¯•ä¹¦ç±
func (f *TestDataFactory) CreateTestBook(title string, options ...BookOption) string {
    book := &bookstore.Book{
        Title:       title,
        Author:      "æµ‹è¯•ä½œè€…",
        Category:    "æµ‹è¯•åˆ†ç±»",
        Status:      "published",
        WordCount:   100000,
        ChapterCount: 10,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    // åº”ç”¨å¯é€‰é…ç½®
    for _, opt := range options {
        opt(book)
    }
    
    result, err := global.DB.Collection("books").InsertOne(f.ctx, book)
    require.NoError(f.t, err, "åˆ›å»ºæµ‹è¯•ä¹¦ç±å¤±è´¥")
    
    bookID := result.InsertedID.(primitive.ObjectID).Hex()
    f.bookIDs = append(f.bookIDs, bookID)
    
    f.t.Logf("âœ“ åˆ›å»ºæµ‹è¯•ä¹¦ç±: %s (ID: %s)", title, bookID)
    return bookID
}

// CreateTestUser åˆ›å»ºæµ‹è¯•ç”¨æˆ·
func (f *TestDataFactory) CreateTestUser(username string) (string, string) {
    password := "Test@123456"
    hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    
    user := &users.User{
        Username: username,
        Password: string(hashedPassword),
        Email:    username + "@test.com",
        Role:     "user",
        CreatedAt: time.Now(),
    }
    
    result, err := global.DB.Collection("users").InsertOne(f.ctx, user)
    require.NoError(f.t, err, "åˆ›å»ºæµ‹è¯•ç”¨æˆ·å¤±è´¥")
    
    userID := result.InsertedID.(primitive.ObjectID).Hex()
    f.userIDs = append(f.userIDs, userID)
    
    f.t.Logf("âœ“ åˆ›å»ºæµ‹è¯•ç”¨æˆ·: %s (ID: %s)", username, userID)
    return userID, password
}

// CreateTestChapter åˆ›å»ºæµ‹è¯•ç« èŠ‚
func (f *TestDataFactory) CreateTestChapter(bookID string, chapterNum int) string {
    chapter := &bookstore.Chapter{
        BookID:      bookID,
        ChapterNum:  chapterNum,
        Title:       fmt.Sprintf("ç¬¬%dç«  æµ‹è¯•ç« èŠ‚", chapterNum),
        Content:     "è¿™æ˜¯æµ‹è¯•ç« èŠ‚å†…å®¹...",
        WordCount:   5000,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    result, err := global.DB.Collection("chapters").InsertOne(f.ctx, chapter)
    require.NoError(f.t, err, "åˆ›å»ºæµ‹è¯•ç« èŠ‚å¤±è´¥")
    
    chapterID := result.InsertedID.(primitive.ObjectID).Hex()
    f.chapterIDs = append(f.chapterIDs, chapterID)
    
    return chapterID
}

// CleanupAll æ¸…ç†æ‰€æœ‰åˆ›å»ºçš„æµ‹è¯•æ•°æ®
func (f *TestDataFactory) CleanupAll() {
    // æ¸…ç†ä¹¦ç±
    for _, bookID := range f.bookIDs {
        objID, _ := primitive.ObjectIDFromHex(bookID)
        global.DB.Collection("books").DeleteOne(f.ctx, bson.M{"_id": objID})
    }
    
    // æ¸…ç†ç”¨æˆ·
    for _, userID := range f.userIDs {
        objID, _ := primitive.ObjectIDFromHex(userID)
        global.DB.Collection("users").DeleteOne(f.ctx, bson.M{"_id": objID})
    }
    
    // æ¸…ç†ç« èŠ‚
    for _, chapterID := range f.chapterIDs {
        objID, _ := primitive.ObjectIDFromHex(chapterID)
        global.DB.Collection("chapters").DeleteOne(f.ctx, bson.M{"_id": objID})
    }
    
    f.t.Logf("âœ“ æ¸…ç†å®Œæˆ: %dæœ¬ä¹¦, %dä¸ªç”¨æˆ·, %dä¸ªç« èŠ‚",
        len(f.bookIDs), len(f.userIDs), len(f.chapterIDs))
}

// BookOption ä¹¦ç±é…ç½®é€‰é¡¹
type BookOption func(*bookstore.Book)

// WithAuthor è®¾ç½®ä½œè€…
func WithAuthor(author string) BookOption {
    return func(b *bookstore.Book) {
        b.Author = author
    }
}

// WithCategory è®¾ç½®åˆ†ç±»
func WithCategory(category string) BookOption {
    return func(b *bookstore.Book) {
        b.Category = category
    }
}

// WithWordCount è®¾ç½®å­—æ•°
func WithWordCount(count int) BookOption {
    return func(b *bookstore.Book) {
        b.WordCount = count
    }
}
```

### 5.3 ä½¿ç”¨ç¤ºä¾‹

```go
func TestWithFactory(t *testing.T) {
    // åˆ›å»ºå·¥å‚
    factory := testutil.NewTestDataFactory(t)
    defer factory.CleanupAll()  // ç¡®ä¿æ¸…ç†
    
    // åˆ›å»ºæµ‹è¯•ä¹¦ç±ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
    bookID1 := factory.CreateTestBook("æµ‹è¯•ä¹¦ç±1")
    
    // åˆ›å»ºæµ‹è¯•ä¹¦ç±ï¼ˆè‡ªå®šä¹‰é€‰é¡¹ï¼‰
    bookID2 := factory.CreateTestBook("æµ‹è¯•ä¹¦ç±2",
        testutil.WithAuthor("çŸ¥åä½œè€…"),
        testutil.WithCategory("ç„å¹»"),
        testutil.WithWordCount(500000),
    )
    
    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
    userID, password := factory.CreateTestUser("test_user_temp")
    
    // åˆ›å»ºæµ‹è¯•ç« èŠ‚
    chapterID := factory.CreateTestChapter(bookID1, 1)
    
    // ä½¿ç”¨è¿™äº›æµ‹è¯•æ•°æ®è¿›è¡Œæµ‹è¯•...
    
    // æµ‹è¯•ç»“æŸåè‡ªåŠ¨æ¸…ç†ï¼ˆé€šè¿‡deferï¼‰
}
```

### 5.4 ä¼˜åŠ¿

- âœ… ä»£ç å¤ç”¨ï¼šé¿å…é‡å¤çš„æ•°æ®åˆ›å»ºé€»è¾‘
- âœ… çµæ´»é…ç½®ï¼šæ”¯æŒé»˜è®¤å€¼å’Œè‡ªå®šä¹‰é€‰é¡¹
- âœ… è‡ªåŠ¨æ¸…ç†ï¼šé€šè¿‡deferç¡®ä¿æ•°æ®æ¸…ç†
- âœ… ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œå‡å°‘é”™è¯¯
- âœ… æ˜“äºç»´æŠ¤ï¼šé›†ä¸­ç®¡ç†æ•°æ®åˆ›å»ºé€»è¾‘

---

## å…­ã€æµ‹è¯•æ•°æ®å‡†å¤‡è„šæœ¬

### 6.1 Linux/Macè„šæœ¬

**æ–‡ä»¶**ï¼š`scripts/testing/ensure_test_data.sh`

```bash
#!/bin/bash

# æµ‹è¯•æ•°æ®å‡†å¤‡è„šæœ¬
# ç¡®ä¿æµ‹è¯•ç¯å¢ƒæœ‰è¶³å¤Ÿçš„æµ‹è¯•æ•°æ®

set -e

echo "========================================="
echo "  æµ‹è¯•æ•°æ®å‡†å¤‡è„šæœ¬"
echo "========================================="

# é…ç½®
DB_NAME="qingyu_test"
MIN_BOOKS=10
MIN_CHAPTERS=100

# æ£€æŸ¥MongoDBæ˜¯å¦è¿è¡Œ
echo ""
echo "1. æ£€æŸ¥MongoDBè¿æ¥..."
if ! mongosh --quiet --eval "db.version()" > /dev/null 2>&1; then
    echo "âŒ MongoDBæœªè¿è¡Œæˆ–æ— æ³•è¿æ¥"
    exit 1
fi
echo "âœ“ MongoDBè¿æ¥æ­£å¸¸"

# æ£€æŸ¥ä¹¦ç±æ•°é‡
echo ""
echo "2. æ£€æŸ¥ä¹¦ç±æ•°æ®..."
BOOK_COUNT=$(mongosh $DB_NAME --quiet --eval "db.books.countDocuments({})")
echo "   å½“å‰ä¹¦ç±æ•°é‡: $BOOK_COUNT"

if [ "$BOOK_COUNT" -lt "$MIN_BOOKS" ]; then
    echo "   âš  ä¹¦ç±æ•°é‡ä¸è¶³ï¼ˆéœ€è¦è‡³å°‘ $MIN_BOOKS æœ¬ï¼‰"
    echo "   æ­£åœ¨å¯¼å…¥æµ‹è¯•ä¹¦ç±..."
    go run cmd/migrate/main.go --seed books
    echo "   âœ“ ä¹¦ç±æ•°æ®å¯¼å…¥å®Œæˆ"
else
    echo "   âœ“ ä¹¦ç±æ•°æ®å……è¶³"
fi

# æ£€æŸ¥ç« èŠ‚æ•°é‡
echo ""
echo "3. æ£€æŸ¥ç« èŠ‚æ•°æ®..."
CHAPTER_COUNT=$(mongosh $DB_NAME --quiet --eval "db.chapters.countDocuments({})")
echo "   å½“å‰ç« èŠ‚æ•°é‡: $CHAPTER_COUNT"

if [ "$CHAPTER_COUNT" -lt "$MIN_CHAPTERS" ]; then
    echo "   âš  ç« èŠ‚æ•°é‡ä¸è¶³ï¼ˆéœ€è¦è‡³å°‘ $MIN_CHAPTERS ä¸ªï¼‰"
    echo "   æ­£åœ¨å¯¼å…¥æµ‹è¯•ç« èŠ‚..."
    go run cmd/migrate/main.go --seed chapters
    echo "   âœ“ ç« èŠ‚æ•°æ®å¯¼å…¥å®Œæˆ"
else
    echo "   âœ“ ç« èŠ‚æ•°æ®å……è¶³"
fi

# æ£€æŸ¥æµ‹è¯•ç”¨æˆ·
echo ""
echo "4. æ£€æŸ¥æµ‹è¯•ç”¨æˆ·..."
USER_COUNT=$(mongosh $DB_NAME --quiet --eval 'db.users.countDocuments({username: /^test_user/})')
echo "   å½“å‰æµ‹è¯•ç”¨æˆ·æ•°é‡: $USER_COUNT"

if [ "$USER_COUNT" -lt 5 ]; then
    echo "   âš  æµ‹è¯•ç”¨æˆ·ä¸è¶³"
    echo "   æ­£åœ¨åˆ›å»ºæµ‹è¯•ç”¨æˆ·..."
    go run cmd/create_beta_users/main.go
    echo "   âœ“ æµ‹è¯•ç”¨æˆ·åˆ›å»ºå®Œæˆ"
else
    echo "   âœ“ æµ‹è¯•ç”¨æˆ·å……è¶³"
fi

# å®Œæˆ
echo ""
echo "========================================="
echo "  âœ“ æµ‹è¯•æ•°æ®å‡†å¤‡å®Œæˆ"
echo "========================================="
echo ""
echo "æ•°æ®ç»Ÿè®¡:"
echo "  - ä¹¦ç±: $BOOK_COUNT æœ¬"
echo "  - ç« èŠ‚: $CHAPTER_COUNT ä¸ª"
echo "  - æµ‹è¯•ç”¨æˆ·: $USER_COUNT ä¸ª"
echo ""
```

### 6.2 Windowsè„šæœ¬

**æ–‡ä»¶**ï¼š`scripts/testing/ensure_test_data.bat`

```batch
@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

echo =========================================
echo   æµ‹è¯•æ•°æ®å‡†å¤‡è„šæœ¬
echo =========================================

set DB_NAME=qingyu_test
set MIN_BOOKS=10
set MIN_CHAPTERS=100

:: æ£€æŸ¥MongoDB
echo.
echo 1. æ£€æŸ¥MongoDBè¿æ¥...
mongosh --quiet --eval "db.version()" >nul 2>&1
if errorlevel 1 (
    echo âŒ MongoDBæœªè¿è¡Œæˆ–æ— æ³•è¿æ¥
    exit /b 1
)
echo âœ“ MongoDBè¿æ¥æ­£å¸¸

:: æ£€æŸ¥ä¹¦ç±æ•°é‡
echo.
echo 2. æ£€æŸ¥ä¹¦ç±æ•°æ®...
for /f %%i in ('mongosh %DB_NAME% --quiet --eval "db.books.countDocuments({})"') do set BOOK_COUNT=%%i
echo    å½“å‰ä¹¦ç±æ•°é‡: %BOOK_COUNT%

if %BOOK_COUNT% LSS %MIN_BOOKS% (
    echo    âš  ä¹¦ç±æ•°é‡ä¸è¶³ï¼ˆéœ€è¦è‡³å°‘ %MIN_BOOKS% æœ¬ï¼‰
    echo    æ­£åœ¨å¯¼å…¥æµ‹è¯•ä¹¦ç±...
    go run cmd/migrate/main.go --seed books
    echo    âœ“ ä¹¦ç±æ•°æ®å¯¼å…¥å®Œæˆ
) else (
    echo    âœ“ ä¹¦ç±æ•°æ®å……è¶³
)

:: æ£€æŸ¥ç« èŠ‚æ•°é‡
echo.
echo 3. æ£€æŸ¥ç« èŠ‚æ•°æ®...
for /f %%i in ('mongosh %DB_NAME% --quiet --eval "db.chapters.countDocuments({})"') do set CHAPTER_COUNT=%%i
echo    å½“å‰ç« èŠ‚æ•°é‡: %CHAPTER_COUNT%

if %CHAPTER_COUNT% LSS %MIN_CHAPTERS% (
    echo    âš  ç« èŠ‚æ•°é‡ä¸è¶³ï¼ˆéœ€è¦è‡³å°‘ %MIN_CHAPTERS% ä¸ªï¼‰
    echo    æ­£åœ¨å¯¼å…¥æµ‹è¯•ç« èŠ‚...
    go run cmd/migrate/main.go --seed chapters
    echo    âœ“ ç« èŠ‚æ•°æ®å¯¼å…¥å®Œæˆ
) else (
    echo    âœ“ ç« èŠ‚æ•°æ®å……è¶³
)

:: æ£€æŸ¥æµ‹è¯•ç”¨æˆ·
echo.
echo 4. æ£€æŸ¥æµ‹è¯•ç”¨æˆ·...
for /f %%i in ('mongosh %DB_NAME% --quiet --eval "db.users.countDocuments({username: /^test_user/})"') do set USER_COUNT=%%i
echo    å½“å‰æµ‹è¯•ç”¨æˆ·æ•°é‡: %USER_COUNT%

if %USER_COUNT% LSS 5 (
    echo    âš  æµ‹è¯•ç”¨æˆ·ä¸è¶³
    echo    æ­£åœ¨åˆ›å»ºæµ‹è¯•ç”¨æˆ·...
    go run cmd/create_beta_users/main.go
    echo    âœ“ æµ‹è¯•ç”¨æˆ·åˆ›å»ºå®Œæˆ
) else (
    echo    âœ“ æµ‹è¯•ç”¨æˆ·å……è¶³
)

:: å®Œæˆ
echo.
echo =========================================
echo   âœ“ æµ‹è¯•æ•°æ®å‡†å¤‡å®Œæˆ
echo =========================================
echo.
echo æ•°æ®ç»Ÿè®¡:
echo   - ä¹¦ç±: %BOOK_COUNT% æœ¬
echo   - ç« èŠ‚: %CHAPTER_COUNT% ä¸ª
echo   - æµ‹è¯•ç”¨æˆ·: %USER_COUNT% ä¸ª
echo.

endlocal
```

### 6.3 é›†æˆåˆ°æµ‹è¯•æµç¨‹

```bash
# è¿è¡Œæµ‹è¯•å‰è‡ªåŠ¨å‡†å¤‡æ•°æ®
./scripts/testing/ensure_test_data.sh && go test ./test/integration/... -v
```

---

## ä¸ƒã€ç¯å¢ƒéªŒè¯å·¥å…·

### 7.1 è®¾è®¡ç›®æ ‡

**éœ€æ±‚**ï¼š
- åœ¨è¿è¡Œæµ‹è¯•å‰éªŒè¯ç¯å¢ƒæ˜¯å¦å°±ç»ª
- æ£€æŸ¥å¿…è¦çš„æœåŠ¡æ˜¯å¦å¯ç”¨
- éªŒè¯æµ‹è¯•æ•°æ®æ˜¯å¦å……è¶³
- æä¾›æ¸…æ™°çš„é”™è¯¯æç¤º

### 7.2 ç¯å¢ƒæ£€æŸ¥å®ç°

**æ–°æ–‡ä»¶**ï¼š`test/integration/environment_check.go`

```go
package integration

import (
    "context"
    "testing"
    
    "go.mongodb.org/mongo-driver/bson"
    
    "Qingyu_backend/global"
)

// CheckTestEnvironment æ£€æŸ¥æµ‹è¯•ç¯å¢ƒ
func CheckTestEnvironment(t *testing.T) error {
    ctx := context.Background()
    
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    if global.DB == nil {
        t.Fatal("âŒ æ•°æ®åº“æœªåˆå§‹åŒ–")
    }
    
    // Pingæ•°æ®åº“
    if err := global.DB.Client().Ping(ctx, nil); err != nil {
        t.Fatalf("âŒ æ•°æ®åº“è¿æ¥å¤±è´¥: %v", err)
    }
    
    t.Logf("âœ“ æ•°æ®åº“è¿æ¥æ­£å¸¸")
    return nil
}

// EnsureTestData ç¡®ä¿æµ‹è¯•æ•°æ®å­˜åœ¨
func EnsureTestData(t *testing.T) error {
    ctx := context.Background()
    
    // æ£€æŸ¥ä¹¦ç±æ•°é‡
    bookCount, err := global.DB.Collection("books").CountDocuments(ctx, bson.M{})
    if err != nil {
        t.Fatalf("âŒ æŸ¥è¯¢ä¹¦ç±æ•°é‡å¤±è´¥: %v", err)
    }
    
    if bookCount < 10 {
        t.Logf("âš  è­¦å‘Šï¼šä¹¦ç±æ•°é‡ä¸è¶³ï¼ˆå½“å‰: %dï¼Œå»ºè®®: >= 10ï¼‰", bookCount)
        t.Logf("   è¯·è¿è¡Œ: ./scripts/testing/ensure_test_data.sh")
    } else {
        t.Logf("âœ“ ä¹¦ç±æ•°æ®å……è¶³ (%d æœ¬)", bookCount)
    }
    
    // æ£€æŸ¥ç« èŠ‚æ•°é‡
    chapterCount, err := global.DB.Collection("chapters").CountDocuments(ctx, bson.M{})
    if err != nil {
        t.Fatalf("âŒ æŸ¥è¯¢ç« èŠ‚æ•°é‡å¤±è´¥: %v", err)
    }
    
    if chapterCount < 100 {
        t.Logf("âš  è­¦å‘Šï¼šç« èŠ‚æ•°é‡ä¸è¶³ï¼ˆå½“å‰: %dï¼Œå»ºè®®: >= 100ï¼‰", chapterCount)
    } else {
        t.Logf("âœ“ ç« èŠ‚æ•°æ®å……è¶³ (%d ä¸ª)", chapterCount)
    }
    
    // æ£€æŸ¥æµ‹è¯•ç”¨æˆ·
    userCount, err := global.DB.Collection("users").CountDocuments(ctx, bson.M{
        "username": bson.M{"$regex": "^test_user"},
    })
    if err != nil {
        t.Fatalf("âŒ æŸ¥è¯¢ç”¨æˆ·æ•°é‡å¤±è´¥: %v", err)
    }
    
    if userCount < 5 {
        t.Logf("âš  è­¦å‘Šï¼šæµ‹è¯•ç”¨æˆ·ä¸è¶³ï¼ˆå½“å‰: %dï¼Œå»ºè®®: >= 5ï¼‰", userCount)
        t.Logf("   è¯·è¿è¡Œ: go run cmd/create_beta_users/main.go")
    } else {
        t.Logf("âœ“ æµ‹è¯•ç”¨æˆ·å……è¶³ (%d ä¸ª)", userCount)
    }
    
    return nil
}

// ValidateServices éªŒè¯æœåŠ¡å¯ç”¨æ€§
func ValidateServices(t *testing.T) []string {
    unavailable := make([]string, 0)
    
    // æ£€æŸ¥æœåŠ¡å®¹å™¨
    if global.ServiceContainer == nil {
        t.Logf("âš  æœåŠ¡å®¹å™¨æœªåˆå§‹åŒ–")
        unavailable = append(unavailable, "ServiceContainer")
    }
    
    // æ£€æŸ¥å¿…è¦çš„æœåŠ¡
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šæœåŠ¡æ£€æŸ¥
    
    if len(unavailable) > 0 {
        t.Logf("âš  éƒ¨åˆ†æœåŠ¡ä¸å¯ç”¨: %v", unavailable)
    } else {
        t.Logf("âœ“ æ‰€æœ‰æœåŠ¡æ­£å¸¸")
    }
    
    return unavailable
}
```

### 7.3 ä½¿ç”¨ç¤ºä¾‹

```go
func TestMain(m *testing.M) {
    // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
    setupTestEnvironment()
    
    // éªŒè¯ç¯å¢ƒ
    CheckTestEnvironment(nil)
    EnsureTestData(nil)
    ValidateServices(nil)
    
    // è¿è¡Œæµ‹è¯•
    code := m.Run()
    
    // æ¸…ç†
    cleanupTestEnvironment()
    
    os.Exit(code)
}
```

---

## å…«ã€å·¥å…·é›†æˆä¸ä½¿ç”¨æµç¨‹

### 8.1 å®Œæ•´çš„æµ‹è¯•ç¼–å†™æµç¨‹

```go
package integration

import (
    "testing"
    "Qingyu_backend/test/integration"
    "Qingyu_backend/test/testutil"
)

func TestCompleteFlow(t *testing.T) {
    // 1. ç¯å¢ƒéªŒè¯
    integration.CheckTestEnvironment(t)
    integration.EnsureTestData(t)
    
    // 2. åˆ›å»ºTestHelper
    helper := integration.NewTestHelper(t, router)
    
    // 3. åˆ›å»ºæ•°æ®å·¥å‚ï¼ˆå¦‚æœéœ€è¦è‡ªå®šä¹‰æ•°æ®ï¼‰
    factory := testutil.NewTestDataFactory(t)
    defer factory.CleanupAll()
    
    // 4. å‡†å¤‡æµ‹è¯•æ•°æ®
    bookID := factory.CreateTestBook("æµ‹è¯•ä¹¦ç±",
        testutil.WithAuthor("çŸ¥åä½œè€…"),
        testutil.WithCategory("ç„å¹»"),
    )
    
    // 5. ç™»å½•
    token := helper.LoginTestUser()
    
    // 6. æµ‹è¯•åœºæ™¯
    t.Run("æ·»åŠ æ”¶è—", func(t *testing.T) {
        reqBody := map[string]interface{}{
            "book_id": bookID,
            "note": "æµ‹è¯•ç¬”è®°",
        }
        
        // è®°å½•è¯·æ±‚
        helper.LogRequest("POST", integration.ReaderCollectionsPath, reqBody, token)
        
        // å‘é€è¯·æ±‚
        w := helper.DoAuthRequest("POST", integration.ReaderCollectionsPath, reqBody, token)
        
        // è®°å½•å“åº”
        helper.LogResponse(w)
        
        // æ–­è¨€
        response := helper.AssertSuccess(w, 201, "æ·»åŠ æ”¶è—å¤±è´¥")
        
        // éªŒè¯è¿”å›æ•°æ®
        data := response["data"].(map[string]interface{})
        assert.Equal(t, bookID, data["book_id"])
        
        helper.LogSuccess("æ·»åŠ æ”¶è—æˆåŠŸ")
    })
    
    // 7. æ¸…ç†ï¼ˆé€šè¿‡deferè‡ªåŠ¨æ‰§è¡Œï¼‰
}
```

### 8.2 å·¥å…·é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èå·¥å…· | åŸå›  |
|-----|---------|------|
| éœ€è¦å¿«é€Ÿæµ‹è¯•API | TestHelper | ç®€åŒ–è¯·æ±‚æ„é€ å’Œæ–­è¨€ |
| éœ€è¦è‡ªå®šä¹‰å¤æ‚æ•°æ® | æ•°æ®å·¥å‚ | çµæ´»é…ç½®ï¼Œè‡ªåŠ¨æ¸…ç† |
| ä½¿ç”¨ç°æœ‰æ•°æ® | GetTestBook | å¿«é€Ÿè·å–ï¼Œæ— éœ€åˆ›å»º |
| ç¯å¢ƒä¸ç¨³å®š | ç¯å¢ƒéªŒè¯å·¥å…· | æå‰å‘ç°é—®é¢˜ |
| å¤šä¸ªæµ‹è¯•å…±äº«æ•°æ® | æ•°æ®å‡†å¤‡è„šæœ¬ | ä¸€æ¬¡å‡†å¤‡ï¼Œå¤šæ¬¡ä½¿ç”¨ |

---

## ä¹ã€æ€»ç»“

### 9.1 å·¥å…·æ¸…å•

| å·¥å…· | æ–‡ä»¶ | åŠŸèƒ½ | çŠ¶æ€ |
|-----|------|------|------|
| TestHelperæ¡†æ¶ | `test/integration/helpers.go` | ç»Ÿä¸€æµ‹è¯•è¾…åŠ© | âœ… å®Œæˆ |
| è·¯å¾„å¸¸é‡ | `test/integration/helpers.go` | APIè·¯å¾„ç®¡ç† | âœ… å®Œæˆ |
| é”™è¯¯è¯Šæ–­ | `test/integration/helpers.go` | å¢å¼ºè¯Šæ–­åŠŸèƒ½ | ğŸ”„ å¾…å®ç° |
| æ•°æ®å·¥å‚ | `test/testutil/factory.go` | æµ‹è¯•æ•°æ®åˆ›å»º | ğŸ”„ å¾…å®ç° |
| æ•°æ®å‡†å¤‡è„šæœ¬ | `scripts/testing/ensure_test_data.*` | è‡ªåŠ¨åŒ–æ•°æ®å‡†å¤‡ | ğŸ”„ å¾…å®ç° |
| ç¯å¢ƒéªŒè¯ | `test/integration/environment_check.go` | ç¯å¢ƒæ£€æŸ¥ | ğŸ”„ å¾…å®ç° |

### 9.2 ä½¿ç”¨å»ºè®®

1. **ä¼˜å…ˆä½¿ç”¨TestHelper**ï¼šç®€åŒ–90%çš„æµ‹è¯•ä»£ç 
2. **è·¯å¾„ä½¿ç”¨å¸¸é‡**ï¼šé¿å…ç¡¬ç¼–ç 
3. **åˆç†ä½¿ç”¨å·¥å‚**ï¼šå¤æ‚åœºæ™¯åˆ›å»ºè‡ªå®šä¹‰æ•°æ®
4. **è¿è¡Œå‰éªŒè¯ç¯å¢ƒ**ï¼šç¡®ä¿æµ‹è¯•æ•°æ®å……è¶³
5. **è¯¦ç»†è®°å½•æ—¥å¿—**ï¼šä¾¿äºé—®é¢˜æ’æŸ¥

---

## åã€å‚è€ƒèµ„æ–™

- `test/integration/README_TestHelperä½¿ç”¨æŒ‡å—.md` - TestHelperè¯¦ç»†ä½¿ç”¨æŒ‡å—
- `doc/testing/æµ‹è¯•æ¶æ„è®¾è®¡è§„èŒƒ.md` - æµ‹è¯•æ¶æ„è®¾è®¡
- `doc/testing/æµ‹è¯•ç»„ç»‡è§„èŒƒ.md` - æµ‹è¯•ç»„ç»‡æ ‡å‡†

---

**ç‰ˆæœ¬å†å²**:
- 1.0 (2025-10-25) - åˆå§‹ç‰ˆæœ¬å‘å¸ƒ

**ç»´æŠ¤è€…**: åç«¯å¼€å‘å›¢é˜Ÿ  
**é—®é¢˜åé¦ˆ**: è¯·åœ¨é¡¹ç›®ä»“åº“æIssue

