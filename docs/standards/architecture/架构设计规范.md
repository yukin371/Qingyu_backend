# 架构设计规范

**版本**: v2.0
**更新**: 2026-01-08
**状态**: ✅ 正式实施

---

## 一、核心原则

### 1.1 分层架构

```
┌─────────────────────────────────┐
│  Router Layer (路由层)          │ HTTP路由、中间件
├─────────────────────────────────┤
│  API Layer (接口层)             │ 参数处理、响应格式化
├─────────────────────────────────┤
│  Service Layer (业务层)         │ 业务逻辑、事务协调
├─────────────────────────────────┤
│  Repository Layer (仓储层)      │ 数据访问、缓存策略
├─────────────────────────────────┤
│  Database/Cache (存储层)        │ MongoDB、Redis
└─────────────────────────────────┘
```

**依赖规则**：
- ✅ 上层可依赖下层接口
- ❌ 下层不能依赖上层
- ❌ 禁止跨层调用（如API直接调用Repository）
- ✅ 层间通过接口交互（依赖倒置）

### 1.2 设计原则

| 原则 | 说明 |
|------|------|
| **单一职责** | 每层只负责自己的职责 |
| **依赖倒置** | 依赖接口而非实现 |
| **接口隔离** | 接口小而专注 |
| **开闭原则** | 对扩展开放，对修改关闭 |

---

## 二、各层职责

### 2.1 Router层（路由层）

**职责**：
- HTTP路由定义和分组
- 中间件配置（认证、日志、限流等）
- 请求分发到对应API处理器

**代码位置**：`router/`

**示例**：
```go
// router/bookstore/bookstore_router.go
func RegisterBookstoreRoutes(r *gin.RouterGroup, bookstoreAPI *bookstore.BookstoreAPI) {
    bookstoreGroup := r.Group("/bookstore")
    {
        bookstoreGroup.GET("/books", bookstoreAPI.GetBooks)
        bookstoreGroup.GET("/books/:id", bookstoreAPI.GetBookByID)
        bookstoreGroup.POST("/books", middleware.Auth(), bookstoreAPI.CreateBook)
    }
}
```

**规范**：
- ✅ 路由按模块分组
- ✅ 公开路由和认证路由分离
- ✅ 路径参数使用`:param`格式
- ❌ 路由层不包含业务逻辑

### 2.2 API层（接口层）

**职责**：
- 请求参数绑定和验证
- 调用Service层处理业务
- 统一响应格式化
- 错误码转换

**代码位置**：`api/v1/{module}/`

**示例**：
```go
// api/v1/bookstore/bookstore_api.go
func (api *BookstoreAPI) GetBooks(c *gin.Context) {
    // 1. 参数提取
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("size", "20"))

    // 2. 调用Service
    books, total, err := api.service.GetBooks(c.Request.Context(), page, pageSize)

    // 3. 响应处理
    if err != nil {
        shared.InternalError(c, "获取书籍列表失败", err)
        return
    }

    shared.Paginated(c, books, total, page, pageSize, "获取成功")
}
```

**规范**：
- ✅ 只处理HTTP相关逻辑
- ❌ 不直接操作数据库
- ❌ 不包含复杂业务逻辑
- ✅ 使用统一的响应方法

### 2.3 Service层（业务层）

**职责**：
- 实现业务逻辑
- 数据验证和转换
- 事务协调
- 调用Repository层访问数据

**代码位置**：`service/{module}/`

**接口定义**：`service/interfaces/{module}/`

**示例**：
```go
// service/bookstore/bookstore_service.go
type BookstoreService interface {
    GetBooks(ctx context.Context, page, pageSize int) ([]*Book, int64, error)
    GetBookByID(ctx context.Context, bookID string) (*Book, error)
    CreateBook(ctx context.Context, book *Book) error
}

type BookstoreServiceImpl struct {
    bookRepo repository.BookRepository
    cache    cache.Cache
}

func (s *BookstoreServiceImpl) GetBooks(ctx context.Context, page, pageSize int) ([]*Book, int64, error) {
    // 1. 参数验证
    if page < 1 {
        page = 1
    }
    if pageSize < 1 || pageSize > 100 {
        pageSize = 20
    }

    // 2. 业务逻辑
    filter := &BookFilter{
        Status:  "published",
        Page:    page,
        PageSize: pageSize,
    }

    // 3. 调用Repository
    books, total, err := s.bookRepo.FindWithFilter(ctx, filter)
    if err != nil {
        return nil, 0, fmt.Errorf("查询书籍失败: %w", err)
    }

    return books, total, nil
}
```

**规范**：
- ✅ 包含所有业务逻辑
- ✅ 通过Repository接口访问数据
- ❌ 不直接操作数据库
- ✅ 提供清晰的接口定义
- ✅ 支持依赖注入和单元测试

### 2.4 Repository层（仓储层）

**职责**：
- 数据库操作封装
- 查询构建和优化
- 索引管理
- 缓存策略实现
- 事务处理

**代码位置**：
- 接口：`repository/interfaces/{module}/`
- 实现：`repository/mongodb/{module}/`

**示例**：
```go
// repository/interfaces/bookstore/BookRepository_interface.go
type BookRepository interface {
    // 基础CRUD
    Create(ctx context.Context, book *Book) error
    GetByID(ctx context.Context, id string) (*Book, error)
    Update(ctx context.Context, book *Book) error
    Delete(ctx context.Context, id string) error

    // 查询
    FindWithFilter(ctx context.Context, filter *BookFilter) ([]*Book, int64, error)
    Search(ctx context.Context, keyword string, page, pageSize int) ([]*Book, error)

    // 工具方法
    Health(ctx context.Context) error
}

// repository/mongodb/bookstore/bookstore_repository_mongo.go
type MongoBookRepository struct {
    db         *mongo.Database
    collection *mongo.Collection
    cache      cache.Cache
}

func (r *MongoBookRepository) FindWithFilter(
    ctx context.Context,
    filter *BookFilter,
) ([]*Book, int64, error) {
    // 1. 构建查询条件
    query := r.buildQuery(filter)

    // 2. 执行查询
    cursor, err := r.collection.Find(ctx, query)
    if err != nil {
        return nil, 0, fmt.Errorf("查询失败: %w", err)
    }
    defer cursor.Close(ctx)

    // 3. 解析结果
    var books []*Book
    if err = cursor.All(ctx, &books); err != nil {
        return nil, 0, fmt.Errorf("解析结果失败: %w", err)
    }

    // 4. 统计总数
    total, err := r.collection.CountDocuments(ctx, query)
    if err != nil {
        return nil, 0, fmt.Errorf("统计失败: %w", err)
    }

    return books, total, nil
}
```

**规范**：
- ✅ 封装所有数据访问逻辑
- ✅ 提供清晰的接口定义
- ✅ 实现与业务逻辑分离
- ✅ 支持事务和缓存
- ✅ 包含索引管理

---

## 三、关键设计模式

### 3.1 Repository模式

**目的**：解耦业务逻辑与数据访问

**结构**：
```
Service → Repository接口 → MongoDB实现
                ↓
            可Mock测试
```

**好处**：
- ✅ 业务逻辑与数据库实现解耦
- ✅ 便于单元测试（Mock Repository）
- ✅ 支持多种数据库实现
- ✅ 统一的数据访问接口

### 3.2 依赖注入

**方式**：通过构造函数注入依赖

**示例**：
```go
// Service构造函数
func NewBookstoreService(
    bookRepo repository.BookRepository,
    cache cache.Cache,
) BookstoreService {
    return &BookstoreServiceImpl{
        bookRepo: bookRepo,
        cache:    cache,
    }
}

// 在main.go中初始化
func initializeServices() {
    // 1. 创建Repository
    bookRepo := repository.NewMongoBookRepository(db)

    // 2. 创建Service（注入Repository）
    bookstoreService := service.NewBookstoreService(bookRepo, redis)

    // 3. 创建API（注入Service）
    bookstoreAPI := api.NewBookstoreAPI(bookstoreService)

    // 4. 注册路由
    router.RegisterBookstoreRoutes(r, bookstoreAPI)
}
```

### 3.3 工厂模式

**Repository工厂**：
```go
// repository/factory/repository_factory.go
type RepositoryFactory interface {
    CreateUserRepository() repository.UserRepository
    CreateBookRepository() repository.BookRepository
    Health(ctx context.Context) error
}

type MongoRepositoryFactory struct {
    db *mongo.Database
}

func (f *MongoRepositoryFactory) CreateBookRepository() repository.BookRepository {
    return NewMongoBookRepository(f.db)
}
```

**Service工厂**：
```go
// service/factory/service_factory.go
type ServiceFactory interface {
    CreateBookstoreService() service.BookstoreService
    CreateUserService() service.UserService
}

type ServiceFactoryImpl struct {
    repoFactory repository.RepositoryFactory
    cache       cache.Cache
}

func (f *ServiceFactoryImpl) CreateBookstoreService() service.BookstoreService {
    bookRepo := f.repoFactory.CreateBookRepository()
    return service.NewBookstoreService(bookRepo, f.cache)
}
```

---

## 四、错误处理

### 4.1 分层错误处理

**Repository层**：数据访问错误
```go
type RepositoryError struct {
    Code    string
    Message string
    Err     error
}

func (e *RepositoryError) Error() string {
    return e.Message
}

// 使用
if err != nil {
    return nil, &RepositoryError{
        Code:    "NOT_FOUND",
        Message: "书籍不存在",
        Err:     err,
    }
}
```

**Service层**：业务逻辑错误
```go
type ServiceError struct {
    Code      string
    Message   string
    Service   string
    Err       error
}

// 使用
if book == nil {
    return nil, &ServiceError{
        Code:    "BOOK_NOT_FOUND",
        Message: "书籍不存在",
        Service: "bookstore",
    }
}
```

**API层**：转换为HTTP响应
```go
func (api *BookstoreAPI) handleError(c *gin.Context, err error) {
    switch e := err.(type) {
    case *ServiceError:
        switch e.Code {
        case "BOOK_NOT_FOUND":
            shared.NotFound(c, e.Message)
        case "INVALID_PARAM":
            shared.BadRequest(c, e.Message)
        default:
            shared.InternalError(c, "服务错误", err)
        }
    default:
        shared.InternalError(c, "内部错误", err)
    }
}
```

---

## 五、数据访问规范

### 5.1 索引管理

**原则**：索引定义在Repository层

```go
// repository/mongodb/bookstore/bookstore_repository_mongo.go
func (r *MongoBookRepository) EnsureIndexes(ctx context.Context) error {
    models := []mongo.IndexModel{
        {Keys: bson.D{{Key: "title", Value: 1}}},
        {Keys: bson.D{{Key: "author", Value: 1}}},
        {Keys: bson.D{{Key: "status", Value: 1}, {Key: "created_at", Value: -1}}},
    }

    _, err := r.collection.Indexes().CreateMany(ctx, models)
    return err
}
```

### 5.2 查询优化

**原则**：
- ✅ 使用索引字段查询
- ✅ 限制返回字段（投影）
- ✅ 合理使用分页
- ❌ 避免大结果集

```go
// 优化前：返回所有字段
cursor, err := r.collection.Find(ctx, filter)

// 优化后：只返回需要的字段
opts := options.Find().SetProjection(bson.M{
    "title": 1,
    "author": 1,
    "status": 1,
})
cursor, err := r.collection.Find(ctx, filter, opts)
```

### 5.3 事务处理

```go
func (r *MongoBookRepository) Transaction(
    ctx context.Context,
    fn func(sessionContext context.Context) error,
) error {
    session, err := r.db.Client().StartSession()
    if err != nil {
        return err
    }
    defer session.EndSession(ctx)

    _, err = session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) {
        return nil, fn(sessCtx)
    })

    return err
}
```

---

## 六、命名规范

### 6.1 接口命名

```
{模块}Repository  - 数据访问接口
{模块}Service     - 业务逻辑接口
{模块}API         - HTTP处理接口
```

示例：
- `BookRepository`
- `BookstoreService`
- `BookstoreAPI`

### 6.2 实现命名

```
{技术}{模块}Repository
{模块}ServiceImpl
```

示例：
- `MongoBookRepository`
- `BookstoreServiceImpl`

### 6.3 方法命名

**CRUD操作**：
- `Create` / `Add`
- `Get` / `Find` / `Search`
- `Update` / `Modify`
- `Delete` / `Remove`

**业务操作**：
- 动词开头，清晰表达意图
- `ValidateUser`
- `ProcessPayment`
- `GenerateReport`

---

## 七、目录结构

```
Qingyu_backend/
├── api/v1/                    # API层
│   ├── bookstore/
│   │   └── bookstore_api.go
│   └── shared/
│       └── response.go
├── service/                   # Service层
│   ├── interfaces/            # 接口定义
│   │   └── bookstore/
│   │       └── BookRepository_interface.go
│   ├── bookstore/
│   │   └── bookstore_service.go
│   └── base/                 # 基础服务
├── repository/               # Repository层
│   ├── interfaces/           # 接口定义
│   │   └── bookstore/
│   ├── mongodb/             # MongoDB实现
│   │   └── bookstore/
│   └── factory/             # 工厂
├── models/                  # 数据模型
│   ├── bookstore/
│   └── user/
├── router/                  # 路由层
│   └── bookstore/
├── middleware/              # 中间件
└── config/                  # 配置
```

---

## 八、最佳实践

### 8.1 代码组织

✅ **推荐**：
- 按功能模块组织
- 接口与实现分离
- 清晰的依赖关系

❌ **避免**：
- 循环依赖
- 跨层调用
- 过度耦合

### 8.2 测试策略

**单元测试**：Mock Repository
```go
mockRepo := &MockBookRepository{}
mockRepo.On("FindWithFilter", mock.Anything, filter).Return(books, total, nil)
service := NewBookstoreService(mockRepo)
```

**集成测试**：真实数据库
```go
db := setupTestDB()
repo := NewMongoBookRepository(db)
service := NewBookstoreService(repo)
```

### 8.3 性能优化

- ✅ Repository层实现缓存
- ✅ 使用索引优化查询
- ✅ 批量操作合并请求
- ✅ 异步处理非关键业务

---

## 九、检查清单

### Service层检查

- [ ] 不直接操作数据库
- [ ] 通过Repository接口访问数据
- [ ] 包含业务逻辑验证
- [ ] 有清晰的错误处理
- [ ] 支持依赖注入
- [ ] 有对应的单元测试

### Repository层检查

- [ ] 接口定义清晰
- [ ] 实现与数据库分离
- [ ] 包含错误处理
- [ ] 支持事务操作
- [ ] 有索引管理
- [ ] 有健康检查

### API层检查

- [ ] 只处理HTTP请求响应
- [ ] 不包含业务逻辑
- [ ] 有参数验证
- [ ] 统一的错误响应格式
- [ ] 适当的HTTP状态码
- [ ] 有请求日志记录

---

**相关文档**：
- [API设计规范](../api/API设计规范.md)
- [路由层设计规范](./路由层设计规范.md)
- [依赖管理规范](./依赖管理规范.md)
