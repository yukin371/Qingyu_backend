# å•å…ƒæµ‹è¯•æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2026-01-06
> **é€‚ç”¨ç³»ç»Ÿ**: é’ç¾½å†™ä½œå¹³å°åç«¯

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯´æ˜å¦‚ä½•ä¸ºé’ç¾½å¹³å°ç¼–å†™é«˜è´¨é‡çš„å•å…ƒæµ‹è¯•ï¼ŒåŒ…æ‹¬æµ‹è¯•æ¡†æ¶ã€æµ‹è¯•ç­–ç•¥ã€Mockä½¿ç”¨å’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ æµ‹è¯•ç›®æ ‡

| æŒ‡æ ‡ | å½“å‰ | ç›®æ ‡ | è¯´æ˜ |
|------|------|------|------|
| æ•´ä½“è¦†ç›–ç‡ | ~30% | 60% | è¡Œè¦†ç›–ç‡ |
| Serviceå±‚ | ~20% | 70% | æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ |
| APIå±‚ | ~15% | 50% | HTTPæ¥å£ |
| Repositoryå±‚ | ~10% | 40% | æ•°æ®è®¿é—® |

## ğŸ› ï¸ æµ‹è¯•å·¥å…·æ ˆ

### 1. æ ¸å¿ƒæµ‹è¯•æ¡†æ¶

```go
// Goæ ‡å‡†æµ‹è¯•åŒ…
import "testing"

// æµ‹è¯•æ–­è¨€åº“
import "github.com/stretchr/testify/assert"
import "github.com/stretchr/testify/require"
import "github.com/stretchr/testify/mock"

// HTTPæµ‹è¯•
import "net/http/httptest"

// Mockå·¥å…·
import "github.com/stretchr/testify/mock"
import "github.com/golang/mock/gomock"
```

### 2. å®‰è£…æµ‹è¯•å·¥å…·

```bash
# å®‰è£…testifyï¼ˆæ–­è¨€åº“ï¼‰
go get github.com/stretchr/testify

# å®‰è£…gomockï¼ˆMockç”Ÿæˆå·¥å…·ï¼‰
go install github.com/golang/mock/mockgen@latest

# å®‰ç½®æµ‹è¯•è¦†ç›–ç‡å·¥å…·
go install github.com/axw/gocov/gocov@latest
```

## ğŸ“ æµ‹è¯•æ–‡ä»¶ç»„ç»‡

### 1. æ–‡ä»¶å‘½åè§„èŒƒ

```
# æºæ–‡ä»¶
service/user/user_service.go

# æµ‹è¯•æ–‡ä»¶
service/user/user_service_test.go
```

### 2. ç›®å½•ç»“æ„

```
project/
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ user_service_test.go       # Serviceå±‚æµ‹è¯•
â”‚   â””â”€â”€ book/
â”‚       â”œâ”€â”€ book_service.go
â”‚       â””â”€â”€ book_service_test.go
â”œâ”€â”€ api/v1/
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ user_api.go
â”‚   â”‚   â””â”€â”€ user_api_test.go            # APIå±‚æµ‹è¯•
â”‚   â””â”€â”€ book/
â”‚       â”œâ”€â”€ book_api.go
â”‚       â””â”€â”€ book_api_test.go
â””â”€â”€ repository/
    â”œâ”€â”€ user_repository_test.go         # Repositoryå±‚æµ‹è¯•
    â””â”€â”€ book_repository_test.go
```

## âœï¸ åŸºç¡€æµ‹è¯•ç¤ºä¾‹

### 1. ç®€å•å‡½æ•°æµ‹è¯•

```go
// service/utils/string.go
func ReverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

// service/utils/string_test.go
func TestReverseString(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
    }{
        {
            name:     "æ­£å¸¸å­—ç¬¦ä¸²",
            input:    "hello",
            expected: "olleh",
        },
        {
            name:     "ç©ºå­—ç¬¦ä¸²",
            input:    "",
            expected: "",
        },
        {
            name:     "å•ä¸ªå­—ç¬¦",
            input:    "a",
            expected: "a",
        },
        {
            name:     "ä¸­æ–‡å­—ç¬¦ä¸²",
            input:    "ä½ å¥½",
            expected: "å¥½ä½ ",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := ReverseString(tt.input)
            assert.Equal(t, tt.expected, result)
        })
    }
}
```

### 2. ä½¿ç”¨testifyæ–­è¨€

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestUserCreation(t *testing.T) {
    // assert - å¤±è´¥åç»§ç»­æ‰§è¡Œ
    assert.NotNil(t, user, "ç”¨æˆ·ä¸åº”ä¸ºnil")
    assert.Equal(t, "john", user.Username, "ç”¨æˆ·åä¸åŒ¹é…")
    assert.True(t, user.IsActive, "ç”¨æˆ·åº”è¯¥æ˜¯æ¿€æ´»çŠ¶æ€")
    assert.Contains(t, user.Roles, "user", "è§’è‰²åº”åŒ…å«user")

    // require - å¤±è´¥åç«‹å³åœæ­¢
    require.NoError(t, err, "åˆ›å»ºç”¨æˆ·ä¸åº”å‡ºé”™")
    require.NotNil(t, user.ID, "ç”¨æˆ·IDä¸åº”ä¸ºç©º")
}
```

## ğŸ­ Mockä½¿ç”¨

### 1. ä½¿ç”¨testify/mock

```go
// å®šä¹‰Mockæ¥å£
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

// ä½¿ç”¨Mockè¿›è¡Œæµ‹è¯•
func TestUserService_GetUser(t *testing.T) {
    // åˆ›å»ºMock
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    // è®¾ç½®Mocké¢„æœŸ
    expectedUser := &User{
        ID:       "123",
        Username: "john",
    }
    mockRepo.On("GetByID", mock.Anything, "123").Return(expectedUser, nil)

    // æ‰§è¡Œæµ‹è¯•
    user, err := service.GetUser(context.Background(), "123")

    // éªŒè¯ç»“æœ
    require.NoError(t, err)
    assert.Equal(t, expectedUser.ID, user.ID)
    assert.Equal(t, expectedUser.Username, user.Username)

    // éªŒè¯Mockè¢«è°ƒç”¨
    mockRepo.AssertExpectations(t)
}

func TestUserService_GetUser_NotFound(t *testing.T) {
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    // è®¾ç½®è¿”å›é”™è¯¯
    mockRepo.On("GetByID", mock.Anything, "999").Return(nil, ErrUserNotFound)

    // æ‰§è¡Œæµ‹è¯•
    user, err := service.GetUser(context.Background(), "999")

    // éªŒè¯é”™è¯¯
    require.Error(t, err)
    assert.Nil(t, user)
    assert.Equal(t, ErrUserNotFound, err)
}
```

### 2. ä½¿ç”¨httptestæµ‹è¯•API

```go
func TestUserAPI_GetUser(t *testing.T) {
    // è®¾ç½®Ginæµ‹è¯•ç¯å¢ƒ
    gin.SetMode(gin.TestMode)
    router := gin.New()

    // åˆ›å»ºMockæœåŠ¡
    mockService := new(MockUserService)
    api := NewUserAPI(mockService)
    router.GET("/users/:id", api.GetUser)

    // è®¾ç½®Mocké¢„æœŸ
    expectedUser := &User{
        ID:       "123",
        Username: "john",
        Email:    "john@example.com",
    }
    mockService.On("GetUser", mock.Anything, "123").Return(expectedUser, nil)

    // åˆ›å»ºæµ‹è¯•è¯·æ±‚
    req := httptest.NewRequest("GET", "/users/123", nil)
    req.Header.Set("Authorization", "Bearer test_token")
    w := httptest.NewRecorder()

    // æ‰§è¡Œè¯·æ±‚
    router.ServeHTTP(w, req)

    // éªŒè¯å“åº”
    assert.Equal(t, 200, w.Code)

    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    assert.Equal(t, float64(200), response["code"])
    assert.NotEmpty(t, response["data"])

    data := response["data"].(map[string]interface{})
    assert.Equal(t, "123", data["id"])
    assert.Equal(t, "john", data["username"])

    // éªŒè¯Mockè¢«è°ƒç”¨
    mockService.AssertExpectations(t)
}
```

## ğŸ“Š è¡¨é©±åŠ¨æµ‹è¯•

```go
func TestValidateEmail(t *testing.T) {
    tests := []struct {
        name      string
        email     string
        wantErr   bool
        errReason string
    }{
        {
            name:    "æœ‰æ•ˆé‚®ç®±",
            email:   "user@example.com",
            wantErr: false,
        },
        {
            name:      "ç¼ºå°‘@ç¬¦å·",
            email:     "userexample.com",
            wantErr:   true,
            errReason: "invalid email format",
        },
        {
            name:      "ç¼ºå°‘åŸŸå",
            email:     "user@",
            wantErr:   true,
            errReason: "invalid email format",
        },
        {
            name:      "ç©ºå­—ç¬¦ä¸²",
            email:     "",
            wantErr:   true,
            errReason: "email is required",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateEmail(tt.email)

            if tt.wantErr {
                require.Error(t, err)
                assert.Contains(t, err.Error(), tt.errReason)
            } else {
                require.NoError(t, err)
            }
        })
    }
}
```

## ğŸ”§ æµ‹è¯•è¾…åŠ©å‡½æ•°

### 1. æµ‹è¯•æ•°æ®æ„å»ºå™¨

```go
// test/builders.go
package test

type UserBuilder struct {
    user *User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{
            ID:        generateID(),
            Username:  "test_user",
            Email:     "test@example.com",
            Status:    "active",
            CreatedAt: time.Now(),
        },
    }
}

func (b *UserBuilder) WithID(id string) *UserBuilder {
    b.user.ID = id
    return b
}

func (b *UserBuilder) WithUsername(username string) *UserBuilder {
    b.user.Username = username
    return b
}

func (b *UserBuilder) WithEmail(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) WithStatus(status string) *UserBuilder {
    b.user.Status = status
    return b
}

func (b *UserBuilder) Build() *User {
    return b.user
}

// ä½¿ç”¨ç¤ºä¾‹
func TestUserService_UpdateUser(t *testing.T) {
    user := NewUserBuilder().
        WithID("123").
        WithUsername("john").
        WithEmail("john@example.com").
        Build()

    // æµ‹è¯•é€»è¾‘...
}
```

### 2. æµ‹è¯•ä¸Šä¸‹æ–‡

```go
// test/context.go
package test

import (
    "context"
    "time"
)

// TestContext åˆ›å»ºæµ‹è¯•ç”¨context
func TestContext() context.Context {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    // åœ¨æµ‹è¯•ç»“æŸæ—¶å–æ¶ˆcontext
    go func() {
        time.Sleep(4 * time.Second)
        cancel()
    }()
    return ctx
}

// WithTestUserID æ·»åŠ æµ‹è¯•ç”¨æˆ·IDåˆ°context
func WithTestUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, "user_id", userID)
}
```

### 3. æ•°æ®åº“æµ‹è¯•å·¥å…·

```go
// test/database.go
package test

import (
    "testing"
    "time"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

// SetupTestDB è®¾ç½®æµ‹è¯•æ•°æ®åº“
func SetupTestDB(t *testing.T) *mongo.Client {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // ä½¿ç”¨å†…å­˜MongoDBæˆ–æµ‹è¯•æ•°æ®åº“
    client, err := mongo.Connect(ctx, options.Client().ApplyURI("mongodb://localhost:27017"))
    require.NoError(t, err)

    // æ¸…ç†å‡½æ•°
    t.Cleanup(func() {
        client.Database("qingyu_test").Drop(ctx)
        client.Disconnect(ctx)
    })

    return client
}
```

## ğŸ§ª é›†æˆæµ‹è¯•

### 1. APIé›†æˆæµ‹è¯•

```go
func TestBookAPIIntegration(t *testing.T) {
    // è·³è¿‡çŸ­æµ‹è¯•
    if testing.Short() {
        t.Skip("è·³è¿‡é›†æˆæµ‹è¯•")
    }

    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    gin.SetMode(gin.TestMode)
    router := setupTestRouter()

    // 1. åˆ›å»ºä¹¦ç±
    createReq := BookCreateRequest{
        Title:       "æµ‹è¯•ä¹¦ç±",
        Description: "è¿™æ˜¯ä¸€æœ¬æµ‹è¯•ä¹¦ç±",
        Category:    "novel",
    }
    reqBody, _ := json.Marshal(createReq)
    req := httptest.NewRequest("POST", "/api/v1/books", bytes.NewBuffer(reqBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+getTestToken())
    w := httptest.NewRecorder()

    router.ServeHTTP(w, req)
    assert.Equal(t, 201, w.Code)

    var createResp map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &createResp)
    bookID := createResp["data"].(map[string]interface{})["id"].(string)

    // 2. è·å–ä¹¦ç±
    req = httptest.NewRequest("GET", "/api/v1/books/"+bookID, nil)
    w = httptest.NewRecorder()
    router.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)

    // 3. æ›´æ–°ä¹¦ç±
    updateReq := BookUpdateRequest{
        Title: "æ›´æ–°åçš„ä¹¦ç±",
    }
    reqBody, _ = json.Marshal(updateReq)
    req = httptest.NewRequest("PUT", "/api/v1/books/"+bookID, bytes.NewBuffer(reqBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+getTestToken())
    w = httptest.NewRecorder()
    router.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)

    // 4. åˆ é™¤ä¹¦ç±
    req = httptest.NewRequest("DELETE", "/api/v1/books/"+bookID, nil)
    req.Header.Set("Authorization", "Bearer "+getTestToken())
    w = httptest.NewRecorder()
    router.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
}
```

## ğŸ“ˆ è¿è¡Œæµ‹è¯•

### 1. åŸºæœ¬æµ‹è¯•å‘½ä»¤

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
go test ./...

# è¿è¡ŒæŒ‡å®šåŒ…çš„æµ‹è¯•
go test ./service/user

# è¿è¡ŒæŒ‡å®šæµ‹è¯•å‡½æ•°
go test ./service/user -run TestUserService_GetUser

# è¿è¡Œ verbose æ¨¡å¼
go test -v ./...

# è¿è¡Œæµ‹è¯•å¹¶æ˜¾ç¤ºè¦†ç›–ç‡
go test -cover ./...

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# è¿è¡ŒåŸºå‡†æµ‹è¯•
go test -bench=. -benchmem

# è·³è¿‡é•¿æµ‹è¯•
go test -short ./...
```

### 2. Makefileé…ç½®

```makefile
# Makefile
.PHONY: test test-cover test-benchmark test-integration

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
test:
	go test -v -race ./...

# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡
test-cover:
	go test -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# è¿è¡ŒåŸºå‡†æµ‹è¯•
test-benchmark:
	go test -bench=. -benchmem -benchtime=10s ./...

# è¿è¡Œé›†æˆæµ‹è¯•
test-integration:
	go test -v -tags=integration ./...

# è¿è¡ŒçŸ­æµ‹è¯•ï¼ˆè·³è¿‡é›†æˆæµ‹è¯•ï¼‰
test-short:
	go test -short -v ./...
```

## âœ… æµ‹è¯•æœ€ä½³å®è·µ

### 1. AAAæ¨¡å¼

```go
func TestUserService_CreateUser(t *testing.T) {
    // Arrange - å‡†å¤‡æµ‹è¯•æ•°æ®å’Œç¯å¢ƒ
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    user := &User{
        Username: "john",
        Email:    "john@example.com",
    }

    mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil)

    // Act - æ‰§è¡Œè¢«æµ‹è¯•çš„ä»£ç 
    err := service.CreateUser(context.Background(), user)

    // Assert - éªŒè¯ç»“æœ
    require.NoError(t, err)
    assert.NotEmpty(t, user.ID)
    mockRepo.AssertExpectations(t)
}
```

### 2. æµ‹è¯•å‘½åè§„èŒƒ

```go
// å¥½çš„å‘½å
func TestUserService_CreateUser_Success(t *testing.T) {}
func TestUserService_CreateUser_DuplicateEmail(t *testing.T) {}
func TestUserService_CreateUser_InvalidInput(t *testing.T) {}

// ä¸å¥½çš„å‘½å
func TestUserService_1(t *testing.T) {}
func TestUserService_Create(t *testing.T) {}
func TestUserService_CreateUserTest(t *testing.T) {}
```

### 3. ç‹¬ç«‹æ€§åŸåˆ™

æ¯ä¸ªæµ‹è¯•åº”è¯¥ç‹¬ç«‹è¿è¡Œï¼Œä¸ä¾èµ–å…¶ä»–æµ‹è¯•ï¼š

```go
func TestUserRepository_Create(t *testing.T) {
    // æ¯ä¸ªæµ‹è¯•éƒ½ä½¿ç”¨ç‹¬ç«‹çš„æ•°æ®
    user := &User{
        ID:       generateUniqueID(),  // ä½¿ç”¨å”¯ä¸€ID
        Username: generateUniqueUsername(),  // ä½¿ç”¨å”¯ä¸€ç”¨æˆ·å
    }

    // æµ‹è¯•é€»è¾‘...
}
```

### 4. é¿å…æµ‹è¯•é€»è¾‘å¤æ‚

```go
// âŒ ä¸å¥½ - æµ‹è¯•é€»è¾‘å¤ªå¤æ‚
func TestComplex(t *testing.T) {
    if condition1 {
        if condition2 {
            if condition3 {
                // æµ‹è¯•é€»è¾‘
            }
        }
    }
}

// âœ… å¥½ - æ‹†åˆ†ä¸ºå¤šä¸ªæµ‹è¯•
func TestCondition1(t *testing.T) {}
func TestCondition2(t *testing.T) {}
func TestCondition3(t *testing.T) {}
```

## ğŸ¯ æµ‹è¯•è¦†ç›–ç›®æ ‡

### 1. ä¼˜å…ˆçº§åˆ’åˆ†

| ä¼˜å…ˆçº§ | å†…å®¹ | è¦†ç›–ç‡ç›®æ ‡ |
|--------|------|-----------|
| P0 | æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ã€æ”¯ä»˜ç›¸å…³ | 80%+ |
| P1 | é‡è¦åŠŸèƒ½ã€æ•°æ®è®¿é—® | 60%+ |
| P2 | ä¸€èˆ¬åŠŸèƒ½ã€å·¥å…·å‡½æ•° | 40%+ |

### 2. å¿…é¡»æµ‹è¯•çš„åœºæ™¯

- [ ] æ‰€æœ‰è¾¹ç•Œæ¡ä»¶
- [ ] é”™è¯¯å¤„ç†è·¯å¾„
- [ ] å¹¶å‘è®¿é—®åœºæ™¯
- [ ] æ•°æ®éªŒè¯é€»è¾‘
- [ ] æƒé™æ£€æŸ¥

---

**æ–‡æ¡£ç»´æŠ¤**: é’ç¾½åç«¯æ¶æ„å›¢é˜Ÿ
**æœ€åæ›´æ–°**: 2026-01-06
